<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://catpaws.top/blog-resource/imgs/webicon.png"><link rel="icon" href="https://catpaws.top/blog-resource/imgs/webicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="一、 概述 1.1 为什么学？ Stream流大量的结合了Lambda的语法风格来编程，提供了一种更加强大，更加简单的方式操作集合或者数组中的数据，代码更简洁，可读性更好。  大数量下处理集合效率高 代码可读性高 消灭嵌套地狱  &#x2F;&#x2F;查询未成年作家的评分在70以上的书籍 由于洋流影响所以作家和书籍可能出现重复，需要进行去重 List&lt;Book&gt; bookList &#x3D;"><meta property="og:type" content="article"><meta property="og:title" content="函数式编程-Stream流"><meta property="og:url" content="https://catpaws.top/146f67fb/index.html"><meta property="og:site_name" content="猫爪在上の书桌"><meta property="og:description" content="一、 概述 1.1 为什么学？ Stream流大量的结合了Lambda的语法风格来编程，提供了一种更加强大，更加简单的方式操作集合或者数组中的数据，代码更简洁，可读性更好。  大数量下处理集合效率高 代码可读性高 消灭嵌套地狱  &#x2F;&#x2F;查询未成年作家的评分在70以上的书籍 由于洋流影响所以作家和书籍可能出现重复，需要进行去重 List&lt;Book&gt; bookList &#x3D;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://catpaws.top/blog-resource/imgs/art-post3.jpg"><meta property="article:published_time" content="2024-12-09T03:04:20.000Z"><meta property="article:modified_time" content="2025-02-10T15:12:43.247Z"><meta property="article:author" content="猫爪在上"><meta property="article:tag" content="Stream流"><meta property="article:tag" content="函数式编程"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://catpaws.top/blog-resource/imgs/art-post3.jpg"><title>函数式编程-Stream流 - 猫爪在上の书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/font.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/poem.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/shubiao.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/loader.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/twikoo_beautify.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/indeximg-hover.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/wave.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/blurpicload.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"https://catpaws.top/img/transpare.svg",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://leancloud.catpaws.top",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loader-container"><div class="loader"><div class="wrapper"><div class="catContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 733 673" class="catbody"><path fill="#212121" d="M111.002 139.5C270.502 -24.5001 471.503 2.4997 621.002 139.5C770.501 276.5 768.504 627.5 621.002 649.5C473.5 671.5 246 687.5 111.002 649.5C-23.9964 611.5 -48.4982 303.5 111.002 139.5Z"></path><path fill="#212121" d="M184 9L270.603 159H97.3975L184 9Z"></path><path fill="#212121" d="M541 0L627.603 150H454.397L541 0Z"></path></svg> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 158 564" class="tail"><path fill="#191919" d="M5.97602 76.066C-11.1099 41.6747 12.9018 0 51.3036 0V0C71.5336 0 89.8636 12.2558 97.2565 31.0866C173.697 225.792 180.478 345.852 97.0691 536.666C89.7636 553.378 73.0672 564 54.8273 564V564C16.9427 564 -5.4224 521.149 13.0712 488.085C90.2225 350.15 87.9612 241.089 5.97602 76.066Z"></path></svg><div class="text"><span class="bigzzz">Z</span> <span class="zzz">Z</span></div></div><div class="wallContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 500 126" class="wall"><line stroke-width="6" stroke="#7C7C7C" y2="3" x2="450" y1="3" x1="50"></line><line stroke-width="6" stroke="#7C7C7C" y2="85" x2="400" y1="85" x1="100"></line><line stroke-width="6" stroke="#7C7C7C" y2="122" x2="375" y1="122" x1="125"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="500" y1="43"></line><line stroke-width="6" stroke="#7C7C7C" y2="1.99391" x2="115.5" y1="43.0061" x1="115.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00002" x2="189" y1="43.0122" x1="189"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00612" x2="262.5" y1="43.0183" x1="262.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01222" x2="336" y1="43.0244" x1="336"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01833" x2="409.5" y1="43.0305" x1="409.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="153" y1="84.0122" x1="153"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="228" y1="84.0122" x1="228"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="303" y1="84.0122" x1="303"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="378" y1="84.0122" x1="378"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="192" y1="125.012" x1="192"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="267" y1="125.012" x1="267"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="342" y1="125.012" x1="342"></line></svg></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上の书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>个人主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://catpaws.top/blog-resource/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="函数式编程-Stream流"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-12-09 11:04" pubdate>2024年12月9日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 11k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 96 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">函数式编程-Stream流</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年2月10日 晚上</p><div class="markdown-body"><meta name="referrer" , content="no-referrer"><h1 id="一-概述">一、 概述</h1><h2 id="为什么学">1.1 为什么学？</h2><p>Stream流大量的结合了Lambda的语法风格来编程，提供了一种更加强大，更加简单的方式操作集合或者数组中的数据，代码更简洁，可读性更好。</p><ul><li>大数量下处理集合效率高</li><li>代码可读性高</li><li>消灭嵌套地狱</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//查询未成年作家的评分在70以上的书籍 由于洋流影响所以作家和书籍可能出现重复，需要进行去重</span>
List&lt;Book&gt; bookList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
Set&lt;Book&gt; uniqueBookValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
Set&lt;Author&gt; uniqueAuthorValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
<span class="hljs-keyword">for</span> (Author author : authors) &#123;
    <span class="hljs-keyword">if</span> (uniqueAuthorValues.add(author)) &#123;
        <span class="hljs-keyword">if</span> (author.getAge() &lt; <span class="hljs-number">18</span>) &#123;
            List&lt;Book&gt; books = author.getBooks();
            <span class="hljs-keyword">for</span> (Book book : books) &#123;
                <span class="hljs-keyword">if</span> (book.getScore() &gt; <span class="hljs-number">70</span>) &#123;
                    <span class="hljs-keyword">if</span> (uniqueBookValues.add(book)) &#123;
                        bookList.add(book);
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
System.out.println(bookList);</code></pre></div><div class="code-wrapper"><pre><code class="hljs java">List&lt;Book&gt; collect = authors.stream()
    .distinct()
    .filter(author -&gt; author.getAge() &lt; <span class="hljs-number">18</span>)
    .map(author -&gt; author.getBooks())
    .flatMap(Collection::stream)
    .filter(book -&gt; book.getScore() &gt; <span class="hljs-number">70</span>)
    .distinct()
    .collect(Collectors.toList());
System.out.println(collect);</code></pre></div><h2 id="函数式编程思想">1.2 函数式编程思想</h2><p>​ 面向对象思想需要关注用什么对象完成什么事情。而函数式编程思想就类似于我们数学中的函数。它主要关注的是对数据进行了什么操作。</p><p>优点：</p><ul><li>代码简洁，开发快速</li><li>接近自然语言，易于理解</li><li>易于"并发编程"</li></ul><h1 id="二-lambda表达式">二、 Lambda表达式</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45082647/article/details/106991685">Lambad表达式详解</a></p><h2 id="概述">2.1 概述</h2><p>​ Lambda是JDK8中一个语法糖。他可以对某些匿名内部类的写法进行简化（原则：是接口的匿名内部类，且接口中只有一个待重写的抽象方法）。它是函数式编程思想的一个重要体现。让我们不用关注是什么对象。而是更关注我们对数据进行了什么操作。</p><p>核心原则：可推导可省略。</p><h2 id="四大内置核心函数式接口">2.2 四大内置核心函数式接口</h2><p>在Java 8中，引入了四个核心的函数式接口，这些接口极大地简化了代码的编写，并且能够满足大部分的编程需求。</p><p>Java8中内置四大核心函数式接口如下： <img src="https://i-blog.csdnimg.cn/blog_migrate/c443ac5e807bff05714384cbdf58eff2.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p><p>除了上面那四大接口之外，还提供了几个其他的接口供使用。这些接口已经能够覆盖大部分的场景了。 <img src="https://i-blog.csdnimg.cn/blog_migrate/ec99dc0d2ec039d44386d9cedfd73718.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p><h3 id="消费型接口-consumer"><strong>消费型接口 (Consumer)</strong></h3><p><code>Consumer&lt;T&gt;</code>接口接受一个输入参数并且无返回值。它常用于执行某些操作，例如打印、发送消息等<strong>不需要返回结果</strong>的操作。</p><p>主要方法：<code>void accept(T t)</code></p><p>源码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Consumer</span>&lt;T&gt; &#123;
    <span class="hljs-comment">// 该函数式接口的唯一的抽象方法，接收一个参数，没有返回值</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t)</span>;
 
   <span class="hljs-comment">// 在执行完调用者方法后再执行传入参数的方法</span>
    <span class="hljs-keyword">default</span> Consumer&lt;T&gt; <span class="hljs-title function_">andThen</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; after)</span> &#123;
        Objects.requireNonNull(after);
        <span class="hljs-keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;
    &#125;
&#125;</code></pre></div><p>示例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testConsumer</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">// 在accept方法中打印输入值加2的结果</span>
	handle(<span class="hljs-number">6</span>, (x) -&gt; System.out.println(x + <span class="hljs-number">2</span>));
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(<span class="hljs-type">int</span> value, Consumer&lt;Integer&gt; consumer)</span> &#123;
	consumer.accept(value);
&#125;</code></pre></div><h3 id="供给型接口-supplier"><strong>供给型接口 (Supplier)</strong></h3><p><code>Supplier&lt;T&gt;</code>接口无输入参数，返回一个结果。它常用于延迟计算、对象工厂、获取配置值等 <strong>需要生成结果</strong>的操作</p><p>主要方法：<code>T get()</code></p><p>源码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Supplier</span>&lt;T&gt; &#123;
    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;
&#125;</code></pre></div><p>示例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSupplier</span><span class="hljs-params">()</span> &#123;
	<span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> Person.builder().name(<span class="hljs-string">&quot;供给者&quot;</span>).build();
    <span class="hljs-comment">//获取一个人的名字</span>
	System.out.println(getObject(() -&gt; person.getName()));
&#125;

<span class="hljs-keyword">public</span> String <span class="hljs-title function_">getObject</span><span class="hljs-params">(Supplier&lt;String&gt; supplier)</span> &#123;
	<span class="hljs-keyword">return</span> supplier.get();
&#125;</code></pre></div><h3 id="函数型接口-function"><strong>函数型接口 (Function)</strong></h3><p><code>Function&lt;T, R&gt;</code>接口接受一个输入参数，返回一个结果。它常用于数据类型转换、数据加工、链式处理等 <strong>需要转换或计算</strong>的操作。</p><p>主要方法：<code>R apply(T t)</code></p><p>示例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFunction</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">//将输入值加2并返回结果</span>
	<span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> plusTwo(<span class="hljs-number">6</span>, (x) -&gt; x + <span class="hljs-number">2</span>);
	System.out.println(result);
&#125;

<span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">plusTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> origen, Function&lt;Integer, Integer&gt; function)</span> &#123;
	<span class="hljs-keyword">return</span> function.apply(origen);
&#125;</code></pre></div><h3 id="断言型接口-predicate"><strong>断言型接口 (Predicate)</strong></h3><p><code>Predicate&lt;T&gt;</code>接口接受一个输入参数，返回一个布尔值结果。它常用于条件过滤、数据校验、规则匹配等 <strong>需要判断真假</strong>的操作。</p><p>主要方法：<code>boolean test(T t)</code></p><p>源码：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Predicate</span>&lt;T&gt; &#123;
    <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;
 
    <span class="hljs-comment">// 返回值为已实现Predicate接口抽象方法的类</span>
    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">and</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; other)</span> &#123;
        Objects.requireNonNull(other);
        <span class="hljs-keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);
    &#125;
 
    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">negate</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> (t) -&gt; !test(t);
    &#125;
 
    <span class="hljs-keyword">default</span> Predicate&lt;T&gt; <span class="hljs-title function_">or</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> T&gt; other)</span> &#123;
        Objects.requireNonNull(other);
        <span class="hljs-keyword">return</span> (t) -&gt; test(t) || other.test(t);
    &#125;
 
    <span class="hljs-keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="hljs-title function_">isEqual</span><span class="hljs-params">(Object targetRef)</span> &#123;
        <span class="hljs-keyword">return</span> (<span class="hljs-literal">null</span> == targetRef)
                ? Objects::isNull
                : object -&gt; targetRef.equals(object);
    &#125;
&#125;</code></pre></div><p>示例</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPredicate</span><span class="hljs-params">()</span> &#123;
	<span class="hljs-type">boolean</span> <span class="hljs-variable">judge</span> <span class="hljs-operator">=</span> judge(<span class="hljs-number">6</span>, (x) -&gt; (x &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">1</span>);
	System.out.println(judge);
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">judge</span><span class="hljs-params">(Integer input, Predicate&lt;Integer&gt; predicate)</span> &#123;
	<span class="hljs-keyword">return</span> predicate.test(input);
&#125;</code></pre></div><p>在Predicate接口中进行判断条件时，可以通过<code>and</code>、<code>or</code>、<code>negate</code>方法构造更为复杂的条件：</p><ul><li><p>and</p><p>我们在使用Predicate接口时候可能需要进行判断条件的拼接。而and方法相当于是使用&amp;&amp;来拼接两个判断条件</p><p>例如：打印作家中年龄大于17并且姓名的长度大于1的作家。</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();
  Stream&lt;Author&gt; authorStream = authors.stream();
  authorStream.filter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Author&gt;() &#123;
      <span class="hljs-meta">@Override</span>
      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Author author)</span> &#123;
          <span class="hljs-keyword">return</span> author.getAge()&gt;<span class="hljs-number">17</span>;
      &#125;
  &#125;.and(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Author&gt;() &#123;
      <span class="hljs-meta">@Override</span>
      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Author author)</span> &#123;
          <span class="hljs-keyword">return</span> author.getName().length()&gt;<span class="hljs-number">1</span>;
      &#125;
  &#125;)).forEach(author -&gt; System.out.println(author));</code></pre></div></li><li><p>or</p><p>我们在使用Predicate接口时候可能需要进行判断条件的拼接。而or方法相当于是使用||来拼接两个判断条件。</p><p>例如：打印作家中年龄大于17或者姓名的长度小于2的作家。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        打印作家中年龄大于17或者姓名的长度小于2的作家。</span>
          List&lt;Author&gt; authors = getAuthors();
          authors.stream()
                  .filter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Author&gt;() &#123;
                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Author author)</span> &#123;
                          <span class="hljs-keyword">return</span> author.getAge()&gt;<span class="hljs-number">17</span>;
                      &#125;
                  &#125;.or(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Author&gt;() &#123;
                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Author author)</span> &#123;
                          <span class="hljs-keyword">return</span> author.getName().length()&lt;<span class="hljs-number">2</span>;
                      &#125;
                  &#125;)).forEach(author -&gt; System.out.println(author.getName()));</code></pre></div></li><li><p>negate</p><p>Predicate接口中的方法。negate方法相当于是在判断添加前面加了个! 表示取反</p><p>例如：打印作家中年龄不大于17的作家。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        打印作家中年龄不大于17的作家。</span>
          List&lt;Author&gt; authors = getAuthors();
          authors.stream()
                  .filter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Author&gt;() &#123;
                      <span class="hljs-meta">@Override</span>
                      <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Author author)</span> &#123;
                          <span class="hljs-keyword">return</span> author.getAge()&gt;<span class="hljs-number">17</span>;
                      &#125;
                  &#125;.negate()).forEach(author -&gt; System.out.println(author.getAge()));</code></pre></div></li></ul><h2 id="基本格式">2.3 基本格式</h2><div class="code-wrapper"><pre><code class="hljs java">(参数列表)-&gt;&#123;代码&#125;</code></pre></div><h3 id="例一">例一</h3><p>我们在创建线程并启动时可以使用匿名内部类的写法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;
        System.out.println(<span class="hljs-string">&quot;你知道吗 我比你想象的 更想在你身边&quot;</span>);
    &#125;
&#125;).start();</code></pre></div><p>可以使用Lambda的格式对其进行修改。修改后如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;
    System.out.println(<span class="hljs-string">&quot;你知道吗 我比你想象的 更想在你身边&quot;</span>);
&#125;).start();</code></pre></div><h3 id="例二">例二</h3><p>现有方法定义如下，其中IntBinaryOperator是一个接口。先使用匿名内部类的写法调用该方法。</p><div class="code-wrapper"><pre><code class="hljs java">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateNum</span><span class="hljs-params">(IntBinaryOperator operator)</span>&#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;
    <span class="hljs-keyword">return</span> operator.applyAsInt(a, b);
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> calculateNum(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntBinaryOperator</span>() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">applyAsInt</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;
            <span class="hljs-keyword">return</span> left + right;
        &#125;
    &#125;);
    System.out.println(i);
&#125;</code></pre></div><p>Lambda写法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> calculateNum((<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)-&gt;&#123;
        <span class="hljs-keyword">return</span> left + right;
    &#125;);
    System.out.println(i);
&#125;</code></pre></div><h3 id="例三">例三</h3><p>现有方法定义如下，其中IntPredicate是一个接口。先使用匿名内部类的写法调用该方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNum</span><span class="hljs-params">(IntPredicate predicate)</span>&#123;
    <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr) &#123;
        <span class="hljs-keyword">if</span>(predicate.test(i))&#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
    printNum(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntPredicate</span>() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;
            <span class="hljs-keyword">return</span> value%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;
        &#125;
    &#125;);
&#125;</code></pre></div><p>Lambda写法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
    printNum((<span class="hljs-type">int</span> value)-&gt; &#123;
        <span class="hljs-keyword">return</span> value%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;
    &#125;);
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNum</span><span class="hljs-params">(IntPredicate predicate)</span>&#123;
    <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr) &#123;
        <span class="hljs-keyword">if</span>(predicate.test(i))&#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;</code></pre></div><h3 id="例四">例四</h3><p>现有方法定义如下，其中Function是一个接口。先使用匿名内部类的写法调用该方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;R&gt; R <span class="hljs-title function_">typeConver</span><span class="hljs-params">(Function&lt;String,R&gt; function)</span>&#123;
    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1235&quot;</span>;
    <span class="hljs-type">R</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> function.apply(str);
    <span class="hljs-keyword">return</span> result;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
    <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> typeConver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;String, Integer&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">apply</span><span class="hljs-params">(String s)</span> &#123;
            <span class="hljs-keyword">return</span> Integer.valueOf(s);
        &#125;
    &#125;);
    System.out.println(result);
&#125;</code></pre></div><p>Lambda写法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> typeConver((String s)-&gt;&#123;
    <span class="hljs-keyword">return</span> Integer.valueOf(s);
&#125;);
System.out.println(result);
</code></pre></div><h3 id="例五">例五</h3><p>现有方法定义如下，其中IntConsumer是一个接口。先使用匿名内部类的写法调用该方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foreachArr</span><span class="hljs-params">(IntConsumer consumer)</span>&#123;
    <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr) &#123;
        consumer.accept(i);
    &#125;
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
    foreachArr(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntConsumer</span>() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;
            System.out.println(value);
        &#125;
    &#125;);
&#125;</code></pre></div><p>Lambda写法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
    foreachArr((<span class="hljs-type">int</span> value)-&gt;&#123;
        System.out.println(value);
    &#125;);
&#125;</code></pre></div><h3 id="省略规则">2.4 省略规则</h3><ul><li>参数类型可以省略</li><li>方法体只有一句代码时大括号、return和唯一一句代码的分号可以省略</li><li>方法只有一个参数时小括号可以省略</li><li>以上这些规则都记不住也可以省略不记</li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601102040478-2024-6-110:20:53.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601102040478"><figcaption aria-hidden="true">image-20240601102040478</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601102217951-2024-6-110:22:18.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601102217951"><figcaption aria-hidden="true">image-20240601102217951</figcaption></figure><h1 id="三stream流">三、Stream流</h1><h2 id="概述-1">3.1 概述</h2><p>​ Java8的Stream使用的是函数式编程模式，如同它的名字一样，它可以被用来对<strong>集合或数组</strong>进行链状流式的操作。可以更方便的让我们对集合或数组操作。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250209121112046-2025-2-912:11:17.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p><p>特点：</p><ul><li>惰性求值：如果没有终结操作，没有中间操作是不会得到执行的</li><li>流是一次性的：一旦一个流对象经过一个终结操作后。这个流就不能再被使用</li><li><u><strong>非破坏性</strong></u>：Stream API 设计为对数据源进行一系列操作（如过滤、映射、排序等），然后生成一个新的流或结果，而不会更改原始数据</li></ul><h2 id="案例数据准备">3.2 案例数据准备</h2><p><a target="_blank" rel="noopener" href="https://github.com/cmyk359/JavaStream_demo">Demo地址</a></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@EqualsAndHashCode</span><span class="hljs-comment">//用于后期的去重使用</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Author</span> &#123;
    <span class="hljs-comment">//id</span>
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-comment">//姓名</span>
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-comment">//年龄</span>
    <span class="hljs-keyword">private</span> Integer age;
    <span class="hljs-comment">//简介</span>
    <span class="hljs-keyword">private</span> String intro;
    <span class="hljs-comment">//作品</span>
    <span class="hljs-keyword">private</span> List&lt;Book&gt; books;
&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@EqualsAndHashCode</span><span class="hljs-comment">//用于后期的去重使用</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;
    <span class="hljs-comment">//id</span>
    <span class="hljs-keyword">private</span> Long id;
    <span class="hljs-comment">//书名</span>
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-comment">//分类</span>
    <span class="hljs-keyword">private</span> String category;

    <span class="hljs-comment">//评分</span>
    <span class="hljs-keyword">private</span> Integer score;

    <span class="hljs-comment">//简介</span>
    <span class="hljs-keyword">private</span> String intro;

&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Author&gt; <span class="hljs-title function_">getAuthors</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">//数据初始化</span>
    <span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Author</span>(<span class="hljs-number">1L</span>,<span class="hljs-string">&quot;蒙多&quot;</span>,<span class="hljs-number">33</span>,<span class="hljs-string">&quot;一个从菜刀中明悟哲理的祖安人&quot;</span>,<span class="hljs-literal">null</span>);
    <span class="hljs-type">Author</span> <span class="hljs-variable">author2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Author</span>(<span class="hljs-number">2L</span>,<span class="hljs-string">&quot;亚拉索&quot;</span>,<span class="hljs-number">15</span>,<span class="hljs-string">&quot;狂风也追逐不上他的思考速度&quot;</span>,<span class="hljs-literal">null</span>);
    <span class="hljs-type">Author</span> <span class="hljs-variable">author3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Author</span>(<span class="hljs-number">3L</span>,<span class="hljs-string">&quot;易&quot;</span>,<span class="hljs-number">14</span>,<span class="hljs-string">&quot;是这个世界在限制他的思维&quot;</span>,<span class="hljs-literal">null</span>);
    <span class="hljs-type">Author</span> <span class="hljs-variable">author4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Author</span>(<span class="hljs-number">3L</span>,<span class="hljs-string">&quot;易&quot;</span>,<span class="hljs-number">14</span>,<span class="hljs-string">&quot;是这个世界在限制他的思维&quot;</span>,<span class="hljs-literal">null</span>);

    <span class="hljs-comment">//书籍列表</span>
    List&lt;Book&gt; books1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    List&lt;Book&gt; books2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    List&lt;Book&gt; books3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

    books1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">1L</span>,<span class="hljs-string">&quot;刀的两侧是光明与黑暗&quot;</span>,<span class="hljs-string">&quot;哲学,爱情&quot;</span>,<span class="hljs-number">88</span>,<span class="hljs-string">&quot;用一把刀划分了爱恨&quot;</span>));
    books1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">2L</span>,<span class="hljs-string">&quot;一个人不能死在同一把刀下&quot;</span>,<span class="hljs-string">&quot;个人成长,爱情&quot;</span>,<span class="hljs-number">99</span>,<span class="hljs-string">&quot;讲述如何从失败中明悟真理&quot;</span>));

    books2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">3L</span>,<span class="hljs-string">&quot;那风吹不到的地方&quot;</span>,<span class="hljs-string">&quot;哲学&quot;</span>,<span class="hljs-number">85</span>,<span class="hljs-string">&quot;带你用思维去领略世界的尽头&quot;</span>));
    books2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">3L</span>,<span class="hljs-string">&quot;那风吹不到的地方&quot;</span>,<span class="hljs-string">&quot;哲学&quot;</span>,<span class="hljs-number">85</span>,<span class="hljs-string">&quot;带你用思维去领略世界的尽头&quot;</span>));
    books2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">4L</span>,<span class="hljs-string">&quot;吹或不吹&quot;</span>,<span class="hljs-string">&quot;爱情,个人传记&quot;</span>,<span class="hljs-number">56</span>,<span class="hljs-string">&quot;一个哲学家的恋爱观注定很难把他所在的时代理解&quot;</span>));

    books3.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">5L</span>,<span class="hljs-string">&quot;你的剑就是我的剑&quot;</span>,<span class="hljs-string">&quot;爱情&quot;</span>,<span class="hljs-number">56</span>,<span class="hljs-string">&quot;无法想象一个武者能对他的伴侣这么的宽容&quot;</span>));
    books3.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">6L</span>,<span class="hljs-string">&quot;风与剑&quot;</span>,<span class="hljs-string">&quot;个人传记&quot;</span>,<span class="hljs-number">100</span>,<span class="hljs-string">&quot;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&quot;</span>));
    books3.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">6L</span>,<span class="hljs-string">&quot;风与剑&quot;</span>,<span class="hljs-string">&quot;个人传记&quot;</span>,<span class="hljs-number">100</span>,<span class="hljs-string">&quot;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&quot;</span>));

    author.setBooks(books1);
    author2.setBooks(books2);
    author3.setBooks(books3);
    author4.setBooks(books3);

    List&lt;Author&gt; authorList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(author,author2,author3,author4));
    <span class="hljs-keyword">return</span> authorList;
&#125;</code></pre></div><h2 id="快速入门">3.3 快速入门</h2><p>​ 我们可以调用getAuthors方法获取到作家的集合。现在需要打印所有年龄小于18的作家的名字，并且要注意去重。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//打印所有年龄小于18的作家的名字，并且要注意去重</span>
List&lt;Author&gt; authors = getAuthors();
authors.stream()<span class="hljs-comment">//把集合转换成流</span>
        .distinct()<span class="hljs-comment">//先去除重复的作家</span>
        .filter(author -&gt; author.getAge()&lt;<span class="hljs-number">18</span>)<span class="hljs-comment">//筛选年龄小于18的</span>
        .forEach(author -&gt; System.out.println(author.getName()));<span class="hljs-comment">//遍历打印名字</span></code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601154243071-2024-6-115:42:46.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601154243071"><figcaption aria-hidden="true">image-20240601154243071</figcaption></figure><h2 id="创建流">3.4 创建流</h2><h3 id="获取集合的stream流">获取<strong>集合</strong>的Stream流</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250209122026119-2025-2-912:20:29.png" srcset="https://catpaws.top/img/transpare.svg" lazyload style="zoom:80%"></p><ul><li><p>单列集合</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();
Stream&lt;Author&gt; stream = authors.stream();</code></pre></div></li><li><p>双列集合</p><p><code>stream</code>方法是<code>Collection</code>接口提供的方法，<code>Map</code>接口及其实现类无法直接使用。</p><p>但<code>Map</code>接口为了方便遍历，提供了<code>entrySet</code>视图，可以将map中的键值对封装在一个个键值对对象entry中，并放在Set集合中返回。也可以使用<code>keySet()</code>和<code>values()</code>方法单独获取map中键和值的集合。</p><p>获取到这些集合后，就可以使用<code>Collecion</code>接口的<code>stream()</code>方法获取流</p><div class="code-wrapper"><pre><code class="hljs java">Map&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
map.put(<span class="hljs-string">&quot;蜡笔小新&quot;</span>,<span class="hljs-number">19</span>);
map.put(<span class="hljs-string">&quot;黑子&quot;</span>,<span class="hljs-number">17</span>);
map.put(<span class="hljs-string">&quot;日向翔阳&quot;</span>,<span class="hljs-number">16</span>);
Set&lt;String&gt; keySet = map.keySet(); <span class="hljs-comment">//获取键集合</span>
Collection&lt;Integer&gt; values = map.values(); <span class="hljs-comment">// 获取值集合</span>
Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet(); <span class="hljs-comment">// 获取entry集合</span>
entries.stream()
        .filter(entry -&gt; entry.getValue() &gt; <span class="hljs-number">16</span>)
        .forEach(entry -&gt; System.out.println(entry.getKey()+<span class="hljs-string">&quot; ---&quot;</span>+entry.getValue()));</code></pre></div></li></ul><h3 id="获取数组的stream流">获取数组的Stream流</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250209123356836-2025-2-912:33:58.png" srcset="https://catpaws.top/img/transpare.svg" lazyload style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java">Integer[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;
Stream&lt;Integer&gt; stream = Arrays.stream(arr);
Stream&lt;Integer&gt; stream2 = Stream.of(arr);</code></pre></div><h2 id="中间操作">3.5 中间操作</h2><p>Java8的Stream中间操作可分为 <strong>6大类</strong>，每类操作均返回新Stream并支持链式调用，总结分类如下：</p><table><thead><tr class="header"><th><strong>分类</strong></th><th><strong>方法</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr class="odd"><td>筛选与切片</td><td><code>filter</code>, <code>distinct</code>, <code>limit</code>, <code>skip</code></td><td>减少元素数量</td></tr><tr class="even"><td>映射转换</td><td><code>map</code>, <code>flatMap</code>, <code>mapToXxx</code></td><td>改变元素类型或结构</td></tr><tr class="odd"><td>排序</td><td><code>sorted</code></td><td>调整元素顺序</td></tr><tr class="even"><td>调试观察</td><td><code>peek</code></td><td>无状态副作用操作</td></tr><tr class="odd"><td>状态操作</td><td><code>distinct</code>, <code>sorted</code>, <code>limit/skip</code></td><td>依赖其他元素或需收集全部数据</td></tr><tr class="even"><td>特殊转换</td><td><code>boxed</code>, <code>parallel</code>, <code>sequential</code></td><td>改变流类型或执行模式</td></tr></tbody></table><h3 id="筛选与切片">筛选与切片</h3><p>​ 过滤或限制流中元素</p><h4 id="filter">filter</h4><p><code>filter(Predicate&lt;T&gt;)</code>：可以对流中的元素进行条件过滤，<strong>符合过滤条件的才能继续留在流中</strong>。</p><p>例如：打印所有姓名长度大于1的作家的姓名</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//打印所有姓名长度大于1的作家的姓名</span>
List&lt;Author&gt; authors = getAuthors();
authors.stream()
    .filter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Author&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-comment">//***返回一个布尔值，对流中的每个对象按条件进行筛选，符合条件的才保留***</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Author author)</span> &#123; 
            <span class="hljs-keyword">return</span> author.getName().length() &gt; <span class="hljs-number">1</span>; 
        &#125;
    &#125;)
    .forEach(author -&gt; System.out.println(author.getName()));

==========================lambda表达式简化写法===============================

List&lt;Author&gt; authors = getAuthors();
authors.stream()
    .filter(author -&gt; author.getName().length()&gt;<span class="hljs-number">1</span>)
    .forEach(author -&gt; System.out.println(author.getName()));</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601155929817-2024-6-116:00:05.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601155929817"><figcaption aria-hidden="true">image-20240601155929817</figcaption></figure><h4 id="distinct">distinct</h4><p><code>distinct()</code>:可以去除流中的重复元素，依赖<code>equals()</code>和<code>hashCode()</code></p><p>例如：打印所有作家的姓名，并且要求其中不能有重复元素。</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();

authors.stream()
    .distinct()<span class="hljs-comment">//对流中的元素，两两调用equals方法判断是否为同一个，若是则从流中去除一个</span>
    .forEach(author -&gt; System.out.println(author.getName()));</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601162902927-2024-6-116:29:05.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601162902927"><figcaption aria-hidden="true">image-20240601162902927</figcaption></figure><p><strong>注意：distinct方法是依赖Object的equals方法来判断是否是相同对象的。所以需要注意重写equals方法。</strong>Object默认的equals方法中默认使用 <code>==</code>判断两对象的地址是否相同来判断是否是同一个。而在业务中，当两个对象各个属性值都相同时，就可以判断为重复。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601162319873-2024-6-116:24:05.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601162319873"><figcaption aria-hidden="true">image-20240601162319873</figcaption></figure><blockquote><p>也可以在实体类上添加LomBok注解 <code>@EqualsAndHashCode</code>，会自动生成重写equals方法的代码</p></blockquote><h4 id="limit">limit</h4><p><code>limit(long maxSize)</code>，保留前N个元素。可以设置流的最大长度，超出的部分将被抛弃。</p><p>例如：对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素,然后打印其中年龄最大的两个作家的姓名。</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();
authors.stream()
    .distinct()
    .sorted()
    .limit(<span class="hljs-number">2</span>)
    .forEach(author -&gt; System.out.println(author.getName()));</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601183333481-2024-6-118:34:05.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601183333481"><figcaption aria-hidden="true">image-20240601183333481</figcaption></figure><h4 id="skip">skip</h4><p><code>skip(long n)</code>：跳过前N个元素，返回剩下的元素</p><p>例如：打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。</span>
List&lt;Author&gt; authors = getAuthors();
authors.stream()
    .distinct()
    .sorted()
    .skip(<span class="hljs-number">1</span>)
    .forEach(author -&gt; System.out.println(author.getName()));</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601183516052-2024-6-118:35:56.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601183516052"><figcaption aria-hidden="true">image-20240601183516052</figcaption></figure><h3 id="映射转换">映射转换</h3><p>转换元素类型或结构</p><h4 id="map">map</h4><p>​ <code>map(Function&lt;T, R&gt;)</code>：元素一对一转换。可以对流中的元素进行计算或转换。</p><p>例如：</p><p>1、对流中元素进行类型转化</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//	打印所有作家的姓名</span>

List&lt;Author&gt; authors = getAuthors();
authors.stream()
    <span class="hljs-comment">//传入的是Function接口的实现类，第一个泛型是流中对象的类型，第二个泛型是转化的目的类型</span>
    .map(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Author, String&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(Author author)</span> &#123;
            <span class="hljs-keyword">return</span> author.getName(); <span class="hljs-comment">//将流中的Author类型的对象，转化为String对象</span>
        &#125;
    &#125;)
    .forEach(s -&gt; System.out.println(s));


==========================lambda表达式简化写法===============================
List&lt;Author&gt; authors = getAuthors();

authors
    .stream()
    .map(author -&gt; author.getName())
    .forEach(name-&gt;System.out.println(name));</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601161216170-2024-6-116:12:37.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601161216170"><figcaption aria-hidden="true">image-20240601161216170</figcaption></figure><p>2、对流中元素进行运算</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//将所有作家年龄加10后输出</span>
List&lt;Author&gt; authors = getAuthors();
authors.stream()
    .map(author -&gt; author.getAge())
    .map(age-&gt;age+<span class="hljs-number">10</span>) <span class="hljs-comment">//运算</span>
    .forEach(age-&gt; System.out.println(age));</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601161354857-2024-6-116:13:56.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601161354857"><figcaption aria-hidden="true">image-20240601161354857</figcaption></figure><h4 id="flatmap">flatMap</h4><p>​ <code>flatMap(Function&lt;T, Stream&lt;R&gt;&gt;)</code>：元素一对多展开（降维）。map只能把一个对象转换成另一个对象来作为流中的元素；而<strong>flatMap可以把一个对象转换成多个对象作为流中的元素</strong>。（1---&gt;多）</p><p>例一：</p><p>​ 打印所有书籍的名字。要求对重复的元素进行去重。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        打印所有书籍的名字。要求对重复的元素进行去重。</span>

List&lt;Author&gt; authors = getAuthors();
authors.stream()
    .flatMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Author, Stream&lt;Book&gt;&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> Stream&lt;Book&gt; <span class="hljs-title function_">apply</span><span class="hljs-params">(Author author)</span> &#123;
            <span class="hljs-keyword">return</span> author.getBooks().stream();
        &#125;
    &#125;)
    .distinct()
    .forEach(book -&gt; System.out.println(book.getName()));

==========================使用lambda表达式简化写法===============================

List&lt;Author&gt; authors = getAuthors();

authors.stream()
    .flatMap(author -&gt; author.getBooks().stream())
    .distinct()
    .forEach(book -&gt; System.out.println(book.getName()));</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601184215959-2024-6-118:43:05.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601184215959"><figcaption aria-hidden="true">image-20240601184215959</figcaption></figure><p>例二：</p><p>​ 打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情     爱情</span>
List&lt;Author&gt; authors = getAuthors();
authors.stream()
    .flatMap(author -&gt; author.getBooks().stream())<span class="hljs-comment">//将Author转化为book</span>
    .distinct()<span class="hljs-comment">//book去重</span>
    <span class="hljs-comment">//将book转化为String：将每本书的category按`,`分割为String数组，获取该数组的流对象作为目标流</span>
    .flatMap(book -&gt; Arrays.stream(book.getCategory().split(<span class="hljs-string">&quot;,&quot;</span>)))
    .distinct()<span class="hljs-comment">//分类去重</span>
    .forEach(category-&gt; System.out.println(category));</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601190717948-2024-6-119:08:05.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601190717948"><figcaption aria-hidden="true">image-20240601190717948</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601190844033-2024-6-119:09:05.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601190844033"><figcaption aria-hidden="true">image-20240601190844033</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601190944564-2024-6-119:10:05.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601190944564"><figcaption aria-hidden="true">image-20240601190944564</figcaption></figure><h4 id="maptoxxx">mapToXXX</h4><p><code>mapToInt()/mapToLong()/mapToDouble()</code>：转为数值流（避免装箱开销）。</p><p><code>mapToXXX</code>和 <code>flatMapToXXX</code>是两类针对 <strong>原始类型数据优化</strong>的中间操作，直接操作 <code>int</code>、<code>long</code>、<code>double</code>，避免自动装箱/拆箱带来的性能开销。它们与 <code>map</code>和 <code>flatMap</code>类似，但直接操作原始类型流（如 IntStream、LongStream、DoubleStream）。</p><p>相比于map()，mapToXxx() 还提供了该种类型的流的特有方法（原生方法支持），比如数值型求和、平均数、最值</p><table><thead><tr class="header"><th><strong>操作</strong></th><th><strong>输入</strong></th><th><strong>转换规则</strong></th><th><strong>输出流类型</strong></th><th><strong>典型场景</strong></th></tr></thead><tbody><tr class="odd"><td><code>map</code></td><td><code>Stream&lt;T&gt;</code></td><td><code>T → R</code>（对象到对象）</td><td><code>Stream&lt;R&gt;</code></td><td>对象类型转换（如 <code>String</code> → <code>Integer</code>）</td></tr><tr class="even"><td><code>mapToXXX</code></td><td><code>Stream&lt;T&gt;</code></td><td><code>T →原始类型</code>（如 <code>int</code>）</td><td><code>IntStream</code>等</td><td>原始类型计算（求和、平均）</td></tr><tr class="odd"><td><code>flatMap</code></td><td><code>Stream&lt;T&gt;</code></td><td><code>T → Stream&lt;R&gt;</code>（对象到对象流）</td><td><code>Stream&lt;R&gt;</code></td><td>扁平化嵌套集合（如 <code>List&lt;List&lt;T&gt;&gt;</code> → <code>Stream&lt;T&gt;</code>）</td></tr><tr class="even"><td><code>flatMapToXXX</code></td><td><code>Stream&lt;T&gt;</code></td><td><code>T →原始类型流</code>（如 <code>IntStream</code>）</td><td><code>IntStream</code>等</td><td>展开并合并原始类型数据（如拆分字符串为数字流）</td></tr></tbody></table><hr><div class="code-wrapper"><pre><code class="hljs java">List&lt;String&gt; list = Arrays. asList(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Grapes&quot;</span>);
<span class="hljs-comment">//从list获取stream流，并将原来流中元素的长度作为新流返回</span>
<span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> list.stream().mapToInt(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ToIntFunction</span>&lt;String&gt;() &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">applyAsInt</span><span class="hljs-params">(String s)</span> &#123;
        <span class="hljs-keyword">return</span> s.length();
    &#125;
&#125;);
intStream.forEach(System. out:: println);

===========================简化写法=================================
List&lt;String&gt; list = Arrays. asList(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Grapes&quot;</span>);
<span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> list. stream().mapToInt(s -&gt; s.length());
intStream.forEach(System. out:: println);


<span class="hljs-comment">//将原来流中的元素 通过 Interger.valueOf方法 转化为 整数后返回。</span>
List&lt;String&gt; list = Arrays. asList(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>);
<span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> list. stream(). mapToInt(s -&gt; Integer.valueOf(s));
intStream.forEach(System. out:: println);
</code></pre></div><h4 id="flatmaptoxxx">flatMapToXXX</h4><p>元素一对多展开到原始类型流，将每个元素转换为一个原始类型流，再合并为单个原始类型流。操方法同上面的 mapToXXX</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;String&gt; texts = Arrays.asList(<span class="hljs-string">&quot;1,2,3&quot;</span>, <span class="hljs-string">&quot;4,5&quot;</span>);
<span class="hljs-comment">//将每个字符串拆分为数字并转为IntStream</span>
<span class="hljs-type">IntStream</span> <span class="hljs-variable">numbers</span> <span class="hljs-operator">=</span> texts.stream()
        .flatMapToInt(s -&gt; Arrays.stream(s.split(<span class="hljs-string">&quot;,&quot;</span>))
                .mapToInt(Integer::parseInt)
        );<span class="hljs-comment">//1,2,3,4,5</span>
<span class="hljs-comment">//计算总和</span>
<span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> numbers.sum(); <span class="hljs-comment">//15</span></code></pre></div><h3 id="排序">排序</h3><h4 id="sorted">sorted</h4><ul><li><code>sorted()</code>：自然排序（元素需实现<code>Comparable</code>）。</li><li><code>sorted(Comparator&lt;T&gt;)</code>：自定义排序规则。</li></ul><p>例如：</p><p>​ 对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</p><div class="code-wrapper"><pre><code class="hljs java">        List&lt;Author&gt; authors = getAuthors();
<span class="hljs-comment">//        对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</span>
        authors.stream()
                .distinct()
                .sorted() 
                .forEach(author -&gt; System.out.println(author.getAge()));</code></pre></div><blockquote><p><strong>注意：如果调用空参的sorted()方法，需要流中的元素是实现了Comparable接口，在其中的compareTo方法中定义排序策略。</strong></p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601175756515-2024-6-117:58:05.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601175756515"><figcaption aria-hidden="true">image-20240601175756515</figcaption></figure><p>使用有参的sort方法，传入比较器Comparator，重写compare方法，指定排序策略</p><div class="code-wrapper"><pre><code class="hljs java">authors.stream()
    .distinct()
    .sorted(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Author&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Author o1, Author o2)</span> &#123;
            <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();
        &#125;
    &#125;) <span class="hljs-comment">//设置比较器，按升序排序</span>
    .forEach(author -&gt; System.out.println(author.getAge()));

==========================lambda表达式简化写法===============================
authors.stream()
    .distinct()
    .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge()) <span class="hljs-comment">//设置比较器，按升序排序</span>
    .forEach(author -&gt; System.out.println(author.getAge()));</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601182321786-2024-6-118:24:05.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601182321786"><figcaption aria-hidden="true">image-20240601182321786</figcaption></figure><h3 id="调试观察">调试观察</h3><h4 id="peek">peek</h4><p><code>peek(Consumer&lt;T&gt;)</code>的主要作用是在流的每个元素上执行一个操作，比如打印元素的值、记录日志、调试等。它通常用于调试和观察流的中间状态，而不会对流的内容进行修改。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test23</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">//使用reduce求所有作者年龄的和</span>
    List&lt;Author&gt; authors = getAuthors();
    <span class="hljs-type">Integer</span> <span class="hljs-variable">ageSum</span> <span class="hljs-operator">=</span> authors.stream()
            .distinct()
            .map(author -&gt; author.getAge())
            .peek(System.out::println) <span class="hljs-comment">//查看当前流中的每个元素</span>
            <span class="hljs-comment">//初始result值为0，两者相同加，再赋值给result，最后返回结果为result</span>
            .reduce(<span class="hljs-number">0</span>, (result, element) -&gt; result + element);
    System.out.println(ageSum);
&#125;</code></pre></div><h3 id="特殊转换">特殊转换</h3><p>改变流的结构或类型。</p><ul><li><p><code>boxed()</code>：将数值流（如IntStream）转为对象流（Stream<integer>）。</integer></p></li><li><p><code>parallel()</code>：转换为并行流。</p><p>具体参见下文<a target="_blank" rel="noopener" href="https://captpaws.top/146f67fb/#并行流">并行流</a></p></li><li><p><code>sequential()</code>：转换为顺序流。</p></li></ul><h2 id="终结操作">3.6、终结操作</h2><p>必须要有终结操作，否则之前定义的中间操作就不会生效。这些操作的返回值不再是stream类型，不能再进行链式编程。操作分类如下：</p><table><thead><tr class="header"><th><strong>分类</strong></th><th><strong>方法/操作</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr class="odd"><td><strong>遍历处理</strong></td><td><code>forEach</code>, <code>forEachOrdered</code></td><td>产生副作用，不返回数据</td></tr><tr class="even"><td><strong>匹配查找</strong></td><td><code>anyMatch</code>, <code>allMatch</code>, <code>noneMatch</code>, <code>findFirst</code>, <code>findAny</code></td><td>返回布尔值或<code>Optional</code>，支持短路逻辑</td></tr><tr class="odd"><td><strong>归约统计</strong></td><td><code>reduce</code>, <code>count</code>, <code>sum</code>, <code>min</code>, <code>max</code></td><td>聚合计算，数值流有优化</td></tr><tr class="even"><td><strong>收集转换</strong></td><td><code>collect</code>, <code>toArray</code></td><td>灵活生成集合/数组，支持复杂聚合（如分组、分区、统计）</td></tr><tr class="odd"><td><strong>其他操作</strong></td><td><code>iterator</code>, <code>spliterator</code></td><td>低级别操作，通常用于框架或库开发</td></tr></tbody></table><h3 id="遍历处理">遍历处理</h3><ul><li><code>forEach(Consumer&lt;T&gt;)</code>：无序遍历（并行流不保证顺序）。</li><li><code>forEachOrdered(Consumer&lt;T&gt;)</code>：按流顺序遍历（并行流中强制顺序，性能较低）</li></ul><h5 id="foreach">forEach</h5><p>​ 对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作。</p><p>例子：输出所有作家的名字</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        输出所有作家的名字</span>
        List&lt;Author&gt; authors = getAuthors();

        authors.stream()
                .map(author -&gt; author.getName())
                .distinct()
                .forEach(name-&gt; System.out.println(name));
</code></pre></div><h3 id="匹配查找">匹配查找</h3><p>检查流中元素是否满足条件或查找特定元素。</p><h4 id="anymatch">anyMatch</h4><p>​ 可以用来判断<strong>是否有任意符合匹配条件</strong>的元素，结果为boolean类型</p><p>例子：</p><p>​ 判断是否有年龄在29以上的作家</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        判断是否有年龄在29以上的作家</span>
        List&lt;Author&gt; authors = getAuthors();
        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> authors.stream()
                .anyMatch(author -&gt; author.getAge() &gt; <span class="hljs-number">29</span>);
        System.out.println(flag);</code></pre></div><h4 id="allmatch">allMatch</h4><p>​ 可以用来判断是否<strong>都符合</strong>匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。</p><p>例子：判断是否所有的作家都是成年人</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        判断是否所有的作家都是成年人</span>
        List&lt;Author&gt; authors = getAuthors();
        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> authors.stream()
                .allMatch(author -&gt; author.getAge() &gt;= <span class="hljs-number">18</span>);
        System.out.println(flag);</code></pre></div><h4 id="nonematch">noneMatch</h4><p>​ 可以判断流中的元素是否<strong>都不符合</strong>匹配条件。如果都不符合结果为true，否则结果为false</p><p>例子：判断作家是否都没有超过100岁的。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        判断作家是否都没有超过100岁的。</span>
        List&lt;Author&gt; authors = getAuthors();

        <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> authors.stream()
                .noneMatch(author -&gt; author.getAge() &gt; <span class="hljs-number">100</span>);

        System.out.println(b);</code></pre></div><h4 id="findany">findAny</h4><p>​ 获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。</p><p>例子：获取任意一个年龄大于18的作家，如果存在就输出他的名字</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        获取任意一个年龄大于18的作家，如果存在就输出他的名字</span>
        List&lt;Author&gt; authors = getAuthors();
        Optional&lt;Author&gt; optionalAuthor = authors.stream()
                .filter(author -&gt; author.getAge()&gt;<span class="hljs-number">18</span>)
                .findAny();

        optionalAuthor.ifPresent(author -&gt; System.out.println(author.getName()));</code></pre></div><h4 id="findfirst">findFirst</h4><p>​ 获取流中的第一个元素。</p><p>例子：获取一个年龄最小的作家，并输出他的姓名。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        获取一个年龄最小的作家，并输出他的姓名。</span>
        List&lt;Author&gt; authors = getAuthors();
        Optional&lt;Author&gt; first = authors.stream()
                .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge())
                .findFirst();

        first.ifPresent(author -&gt; System.out.println(author.getName()));</code></pre></div><h3 id="归约统计">归约统计</h3><h4 id="reduce">reduce</h4><p><code>Stream.reduce()</code>是一个用于将流中的元素组合成一个单一结果的方法。它通过反复应用一个组合操作来实现，这个操作可以是求和、求最大值、字符串连接等（按照你指定的计算方式计算出一个结果）</p><p>​ reduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。</p><blockquote><p>进行reduce操作前，一般会使用map将流对象转化为我们操作的类型。（称为 map-reduce模式）</p><p>如：要求所有作者的年龄和，先把Author流对象通过map转化为Integer流，再进行reduce求和</p></blockquote><h5 id="无初始值">无初始值</h5><p><strong><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></strong></p><p>将流中<strong>第一个元素作为初始值</strong>，然后按照指定计算方式与后续的流对象进行计算，将最终结果封装在Optional对象中并返回，若流为空，返回 <code>Optional.empty()</code>。</p><p><strong>适用场景</strong>：无需初始值，处理可能为空的流。</p><p>其内部处理逻辑如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">foundAny</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
<span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
<span class="hljs-keyword">for</span> (T element : <span class="hljs-built_in">this</span> stream) &#123;
    <span class="hljs-keyword">if</span> (!foundAny) &#123;
        foundAny = <span class="hljs-literal">true</span>;
        result = element;
    &#125;
    <span class="hljs-keyword">else</span>
        <span class="hljs-comment">//使用累加器的apply方法进行计算</span>
        result = accumulator.apply(result, element);
&#125;
<span class="hljs-keyword">return</span> foundAny ? Optional.of(result) : Optional.empty();</code></pre></div><p>如果用一个参数的重载方法去求最小值代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        使用reduce求所有作者中年龄的最小值</span>
List&lt;Author&gt; authors = getAuthors();
Optional&lt;Integer&gt; minOptional = authors.stream()
    .map(author -&gt; author.getAge())
    .reduce((result, element) -&gt; result &gt; element ? element : result);
minOptional.ifPresent(age-&gt; System.out.println(age));</code></pre></div><h5 id="有初始值">有初始值</h5><p><strong><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></strong>，指定 <strong>初始值identity</strong>和累加器进行归约，返回确定类型结果（流为空时返回初始值）。</p><p>其内部的计算方式如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> identity;
<span class="hljs-keyword">for</span> (T element : <span class="hljs-built_in">this</span> stream)
	result = accumulator.apply(result, element)
<span class="hljs-keyword">return</span> result;</code></pre></div><p>​ 其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算，也是我们通过方法参数来确定的。</p><p>例子：</p><p>​ 使用reduce求所有作者年龄的和</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        使用reduce求所有作者年龄的和</span>
List&lt;Author&gt; authors = getAuthors();
<span class="hljs-type">Integer</span> <span class="hljs-variable">ageSum</span> <span class="hljs-operator">=</span> authors.stream()
    .distinct()
    .map(author -&gt; author.getAge())
    .reduce(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryOperator</span>&lt;Integer&gt;() &#123;<span class="hljs-comment">//初始result值为0</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">apply</span><span class="hljs-params">(Integer result, Integer element)</span> &#123;
            <span class="hljs-keyword">return</span> result + element;<span class="hljs-comment">//两者相同加，再赋值给result，最后返回结果为result</span>
        &#125;
    &#125;);
System.out.println(ageSum);

==========================使用lambda表达式简化写法===============================
List&lt;Author&gt; authors = getAuthors();
<span class="hljs-type">Integer</span> <span class="hljs-variable">ageSum</span> <span class="hljs-operator">=</span> authors.stream()
    .distinct()
    .map(author -&gt; author.getAge())
    <span class="hljs-comment">//初始result值为0，两者相同加，再赋值给result，最后返回结果为result</span>
    .reduce(<span class="hljs-number">0</span>, (result, element) -&gt; result + element);
System.out.println(ageSum);</code></pre></div><p>​ 使用reduce求所有作者中年龄的最大值</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        使用reduce求所有作者中年龄的最大值</span>
List&lt;Author&gt; authors = getAuthors();
<span class="hljs-type">Integer</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> authors.stream()
    .map(author -&gt; author.getAge())
    .reduce(Integer.MIN_VALUE, 
            (result, element) -&gt; result &lt; element ? element : result);

System.out.println(max);</code></pre></div><p>​ 使用reduce求所有作者中年龄的最小值</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        使用reduce求所有作者中年龄的最小值</span>
        List&lt;Author&gt; authors = getAuthors();
        <span class="hljs-type">Integer</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> authors.stream()
                .map(author -&gt; author.getAge())
                .reduce(Integer.MAX_VALUE, (result, element) -&gt; result &gt; element ? element : result);
        System.out.println(min);</code></pre></div><h5 id="支持并行流的规约">支持并行流的规约</h5><p><strong><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U, T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code></strong></p><ul><li><strong>功能</strong>：支持 <strong>并行流</strong>的归约，提供初始值、累加器（用于合并单个元素）和组合器（用于合并部分结果）。</li><li><strong>执行逻辑</strong>： 1.初始值 <code>identity</code>作为计算的起点。 2.在 <strong>并行流</strong>中，每个线程分片处理数据，使用 <code>accumulator</code>合并元素。 3.最终使用 <code>combiner</code>合并各分片的结果。</li><li><strong>适用场景</strong>：在并行流中进行复杂归约（如类型转换或聚合）。</li></ul><h4 id="count">count</h4><p>​ 可以用来获取当前流中元素的个数。</p><p>例子：</p><p>​ 打印这些作家的所出书籍的数目，注意删除重复元素。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        打印这些作家的所出书籍的数目，注意删除重复元素。</span>
        List&lt;Author&gt; authors = getAuthors();

        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> authors.stream()
                .flatMap(author -&gt; author.getBooks().stream())
                .distinct()
                .count();
        System.out.println(count);</code></pre></div><h4 id="maxmin">max&amp;min</h4><p>​ 可以用来或者流中的最值。</p><p>例子：</p><p>​ 分别获取这些作家的所出书籍的最高分和最低分并打印。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        分别获取这些作家的所出书籍的最高分和最低分并打印。</span>
        <span class="hljs-comment">//Stream&lt;Author&gt;  -&gt; Stream&lt;Book&gt; -&gt;Stream&lt;Integer&gt;  -&gt;求值</span>

        List&lt;Author&gt; authors = getAuthors();
        Optional&lt;Integer&gt; max = authors.stream()
                .flatMap(author -&gt; author.getBooks().stream())
                .map(book -&gt; book.getScore())
            <span class="hljs-comment">//指定比较器，告诉JDK按什么规则排序来得到最大最小值</span>
                .max((score1, score2) -&gt; score1 - score2); 

        Optional&lt;Integer&gt; min = authors.stream()
                .flatMap(author -&gt; author.getBooks().stream())
                .map(book -&gt; book.getScore())
                .min((score1, score2) -&gt; score1 - score2);
        System.out.println(max.get());
        System.out.println(min.get());</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601192954475-2024-6-119:30:05.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601192954475"><figcaption aria-hidden="true">image-20240601192954475</figcaption></figure><h3 id="收集转换">收集转换</h3><h5 id="toarray">toArray</h5><p><code>toArray()</code>：将流中的元素放入到一个数组中，默认为Object数组。他还有一个重载方法可以返回指定类型的数组</p><div class="code-wrapper"><pre><code class="hljs java">Object[] objects = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).toArray();
Integer[] integers = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).toArray(Integer[]::<span class="hljs-keyword">new</span>);</code></pre></div><p>如果想转换成其它集合类型，需要调用collect方法，利用Collectors.toXXX方法进行转换。</p><h5 id="collect">collect</h5><p>​ 收集操作，把当前流转换成一个集合。</p><p>例子：</p><p>​ 获取一个存放所有作者名字的List集合。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        获取一个存放所有作者名字的List集合。</span>
        List&lt;Author&gt; authors = getAuthors();
        List&lt;String&gt; nameList = authors.stream()
                .map(author -&gt; author.getName())
                .collect(Collectors.toList());
        System.out.println(nameList);</code></pre></div><p>​ 获取一个所有书名的Set集合。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        获取一个所有书名的Set集合。</span>
List&lt;Author&gt; authors = getAuthors();
Set&lt;String&gt; bookSet = authors.stream()
    .flatMap(author -&gt; author.getBooks().stream())
    .map(book -&gt; book.getName())
    .collect(Collectors.toSet());
System.out.println(bookSet);</code></pre></div><p>​</p><p>获取一个Map集合，map的key为作者名，value为List<book></book></p><p>Collectors.toMap方法有两个Function类型的参数，定义了要用当前流对象的哪个属性作为key，哪个属性作为value（这个参数与map中间操作的参数相同）</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601203246895-2024-6-120:33:05.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601203246895"><figcaption aria-hidden="true">image-20240601203246895</figcaption></figure><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        获取一个Map集合，map的key为作者名，value为List&lt;Book&gt;</span>

List&lt;Author&gt; authors = getAuthors();
Map&lt;String, List&lt;Book&gt;&gt; map = authors.stream()
    .distinct()
    .collect(Collectors.toMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Author, String&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(Author author)</span> &#123; <span class="hljs-comment">//用Author对象的什么属性作为key</span>
            <span class="hljs-keyword">return</span> author.getName();
        &#125;
    &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Author, List&lt;Book&gt;&gt;() &#123;<span class="hljs-comment">//用Author对象的什么属性作为value</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> List&lt;Book&gt; <span class="hljs-title function_">apply</span><span class="hljs-params">(Author author)</span> &#123;
            <span class="hljs-keyword">return</span> author.getBooks();
        &#125;
    &#125;));

</code></pre></div><p>lambda简化</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        获取一个Map集合，map的key为作者名，value为List&lt;Book&gt;</span>
List&lt;Author&gt; authors = getAuthors();

Map&lt;String, List&lt;Book&gt;&gt; map = authors.stream()
    .distinct()
    .collect(Collectors.toMap(author -&gt; author.getName(),
                              author -&gt; author.getBooks()));
System.out.println(map);</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601205542796-2024-6-120:55:51.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601205542796"><figcaption aria-hidden="true">image-20240601205542796</figcaption></figure><p><code>Collectors.groupingBy</code></p><p>将List的数据按照指定字段分组，结果为一个Map，key为分组字段，value为每组的元素。通过遍历Map的entrySet获取每组的key和value。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1、获取所有店铺</span>
   List&lt;Shop&gt; shops = shopService.list();
   <span class="hljs-comment">//2、根据Shop的typeID字段分组,typeId一致的放到一个集合</span>
   Map&lt;Long, List&lt;Shop&gt;&gt; collect = shops.stream()
       .collect(Collectors.groupingBy(Shop::getTypeId));

   <span class="hljs-comment">//3、遍历entrySet</span>
   <span class="hljs-keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : collect.entrySet()) &#123;
       <span class="hljs-comment">//3.1 获取类型id</span>
       <span class="hljs-type">Long</span> <span class="hljs-variable">typeId</span> <span class="hljs-operator">=</span> entry.getKey();
       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;
       <span class="hljs-comment">//3.2 获取对应店铺集合</span>
       List&lt;Shop&gt; shopList = entry.getValue();
   &#125;</code></pre></div><h1 id="四optional">四、Optional</h1><h2 id="概述-2">4.1 概述</h2><p>​ 我们在编写代码的时候出现最多的就是空指针异常。所以在很多情况下我们需要做各种非空的判断。</p><p>​ 例如：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> getAuthor();
<span class="hljs-keyword">if</span>(author!=<span class="hljs-literal">null</span>)&#123;
    System.out.println(author.getName());
&#125;</code></pre></div><p>​ 尤其是对象中的属性还是一个对象的情况下。这种判断会更多。</p><p>​ 而过多的判断语句会让我们的代码显得臃肿不堪。</p><p>​ 所以在JDK8中引入了Optional,养成使用Optional的习惯后你可以写出更优雅的代码来<strong>避免空指针异常</strong>。</p><p>​ 并且在很多函数式编程相关的API中也都用到了Optional，如果不会使用Optional也会对函数式编程的学习造成影响。</p><h2 id="使用">4.2 使用</h2><h3 id="创建对象">创建对象</h3><p>​ Optional就好像是包装类，可以把我们的具体数据封装Optional对象内部。然后我们去使用Optional中封装好的方法操作封装进去的数据，就可以非常优雅的避免空指针异常。</p><p>​ 我们一般使用<strong>Optional</strong>的<code>静态方法ofNullable</code>来把数据封装成一个Optional对象。无论传入的参数是否为null都不会出现问题。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240601230809882-2024-6-123:08:22.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240601230809882"><figcaption aria-hidden="true">image-20240601230809882</figcaption></figure><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> getAuthor();
Optional&lt;Author&gt; authorOptional = Optional.ofNullable(author);</code></pre></div><p>​ 你可能会觉得还要加一行代码来封装数据比较麻烦。但是如果改造下getAuthor方法，让其的返回值就是封装好的Optional的话，我们在使用时就会方便很多。</p><p>​ 而且在实际开发中我们的数据很多是从数据库获取的。Mybatis从3.5版本可以也已经支持Optional了。我们可以直接把dao方法的返回值类型定义成Optional类型，MyBastis会自己把数据封装成Optional对象返回。封装的过程也不需要我们自己操作。</p><p>​ 如果你<strong>确定一个对象不是空</strong>的则可以使用<strong>Optional</strong>的<strong>静态方法of</strong>来把数据封装成Optional对象。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Author</span>();
Optional&lt;Author&gt; authorOptional = Optional.of(author);</code></pre></div><p>​ 但是一定要注意，如果使用of的时候传入的参数<strong>必须不为null</strong>。（尝试下传入null会出现什么结果）</p><p>​ 如果一个方法的返回值类型是Optional类型。而如果我们经判断发现某次计算得到的返回值为null，这个时候就需要把null封装成Optional对象返回。这时则可以使用<strong>Optional</strong>的<strong>静态方法empty</strong>来进行封装。</p><div class="code-wrapper"><pre><code class="hljs java">Optional.empty()</code></pre></div><p>​</p><p>​ 所以最后你觉得哪种方式会更方便呢？<strong>ofNullable</strong></p><h3 id="安全消费值">安全消费值</h3><p>​ 我们获取到一个Optional对象后肯定需要对其中的数据进行使用。这时候我们可以使用其<code>ifPresent</code>方法对来消费其中的值。</p><p>​ <u>这个方法会判断其内封装的数据是否为空，不为空时才会执行具体的消费代码。</u>这样使用起来就更加安全了。</p><p>​ 例如,以下写法就优雅的避免了空指针异常。</p><div class="code-wrapper"><pre><code class="hljs java">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());

authorOptional.ifPresent(author -&gt; System.out.println(author.getName()));</code></pre></div><h3 id="获取值">获取值</h3><p>​ 如果我们想获取值自己进行处理可以使用get方法获取，但是不推荐。因为当Optional内部的数据为空的时候会出现异常。</p><h3 id="安全获取值">安全获取值</h3><p>​ 如果我们期望安全的获取值。我们不推荐使用get方法，而是使用Optional提供的以下方法。</p><ul><li><p><code>orElseGet</code></p><p><strong>获取数据并且设置数据为空时的默认值</strong>。如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建对象作为默认值返回。</p><div class="code-wrapper"><pre><code class="hljs java">Optional&lt;Author&gt; authorOptional = getAuthor();
<span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> authorOptional.orElseGet(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Supplier</span>&lt;Author&gt;() &#123;
    <span class="hljs-meta">@Override</span>
  <span class="hljs-comment">//如果该optional对象内部封装的数据为null时，返回方法内声明的数据</span>
    <span class="hljs-keyword">public</span> Author <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123; 
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Author</span>(<span class="hljs-number">1L</span>, <span class="hljs-string">&quot;叶枕眠&quot;</span>, <span class="hljs-number">33</span>, <span class="hljs-string">&quot;一个从菜刀中明悟哲理的祖安人&quot;</span>, <span class="hljs-literal">null</span>);
    &#125;
&#125;);

=============================lambda简化写法===================================

Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());
<span class="hljs-type">Author</span> <span class="hljs-variable">author1</span> <span class="hljs-operator">=</span> authorOptional.orElseGet(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Author</span>());</code></pre></div></li><li><p>orElseThrow</p><p>获取数据，如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建异常抛出。（可以在spring中对这些异常进行捕获处理）</p><div class="code-wrapper"><pre><code class="hljs java">Optional&lt;Author&gt; authorOptional = getAuthor();
<span class="hljs-keyword">try</span> &#123;
    <span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> authorOptional.orElseThrow(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Supplier</span>&lt;Throwable&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> Throwable <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//抛出自定义异常</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;author为空&quot;</span>);
        &#125;
    &#125;);
  System.out.println(author.getName());
&#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;
    throwable.printStackTrace();
&#125;


==========================lambda简化写法======================================

Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());
<span class="hljs-keyword">try</span> &#123;
    <span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> authorOptional.orElseThrow(
        () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;author为空&quot;</span>));
    System.out.println(author.getName());
&#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;
    throwable.printStackTrace();
&#125;</code></pre></div></li></ul><h3 id="过滤">过滤</h3><p>​ 我们可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据的Optional对象。</p><div class="code-wrapper"><pre><code class="hljs java">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());
authorOptional
    .filter(author -&gt; author.getAge()&gt;<span class="hljs-number">100</span>)<span class="hljs-comment">//对optional内封装的数据进行过滤</span>
    .ifPresent(author -&gt; System.out.println(author.getName()));<span class="hljs-comment">//过滤后再消费</span>
</code></pre></div><h3 id="判断">判断</h3><p>​ 我们可以使用<code>isPresent</code>方法进行是否存在数据的判断。如果为空返回值为false,如果不为空，返回值为true。但是这种方式并不能体现Optional的好处，<strong>更推荐使用ifPresent方法</strong>。</p><div class="code-wrapper"><pre><code class="hljs java">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());

<span class="hljs-keyword">if</span> (authorOptional.isPresent()) &#123;
    System.out.println(authorOptional.get().getName());
&#125;</code></pre></div><h3 id="数据转换">数据转换</h3><p>​ Optional还提供了map可以让我们的对数据进行转换，并且转换得到的数据也还是被Optional包装好的，保证了我们的使用安全。</p><p>例如我们想获取作家的书籍集合。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMap</span><span class="hljs-params">()</span> &#123;
    Optional&lt;Author&gt; authorOptional = getAuthor();
    authorOptional
            .map(author -&gt; author.getBooks())
            .ifPresent(books -&gt; System.out.println(books));
&#125;</code></pre></div><h1 id="六-方法引用">六、 方法引用</h1><blockquote><p>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案:拿什么参数做什么操作。</p><p>那么考虑一种情况:如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑? 如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</p><p>函数式接口是 Lambda 的基础，而方法引用是 Lambda 的孪生兄弟。</p></blockquote><p>我们在使用lambda时，<strong>如果方法体中只有一个方法的调用的话</strong>（包括构造方法）,我们可以用方法引用进一步简化代码。</p><p>例如：map操作的参数是一个lambda表达式且方法体重只有一个方法的调用，此时就可以使用方法引用来进一步简化</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test14</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">//获取一个存放所有作者名字的List集合。</span>
    List&lt;Author&gt; authors = getAuthors();
    List&lt;String&gt; nameList = authors.stream()
            <span class="hljs-comment">//.map(author -&gt; author.getName())</span>
        	.map(Author::getName)
            .distinct()
            .collect(Collectors.toList());
    System.out.println(nameList);
&#125;</code></pre></div><h2 id="推荐用法">6.1 推荐用法</h2><p>​ 我们在使用lambda时不需要考虑什么时候用方法引用，用哪种方法引用，方法引用的格式是什么。我们只需要在写完lambda方法发现方法体只有一行代码，并且是方法的调用时使用快捷键尝试是否能够转换成方法引用即可。</p><p>​ 当我们方法引用使用的多了慢慢的也可以直接写出方法引用。</p><h2 id="基本格式-1">6.2 基本格式</h2><p>​ 类名或者对象名::方法名</p><h2 id="语法详解了解">6.3 语法详解(了解)</h2><h3 id="引用类的静态方法">引用类的静态方法</h3><p>​ 其实就是引用类的静态方法</p><p>格式</p><div class="code-wrapper"><pre><code class="hljs java">类名::方法名</code></pre></div><p>使用前提：</p><ol type="1"><li>如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong></li><li>并且这行代码是<strong>调用了某个类的静态方法</strong></li><li>并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个静态方法中</strong></li></ol><p>这个时候我们就可以引用类的静态方法。</p><p>​</p><p>例如：如下代码就可以用方法引用进行简化</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();

Stream&lt;Author&gt; authorStream = authors.stream();

authors.stream()
    .map(author -&gt; author.getAge())
    .map(age-&gt;String.valueOf(age));


==========================其对应的匿名内部类写法如下=================================

    List&lt;Author&gt; authors = getAuthors();

authors.stream()
    .map(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Author, Integer&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">apply</span><span class="hljs-params">(Author author)</span> &#123;
            <span class="hljs-keyword">return</span> author.getAge(); <span class="hljs-comment">//并没有调用静态方法，也没有传递抽象方法的参数,不能简化</span>
        &#125;
    &#125;)
    .map(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Integer, String&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(Integer age)</span> &#123;
            <span class="hljs-keyword">return</span> String.valueOf(age); <span class="hljs-comment">//调用String的静态方法，且将抽象方法的参数传递进去</span>
        &#125;
    &#125;);</code></pre></div><blockquote><p>注意，如果我们所重写的方法是没有参数的，调用的方法也是没有参数的也相当于符合以上规则。</p></blockquote><p>优化后如下：</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();

Stream&lt;Author&gt; authorStream = authors.stream();

authorStream.map(author -&gt; author.getAge())
        .map(String::valueOf);</code></pre></div><h3 id="引用对象的实例方法">引用对象的实例方法</h3><p>格式</p><div class="code-wrapper"><pre><code class="hljs java">对象名::方法名</code></pre></div><p>使用前提</p><ol type="1"><li>如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong></li><li>并且这行代码是<strong>调用了某个对象的成员方法</strong></li><li>并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个成员方法中</strong></li></ol><p>这个时候我们就可以引用对象的实例方法</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();

Stream&lt;Author&gt; authorStream = authors.stream();
<span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
authorStream.map(author -&gt; author.getName())
    .forEach(name-&gt;sb.append(name));


==========================其对应的匿名内部类写法如下=================================

List&lt;Author&gt; authors = getAuthors();

Stream&lt;Author&gt; authorStream = authors.stream();
<span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
authorStream
    .map(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Author, String&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(Author author)</span> &#123;
            <span class="hljs-keyword">return</span> author.getName(); <span class="hljs-comment">//调用了author对象的成员方法，但没有传递抽象方法的参数，不能简化</span>
        &#125;
    &#125;)
    .forEach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String name)</span> &#123;
            sb.append(name);<span class="hljs-comment">//调用了sb对象的成员方法，且将抽象方法的参数传递进去,可以简化</span>
        &#125;
    &#125;);</code></pre></div><p>优化后：</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();

Stream&lt;Author&gt; authorStream = authors.stream();
<span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
authorStream.map(author -&gt; author.getName())
        .forEach(sb::append);</code></pre></div><h3 id="引用类的实例方法">引用类的实例方法</h3><p>格式</p><div class="code-wrapper"><pre><code class="hljs java">类名::方法名</code></pre></div><p>使用前提</p><ol type="1"><li>如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong></li><li>并且这行代码是<strong>调用了第一个参数的成员方法</strong></li><li>并且我们把要<strong>重写的抽象方法中剩余的所有的参数都按照顺序传入了这个成员方法中</strong></li></ol><p>这个时候我们就可以引用类的实例方法。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs java">   <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UseString</span>&#123;
       String <span class="hljs-title function_">use</span><span class="hljs-params">(String str,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> length)</span>;
   &#125;

   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">subAuthorName</span><span class="hljs-params">(String str, UseString useString)</span>&#123;
       <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
       <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;
       <span class="hljs-keyword">return</span> useString.use(str,start,length);
   &#125;


   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;

       subAuthorName(<span class="hljs-string">&quot;三更草堂&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UseString</span>() &#123;
           <span class="hljs-meta">@Override</span>
           <span class="hljs-keyword">public</span> String <span class="hljs-title function_">use</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> length)</span> &#123;
               <span class="hljs-keyword">return</span> str.substring(start,length);
           &#125;
       &#125;);

&#125;</code></pre></div><p>优化后如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;

    subAuthorName(<span class="hljs-string">&quot;三更草堂&quot;</span>, String::substring);

&#125;</code></pre></div><h3 id="构造器引用">构造器引用</h3><p>​ 如果方法体中的一行代码是构造器的话就可以使用构造器引用。</p><p>格式</p><div class="code-wrapper"><pre><code class="hljs java">类名::<span class="hljs-keyword">new</span></code></pre></div><p>使用前提</p><ol type="1"><li>如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong></li><li>并且这行代码是<strong>调用了某个类的构造方法</strong></li><li>并且我们把<strong>要重写的抽象方法中的所有的参数都按照顺序传入了这个构造方法中</strong></li></ol><p>这个时候我们就可以引用构造器。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();
authors.stream()
        .map(author -&gt; author.getName())
        .map(name-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(name))
        .map(sb-&gt;sb.append(<span class="hljs-string">&quot;-三更&quot;</span>).toString())
        .forEach(str-&gt; System.out.println(str));</code></pre></div><p>优化后：</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();
authors.stream()
    .map(author -&gt; author.getName())
    .map(StringBuilder::<span class="hljs-keyword">new</span>)
    .map(sb-&gt;sb.append(<span class="hljs-string">&quot;-三更&quot;</span>).toString())
    .forEach(str-&gt; System.out.println(str));

======================进一步简化===========================&gt;
List&lt;Author&gt; authors = getAuthors();
authors.stream()
    .map(Author::getName)
    .map(StringBuilder::<span class="hljs-keyword">new</span>)
    .map(sb-&gt;sb.append(<span class="hljs-string">&quot;-三更&quot;</span>).toString())
    .forEach(System.out::println);</code></pre></div><h2 id="七高级用法">七、高级用法</h2><h3 id="基本数据类型优化">7.1 基本数据类型优化</h3><p>​ 我们之前用到的很多Stream的方法由于都使用了泛型。所以涉及到的参数和返回值都是引用数据类型。</p><p>​ 即使我们操作的是整数小数，但是实际用的都是他们的包装类。JDK5中引入的自动装箱和自动拆箱让我们在使用对应的包装类时就好像使用基本数据类型一样方便。但是你一定要知道装箱和拆箱肯定是要消耗时间的。虽然这个时间消耗很下。但是在大量的数据不断的重复装箱拆箱的时候，你就不能无视这个时间损耗了。</p><p>​ 所以为了让我们能够对这部分的时间消耗进行优化。Stream还提供了很多专门针对基本数据类型的方法。</p><p>​ 例如：mapToInt、mapToLong、mapToDouble、flatMapToInt、flatMapToDouble等。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test27</span><span class="hljs-params">()</span> &#123;

    List&lt;Author&gt; authors = getAuthors();
    authors.stream()
            .map(author -&gt; author.getAge())
            .map(age -&gt; age + <span class="hljs-number">10</span>)
            .filter(age-&gt;age&gt;<span class="hljs-number">18</span>)
            .map(age-&gt;age+<span class="hljs-number">2</span>)
            .forEach(System.out::println);

    authors.stream()
            .mapToInt(author -&gt; author.getAge())<span class="hljs-comment">//****转化为int类型再操作</span>
            .map(age -&gt; age + <span class="hljs-number">10</span>)
            .filter(age-&gt;age&gt;<span class="hljs-number">18</span>)
            .map(age-&gt;age+<span class="hljs-number">2</span>)
            .forEach(System.out::println);
&#125;</code></pre></div><h3 id="并行流">7.2 并行流</h3><p>​ 当流中有大量元素时，我们可以使用并行流去提高操作的效率。其实并行流就是把任务分配给多个线程去完全。如果我们自己去用代码实现的话其实会非常的复杂，而如果我们使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮我们实现，从而提高效率。</p><p>​ parallel方法可以把串行流转换成并行流。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test28</span><span class="hljs-params">()</span> &#123;
    Stream&lt;Integer&gt; stream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);
    <span class="hljs-type">Integer</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> stream.parallel()
            .peek(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;Integer&gt;() &#123;
                <span class="hljs-meta">@Override</span>
                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Integer num)</span> &#123;
                    System.out.println(num+Thread.currentThread().getName());
                &#125;
            &#125;)
            .filter(num -&gt; num &gt; <span class="hljs-number">5</span>)
            .reduce((result, ele) -&gt; result + ele)
            .get();
    System.out.println(sum);
&#125;</code></pre></div><p>​ 也可以通过parallelStream直接获取并行流对象。</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();
authors.parallelStream()
        .map(author -&gt; author.getAge())
        .map(age -&gt; age + <span class="hljs-number">10</span>)
        .filter(age-&gt;age&gt;<span class="hljs-number">18</span>)
        .map(age-&gt;age+<span class="hljs-number">2</span>)
        .forEach(System.out::println);</code></pre></div></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/JavaSE/" class="category-chain-item">JavaSE</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Stream%E6%B5%81/" class="print-no-link">#Stream流</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="print-no-link">#函数式编程</a></div></div><div class="license-box my-3"><div class="license-title"><div>函数式编程-Stream流</div><div>https://catpaws.top/146f67fb/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年12月9日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/a974f5b0/" title="注解和反射"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">注解和反射</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/f07c622d/" title="MySQL（三）"><span class="hidden-mobile">MySQL（三）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://catpaws.top/blog-resource/twikoo1.6.42/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本站由<img src="/img/upyun_logo.png" srcset="https://catpaws.top/img/transpare.svg" lazyload style="width:auto;height:auto">提供CDN加速/云存储服务</a></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备2025059828号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61032302000087" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="police-icon"> <span>陕公网安备61032302000087号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//catpaws.top/blog-resource/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="//catpaws.top/blog-resource/js/loader.js"></script><script src="//catpaws.top/blog-resource/js/blurpicload.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://registry.npmmirror.com/oh-my-live2d/latest/files"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",libraryUrls:{complete:"https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/complete.js",cubism2:"https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/cubism2.js",cubism5:"https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/cubism5.js"},mobileDisplay:!1,models:[{path:"https://catpaws.top/blog-resource/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"}}})</script></body></html>