<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="http://img.catpaws.top/blog-source/imgs/webicon.png"><link rel="icon" href="http://img.catpaws.top/blog-source/imgs/webicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="一、查找的基本概念 查找表：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，可以是一个数组或链表等数据类型。  静态查找表：只进行查找操作，无须动态地修改的查找表称为静态查找表。  适合静态查找表的查找方法：顺序查找、折半查找、散列查找等  动态查找表：不仅要进行查找，还需要动态地插入或删除的查找表称为动态查找表。  特点：表结构本身是在查找过程中动态"><meta property="og:type" content="article"><meta property="og:title" content="七、查找"><meta property="og:url" content="https://catpaws.top/24d4ba7c/index.html"><meta property="og:site_name" content="猫爪在上de书桌"><meta property="og:description" content="一、查找的基本概念 查找表：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，可以是一个数组或链表等数据类型。  静态查找表：只进行查找操作，无须动态地修改的查找表称为静态查找表。  适合静态查找表的查找方法：顺序查找、折半查找、散列查找等  动态查找表：不仅要进行查找，还需要动态地插入或删除的查找表称为动态查找表。  特点：表结构本身是在查找过程中动态"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://img.catpaws.top/img/image-20230316184247777-2024-12-811_15_42.png"><meta property="og:image" content="http://img.catpaws.top/img/Snipaste_2023-03-16_21-18-09-2024-12-811_16_15.png"><meta property="og:image" content="http://img.catpaws.top/img/image-20230316213850597-2024-12-811_19_51.png"><meta property="og:image" content="http://img.catpaws.top/img/Snipaste_2023-03-16_22-19-50-2024-12-811_32_47.png"><meta property="og:image" content="http://img.catpaws.top/img/image-20241208112949836-2024-12-811_29_56.png"><meta property="og:image" content="http://img.catpaws.top/img/image-20230318204512157-2024-12-811_54_28.png"><meta property="og:image" content="http://img.catpaws.top/img/image-20230318204722921-2024-12-811_54_46.png"><meta property="og:image" content="http://img.catpaws.top/img/Snipaste_2023-03-18_21-01-04-2024-12-811_55_02.png"><meta property="og:image" content="http://img.catpaws.top/img/image-20230323160202508-2024-12-811_55_23.png"><meta property="og:image" content="http://img.catpaws.top/img/image-20230320161057030-2024-12-811_56_35.png"><meta property="og:image" content="http://img.catpaws.top/img/image-20230320150715631-2024-12-811_56_43.png"><meta property="og:image" content="http://img.catpaws.top/img/image-20230320153438409-2024-12-811_56_48.png"><meta property="og:image" content="http://img.catpaws.top/img/image-20230320174149811-2024-12-811_57_00.png"><meta property="og:image" content="http://img.catpaws.top/img/image-20230320164537682-2024-12-811_57_04.png"><meta property="og:image" content="http://img.catpaws.top/img/Snipaste_2023-03-20_17-41-10-2024-12-811_57_10.png"><meta property="og:image" content="http://img.catpaws.top/img/image-20230320180717857-2024-12-811_57_14.png"><meta property="og:image" content="http://img.catpaws.top/img/image-20230320213023659-2024-12-815_42_20.png"><meta property="article:published_time" content="2024-12-08T03:10:57.000Z"><meta property="article:modified_time" content="2025-01-26T07:06:07.502Z"><meta property="article:author" content="猫爪在上"><meta property="article:tag" content="查找"><meta property="article:tag" content="二分查找"><meta property="article:tag" content="分块查找"><meta property="article:tag" content="二叉排序树"><meta property="article:tag" content="平衡二叉树"><meta property="article:tag" content="红黑树"><meta property="article:tag" content="B树"><meta property="article:tag" content="散列表"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://img.catpaws.top/img/image-20230316184247777-2024-12-811_15_42.png"><title>七、查找 - 猫爪在上de书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css"><link rel="stylesheet" href="//img.catpaws.top/blog-source/css/font.css"><link rel="stylesheet" href="//img.catpaws.top/blog-source/css/poem.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://tntpv22c.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上de书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(http://img.catpaws.top/blog-source/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="七、查找"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-12-08 11:10" pubdate>2024年12月8日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 10k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 85 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">七、查找</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年1月26日 下午</p><div class="markdown-body"><meta name="referrer" content="no-referrer"><p><img src="http://img.catpaws.top/img/image-20230316184247777-2024-12-811_15_42.png" srcset="/img/loading.gif" lazyload alt="image-20230316184247777" style="zoom:60%"></p><h2 id="一查找的基本概念">一、查找的基本概念</h2><p><strong>查找表</strong>：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，可以是一个数组或链表等数据类型。</p><ul><li>静态查找表：只进行查找操作，无须动态地修改的查找表称为静态查找表。<ul><li>适合静态查找表的查找方法：顺序查找、折半查找、散列查找等</li></ul></li><li>动态查找表：不仅要进行查找，还需要动态地插入或删除的查找表称为动态查找表。<ul><li>特点：表结构本身是在查找过程中动态生成的，即对于给定的 key，若表中存在关键字等于 key 的记录，则查找成功；否则插入关键字为 key 的记录。</li><li>数个动态查找表的查找方法：二叉排序树的查找、散列查找、<u>二叉平衡树、B 树、B+树</u>（其都是二叉排序树的改进）等。</li></ul></li></ul><p><strong>关键字</strong>：<strong>唯一标识</strong>数据元素的数据项。</p><p>查找算法的效率评价：</p><p>​ <strong>平均查找长度是衡量查找算法效率最主要的指标，其数量级反映了算法的时间复杂度。</strong></p><p>​ 平均查找长度 （<strong>ASL</strong>）：在查找过程中，一次查找长度是指需要比较的关键字次数，而平均查找长度是指所有查找过程中进行关键字的比较次数的平均值，记为 <span class="math inline">\(ASL = \sum_{i=1}^{n} P_iC_i\)</span>。</p><ul><li>n 是查找表的长度</li><li><span class="math inline">\(P_i\)</span>是查找第<span class="math inline">\(i\)</span>个元素的概率。一般认为每个数据元素的查找概率相等，即<span class="math inline">\(P_i = \frac{1}{n}\)</span></li><li><span class="math inline">\(C_i\)</span>是找到第<span class="math inline">\(i\)</span>个元素所要进行比较的次数。</li></ul><p>通常考虑查找成功和查找失败两种情况下的 ASL（<span class="math inline">\(ASL_{成功}\)</span>和 <span class="math inline">\(ASL_{失败}\)</span>）</p><h2 id="二线性结构查找方法">二、线性结构查找方法</h2><h3 id="顺序查找">2.1、顺序查找</h3><p>顺序查找又称线性查找，分为对一般的无序线性表的顺序查找和对关键字有序的顺序表的查找</p><p><strong>一般线性表的查找</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">//查找表</span>
    ElemType *elem; <span class="hljs-comment">//元素存储空间基址</span>
    <span class="hljs-type">int</span> TableLen; <span class="hljs-comment">//表的长度</span>
&#125;SSTable;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search_Seq</span><span class="hljs-params">(SSTable ST, ElemType key)</span> </span>&#123;
    ST.elem[<span class="hljs-number">0</span>] = key; <span class="hljs-comment">// 哨兵</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ST.TableLen; ST.elem[i] != key; --i); <span class="hljs-comment">//从后往前找</span>
    <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//若i = 0 表示查找失败</span>
&#125;</code></pre></div><p>对于有 n 个元素的表，给定值 key 与表中第 i 个元素相等，即定位第 i 个元素时，需要进行 n-i+1 次比较，当每个元素的查找概率相等时，<span class="math inline">\(ASL_{成功}\)</span> = <span class="math inline">\(\frac{1+2+3+...+n}{n} = \frac{n+1}{2}\)</span>, <span class="math inline">\(ASL_{失败} = n+1\)</span> 。其时间复杂度为<span class="math inline">\(O(n)\)</span></p><p><strong>有序表的顺序查找</strong></p><p>若查找表中的关键字是有序的，则查找失败时可以不用再比较到表的另一端，就能返回查找失败的信息，从而<strong>降低查找失败时的平均查找长度<span class="math inline">\(ASL_{失败}\)</span></strong>，<span class="math inline">\(ASL_{成功}\)</span>和查找表无序时相同。</p><p>如在查找表 (10,20,30,40)中查找 25，该<strong>查找判定树</strong>如下：</p><p><img src="http://img.catpaws.top/img/Snipaste_2023-03-16_21-18-09-2024-12-811_16_15.png" srcset="/img/loading.gif" lazyload alt="Snipaste_2023-03-16_21-18-09" style="zoom:45%"></p><p>由判定树可得： <span class="math inline">\(ASL_{失败} = \frac{1+2+..+n+n}{n+1} = \frac{n}{2}+\frac{n}{n+1}\)</span>（西电课件上：<span class="math inline">\(ASL_{失败} = \frac{n}{2}+1\)</span>）</p><p>在一棵查找判定树中：</p><ul><li>n 个元素，有 n+1 种查找失败的情况（对应 n+1 个空链域）</li><li><strong>一个成功结点的查找长度 = 自身所在的层数</strong> (在折半查找中也是一样)</li><li><strong>一个失败结点的查找长度 = 其父节点所在的层数</strong> (在折半查找中也是一样)</li></ul><h3 id="折半查找">2.2、折半查找</h3><p>折半查找仅适用于<u><strong>有序的顺序表</strong></u>。</p><p>思想：默认顺序表为升序</p><ul><li>初始时，low = <span class="math inline">\(0\)</span>, high = len-1，mid。</li><li>当 low &lt;= high 时, mid = <span class="math inline">\(\lfloor (low + high)/2\rfloor\)</span><ul><li>若 elem[mid] = key, 则已找到指定元素，返回 key</li><li>若 elem[mid] &lt; key，则 key 在 mid 的右侧， <strong>low = mid + 1</strong>，继续查找</li><li>若 elem[mid] &gt; key， 则 key 在 mid 的左侧，<strong>high = mid -1</strong>，继续查找</li></ul></li><li>当 low &gt; high 时，查找失败。</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Binary_Search</span><span class="hljs-params">(SeqList L, ElemType key)</span> </span>&#123;
    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>, high = L.TableLen - <span class="hljs-number">1</span>, mid;
    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;
        mid = （low + high) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span> (L.elem[mid] == key)
            <span class="hljs-keyword">return</span> mid;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (L.elem[mid] &lt; key)
            low = mid + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span>
            high = mid - <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">//查找失败返回-1</span>
&#125;
<span class="hljs-comment">//递归形式</span>
...</code></pre></div><p>对在查找表(7,10,13,16,19,29,32,33,37,41,43)中查找值为 11 和值为 32 的过程，可以用其判定树来描述。</p><p><img src="http://img.catpaws.top/img/image-20230316213850597-2024-12-811_19_51.png" srcset="/img/loading.gif" lazyload alt="image-20230316213850597" style="zoom:80%"></p><p>对于 11 个成功的结点,当每个结点的查找概率相同，<span class="math inline">\(ASL_{成功} = (1*1+2*2+3*4+4*4)/11 = 3\)</span></p><p>对于 12 个查找失败的结点，假设每个结点的查找概率相同，<span class="math inline">\(ASL_{失败} = (3*4+4*8)/12 = \frac{11}{3}\)</span></p><p>该判定树只有最下层是不满的，高度和完全二叉树相同，故折半查找判定树的树高 <span class="math inline">\(h = \lceil log_{2}{(n+1)}\rceil\)</span>（<strong>不包含失败结点</strong>），所以折半查找的时间复杂度为 <span class="math inline">\(O(log_2n)\)</span></p><p>折半查找的判定树</p><ul><li><p>当 mid = <span class="math inline">\(\lfloor (low + high)/2\rfloor\)</span>时</p><ul><li>若共有奇数个元素，mid 分割后 左右子树元素个数相等</li><li>若有偶数个元素，mid 分割后右子树比比左子树多一个元素</li></ul><p>在该判定树中，若 mid = <span class="math inline">\(\lfloor (low + high)/2\rfloor\)</span>，则对任何一个结点，必有：<u>右子树结点数- 左子树结点数 = <span class="math inline">\(0\)</span>或<span class="math inline">\(1\)</span>。</u></p></li><li><p>当 mid = <span class="math inline">\(\lceil (low + high)/2\rceil\)</span>时，在折半查找的判定树中，对任何一个结点，必有：<u>左子树结点数 - 右子树结点数= <span class="math inline">\(0\)</span>或<span class="math inline">\(1\)</span></u></p></li><li><p>折半查找的判定树一定是<strong><u>平衡二叉树</u></strong></p></li><li><p>在该判定树中，只有最后一层是不满的， 树高 h= <span class="math inline">\(\lceil log_2{(n+1)}\rceil\)</span>或 <span class="math inline">\(\lfloor log_2n\rfloor + 1\)</span>。</p></li><li><p>判定树中的关键字，左&lt;中&lt;右，满足<u>二叉排序树</u>的定义。</p></li><li><p>失败结点的个数为 <span class="math inline">\(n+1\)</span>，即空链域的个数。</p></li></ul><p><strong>构造查找判定树</strong>（构造 n 个结点的平衡二叉树）</p><ul><li><p>mid = <span class="math inline">\(\lfloor (low + high)/2\rfloor\)</span>时，右子树结点数- 左子树结点数 = <span class="math inline">\(0\)</span>或<span class="math inline">\(1\)</span>。每次先在右子树上插入，之后再在左子树中<u>同样的位置</u>插入，依次进行。注意不能破坏不能破坏左右子树中结点数量的关系。</p></li><li><p>mid = <span class="math inline">\(\lceil (low + high)/2\rceil\)</span>时，左子树结点数 - 右子树结点数= <span class="math inline">\(0或1\)</span>。每次先在左子树上插入，之后再在右子树中<u>同样的位置</u>插入，依次进行。注意不能破坏不能破坏左右子树中结点数量的关系。</p></li></ul><p>给定 n 个元素，构造其查找判定树时，先按某个 mid 取值方法，构造出 n 个结点的判定树的形状，再按<strong>中序遍历</strong>填入各个元素。（<strong>记得加上失败节点</strong>）</p><blockquote><p>1、折半查找平均情况下比顺序查找的效率高，但折半查找并不一定比顺序查找快</p><p>2、由于该判定树只有最下层是不满的，失败结点最早出现在第 <span class="math inline">\(h-1\)</span>层结点的左右子树中，最迟出现在叶子结点的左右子树中，故使用二分查找算法查找一个不存在的元素，比较次数至少为 <span class="math inline">\(h-1\)</span>,至多为 <span class="math inline">\(h\)</span></p><p>3、折半查找失败时，low &gt; high, 此时 low 所指的是大于 key 的最小值，即第一个大于 key 的元素，low 之后的元素都大于 key；high 所指的是小于 key 的最大值，即第一个小于 key 的值，high 之前的元素都小于 key。</p></blockquote><p>在 n 个关键字的有序的顺序表中，使用折半查找时，<span class="math inline">\(ASL_{成功}\)</span>和<span class="math inline">\(ASL_{失败}\)</span></p><ol type="1"><li><p>n 个关键字，其判定树树高 <span class="math inline">\(h = \lceil log_2(n+1)\rceil\)</span> ，叶子结点个数 <span class="math inline">\(K = n - (2^{h-1}-1)\)</span></p><p>故 <span class="math inline">\(ASL_{成功} = \frac{1*1+2*2+2^2*3+...+2^{h-2}*(h-1)+K*h}{n}\)</span></p><p><span class="math inline">\(ASL_{失败} = \frac{(h-1)*(2^{h-1}-K)+h*2K}{n+1}\)</span></p></li><li><p>构造 n 个关键字的查找判定树，根据判定树确定<span class="math inline">\(ASL_{成功}\)</span>和<span class="math inline">\(ASL_{失败}\)</span>。</p></li></ol><p>不论 mid 取值的方法如何，选用一种进行判定树的构造，对计算平均查找长度没有影响。</p><h3 id="分块查找">2.3、分块查找</h3><p>分块查找又称 <strong>索引顺序查找</strong>。</p><p><img src="http://img.catpaws.top/img/Snipaste_2023-03-16_22-19-50-2024-12-811_32_47.png" srcset="/img/loading.gif" lazyload alt="Snipaste_2023-03-16_22-19-50" style="zoom:80%"></p><p><img src="http://img.catpaws.top/img/image-20241208112949836-2024-12-811_29_56.png" srcset="/img/loading.gif" lazyload alt="image-20241208112949836" style="zoom:67%"></p><p>思想：将查找表分为若干子块，<strong>块内元素可以无序，但块间有序</strong>。再建立索引表，索引表中每个元素包括<u>各块中元素的最大值</u>和<u>每个块的第一个元素地址</u>，其中索引表按关键字有序排列。</p><p>分块查找的步骤：先查索引表（顺序查找或折半查找），再对分块内进行顺序查找。</p><p><strong>ASL = 查找索引表的查找长度 + 查分块的查找长度</strong></p><p>用折半查找查索引表时，<strong>若待查记录不在索引表中</strong>，折半查找失败，此时 low&gt;high，应在<strong>low</strong>所指的块中查找。<strong>此时查索引表的查找长度是折半查找的判定树中该失败结点的父节点所在的层数</strong>，若最终 low 超出索引表的范围，则查找失败。</p><blockquote><p>此时 low 所指的是大于关键字的最小值，应在该块对应的范围内再寻找。</p><p>而 high 所指的是小于关键字的最大值，high 对应的块其范围内的元素都比关键字小。</p></blockquote><p>若 n 个元素的查找表被分成 b 块，每块 s 个元素，在每个元素查找概率相同的情况下：</p><ul><li><p>顺序查找索引表：<span class="math inline">\(ASL_{成功}\)</span>= L1 + L2 = <span class="math inline">\(\frac{1+2+...+b}{b}+\frac{1+2+...+s}{s} = {\frac{b+1}{2}+\frac{s+1}{2}} = \frac{s^2+2s+n}{2}\)</span>，当 <span class="math inline">\(s = \sqrt{n}\)</span>时，<span class="math inline">\(ASL_{成功}\)</span> 取得最小值$ +1$。</p></li><li><p>折半查找索引表：<span class="math inline">\(ASL_{成功} = L1+L2 = \lceil log_2(b+1)\rceil + \frac{s+1}{2}\)</span></p></li></ul><h2 id="三树形结构查找方法">三、树形结构查找方法</h2><h3 id="二叉排序树bst">3.1、二叉排序树（BST）</h3><p>1、<strong>二叉排序树的定义</strong></p><p>二叉排序树，又称二叉查找树（BST，Binary Search Tree）一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p><ul><li>左子树上所有结点的关键字均小于根结点的关键字；</li><li>右子树上所有结点的关键字均大于根结点的关键字。</li><li>左子树和右子树又各是一棵二叉排序树。</li></ul><p>根据二叉排序树的定义，左子树结点值 &lt; 根结点值 &lt;右子树结点值，对其进行一次<strong>中序遍历</strong>，可以得到一个递增的有序序列。</p><blockquote><ol type="i"><li><p>若已知一个二叉排序树的先序/后序/层序遍历序列，可以得到其中序序列，进而可以构造出这棵二叉排序树，其中序序列为递增有序的序列。</p></li><li><p>利用二叉排序树进行查找时，要画上失败结点。</p></li><li><p>成功和失败查找长度的计算与折半查找判定树中对应查找长度的计算方法相同。</p></li></ol></blockquote><p>2、<strong>二叉排序树的查找</strong></p><p>二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//非递归算法</span>
<span class="hljs-function">BSTNode* <span class="hljs-title">search</span><span class="hljs-params">(BiTree T, ElemType key)</span> </span>&#123;
    <span class="hljs-keyword">while</span> (T != <span class="hljs-literal">NULL</span> &amp;&amp; key != T-&gt;data) &#123;
        <span class="hljs-keyword">if</span> (key &lt; T-&gt;data)
            T = T-&gt;lchild;
        <span class="hljs-keyword">else</span>
            T = T-&gt;rchild;
    &#125;
    <span class="hljs-keyword">return</span> T;
&#125;
<span class="hljs-comment">//递归算法</span>
<span class="hljs-function">BSTNode* <span class="hljs-title">search</span><span class="hljs-params">(BiTree T, ElemType key)</span></span>&#123;
    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">if</span> (key == T-&gt;data) <span class="hljs-keyword">return</span> T;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; T-&gt;data)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">search</span>(T-&gt;lchild, key);
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">search</span>(T-&gt;rchild, key);
&#125;</code></pre></div><p>3、二叉排序树的插入</p><p>二叉排序树作为一个动态树表，该树的结构不是一次生成的，而是在查找过程中，当树中不存在关键字值等于给定值的节点时再进行插入的。</p><p>插入过程：若原二叉排序树为空，则直接插入结点；否则，若关键字 k 小于根结点的值，则插入到左子树，若关键字 k 大于根结点值，则插入到右子树。</p><p>插入的结点一定是一个新添加的<strong>叶结点</strong>，且是查找失败时的查找路径上最后一个结点的左孩子或右孩子。</p><p>当插入序列有序时，树的高度最大。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//非递归算法</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BST_Insert</span><span class="hljs-params">(BiTree T, ElemType key)</span> </span>&#123;
    BSTNode *p = T,*q;<span class="hljs-comment">//p用于遍历，q保存p的父节点。</span>
    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//寻找插入位置</span>
        q = p; <span class="hljs-comment">//保存父节点</span>
        <span class="hljs-keyword">if</span> (key == p-&gt;data)
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//插入失败</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; p-&gt;data)
            p = p-&gt;lchild;
        <span class="hljs-keyword">else</span>
            p = p-&gt;rchild;
    &#125;
    <span class="hljs-comment">//若在树中没有找到key，最终该结点要插在q所指结点的左孩子或右孩子处</span>
    BSTNode* node = (BiTree) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BSTNode));
    node-&gt;data = key;
    node-&gt;lchild = <span class="hljs-literal">NULL</span>; node-&gt;rchild = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">if</span> (key &lt; q-&gt;data)
        q-&gt;lchild = node;
    <span class="hljs-keyword">else</span>
        q-&gt;rchild = node;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//插入成功</span>
&#125;

<span class="hljs-comment">//递归算法</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BST_Insert</span><span class="hljs-params">(BiTree &amp;T, ElemType key)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//若原树为空，则创建一个新结点插入。最终一定会插入到叶子结点的位置</span>
        T = (BiTree) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BSTNode));
        T-&gt;data = key;
        T-&gt;lchild = <span class="hljs-literal">NULL</span>; T-&gt;rchild = <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//返回1，插入成功</span>
    &#125;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == T-&gt;data) <span class="hljs-comment">//在树中找到该结点，插入失败</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; T-&gt;data)  <span class="hljs-comment">//在左子树中插入</span>
        <span class="hljs-built_in">BST_Insert</span>(T-&gt;lchild, key);
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">BST_Insert</span>(T-&gt;rchild, key);
&#125;

<span class="hljs-comment">//构造二叉排序树</span>
<span class="hljs-comment">//从一棵空树出发，依次输入元素，将其插入二叉排序树中合适的位置</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BST_Creat</span><span class="hljs-params">(BiTree &amp;T, ElemType str[], <span class="hljs-type">int</span> n)</span> </span>&#123;
    <span class="hljs-comment">//按照str[]中的关键字序列建立二叉排序树</span>
    T = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//初始时T为空树</span>
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (i &lt; n) &#123;
        <span class="hljs-built_in">BST_Insert</span>(T, str[i]);
        i++;
    &#125;
&#125;</code></pre></div><p>4、<strong>二叉排序树的删除</strong></p><p>删除某结点后要保持二叉排序树的特性不变，即 左&lt;根&lt;右。</p><p>对于被删除的结点 Z，有三种情况</p><ol type="1"><li><p>Z 是叶节点，则直接删除</p></li><li><p>Z 只有左子树或右子树，则删除结点 Z，并让 Z 的子树成为 Z 的父节点的子树，替代 Z 的位置</p></li><li><p>Z 同时有左子树和右子树</p><ul><li><p>方案一：<strong>用左子树中值最大的结点代替 Z 的位置</strong>。该结点是 Z 左子树的中序遍历序列的最后一个结点，即用<strong>左子树最右下的结点代替 Z</strong>，再删除该结点。而该结点一定没有右子树，对该结点的删除转化为第 1.2 中情况下的删除。</p></li><li><p>方案二：<strong>用右子树中值最小的结点代替 Z 的位置。</strong>该结点是 Z 右子树的中序遍历序列的第一个结点，即用<strong>右子树最左下的结点代替 Z</strong>，再删除该结点。而该结点一定没有左子树，对该结点的删除转化为第 1.2 中情况下的删除。</p></li><li><p>方案三：令<em>p 的左子树为 </em>f 的左子树（若 *p 是 *f 的左孩子），而*p 的右子树为 *s 的右子树（*s 是对 *p 的左子树进行中序遍历的最后一个结点 ，即让 *p 的右孩子连接到左子树中最大元素的右孩子处）</p><p>或者，令 *p 的右子树为 *f 的右子树（若 *p 是 *f 的右孩子），而*p 的左子树为 *s 的左子树（*s 是对 *p 的右子树进行中序遍历的第一个结点 ，即让 *p 的左孩子连接到右子树中最小元素的左孩子上）</p><figure><img src="http://img.catpaws.top/img/image-20241208115345730-2024-12-811_53_54.png" srcset="/img/loading.gif" lazyload alt="image-20241208115345730"><figcaption aria-hidden="true">image-20241208115345730</figcaption></figure></li></ul></li></ol><p><strong>删除并插入结点 v</strong></p><ul><li><p>在<u>二叉排序树</u>中，<strong>删除并插入</strong>某结点时，由于插入位置一定在叶子结点处，所以当被该结点<strong>不是叶子结点</strong>时，删除插入操作完成后二叉排序树结构将发生改变。</p></li><li><p>在<u>二叉平衡树</u> <span class="math inline">\(T_1\)</span>中，删除一个结点 v 后得到新的 AVL 树<span class="math inline">\(T_2\)</span>，再将该结点插回得到新的 AVL 树<span class="math inline">\(T_3\)</span>。</p><ul><li>v 是叶结点：若删除操作没有导致<span class="math inline">\(T_1\)</span>失去平衡，不会发生调整，再插入此结点得到的 AVL 树<span class="math inline">\(T_3\)</span>和<span class="math inline">\(T_1\)</span>相同。若删除操作后<span class="math inline">\(T_1\)</span>失去平衡而发生调整，再插入该结点后得到的<span class="math inline">\(T_3\)</span>和<span class="math inline">\(T_1\)</span>有<strong>可能不同</strong>。</li><li>v 不是叶结点：<span class="math inline">\(T_1\)</span>和<span class="math inline">\(T_3\)</span>有可能相同，也有可能不同。</li></ul></li></ul><p>5、<strong>二叉排序树的查找效率分析</strong></p><p>二叉排序树查找效率。主要取决于树高。对 n 个结点的二叉排序树，高度最大为 n，最低为 <span class="math inline">\(\lfloor log_2n \rfloor +1\)</span></p><h3 id="平衡二叉树-avl">7.3.2、平衡二叉树 （AVL）</h3><p>平衡二叉树（balanced Binary Tree）简称平衡树(AVL 树)，树上任一结点的左子树和右子树的高度之差不超过 1</p><p>结点的平衡因子 = 左子树高度 - 右子树高度</p><p><strong>平衡二叉树的插入</strong></p><p>平衡二叉树的插入过程前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。每次调整的都是<strong>最小不平衡子树</strong>，即以插入路径上离插入结点最近的平衡因子绝对值大于 1 的结点作为根的子树。只要将最小不平衡子树调整平衡，则其他祖先结点都会回复平衡。调整的规律如下：</p><p>调整最小不平衡子树 A</p><ul><li><p>LL：在 A 的左孩子的左子树中插入导致不平衡 （<strong>A 的左孩子右上旋</strong>）</p><p><img src="http://img.catpaws.top/img/image-20230318204512157-2024-12-811_54_28.png" srcset="/img/loading.gif" lazyload alt="image-20230318204512157" style="zoom:80%"></p><p>将 A 的左孩子 B 向右旋转代替 A 成为根结点，A 结点向下旋转成为 B 的右孩子，同时 B 的原右子树作为 A 的左子树。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//若F是A的父节点，A是左孩子，则代码思路为：</span>
A-&gt;lchild = B-&gt;rchild;
F-&gt;lchild = B;
B-&gt;rchild = A;</code></pre></div></li><li><p>RR：在 A 的右孩子的右子树中插入导致不平衡（<strong>A 的右孩子左上旋</strong>）</p><p><img src="http://img.catpaws.top/img/image-20230318204722921-2024-12-811_54_46.png" srcset="/img/loading.gif" lazyload alt="image-20230318204722921" style="zoom:80%"></p><p>将 A 的右孩子 B 向左旋转代替 A 成为根结点，A 结点向下旋转成为 B 的左孩子，同时 B 的原左子树作为 A 的右子树。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//若F是A的父节点，A为右孩子，则代码实现为</span>
A-&gt;rchild = B-&gt;lchild;
F-&gt;rchild = B;
B-&gt;lchild = A;</code></pre></div></li><li><p>LR：在 A 的左孩子的右子树中插入导致不平衡（<strong>A 左孩子的右孩子先左上旋再右上旋</strong>）</p><figure><img src="http://img.catpaws.top/img/image-20230318205430184-2024-12-811_34_20.png" srcset="/img/loading.gif" lazyload alt="image-20230318205430184"><figcaption aria-hidden="true">image-20230318205430184</figcaption></figure><p>在 A 左孩子的右子树 C 中插入结点导致了不平衡，可能插入在 C 的左子树或右子树上。</p><p>调整：将 C 左旋加右旋，调整到 A 的位置。<u>即让 C 代替 A 的位置，B 做 C 的左孩子，A 做 C 的右孩子，C 的左子树做 B 的右子树，C 的右子树做 A 的左子树，一步调整完成。</u></p></li><li><p>RL：在 A 的右孩子的左子树中插入导致不平衡（<strong>A 右孩子的左孩子先右上旋再左上旋</strong>）</p></li></ul><p><img src="http://img.catpaws.top/img/Snipaste_2023-03-18_21-01-04-2024-12-811_55_02.png" srcset="/img/loading.gif" lazyload alt="Snipaste_2023-03-18_21-01-04" style="zoom:80%"></p><p>同上。</p><p><strong>查找效率分析</strong></p><p>若树高为 h，则最坏情况下，查找一个关键字最多需要对比 h 次，即查找操作的时间复杂度不可能超过 <span class="math inline">\(O(h)\)</span>。</p><p>假设以<span class="math inline">\(n_h\)</span>表示深度为<span class="math inline">\(h\)</span>的平衡树中含有的<strong>最少</strong>结点数，则有<span class="math inline">\(n_0 = 0,n_1 = 1,n_2 = 2\)</span>，并且<u>有<span class="math inline">\(n_h = n_{h-1} +n_{h-2}+1\)</span></u>。由下图可知，<span class="math inline">\(T_h = T_{h-1}+T_{h-2}+1\)</span>即为递推公式。此时平衡二叉树的结点个数最少，<strong>每个非叶结点的平衡因子都是<span class="math inline">\(1\)</span>。</strong></p><p><img src="http://img.catpaws.top/img/image-20230323160202508-2024-12-811_55_23.png" srcset="/img/loading.gif" lazyload alt="image-20230323160202508" style="zoom:80%"></p><p>一个平衡二叉树有 9 个结点，因为<span class="math inline">\(n_4 = 7,n_5 =12\)</span>，9&lt;12，所以其最大深度为 4。<strong>含有 n 个结点的平衡二叉树的最大深度为<span class="math inline">\(O(log_2n)\)</span>，</strong>所以平衡二叉树的平均查找长度为<span class="math inline">\(O(log_2n)\)</span>。</p><h3 id="红黑树brt">7.3.3、红黑树（BRT）</h3><p><img src="http://img.catpaws.top/img/image-20230320161057030-2024-12-811_56_35.png" srcset="/img/loading.gif" lazyload alt="image-20230320161057030" style="zoom:80%"></p><p>平衡二叉树和红黑树对比</p><ul><li>平衡二叉树 AVL：插入和删除很容易破坏“平衡”特性，需要频繁调整树的形态。如：插入操作导致不平衡，则需要先计算平衡因子，找到最小不平衡子树（时间开销大），再进行 LL/LR/RR/RL 调整。</li><li>红黑树 RBT：插入和删除 很多时候并不会破坏"红黑"特性，无需频繁调整树的形态。即便需要调整也可以在常数级时间内完成。</li></ul><p>平衡二叉树适用于以查为主、很少进行插入/删除的场景；红黑树：适用于频繁插入/删除的场景，实用性更强。二者在查找、插入、删除方面的时间复杂度都为<span class="math inline">\(O(log_2n)\)</span>。</p><p><strong>定义和性质</strong></p><p><img src="http://img.catpaws.top/img/image-20230320150715631-2024-12-811_56_43.png" srcset="/img/loading.gif" lazyload alt="image-20230320150715631" style="zoom:67%"></p><p>红黑树是二叉排序树，满足左子树结点值 &lt; 根结点值 &lt; 右子树结点值。和普通 BST 相比，还需要满足以下特性： <strong><u>(左根右，根叶黑，不红红，黑路同)</u></strong></p><ul><li>每个结点或是红色的，或是黑色的。</li><li>根结点是黑色的</li><li>叶结点 (外部结点、NULL 结点、失败节点)均是黑色的。</li><li>不存在两个相邻的红色结点（不存在父节点是红色，子女结点也是红色的情况）</li><li>对每一个结点，从该结点到任一叶子结点的简单路径上，所含黑结点的数目相同。如图中，13 到所有叶结点的路径上都有两个黑结点。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RBNode</span>&#123;</span> <span class="hljs-comment">//红黑树结点定义</span>
    <span class="hljs-type">int</span> key;
    RBNode* parent;
    RBNode* lChild;
    RBNode* rChild;
    <span class="hljs-type">int</span> color;	<span class="hljs-comment">//结点颜色，如：可以用0/1表示红/黑</span>
&#125;;</code></pre></div><p>性质：</p><ul><li><p>结点的<strong><u>黑高</u></strong>：从某结点出发（不包含该结点）到达任一空叶结点的路径上黑结点总数。</p></li><li><p>根结点黑高为 h 的红黑树，内部关键字最少有<span class="math inline">\(2^h-1\)</span>个</p><p>内部结点数最少的情况：所有结点都是黑色，且是高为 h 的满二叉树时内部结点最少。当所有结点都为黑色时，只有该树是满二叉树时才能保证，所有叶结点在同一层，进而满足<u>黑路同</u>的特性。高度为 h 的满二叉树中有 <span class="math inline">\(2^h-1\)</span>个结点。</p><p><img src="http://img.catpaws.top/img/image-20230320153438409-2024-12-811_56_48.png" srcset="/img/loading.gif" lazyload alt="image-20230320153438409" style="zoom:50%"></p></li><li><p>从根结点到叶结点的<u>最长路径</u>不大于<u>最短路径</u>的 2 倍</p><p>由于从根结点到任何一个叶结点的路径上黑结点数量相同，而路径上不能连续出现两个红结点，所以最长路径只能是红结点只能穿插在各个黑结点之间。</p></li><li><p>有 n 个内部节点的红黑树高度 <span class="math inline">\(h \le 2log_2(n+1)\)</span>，故红黑树查找操作时间复杂度 = <span class="math inline">\(O(log_2n)\)</span>。</p><p>若红黑树总高度为 h，则根结点黑高 <span class="math inline">\(\ge h/2\)</span>（此时红结点穿插在查找失败路径上各个黑结点之间，根结点黑高最小，路径最长），则内部结点数 <span class="math inline">\(n \ge 2^{h/2}-1\)</span>，进而得 <span class="math inline">\(h \le 2log_2(n+1)\)</span>。</p></li></ul><p><strong>红黑树的查找</strong></p><p>​ 和二叉排序树的查找相同。</p><p><strong>红黑树的插入</strong></p><ol type="1"><li><p>先查找，确定插入位置，插入新结点（和二叉排序树相同）</p><ul><li>新结点是 <strong>根</strong> -- 染为<strong>黑色</strong></li><li>新结点 <strong>非根</strong> -- 染为<strong>红色 </strong>（保证黑路同的特性）</li></ul></li><li><p>若插入新结点后依然满足红黑树的定义，则插入结束。</p></li><li><p>若插入新结点后不满足红黑树的定义，需要<u><strong>调整</strong></u>，使其重新满足红黑树的定义。</p><p>对于插入的<u>非根</u>结点，被染成红色，此时<strong>只可能</strong>会破坏红黑树特性中的<strong><u>不红红</u></strong>，其他几个都没有影响</p><p>调整策略有新插入结点的叔叔结点的颜色决定。（<strong><u>看其叔叔的脸色行事</u></strong>）</p><ul><li><p>黑叔：<strong>旋转+染色</strong>（旋转操作和平衡二叉树的调整方法完全相同）</p><ul><li><p>LL 型：右单旋，父换爷+染色</p><p>LL 型即新结点插在了爷结点左孩子的左边；父换爷+染色，即<u>右单旋后</u>，其效果为父节点和爷结点位置互换，同时要将两者颜色变为与原来相反，红变黑，黑变红。</p></li><li><p>RR 型：左单旋，父换爷+染色</p></li><li><p>LR 型：左、右双旋，儿换爷+染色</p></li><li><p>RL 型：右、左双旋，儿换爷+染色</p></li></ul></li><li><p>红叔：<strong>染色+变新</strong></p><ul><li>叔父爷染色，爷变为新结点。（爷成为新结点后，回到第一步，若是根节点则染为黑色，若是非根结点染为红色，再看是否破坏了红黑树定义，继续处理）</li></ul></li></ul></li></ol><h3 id="b-树">7.3.4、B 树</h3><p><strong>定义</strong></p><p><img src="http://img.catpaws.top/img/image-20230320174149811-2024-12-811_57_00.png" srcset="/img/loading.gif" lazyload alt="image-20230320174149811" style="zoom:80%"></p><p>B 树，又称多路平衡查找树（所有结点的平衡因子都为<span class="math inline">\(0\)</span>，<strong>绝对平衡</strong>），B 树中所有结点的孩子个数的最大值称为 B 树的阶。</p><p>一棵 m 阶 B 树或为空树，或为满足如下特性的 m 叉树：</p><ul><li><p>树中每个结点至多有 m 棵子树，即至多含有 m-1 个关键字</p></li><li><p>若根节点不是终端节点，则至少有两棵子树。（保证所有结点都绝对平衡）</p></li><li><p>除根结点外（树中可能就只有 1 个结点，达不到<span class="math inline">\(\lceil m/2\rceil\)</span>的要求），所有非叶结点至少有<span class="math inline">\(\lceil m/2\rceil\)</span>棵子树，即至少含有<span class="math inline">\(\lceil m/2\rceil-1\)</span>个关键字（保证查找效率）</p></li><li><p>所有非叶结点结构如下：</p><p><img src="http://img.catpaws.top/img/image-20230320164537682-2024-12-811_57_04.png" srcset="/img/loading.gif" lazyload alt="image-20230320164537682" style="zoom:45%"></p><p>其中<span class="math inline">\(K_i\)</span>为关键字，<span class="math inline">\(P_i\)</span>为指向子树的指针。<strong>非叶节点内关键字有序</strong>，即<span class="math inline">\(K_1&lt;K_2&lt;...&lt;K_n\)</span>。<span class="math inline">\(K_i\)</span>左侧指针<span class="math inline">\(P_{i-1}\)</span>所指子树中所有结点的关键字都比 <span class="math inline">\(K_i\)</span>小，右边的都比<span class="math inline">\(K_i\)</span>大</p></li><li><p>所有叶结点都出现在最后一层，并且不带信息。（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。</p><p><u>n 个关键字的 m 阶 B 树，必定有 n+1 个叶子结点。</u>（相当于 n 个关键字将负无穷到正无穷分成了 n+1 个区间，每个区间对应一个失败结点，即叶子结点）</p></li></ul><blockquote><p>对一棵 5 阶 B 树，除根结点外，只要其结点内的关键字个数在 [2,4]之间，都满足 5 阶 B 树的定义。</p></blockquote><p><strong>m 阶 B 树的核心特性</strong>：</p><ul><li><p><strong>根结点</strong>的子树个数 <span class="math inline">\(\in[2,m]\)</span>，关键字个数 <span class="math inline">\(\in[1,m-1]\)</span>;</p><p><strong>其他结点</strong>的子树个数<span class="math inline">\(\in[\lceil m/2\rceil,m]\)</span>，关键字个数个数<span class="math inline">\(\in[\lceil m/2\rceil-1,m-1]\)</span></p></li><li><p>对任一结点，其所有子树高度都相同，绝对平衡。</p></li><li><p>关键字的值：子树 0&lt;关键字 1&lt;子树 1&lt;关键字 2&lt;子树 2...（ 类比二叉查找树左&lt;中&lt;右）</p></li></ul><p><strong>B 树的高度</strong></p><p>含有 n 个关键字的 m 阶 B 树的最大高度和最小高度：（不包含叶子结点）</p><ul><li><p>最小高度：<span class="math inline">\(log_m(n+1)\)</span></p><p>要让高度最小，须让每个结点尽可能地满，每个结点有 m-1 个关键字，则<span class="math inline">\(n \le (m-1)(1+m+m^2+...+m^{h-1})=m^h-1\)</span>，故<span class="math inline">\(h\ge log_m(n+1)\)</span></p></li><li><p>最大高度：<span class="math inline">\(log_{\lceil m/2 \rceil}(\frac{n+1}{2})+1\)</span></p><p>要让高度最大，让各层的分叉尽可能少。根节点有两个分叉，其余结点有<span class="math inline">\(\lceil m/2\rceil\)</span>个分叉。第一层有 1 个结点，第二层有 2 个结点，第三层有<span class="math inline">\(2\lceil m/2\rceil\)</span>个结点，第四层有<span class="math inline">\(2\lceil m/2\rceil^2\)</span>,第 h 层有<span class="math inline">\(2\lceil m/2\rceil^{h-2}\)</span>。</p><ul><li><p>第 h+1 层共有叶结点(失败节点)<span class="math inline">\(2\lceil m/2\rceil^{h-1}\)</span>个，而有 n 个关键字的 m 阶 B 树必定有 n+1 个叶结点，所以 <span class="math inline">\(n+1 \ge 2\lceil m/2\rceil^{h-1}\)</span>,即 <span class="math inline">\(h \le log_{\lceil m/2 \rceil}(\frac{n+1}{2})+1\)</span></p></li><li><p>记<span class="math inline">\(k=\lceil m/2\rceil\)</span>，h 层的 m 阶 B 树至少包含关键字总数<span class="math inline">\(1+2(k-1)(k^0+k^1+...+k^{h-1}) =1+2(k^{h-1}-1)\)</span>,若关键字总数少于这个值，则高度一定小于 h，故<span class="math inline">\(n \ge 1+2(k^{h-1}-1)=2k^{h-1} -1\)</span> ，所以 <span class="math inline">\(h \le log_k(\frac{n+1}{2})+1\)</span></p></li></ul></li></ul><p><img src="http://img.catpaws.top/img/Snipaste_2023-03-20_17-41-10-2024-12-811_57_10.png" srcset="/img/loading.gif" lazyload alt="Snipaste_2023-03-20_17-41-10" style="zoom:80%"></p><p><strong>B 树的插入</strong></p><p>新元素一定是插入到最底层“终端节点”中，用查找来确定插入位置。</p><p>在插入 key 后，若导致原结点关键字超出上限，则从中间位置 (<span class="math inline">\(\lceil m/2\rceil\)</span>)处将其中的关键字<strong>分为两部分</strong>，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置 (<span class="math inline">\(\lceil m/2\rceil\)</span>)的关键字插入原结点的父节点中。若此时导致父节点中关键字个数也超过上限，则继续进行这种分裂操作，直至这个过程传到根节点为止，进而导致 B 树高度增加 1。</p><p><strong>B 树的删除</strong></p><ul><li><p>若被删除的关键字在<u>终端节点</u>，删除该关键字。</p><ul><li>若删除后结点内的关键字个数未低于下限，无需任何处理。</li><li>若低于下限<ul><li>若左兄弟够借，则用当前关键字的前驱和前驱的前驱依次顶替空缺</li><li>若右兄弟够借，则用当前关键字的后继和后继的后继依次顶替空缺</li><li>若左右兄弟都不够借时，则将关键字删除后与左兄弟（或右兄弟）结点及双亲结点中的关键字合并。在合并过程中，双亲结点中的关键字会减 1。若双亲结点是根结点且关键字个数减少为<span class="math inline">\(0\)</span>，则直接将根结点删除，合并后的新结点成为根。若双亲结点不是根结点且其关键字个数减少到低于下限，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合 B 树要求为止。</li></ul></li></ul></li><li><p>若被删除的关键字在<u>非终端结点</u>，则直接用直接前驱或直接后继来替代被删除的关键字</p><ul><li>直接前驱：当前关键字左侧指针所指子树最右下的元素</li><li>直接后继：当前关键字右侧所指子树最左下的元素</li></ul><p><strong>对非终端结点关键字的删除，就转化为对终端节点中关键字的删除。</strong></p></li></ul><h3 id="b树">7.3.5、B+树</h3><p><img src="http://img.catpaws.top/img/image-20230320180717857-2024-12-811_57_14.png" srcset="/img/loading.gif" lazyload alt="image-20230320180717857" style="zoom:80%"></p><p><strong>定义</strong></p><p>一棵 m 阶 B 树需满足下列条件：</p><ul><li>每个分支结点最多有 m 棵子树</li><li><u>非叶根节点</u>至少有两棵子树，其他每个分支结点至少有<span class="math inline">\(\lceil m/2\rceil\)</span>棵子树</li><li><strong>结点的子树个数和关键字个数相等</strong> （与 B 树不同）</li><li>所有<strong>叶结点包含所有的关键字</strong>及指向相应记录的指针，<strong>叶结点中将关键字按大小顺序排列</strong>，并且<strong>相邻叶结点按大小顺序相互链接起来</strong>。（叶结点支持顺序查找）</li><li>所有分支结点中仅包含它的各个子结点中关键字的最大值及指向子结点的指针</li></ul><figure><img src="http://img.catpaws.top/img/image-20230615210912913-2024-12-811_56_30.png" srcset="/img/loading.gif" lazyload alt="image-20230615210912913"><figcaption aria-hidden="true">image-20230615210912913</figcaption></figure><p>相同点 除根结点外，每个结点至少有 <span class="math inline">\(\lceil m/2 \rceil\)</span>个分叉；任何一个结点的子树都一样高；</p><p>B+树是应文件系统所需而产生的的 B 树的变形，前者比后者，前者的磁盘代价更低，查询效率更加稳定，更加适用于实际应用中的<strong>操作系统文件索引和数据库索引</strong>。</p><p>补：树中的每个结点保存在磁盘中的某个磁盘块中，从根结点开始查询某个关键字，要将该路径上的所有磁盘块读入内存，由于磁盘块大小是固定的，在 B+树中，非叶结点不含有该关键字对应记录的存储地址。可以使一个磁盘块可以包含更多个关键字，使得 B+树的阶更大，树高更矮，读磁盘次数更少，查找更快。相比较于 B 树，每个结点中还包含了关键字对应记录的信息，使得每个磁盘块存储的关键字个数变少，树高增大，查找速度变慢。</p><h2 id="四散列表">四、散列表</h2><h3 id="概念">4.1、概念</h3><ul><li>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为 Hash(key)=Addr</li><li>冲突：散列函数可能会把两个或两个以上的不同关键字映射到同一地址，这种情况称为冲突</li><li>同义词：被散列函数映射到同一地址的不同关键字之间互为同义词</li><li>散列表：根据关键字而直接进行访问的数据结构。散列表建立了关键字和存储地址间的直接映射关系</li></ul><p>一方面设计得好的<strong>散列函数</strong>应尽量减少冲突的发生；另一方面，由于冲突不可避免，所以还要设计好<strong>处理冲突的方法</strong>。散列查找是一种用空间换时间的方法。</p><h3 id="散列函数的构造方法">4.2、散列函数的构造方法</h3><p>常用的散列函数如下</p><ul><li><p>直接定址法</p><ul><li>直接取关键字的某个线性函数值作为散列地址</li><li>散列函数：H(key) = key 或 H(key) = a * key + b</li><li>特点：计算最简单且不会发生冲突，适合关键字分布基本连续的情况，若关键字分布不连续，空位较多，会造成存储空间的浪费。</li></ul></li><li><p>除留余数法</p><ul><li>假定散列表表长为 m，<strong>取一个不大于 m 但最接近或等于 m 的质数</strong>，利用其对关键字取余，将关键字转化为散列地址。（用这样的 p 取余，会使散列地址分布更均匀，冲突更少）</li><li>散列函数为：H(key) = key %p</li><li>特点：最简单，最常用的方法。关键是选好 p。</li></ul></li><li><p>数学分析法</p><ul><li>设关键字是 r 进制数（如十进制数），而<strong>r 个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些</strong>，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时可<strong>选取数码分布较为均匀的若干位作为散列地址</strong>。</li><li>特点：这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。</li></ul></li><li><p>平方取中法</p><ul><li>取关键字的平方的中间几位作为散列地址。具体取多少位要视实际情况而定。<strong>这种方法得到的散列地址与关键字的每位都有关系</strong>，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。</li></ul></li></ul><h3 id="处理冲突的方法">4.3、处理冲突的方法</h3><p>处理冲突，即为产生冲突的关键字寻找下一个"空"的 Hash 地址</p><ul><li><p>开放定址法</p><p>空闲地址既向它的同义词开放，又向它的非同义词开放。</p><p>数学递推公式为：<span class="math inline">\(H_i = (H(key)+d_i)%m\)</span>。其中 H(key)为散列函数，m 为散列表表长，<span class="math inline">\(d_i\)</span>为增量序列</p><p><strong>增量<span class="math inline">\(d_i\)</span>的取值方法</strong></p><ul><li><p>线性探测法（线性探测再散列）</p><ul><li><p><span class="math inline">\(d_i = 0,1,2,...,m-1\)</span>，当出现冲突时，就顺序地向下一个单元探测，直到没有单元发生冲突</p></li><li><p>线性探测法可能使第 i 个散列地址的同义词存入第 i+1 个散列地址，这样本应存入第 i+1 个散列地址的元素就会争夺第 i+2 个散列元素的地址.....从而导致大量元素在相邻的散列地址上<strong>堆积</strong>，大大降低了查找效率。（在解决冲突时可能会造成新的冲突）</p></li><li><p>查找：首先判断散列地址位置的元素是否为待查元素，若不是则依次向后判断，直到找到该元素，或<strong>遇到空位置</strong>时停止，此时查找失败。当其不在散列表中时，<strong>对空位置的判断也要算一次比较</strong>（冲突的次数应与查找时对比的次数相同)</p><blockquote><p>查找不成功时，设散列函数有 m 个取值，即共有 m 个查找失败的入口（0~m-1）,注意是散列函数有 m 个取值，而不是散列表长度为 m。对每个入口依次计算，对每种可能，该位置为空（算作比较一次）或不空但不为正确的关键字，则一直向后找，直到找到一个空位置，即可确定查找失败，查找次数为该位置查找失败的查找长度。</p></blockquote></li><li><p>删除：<u>采用“开放定址法”时</u>，要删除元素，不能简单地将其从散列表中删掉该元素，这会导致该位置为空，将截断在它之后填入元素的查找路径。可以设置一个“删除标记”，<strong>进行逻辑删除</strong>。查找时遇到删除标记，直接跳过向后查找。<strong>遇到删除标记也算一次比较</strong>。</p></li></ul><blockquote><p>线性探测法解决冲突时线性地查找空闲位置，平均查找长度与表的大小 m 无关，只与所选取的哈希函数 H、装填因子有关，<span class="math inline">\(ASL_{成功} \approx \frac{1}{2}(1+\frac{1}{1-\alpha})\)</span></p></blockquote></li><li><p>平方探测法（二次探测再散列）</p><ul><li>当<span class="math inline">\(d_i = 0^2,1^2,-1^2,2^2,-2^2,...,k^2,-k^2\)</span>时，称为平方探测法，又称二次探测法，其中<span class="math inline">\(k \le m/2\)</span>。此时<u>散列表长度 m，必须是可以表示为<span class="math inline">\(\underline{4j+3}\)</span>的素数</u>，这样才能通过平方探测法探测到所有位置。</li><li>特点：可以避免出现“堆积”问题。</li></ul></li><li><p>伪随机序列法（伪随机探测再散列）</p><ul><li><span class="math inline">\(d_i\)</span>是一个伪随机序列</li></ul></li></ul></li><li><p>再散列法</p><p>​ 除了原始的散列函数 H（key）之外，多准备几个散列函数，当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止。</p><blockquote><p>当增量<span class="math inline">\(d_i = Hash_2(key)\)</span>时，称为再散列法。当通过第一个散列函数<span class="math inline">\(H(key)\)</span>得到的地址发生冲突时，再利用第二个散列函数 <span class="math inline">\(Hash_2(key) %\)</span>计算该关键字的增量，即<span class="math inline">\(H_i=[H(key)+i*Hash_2(key)]\%m\)</span> 。初始探测位置<span class="math inline">\(H_0=H(key)%m\)</span>，i 是冲突的次数。在再散列法中，最多经过 m-1 次探测就会遍历表中所有位置，回到<span class="math inline">\(H_0\)</span></p></blockquote></li><li><p>拉链法（链地址法）</p><ul><li>把所有同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。此时散列表中存放的是指向链表的指针。当链表有序时可以提高查找效率</li><li><u>计算查找长度时，和空链域的对比<strong>不计入</strong>查找次数。</u></li><li>拉链法适用于经常进行插入和删除的情况</li></ul><p>例如：采用除留余数法，散列函数为：H(key) = key % 13，采用拉链法处理冲突，对应的散列表如下，此时<span class="math inline">\(ASL_{成功} = \frac{1*6+2*4+3*1}{11}\)</span>，<span class="math inline">\(ASL_{失败}= \frac{1*2+2*3+3*1}{\color{red}13}\)</span></p><p><img src="http://img.catpaws.top/img/image-20230320213023659-2024-12-815_42_20.png" srcset="/img/loading.gif" lazyload alt="image-20230320213023659"></p><blockquote><p>查找失败时，某位置的查找长度的计算，<strong>按对应处理冲突方法的规则寻找空位置</strong>（并不都是依次向后寻找，这只是线性探测寻找空位置的方法），统计寻找的次数</p></blockquote></li></ul><h3 id="性能分析">4.4、性能分析</h3><p><strong>平均查找长度</strong>仍是其查找效率的度量。</p><p>散列表的查找效率取决于三个因素：<strong><u>散列函数</u>、<u>处理冲突的方法</u>和<u>装填因子</u></strong></p><ul><li>散列表的装填因子 α = <span class="math inline">\(\frac{表中记录数n}{散列表长度m}\)</span>，其反映了这个表的装满程度。</li><li><strong>散列表的平均查找长度依赖于散列表的装填因子，而不直接依赖于 n 或 m。</strong>α 越大，表示装填的记录越满，发生冲突的可能性越大，反之发生冲突的可能性越小。</li></ul><blockquote><ol type="1"><li><p>散列查找不是只能在顺序表上进行，采用拉链法处理冲突时，采用的是顺序存储和链式存储相结合的方式。</p></li><li><p>在开放定址法中散列到同一地址而引起的“堆积”问题是由于<u>同义词之间</u>，或<u>非同义词之间</u>发生冲突引起的，造成该问题的原因是处理冲突的方法选择不当，直接影响到的是平均查找长度。</p></li><li><p>通过线性探测法解决冲突时，在查找某关键字时，所查找位置上的键值不一定都是同义词</p></li><li><p>链地址法处理冲突时将同义词放在一个链表中，不会引起聚集现象</p></li><li><p>负数求模运算：在利用平方探测法解决冲突时，在寻找无冲突位置和求查找失败时的平均查找长度时，会出现 “负数 % 正数”的情况。</p><p>计算方法：先将负号提出去，直接求<span class="math inline">\(-(|m| \%n)\)</span>，最后再加上<span class="math inline">\(n\)</span> <span class="math display">\[例如：(4 - 3^2) \% 11 = -5 \% 11 \quad \rightarrow \quad -(5\%11) = -5 \quad -5+11 = 6 \; \therefore -5 \%11=6\]</span></p></li></ol></blockquote></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="category-chain-item">数据结构</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%9F%A5%E6%89%BE/" class="print-no-link">#查找</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" class="print-no-link">#二分查找</a> <a href="/tags/%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE/" class="print-no-link">#分块查找</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/" class="print-no-link">#二叉排序树</a> <a href="/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" class="print-no-link">#平衡二叉树</a> <a href="/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/" class="print-no-link">#红黑树</a> <a href="/tags/B%E6%A0%91/" class="print-no-link">#B树</a> <a href="/tags/%E6%95%A3%E5%88%97%E8%A1%A8/" class="print-no-link">#散列表</a></div></div><div class="license-box my-3"><div class="license-title"><div>七、查找</div><div>https://catpaws.top/24d4ba7c/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年12月8日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/978a1655/" title="八、排序"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">八、排序</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/ce993eeb/" title="六、图"><span class="hidden-mobile">六、图</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://cdn.smartcis.cn/npm/twikoo@1.6.40/dist/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><br>人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//img.catpaws.top/blog-source/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://unpkg.com/oh-my-live2d"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"http://img.catpaws.top/blog-source/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"},idleTips:{interval:15e3,message:function(){return axios.get("https://v1.hitokoto.cn?c=i").then((function(t){return t.data.hitokoto})).catch((function(t){console.error(t)}))}}}})</script></body></html>