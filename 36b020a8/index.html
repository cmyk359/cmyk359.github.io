<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkai/dist/LXGWWenKai-Regular/result.css"><link rel="apple-touch-icon" sizes="76x76" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><link rel="icon" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="反转字符串  思路：使用双指针法，定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。              使用异或运算交换a和b的元素值：a ^&#x3D; b; &#x2F;&#x2F; 此时a &#x3D; a ^ bb ^&#x3D; a; &#x2F;&#x2F; 等价于b&#x3D; a ^ b ^ b &#x3D; a ^ 0 &#x3D; a,此时 b &#x3D; a, a &#x3D; a ^ ba ^&#x3D; b; &#x2F;&#x2F;"><meta property="og:type" content="article"><meta property="og:title" content="四、字符串"><meta property="og:url" content="https://catpaws.top/36b020a8/index.html"><meta property="og:site_name" content="猫爪在上の书桌"><meta property="og:description" content="反转字符串  思路：使用双指针法，定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。              使用异或运算交换a和b的元素值：a ^&#x3D; b; &#x2F;&#x2F; 此时a &#x3D; a ^ bb ^&#x3D; a; &#x2F;&#x2F; 等价于b&#x3D; a ^ b ^ b &#x3D; a ^ 0 &#x3D; a,此时 b &#x3D; a, a &#x3D; a ^ ba ^&#x3D; b; &#x2F;&#x2F;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250901152940156-2025-9-115:29:43.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250901154333985-2025-9-115:43:34.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240809183021689-2024-8-918:30:27.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240809184945736-2024-8-918:50:10.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250903193738615-2025-9-319:37:48.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250901163125134-2025-9-116:31:25.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250901164818797-2025-9-116:48:19.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250902112903645-2025-9-211:29:30.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250904230557750-2025-9-423:05:58.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250905132043779-2025-9-513:20:45.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250906172046160-2025-9-617:20:55.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250905120008101-2025-9-512:00:09.png"><meta property="article:published_time" content="2025-07-18T02:17:59.000Z"><meta property="article:modified_time" content="2025-09-12T15:12:00.897Z"><meta property="article:author" content="猫爪在上"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250901152940156-2025-9-115:29:43.png"><title>四、字符串 - 猫爪在上の书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/font.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/poem.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/cursor.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/loader.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/twikoo_beautify.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/indeximg-hover.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/wave-1.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/blurpicload.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/reward/iconfont.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/switch.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"https://catpaws.top/blog-resource/imgs/transparent.svg",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://leancloud.catpaws.top",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loader-container"><div class="loader"><div class="wrapper"><div class="catContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 733 673" class="catbody"><path fill="#212121" d="M111.002 139.5C270.502 -24.5001 471.503 2.4997 621.002 139.5C770.501 276.5 768.504 627.5 621.002 649.5C473.5 671.5 246 687.5 111.002 649.5C-23.9964 611.5 -48.4982 303.5 111.002 139.5Z"></path><path fill="#212121" d="M184 9L270.603 159H97.3975L184 9Z"></path><path fill="#212121" d="M541 0L627.603 150H454.397L541 0Z"></path></svg> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 158 564" class="tail"><path fill="#191919" d="M5.97602 76.066C-11.1099 41.6747 12.9018 0 51.3036 0V0C71.5336 0 89.8636 12.2558 97.2565 31.0866C173.697 225.792 180.478 345.852 97.0691 536.666C89.7636 553.378 73.0672 564 54.8273 564V564C16.9427 564 -5.4224 521.149 13.0712 488.085C90.2225 350.15 87.9612 241.089 5.97602 76.066Z"></path></svg><div class="text"><span class="bigzzz">Z</span> <span class="zzz">Z</span></div></div><div class="wallContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 500 126" class="wall"><line stroke-width="6" stroke="#7C7C7C" y2="3" x2="450" y1="3" x1="50"></line><line stroke-width="6" stroke="#7C7C7C" y2="85" x2="400" y1="85" x1="100"></line><line stroke-width="6" stroke="#7C7C7C" y2="122" x2="375" y1="122" x1="125"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="500" y1="43"></line><line stroke-width="6" stroke="#7C7C7C" y2="1.99391" x2="115.5" y1="43.0061" x1="115.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00002" x2="189" y1="43.0122" x1="189"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00612" x2="262.5" y1="43.0183" x1="262.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01222" x2="336" y1="43.0244" x1="336"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01833" x2="409.5" y1="43.0305" x1="409.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="153" y1="84.0122" x1="153"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="228" y1="84.0122" x1="228"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="303" y1="84.0122" x1="303"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="378" y1="84.0122" x1="378"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="192" y1="125.012" x1="192"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="267" y1="125.012" x1="267"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="342" y1="125.012" x1="342"></line></svg></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上の书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>个人主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://catpaws.top/blog-resource/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="四、字符串"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-07-18 10:17" pubdate>2025年7月18日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 36 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">四、字符串</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年9月12日 晚上</p><div class="markdown-body"><meta name="referrer" , content="no-referrer"><h2 id="反转字符串"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">反转字符串</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250901152940156-2025-9-115:29:43.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：使用双指针法，定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。</p><div class="note note-info"><p>使用<strong>异或</strong>运算交换a和b的元素值：</p><ol type="1"><li>a ^= b; // 此时a = a ^ b</li><li>b ^= a; // 等价于b= a ^ b ^ b = a ^ 0 = a,此时 b = a, a = a ^ b</li><li>a ^= b; //等价于 a = a ^ b ^ a = b, 此时 a = b, b = a完成交换。</li></ol></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (l &lt; r) &#123;
            s[l] ^= s[r];  <span class="hljs-comment">//构造 a ^ b 的结果，并放在 a 中</span>
            s[r] ^= s[l];  <span class="hljs-comment">//将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b</span>
            s[l] ^= s[r];  <span class="hljs-comment">//a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换</span>
            l++;
            r--;
        &#125;
    &#125;
&#125;

<span class="hljs-comment">// 第二种方法用temp来交换数值更多人容易理解些</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> s.length - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span>(l &lt; r)&#123;
            <span class="hljs-type">char</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s[l];
            s[l] = s[r];
            s[r] = temp;
            l++;
            r--;
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="反转字符串-ii"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">反转字符串 II</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250901154333985-2025-9-115:43:34.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：在for循环遍历字符串的过程中，让i 每次移动 2 * k ，即 i += (2 * k)；每次i的位置就是待翻转区间的左端，然后再找到右端，翻转该区间内的字符即可。</p><blockquote><p><strong>所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。</strong></p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseStr</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> k)</span> &#123;
        <span class="hljs-type">char</span>[] str = s.toCharArray();

        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length; i += <span class="hljs-number">2</span>*k)&#123;
            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i;
            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> Math.min(str.length - <span class="hljs-number">1</span>, left + k - <span class="hljs-number">1</span>);
            reverse(str,left, right);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(str);
    &#125;

    <span class="hljs-comment">//反转指定范围内的字符</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;
        <span class="hljs-keyword">while</span> (l &lt; r) &#123;
            s[l] ^= s[r]; 
            s[r] ^= s[l]; 
            s[l] ^= s[r]; 
            l++;
            r--;
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="反转字符串中的单词"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">反转字符串中的单词</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240809183021689-2024-8-918:30:27.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路一：首先去除首尾以及中间多余的空格，然后整体翻转，再将每个单词翻转。<strong>使用整体反转+局部反转就可以实现反转单词顺序的目的。</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span>[] removeExtraSpace(<span class="hljs-type">char</span>[] s)&#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;
        <span class="hljs-comment">//双指针删除字符数组中的空白字符</span>
        <span class="hljs-keyword">while</span> (j &lt; s.length) &#123;
            <span class="hljs-keyword">if</span> (s[j] != <span class="hljs-string">&#x27; &#x27;</span>) &#123; <span class="hljs-comment">//遇到非空格字符则加入</span>
                s[i++] = s[j++];
                <span class="hljs-keyword">continue</span>;
            &#125;
            <span class="hljs-keyword">while</span>(j &lt; s.length &amp;&amp; s[j] == <span class="hljs-string">&#x27; &#x27;</span>) j++; <span class="hljs-comment">//遇到单词间的空格字符则跳过</span>
            s[i++] = <span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-comment">//手动添加一个分隔单词的空格</span>
        &#125;
        <span class="hljs-keyword">return</span> Arrays.copyOfRange(s, <span class="hljs-number">0</span>, i);
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseString</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span>&#123;
        <span class="hljs-keyword">while</span>(start &lt; end) &#123;
            s[start] ^= s[end];
            s[end]  ^= s[start];
            s[start] ^= s[end];
            start++;
            end--;
        &#125;
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseEachWord</span><span class="hljs-params">(<span class="hljs-type">char</span>[] s)</span> &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length; i++) &#123;
            <span class="hljs-keyword">if</span> (s[i] != <span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-keyword">continue</span>;
            reverseString(s, start, i - <span class="hljs-number">1</span>);
            start = i + <span class="hljs-number">1</span>;
        &#125;
        <span class="hljs-comment">//翻转最后一个单词</span>
        reverseString(s, start, s.length - <span class="hljs-number">1</span>);
    &#125;

    
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;
        <span class="hljs-comment">//1、去除多余空格</span>
        <span class="hljs-type">char</span>[] nc = removeExtraSpace(s.trim().toCharArray()); <span class="hljs-comment">//s.trim()删除首尾多余空格</span>
        <span class="hljs-comment">//2、整体翻转</span>
        reverseString(nc, <span class="hljs-number">0</span>, nc.length - <span class="hljs-number">1</span>);
        <span class="hljs-comment">//3、翻转每个单词</span>
        reverseEachWord(nc);
        
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(nc);
    &#125;
&#125;</code></pre></div><p>思路二：直接将源字符串中的单词放到翻转后的位置。申请一个新字符数组存放结果，在原字符串中从后往前遍历，确定每一个单词的范围，从该范围内取出单词添加到新数组中，并且手动添加一个空格，最终结果末尾多加了一个空格。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240809184945736-2024-8-918:50:10.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">reverseWords</span><span class="hljs-params">(String s)</span> &#123;
        <span class="hljs-comment">//原字符数组 original chars</span>
        <span class="hljs-type">char</span>[] oc = s.toCharArray();
        <span class="hljs-comment">//新字符数组 new chars</span>
        <span class="hljs-type">char</span>[] nc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[oc.length + <span class="hljs-number">1</span>];<span class="hljs-comment">//最终末尾会多一个空白字符</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> oc.length - <span class="hljs-number">1</span>, k = <span class="hljs-number">0</span>; <span class="hljs-comment">//i指向旧数组末尾，k指向新数组开头</span>
        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; oc[i] == <span class="hljs-string">&#x27; &#x27;</span>) i--; <span class="hljs-comment">//跳过空格</span>
            <span class="hljs-comment">//此时i的位置要么为边界，要么为某个单词的右边界</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> i;
            <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; oc[i] != <span class="hljs-string">&#x27; &#x27;</span>) i--; <span class="hljs-comment">//扫描单词</span>
            <span class="hljs-comment">// 此时i的位置要么为边界，要么为某个单词左边界的前一个位置</span>
            <span class="hljs-comment">//移动单词到新数组中</span>
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt;= right; j++) &#123;
                nc[k++] = oc[j];
                <span class="hljs-keyword">if</span> (j == right)
                    nc[k++] = <span class="hljs-string">&#x27; &#x27;</span>;<span class="hljs-comment">//手动插入一个空白字符</span>
            &#125;
        &#125;
        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-comment">//源字符串中没有单词</span>
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>; 
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(nc, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);
    &#125;
&#125;</code></pre></div><hr><p>补充题目：右旋字符串</p><p>题目描述：字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。要求<strong>不能申请额外空间，只能在本串上操作</strong>（Java不能在字符串上修改，所以使用java一定要开辟新空间）</p><p>例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为 "fgabcde"。</p><p>思路：这个问题与反转字符串中的单词基本一样。在右旋字符串中，可以将整个字符串分为两部分，尾部的k个字符和前面的剩余部分。将它们看成两个单词，右旋的效果与反转这两个单词的效果相同，可以采用上面两种思路解决。</p><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-string/">旋转字符串</a>也可以采用类似的方法，每次先整体反转，再将除尾字母外的部分做局部反转即可完成一次字符串整体的旋转操作，判断它和给定串是否相同。若旋转了"字符串长度"次后还未匹配，则说明不能旋转得到指定串。</p><p>它还有一种更巧妙的解法：字符串s后面再拼接一个s后，判断goal是否在其中出现过即可。<strong>首尾相接后就包含了所有旋转操作的结果</strong>，判断goal是否在其中即可。后面的<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">重复的子字符串</a>也可用该思路解决。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250903193738615-2025-9-319:37:48.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h2 id="替换数字"><a target="_blank" rel="noopener" href="https://kamacoder.com/problempage.php?pid=1064">替换数字</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250901163125134-2025-9-116:31:25.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：</p><ul><li>首先扩充数组到每个数字字符替换成 "number" 之后的大小。</li><li>然后使用双指针法<strong>从后向前</strong>替换数字字符。i指向新长度的末尾，j指向旧长度的末尾，使用j从后往前遍历旧数组元素，如果它是字母，将其移到新数组末尾；如果它是数字，则使用number填充新数组对应位置</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250901164818797-2025-9-116:48:19.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>如果从前往后填充新数组，就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素整体向后移动。</p><p><strong>其实很多数组填充类的问题，其做法都是先预先给数组扩容带填充后的大小，然后再从后向前进行操作。</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);
        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> sc.next();
        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();
        <span class="hljs-comment">//计算扩容后的数组大小</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;
            <span class="hljs-keyword">if</span> (s.charAt(i) &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)
                len += <span class="hljs-number">5</span>;
        &#125;
        
        <span class="hljs-comment">//创建新数组，转移元素</span>
        <span class="hljs-type">char</span>[] nc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[len];
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;
            nc[i] = s.charAt(i);
        &#125;
        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> s.length() - <span class="hljs-number">1</span>, i = len - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">if</span> (nc[j] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; nc[j] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;
                nc[i--] = <span class="hljs-string">&#x27;r&#x27;</span>;
                nc[i--] = <span class="hljs-string">&#x27;e&#x27;</span>;
                nc[i--] = <span class="hljs-string">&#x27;b&#x27;</span>;
                nc[i--] = <span class="hljs-string">&#x27;m&#x27;</span>;
                nc[i--] = <span class="hljs-string">&#x27;u&#x27;</span>;
                nc[i--] = <span class="hljs-string">&#x27;n&#x27;</span>;
                j--;
            &#125;<span class="hljs-keyword">else</span> &#123;
                nc[i--] = nc[j--];
            &#125;
        &#125;
        System.out.println(nc);
    &#125;
&#125;</code></pre></div><h2 id="找出字符串中第一个匹配项的下标"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">找出字符串中第一个匹配项的下标</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250902112903645-2025-9-211:29:30.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>题目要求找出模式串在文本串中首次出现的下标，是<a href="https://catpaws.top/dac6dce7/#kmp算法实现">KMP算法</a>的经典应用场景。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] computeNext(String pattern) &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> pattern.length();
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];
	
    <span class="hljs-comment">//多申请一个空间，用next[n]保存整个模式串的最长相等前后缀长度</span>
    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];
    next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 第一个位置固定为-1</span>

    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// 指向前缀的末尾位置</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 指向后缀的末尾位置</span>
	
    <span class="hljs-comment">//先递增索引i再赋值，故i的范围为[0,n-1]</span>
    <span class="hljs-keyword">while</span> (i &lt; n) &#123;
        <span class="hljs-comment">// j == -1 表示需要从头开始匹配</span>
        <span class="hljs-comment">// pattern.charAt(i) == pattern.charAt(j) 表示匹配成功</span>
        <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || pattern.charAt(i) == pattern.charAt(j)) &#123;
            i++;
            j++;
            <span class="hljs-comment">//先递增索引i再赋值，实现右移</span>
            <span class="hljs-comment">//next[i]保存着子串pattern[0:i-1]的最长相等前后缀长度</span>
            next[i] = j; 
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 匹配失败，回溯到前一个可能匹配的位置，直到两字符匹配或到达初始条件为止</span>
            j = next[j];
        &#125;
    &#125;
    
    <span class="hljs-keyword">return</span> next;
&#125;


<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kmpSearch</span><span class="hljs-params">(String text, String pattern)</span> &#123;
    <span class="hljs-keyword">if</span> (pattern.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-type">int</span>[] next = computeNext(pattern);
    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 文本串指针</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 模式串指针</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> text.length();
    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> pattern.length();

    <span class="hljs-keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;
        <span class="hljs-comment">// j == -1 表示模式串需要从头开始匹配</span>
        <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || text.charAt(i) == pattern.charAt(j)) &#123;
            i++;
            j++;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 不匹配时，根据next数组回溯模式串指针</span>
            j = next[j];
        &#125;
    &#125;

    <span class="hljs-comment">// 如果模式串指针走到末尾，说明匹配成功</span>
    <span class="hljs-keyword">if</span> (j == m) &#123;
        <span class="hljs-keyword">return</span> i - j;
    &#125;

    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
&#125;</code></pre></div><h2 id="重复的子字符串"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">重复的子字符串</a></h2><p>题目描述：对一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p><p>思路一：将 s 拼接自身得到 s+s，然后去掉 s+s 的首尾字母，再检查这个新字符串中是否包含 s。如果包含，则 s 可以由子串重复构成；否则，不可以。去掉首尾字母的目的是排除原始 <code>s</code> 在开头和结尾的匹配，只检查中间部分是否出现 <code>s</code></p><p>原理：如果字符串 <code>s</code> 可以由一个子串重复多次构成，那么 <code>s</code> 具有周期性，即存在一个子串 <code>t</code> 使得 <code>s = t + t + ... + t</code>，因此将<code>s</code>循环左移（或右移）<code>t</code>的长度倍后还会出现<code>s</code>。假设<code>s+s</code>并且去掉首尾字符构成的字符串为<code>T</code>，<strong><code>T</code>中包含了 <code>s</code> 的所有循环移位的集合</strong>，如果 <code>s</code> 在其中出现，说明存在一个非平凡的循环移位（即不是原字符串本身）与 <code>s</code> 匹配。这表明 <code>s</code> 具有周期性，可以由一个子串重复构成；否则，<code>s</code> 不具有周期性。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> &#123;
    <span class="hljs-keyword">return</span> (s+s).substring(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> * s.length() - <span class="hljs-number">1</span>).contains(s);
&#125;</code></pre></div><hr><p>思路二：通过KMP的next数组判断字符串是否由重复子串构成，next 数组存储了字符串的最长公共前后缀信息。</p><p>假设字符串s长度为n，由next[n]得到整个字符串的最长相等前后缀长度。若next[n] = 0，说明字符串没有任何相等前后缀，这意味着字符串中不存在重复的模式，因此无法由子串重复构成。(也可以反证，如果它可以由子串重复构成，必然存在非零的最长公共前后缀，next[n]一定大于0，与next[n] = 0矛盾，故它不能由子串重复构成)</p><p><strong>在模式串中，最长相等前缀或后缀所不包含的那部分子串就是最小重复子串。</strong>例如，模式串s="ababab"，由其next数组知，它的最长相等前后缀长度为4，那么最长前缀不包含的那部分子串s[4:5] = "ab"就是最小重复子串，最小重复子串的长度为<code>n - next[n]</code></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250904230557750-2025-9-423:05:58.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>如果 <code>next[n] &gt; 0</code> 且 <code>n</code> 能被 <code>n - next[n]</code> 整除，则字符串 <code>s</code> 可以由子串 <code>s[0: n-next[n]-1]</code> 重复多次构成（重复次数至少为 2）。否则，不能由子串重复构成。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatedSubstringPattern</span><span class="hljs-params">(String s)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//一个字符不能由它自己重复多次组成</span>

    <span class="hljs-type">int</span>[] next = computeNext(s);
    <span class="hljs-keyword">if</span> (next[n] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//没有任何公共前后缀</span>

    <span class="hljs-keyword">return</span> n % (n - next[n]) == <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">//求next数组</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] computeNext(String s) &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> s.length();
    <span class="hljs-comment">//多申请一个空间，next[n]保存整个字符串的最长相等前后缀长度</span>
    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ n + <span class="hljs-number">1</span>];
    next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;

    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//指向前缀末尾</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//指向后缀末尾</span>

    <span class="hljs-keyword">while</span> (i &lt; n) &#123;
        <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || s.charAt(i) == s.charAt(j)) &#123;
            j++;
            i++;
            next[i] = j;
        &#125; <span class="hljs-keyword">else</span>&#123;
            j = next[j];
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> next;
&#125;</code></pre></div><h2 id="重复叠加字符串匹配"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-string-match/">重复叠加字符串匹配</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250905132043779-2025-9-513:20:45.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>判断字符串a至少要重复叠加多少次后才能包含b，基本思路就是a每叠加一次就从其中查找是否包含b，如果包含就返回当前重叠次数。其中在a叠加后的字符串中寻找b，可以使用<a href="https://catpaws.top/dac6dce7/#kmp算法实现">KMP算法</a>或<a href="https://catpaws.top/dac6dce7/#补充rk算法">Rabin-Karp 算法</a></p><p>但是关键是如何判断不包含呢？重复次数的上限在哪呢？</p><p>设n = len(a), m = len(b)。当字符串 a 被重复多次时，形成的字符串是<strong>周期性</strong>的，周期长度为n。子串 b 在重复后的字符串中 可能从任何位置开始，但由于周期性，这些起始位置实际上只有 n 种可能的偏移量（即从 0 到 n−1，相对于 a 的起始位置）。</p><p>a 要重叠 <span class="math inline">\(k =\lceil \frac{m}{n} \rceil\)</span>次才能保证它的长度至少与 b 相等，这样长度的字符串中才可能包含b。k 是重叠的最小次数，但 b可能从 a 的中间开始，因此仅重复 k 次可能不够。当重复 k+1 次后，字符串总长度为 (k+1)×n，这足够覆盖所有可能的起始偏移量，这是因为：</p><ul><li>无论 b 从哪个偏移量开始（0 到 n−1），它都需要最多 n+len(b) 的长度来完整包含。</li><li>由于k×n≥len(b) ,有 (k+1)×n=k×n+n≥len(b)+n，这足以容纳任何起始位置的 b。</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250906172046160-2025-9-617:20:55.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>如果 b 是 a 重复多次后的子串，它一定会在重复 k 次或 k+1次时出现。如果在这两种情况下都没有找到 b，那么即使重复更多次，也不会找到 b，因为额外的重复只是添加了相同的周期模式，但所有可能的匹配位置已经在 k+1次时被穷举了。</p><p>因此，只需检查 k 和 k+1 次重复是否包含 b，如果都不包含则返回 -1。</p><p>此外，我们不需要真正构建出 a 重复很多次后的字符串。由于它是周期性的，可以通过<strong>模运算</strong>在a中访问任何位置的字符。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">repeatedStringMatch</span><span class="hljs-params">(String a, String b)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a.length(), m = b.length(); 
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)Math.ceil((<span class="hljs-type">double</span>)m / n); <span class="hljs-comment">//最小重复次数</span>
    <span class="hljs-type">int</span>[] next = computeNext(b); <span class="hljs-comment">//计算b的next数组</span>
    <span class="hljs-keyword">if</span> (kmpSearch(a, b, next, k))  <span class="hljs-keyword">return</span> k;
    <span class="hljs-keyword">if</span> (kmpSearch(a, b, next, k+ <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> k + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;

&#125;

<span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] computeNext(String b) &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> b.length();

    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];
    next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;

    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (i &lt; n) &#123;
        <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || b.charAt(i) == b.charAt(j)) &#123;
            j++;
            i++;
            next[i] = j;
        &#125; <span class="hljs-keyword">else</span> &#123;
            j = next[j];
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> next;
&#125;

<span class="hljs-type">boolean</span> <span class="hljs-title function_">kmpSearch</span><span class="hljs-params">(String a, String b, <span class="hljs-type">int</span>[] next, <span class="hljs-type">int</span> times)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a.length(), m = b.length(); 
    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (i &lt; times * n &amp;&amp; j &lt; m) &#123;
        <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || a.charAt(i % n) == b.charAt(j)) &#123;
            i++;
            j++;
        &#125; <span class="hljs-keyword">else</span> &#123;
            j = next[j];
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> j == m;
&#125;</code></pre></div><div class="note note-info"><p>总结：本题的关键是A重叠多次后生成的字符串是<strong>周期性的</strong>。字符串B可以出现在 将A重叠无数次后的字符串的任一位置，但由于重叠后的字符串具有周期性，B的起始偏移位置总是在一个A的内部，偏移范围是[0, len(A)-1]。将A重叠<span class="math inline">\(k =\lceil \frac{m}{n} \rceil\)</span>次得到字符串S，它中已经包含了起始偏移在[0,x]范围内的与B长度相同的子串(<span class="math inline">\(x \in len(A)-1\)</span>)；当起始位置超过x时，与B长度相同的子串会有一部分延申出去，延申出去的长度不会超过len(A)，因此只需再重叠一次就能确保所有可能的起始偏移量都被覆盖。</p><p>总结一下周期性的字符串具有的重要性质：</p><ul><li>每个周期字符串都有一个最小周期 p，它是所有可能周期中最小的。最小周期的长度 p 必须整除字符串的长度 n。</li><li>如果一个字符串有长度为 b 的边界（既是前缀又是后缀的子串），那么该字符串具有周期性，周期为 n - b。</li><li>周期字符串的循环移位仍然是周期字符串。具体来说，如果将周期字符串向左或向右移动其周期长度的倍数，得到的字符串与原字符串相同。</li></ul></div><h2 id="多次搜索"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/multi-search-lcci/">多次搜索</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250905120008101-2025-9-512:00:09.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路一：扩展应用<a href="https://catpaws.top/dac6dce7/#kmp算法实现">KMP算法</a>处理多个模式串的匹配问题。将smalls中的每个字符串当作模式串，在主串big中寻找所有匹配的位置（此处允许重叠匹配），收集返回即可。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] multiSearch(String big, String[] smalls) &#123;

    List&lt;List&lt;Integer&gt;&gt; positions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (String pattern : smalls) &#123;
        positions.add(getALLPosition(big, pattern));
    &#125;
	
    <span class="hljs-keyword">return</span> positions.stream()
        .map(subList -&gt; subList.stream().mapToInt(Integer::intValue).toArray())
        .toArray(<span class="hljs-type">int</span>[][]::<span class="hljs-keyword">new</span>);
&#125;

<span class="hljs-comment">//KMP搜索所有匹配位置</span>
<span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">getALLPosition</span><span class="hljs-params">(String text, String pattern)</span> &#123;
    List&lt;Integer&gt; position = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-comment">// 模式串为空</span>
    <span class="hljs-keyword">if</span> (pattern.isEmpty()) 
        <span class="hljs-keyword">return</span> position;

    <span class="hljs-type">int</span>[] next = computeNext(pattern);

    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> text.length();
    <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> pattern.length();

    <span class="hljs-keyword">while</span> (i &lt; n) &#123;
        <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || text.charAt(i) == pattern.charAt(j)) &#123;
            i++;
            j++;

            <span class="hljs-keyword">if</span> (j == m) &#123;
                position.add(i - j);
                j = next[j];
            &#125;
        &#125; <span class="hljs-keyword">else</span>&#123;
            j = next[j];
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> position;
&#125;

<span class="hljs-comment">//计算next数组</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] computeNext(String pattern) &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> pattern.length();
    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];
    next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;

    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (i &lt; n) &#123;
        <span class="hljs-keyword">if</span> (j == -<span class="hljs-number">1</span> || pattern.charAt(i) == pattern.charAt(j)) &#123;
            j++;
            i++;
            next[i] = j;
        &#125; <span class="hljs-keyword">else</span> &#123;
            j = next[j];
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> next;
&#125;</code></pre></div><p>思路二：使用前缀树</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/leetcode/" class="category-chain-item">leetcode</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>四、字符串</div><div>https://catpaws.top/36b020a8/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年7月18日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/700d279/" title="五、栈与队列"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">五、栈与队列</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/4f3efbd5/" title="三、哈希表"><span class="hidden-mobile">三、哈希表</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://catpaws.top/blog-resource/twikoo1.6.42/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本站由<img src="/img/upyun_logo.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="width:auto;height:auto">提供CDN加速/云存储服务</a></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备2025059828号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61032302000087" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="police-icon"> <span>陕公网安备61032302000087号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//catpaws.top/blog-resource/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="//catpaws.top/blog-resource/js/loader.js"></script><script src="//catpaws.top/blog-resource/js/blurpicload.js"></script><script src="//catpaws.top/blog-resource/js/axios.min.js"></script><script src="/js/boot.js"></script><!DOCTYPE html><html><head><style>#matechat-iframe-container{position:fixed;top:0;left:0;width:100%;height:100%;z-index:10000;opacity:0;visibility:hidden;transition:opacity .3s ease,visibility .3s ease}#matechat-iframe-container.active{opacity:1;visibility:visible}.matechat-iframe{width:100%;height:100%;border:none;background:#fff}#matechat-iframe-container.active .matechat-close-btn{opacity:1}body.matechat-open{overflow:hidden}</style></head><body><div id="matechat-iframe-container"><iframe class="matechat-iframe" src="https://chat.catpaws.top" allow="microphone" title="芙芙来帮你"></iframe></div><script>document.addEventListener("DOMContentLoaded",(function(){const e=document.getElementById("oml2d-stage"),t=document.getElementById("matechat-iframe-container");function n(){t.classList.remove("active"),document.body.classList.remove("matechat-open")}e?t?(e.addEventListener("click",(function(){t.classList.add("active"),document.body.classList.add("matechat-open")})),document.addEventListener("keydown",(function(e){"Escape"===e.key&&n()})),window.addEventListener("message",(function(e){"closeMateChat"!==e.data&&"close"!==e.data.type||n()})),t.addEventListener("click",(function(e){e.target===this&&n()}))):console.error("matechat-iframe-container 元素未找到"):console.error("oml2d-stage 元素未找到")}))</script><script data-pjax src="https://catpaws.top/blog-resource/live2d/index.min.js"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"https://catpaws.top/blog-resource/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"}}})</script></body></html><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>