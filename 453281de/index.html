<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://catpaws.top/blog-resource/imgs/webicon.png"><link rel="icon" href="https://catpaws.top/blog-resource/imgs/webicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="一、树的基本概念 1.1、树的定义 树的定义：树是一种递归的数据结构，是n（n≥0）个结点的有限集。当n&#x3D;0时，称为空树。在任意一棵非空树中满足：  有且仅有一个根节点 当n&gt;1时，其余节点可分为m(m&gt;0)个不相交的有限集T1,T2,..Tm，其中每个集合本身又是一棵树，并且称为根的子树  非空树的性质：  有且仅有一个根结点。 根结点没有前驱，除根结点外的所"><meta property="og:type" content="article"><meta property="og:title" content="五、树和二叉树"><meta property="og:url" content="https://catpaws.top/453281de/index.html"><meta property="og:site_name" content="猫爪在上の书桌"><meta property="og:description" content="一、树的基本概念 1.1、树的定义 树的定义：树是一种递归的数据结构，是n（n≥0）个结点的有限集。当n&#x3D;0时，称为空树。在任意一棵非空树中满足：  有且仅有一个根节点 当n&gt;1时，其余节点可分为m(m&gt;0)个不相交的有限集T1,T2,..Tm，其中每个集合本身又是一棵树，并且称为根的子树  非空树的性质：  有且仅有一个根结点。 根结点没有前驱，除根结点外的所"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20230216152040612-2024-12-723:06:46.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20230216153410676-2024-12-723:06:59.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20230216155034041-2024-12-723:07:08.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20230216155116782-2024-12-723:07:14.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250218185008400-2025-2-1818:50:22.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250218185900079-2025-2-1818:59:06.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20230225174818508-2024-12-800:12:51.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20230225175853143-2024-12-723:51:31.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20230225200402386-2024-12-723:58:02.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20230225201513725-2024-12-723:58:12.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-02-25_20-30-40-2024-12-723:58:19.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20230225211114726-2024-12-723:58:35.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20230225212551153-2024-12-723:58:42.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20230225215722535-2024-12-800:03:19.png"><meta property="article:published_time" content="2024-12-07T04:32:13.000Z"><meta property="article:modified_time" content="2025-02-18T12:18:22.831Z"><meta property="article:author" content="猫爪在上"><meta property="article:tag" content="树"><meta property="article:tag" content="二叉树"><meta property="article:tag" content="线索二叉树"><meta property="article:tag" content="哈夫曼树"><meta property="article:tag" content="并查集"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20230216152040612-2024-12-723:06:46.png"><title>五、树和二叉树 - 猫爪在上の书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/font.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/poem.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/shubiao.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/loader.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/twikoo_beautify.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/indeximg-hover.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/wave.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/blurpicload.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"https://catpaws.top/img/transpare.svg",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://leancloud.catpaws.top",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loader-container"><div class="loader"><div class="wrapper"><div class="catContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 733 673" class="catbody"><path fill="#212121" d="M111.002 139.5C270.502 -24.5001 471.503 2.4997 621.002 139.5C770.501 276.5 768.504 627.5 621.002 649.5C473.5 671.5 246 687.5 111.002 649.5C-23.9964 611.5 -48.4982 303.5 111.002 139.5Z"></path><path fill="#212121" d="M184 9L270.603 159H97.3975L184 9Z"></path><path fill="#212121" d="M541 0L627.603 150H454.397L541 0Z"></path></svg> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 158 564" class="tail"><path fill="#191919" d="M5.97602 76.066C-11.1099 41.6747 12.9018 0 51.3036 0V0C71.5336 0 89.8636 12.2558 97.2565 31.0866C173.697 225.792 180.478 345.852 97.0691 536.666C89.7636 553.378 73.0672 564 54.8273 564V564C16.9427 564 -5.4224 521.149 13.0712 488.085C90.2225 350.15 87.9612 241.089 5.97602 76.066Z"></path></svg><div class="text"><span class="bigzzz">Z</span> <span class="zzz">Z</span></div></div><div class="wallContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 500 126" class="wall"><line stroke-width="6" stroke="#7C7C7C" y2="3" x2="450" y1="3" x1="50"></line><line stroke-width="6" stroke="#7C7C7C" y2="85" x2="400" y1="85" x1="100"></line><line stroke-width="6" stroke="#7C7C7C" y2="122" x2="375" y1="122" x1="125"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="500" y1="43"></line><line stroke-width="6" stroke="#7C7C7C" y2="1.99391" x2="115.5" y1="43.0061" x1="115.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00002" x2="189" y1="43.0122" x1="189"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00612" x2="262.5" y1="43.0183" x1="262.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01222" x2="336" y1="43.0244" x1="336"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01833" x2="409.5" y1="43.0305" x1="409.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="153" y1="84.0122" x1="153"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="228" y1="84.0122" x1="228"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="303" y1="84.0122" x1="303"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="378" y1="84.0122" x1="378"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="192" y1="125.012" x1="192"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="267" y1="125.012" x1="267"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="342" y1="125.012" x1="342"></line></svg></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上の书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>个人主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://catpaws.top/blog-resource/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="五、树和二叉树"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-12-07 12:32" pubdate>2024年12月7日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 9.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 80 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">五、树和二叉树</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年2月18日 晚上</p><div class="markdown-body"><meta name="referrer" content="no-referrer"><h2 id="一树的基本概念">一、树的基本概念</h2><h3 id="树的定义">1.1、树的定义</h3><p>树的定义：树是一种递归的数据结构，是n（n≥0）个结点的有限集。当n=0时，称为空树。在任意一棵非空树中满足：</p><ul><li>有且仅有一个根节点</li><li>当n&gt;1时，其余节点可分为m(m&gt;0)个不相交的有限集T1,T2,..Tm，其中每个集合本身又是一棵树，并且称为根的子树</li></ul><p>非空树的性质：</p><ul><li>有且仅有一个根结点。</li><li>根结点没有前驱，除根结点外的所有结点有且仅有一个前驱。</li><li>每个结点可以有0个或多个后继。</li><li>没有后继的结点称为叶子结点，有后继的结点称为分支结点。</li></ul><p>树是一种递归的数据结构，是一种<strong>逻辑结构</strong>，也是一种分层结构，适合于表示具有层次结构的数据。</p><h3 id="基本术语">1.2、基本术语</h3><p>结点之间关系的描述：</p><ul><li><p>祖先结点：从该结点到根结点的唯一路径上的所有结点，均是其祖先结点。</p></li><li><p>子孙结点：从该结点出发的所有分支中的结点，都是其子孙结点。</p></li><li><p>双亲结点（父结点）：一个结点的直接前驱是其父结点。</p></li><li><p>孩子结点：一个结点的直接后继是其孩子结点。</p></li><li><p>兄弟结点：有相同双亲的结点称为兄弟结点。</p></li><li><p>堂兄弟结点：双亲在同一层的结点互为堂兄弟。</p></li><li><p>路径：树中两个结点之间的路径是由这两个结点之间所经过的<strong>结点序列</strong>构成。由于树中的分支是有向的，即双亲指向孩子，所以<strong>树中的路径是从上向下的</strong>。</p></li><li><p>路径长度：路径上所经过的<strong>边的个数</strong>。</p><ul><li>树的路径长度：从根结点到每个结点的路径长度之和（注意和哈夫曼树的带权路径长度相区别）</li><li>树的内路径长度：除叶结点外，从根到树中其他所有结点的路径长度之和</li><li>树的外路径长度：从根结点到树中所有叶子结点的路径长度之和</li></ul></li></ul><p>结点、树的属性描述：</p><ul><li><p>节点的深度：指<u>从根节点到该节点</u>的最长简单路径边的条数或者节点数。（水面）</p></li><li><p>节点的高度：指<u>从该节点到叶子节点</u>的最长简单路径边的条数或者节点数。（高楼）</p></li><li><p>树的高度：根节点的高度。</p></li><li><p>结点的度：孩子的个数称为该结点的度。</p></li><li><p>树的度：各结点度的最大值。</p></li><li><p>有序树：逻辑上看，树中的各个子树从左至右是有次序的，不能互换。</p></li><li><p>无序树：逻辑上看，树中的各个子树从左至右是没有次序的，可以互换。</p></li></ul><p>具体看需要用树存储什么信息，是否需要用节点的左右位置来反应某些逻辑关系，若需要则为有序树，否则为无序树。</p><ul><li>森林：m(m≥0)个互不相交的树的集合</li></ul><h3 id="树的常考性质">1.3、树的常考性质</h3><ul><li><p><strong>总结点数 = 总度数 + 1</strong> （总度数即树所有分支的个数，即除根结点外所有结点的个数）</p></li><li><p>度为m的树和m叉树</p><ul><li><p>度为m的树：树中所有结点的最大度数为m</p></li><li><p>m叉树：每个结点最多有m个孩子的树，即每个结点的度最大是m，也可以为0</p></li></ul><table><thead><tr class="header"><th>度为m的树</th><th>m叉树</th></tr></thead><tbody><tr class="odd"><td>任意结点的度 ≤ m</td><td>任意结点的度 ≤ m</td></tr><tr class="even"><td>至少有一个度为m的结点</td><td>允许所有结点的度均小于m</td></tr><tr class="odd"><td>一定是非空树，至少有m+1个结点</td><td>可以是空树</td></tr></tbody></table></li><li><p>度为m的树第i层至多有<span class="math inline">\(m^{i-1}\)</span>个结点。（第一层有一个，第二层有m个，第三层有<span class="math inline">\(m^2\)</span>个，以此类推）</p><p>m叉树的第i层至多有<span class="math inline">\(m^{i-1}\)</span>个结点。</p></li><li><p>高度为h的m叉树至多有<span class="math inline">\(\frac{m^h-1}{m-1}\)</span>个结点（等比数列求和），至少有h个结点</p></li><li><p>高度为h，度为m的树至多有<span class="math inline">\(\frac{m^h-1}{m-1}\)</span>个结点，至少有h+m-1个结点</p></li><li><p>具有n个结点的m叉树，其最大高度为n，最小高度为<span class="math inline">\(\lceil \log_m{[n(m-1)+1]}\rceil\)</span>。</p><p>具有n个结点的度为m的树，其最大高度为<span class="math inline">\(n-m+1\)</span>,最小高度为<span class="math inline">\(\lceil \log_m{[n(m-1)+1]}\rceil\)</span>。</p><ul><li><p>推导：设最小高度为h，则前h-1层最多共有 <span class="math inline">\(\frac{m^{h-1}-1}{m-1}\)</span>个结点，前h层最多共有<span class="math inline">\(\frac{m^h-1}{m-1}\)</span>个结点</p><p><span class="math inline">\(\therefore\)</span> <span class="math inline">\(\frac{m^{h-1}-1}{m-1}\)</span> &lt; $n $ ≤ <span class="math inline">\(\frac{m^h-1}{m-1}\)</span></p><p><span class="math inline">\(\therefore\)</span> <span class="math inline">\(m^{h-1}\)</span> &lt; <span class="math inline">\(n(m-1) + 1\)</span> ≤ <span class="math inline">\(m^h\)</span></p><p><span class="math inline">\(\therefore\)</span> <span class="math inline">\(h-1\)</span> &lt; <span class="math inline">\(log_m{[n(m-1)+1]}\)</span> ≤ <span class="math inline">\(h\)</span></p><p><span class="math inline">\(\therefore\)</span> <span class="math inline">\(h = \lceil log_m{[n(m-1)+1]}\rceil\)</span></p></li></ul></li><li><p>对度为m的树，<span class="math inline">\(n_i\)</span>表示度为<span class="math inline">\(i\)</span>的结点个数</p><ul><li>总结点数 <span class="math inline">\(=n_0+n_1+...+n_m\)</span>，其中<span class="math inline">\(n_0\)</span>表示叶子结点的个数</li><li>总度数 <span class="math inline">\(=n_1*1+n_2*2+...+n_m*m\)</span>，总度数即总分支数，度为<span class="math inline">\(i\)</span>的结点有<span class="math inline">\(n_i\)</span>个，度为<span class="math inline">\(i\)</span>的结点引出<span class="math inline">\(i\)</span>条分支。</li><li>总结点数 = 总度数 + 1。</li></ul></li></ul><h2 id="二二叉树">二、二叉树</h2><h3 id="二叉树的定义及特性">2.1、二叉树的定义及特性</h3><p><strong>定义</strong>：二叉树是n（n≥0）个结点的有限集合：</p><ul><li>或者为空二叉树，即<span class="math inline">\(n=0\)</span></li><li>或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一颗二叉树。</li></ul><p>特点：每个结点至多有两棵子树；<strong>二叉树是有序树，左右子树不能颠倒。</strong></p><p><strong>区分二叉树和度为二的有序树</strong>：</p><ul><li>度为<span class="math inline">\(2\)</span>的有序树至少有<span class="math inline">\(3\)</span>个结点，而二叉树可以为空。</li><li>度为<span class="math inline">\(2\)</span>的有序树的孩子的左右次序是相对于另一个孩子而言的，若某个结点只有一个孩子，则这孩子就无须区分其左右次序。而二叉树无论其孩子数是否为<span class="math inline">\(2\)</span>，均需确定其左右次序，即<strong>二叉树的结点间次序不是相对于另一结点而言，而是确定的。</strong></li></ul><h3 id="几个特殊的二叉树">2.2、几个特殊的二叉树</h3><p><strong>满二叉树</strong></p><p>一棵高度为<span class="math inline">\(h\)</span>，且含有<span class="math inline">\(2^h-1\)</span>个结点的二叉树，即树中每层都含有最多的结点。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230216152040612-2024-12-723:06:46.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20230216152040612" style="zoom:50%"></p><ul><li>只有最后一层有叶子结点</li><li>不存在度为 <span class="math inline">\(1\)</span> 的结点</li><li>按层序从 <span class="math inline">\(1\)</span> 开始编号，结点 <span class="math inline">\(i\)</span> 的左孩子为 <span class="math inline">\(2i\)</span> ,结点 <span class="math inline">\(i\)</span> 的右孩子为 <span class="math inline">\(2i+1\)</span> ；<span class="math inline">\(i\)</span> 结点的父节点为 <span class="math inline">\(\lfloor i/2\rfloor\)</span>（如果有的话）。<ul><li>对于一棵满m叉树，按层序从1开始编号，结点<span class="math inline">\(i\)</span>的第一个孩子编号为 <span class="math inline">\((i-1)*m+2\)</span>，结点<span class="math inline">\(i\)</span>的双亲结点编号为 $ +1$。</li><li>推导：首先对于第<span class="math inline">\(i\)</span>个分支结点，其前面有 <span class="math inline">\(i-1\)</span>个分支结点，而每个分支结点都有<span class="math inline">\(m\)</span>个孩子，故第<span class="math inline">\(i\)</span>个分支结点的第一个孩子前 共有 <span class="math inline">\((i-1)*m+1\)</span>个结点（1是根结点），故其第一个孩子的编号为<span class="math inline">\((i-1)*m+2\)</span>；反推得，结点<span class="math inline">\(i\)</span>的双亲结点编号为<span class="math inline">\(\lfloor \frac{(i-2)}{m} \rfloor +1\)</span>。</li></ul></li><li>n个结点的满二叉树中有 <span class="math inline">\(\color{red} \frac{n+1}{2}\)</span>个叶子结点。（<span class="math inline">\(n = 2^h-1\)</span>，叶子结点个数为 <span class="math inline">\(2^{h-1} = \frac{n+1}{2}\)</span> ）</li></ul><p><strong>完全二叉树</strong></p><p>当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树。（在对应满二叉树的基础上，去掉一些<u>连续的编号更大的</u>结点后，即为完全二叉树。）</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230216153410676-2024-12-723:06:59.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20230216153410676" style="zoom:50%"></p><ul><li><p>只有最后两层可能有叶子结点</p></li><li><p><strong>最多存在一个度为 <span class="math inline">\(1\)</span> 的结点，且该结点只有左孩子而没有右孩子。</strong></p></li><li><p>编号规则和满二叉树相同</p></li><li><p>总结点数为<span class="math inline">\(n\)</span> ，编号为 <span class="math inline">\(i\)</span> 的结点，<span class="math inline">\(i \leq \lfloor n/2 \rfloor\)</span> 时为分支结点，<span class="math inline">\(i \geq \lfloor n/2 \rfloor\)</span> 时为叶子结点。（<span class="math inline">\(\lfloor n/2\rfloor\)</span>,即<span class="math inline">\(\lfloor 前 h-1层结点个数\rfloor\)</span>）</p></li></ul><blockquote><p>满二叉树是一种特殊的完全二叉树，但完全二叉树不一定是满二叉树。</p></blockquote><p><strong>二叉排序树</strong></p><ul><li><p>定义：一棵二叉树或者是空二叉树，或者是具有以下性质的二叉树</p><ul><li>左子树上所有结点的关键字均小于根结点的关键字</li><li>右子树上所有结点的关键字均大于根结点的关键字</li><li>左子树和右子树又分别是一棵二叉排序树</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230216155034041-2024-12-723:07:08.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20230216155034041" style="zoom:50%"></p></li><li><p>二叉排序树可用于元素的排序、搜索，若一棵二叉排序树是平衡二叉树，其效率会高很多。</p></li></ul><p><strong>平衡二叉树</strong></p><ul><li><p>树上任一结点的左子树和右子树的深度之差不超多 <span class="math inline">\(1\)</span>。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230216155116782-2024-12-723:07:14.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20230216155116782" style="zoom:50%"></p></li></ul><h3 id="二叉树的常考性质">2.3、二叉树的常考性质</h3><ul><li><p><strong><span class="math inline">\(n\)</span> 个结点可以构成 <span class="math inline">\(\color{red} \frac{1}{n+1} C_{2n}^{n}\)</span> （卡特兰数）个不同的二叉树</strong></p></li><li><p>设<strong>非空二叉树</strong>中度为0、1、2的结点的个数分别为 <span class="math inline">\(n_0,n_1，n_2\)</span>，则 <span class="math inline">\(\color{red}n_0 = n_2 + 1\)</span>。<strong>（叶子结点比二分支结点多一个）</strong></p><p>推导：总结点数 <span class="math inline">\(n = n_0 + n_1 + n_2\)</span>，<span class="math inline">\(n = n_1 + 2n_2 + 1\)</span>，故 <span class="math inline">\(n_0 = n_2 + 1\)</span></p></li><li><p>二叉树第 <span class="math inline">\(i\)</span> 层最多有 <span class="math inline">\(2^{i-1}\)</span> 个结点</p></li><li><p>高度为 <span class="math inline">\(h\)</span> 的二叉树至多有 <span class="math inline">\(2^h - 1\)</span> 个结点 （满二叉树）。</p></li></ul><p>完全二叉树的常考性质：</p><ul><li><p><strong>具有 <span class="math inline">\(n\)</span> （<span class="math inline">\(n&gt;0\)</span>）个结点的完全二叉树，其高度为 <span class="math inline">\(\lceil log_2{(n+1)}\rceil\)</span>或 <span class="math inline">\(\lfloor log_2n\rfloor + 1\)</span>。</strong></p><p><strong>同理，第 <span class="math inline">\(i\)</span> 个结点所在的层次为 <span class="math inline">\(\lceil log_2{(i+1)}\rceil\)</span>或 <span class="math inline">\(\lfloor log_2i\rfloor + 1\)</span>。</strong></p><p>推导：高为 <span class="math inline">\(h\)</span> 的二叉树至多有 <span class="math inline">\(2^h - 1\)</span>个结点，高度为 <span class="math inline">\(h-1\)</span> 的二叉树至多有 <span class="math inline">\(2^{h-1} - 1\)</span> 个结点</p><p>​ <span class="math inline">\(\therefore\)</span> <span class="math inline">\(2^{h-1} -1 &lt; n \le 2^h -1\)</span></p><p>​ <span class="math inline">\(\therefore\)</span> <span class="math inline">\(h-1 &lt; log_2{(n+1)} \le h\)</span></p><p>​ <span class="math inline">\(\therefore\)</span> <span class="math inline">\(h = \lceil log_2{(n+1)}\rceil\)</span></p><p>​ 或者，高为 <span class="math inline">\(h-1\)</span> 的二叉树至多有 $2^{h-1} -1 $个结点，故高为 <span class="math inline">\(h\)</span> 的二叉树至少比其多一个结点，为<span class="math inline">\(2^{h-1}\)</span>个；高为 <span class="math inline">\(h\)</span> 的二叉树至多有 $2^{h} -1 $个结点，故高为 <span class="math inline">\(h+1\)</span> 的二叉树至少比其多一个结点，为<span class="math inline">\(2^h\)</span>个</p><p>​ <span class="math inline">\(\therefore\)</span> <span class="math inline">\(2^{h-1} \le n &lt;2^h\)</span></p><p>​ <span class="math inline">\(\therefore\)</span> <span class="math inline">\(h-1 \le log_2n &lt; h\)</span></p><p>​ <span class="math inline">\(\therefore\)</span> <span class="math inline">\(h = \lfloor log_2n\rfloor + 1\)</span></p></li><li><p>高度为 <span class="math inline">\(h\)</span> 的完全二叉树至少有 <span class="math inline">\(2^{h-1}\)</span>个结点，最多有 <span class="math inline">\(2^h -1\)</span>个结点。</p></li><li><p><strong>对于完全二叉树，可由结点数 <span class="math inline">\(n\)</span> 推断出度为 <span class="math inline">\(0,1,2\)</span>的结点个数 <span class="math inline">\(n_0,n_1,n_2\)</span>。</strong></p><p><span class="math inline">\(\because\)</span> 完全二叉树最多有一个度为 1 的结点，故 <span class="math inline">\(n_1 = 0\)</span>或<span class="math inline">\(1\)</span></p><p>又<span class="math inline">\(\because\)</span> <span class="math inline">\(n_0 = n_2 + 1\)</span>， <span class="math inline">\(\therefore\)</span> <span class="math inline">\(n_0 + n_2 = 2 n_2 + 1\)</span></p><p><span class="math inline">\(\therefore\)</span> $ n_0 + n_2 一定是奇数$</p><p>当结点数<span class="math inline">\(n =2k\)</span>个为偶数时，<span class="math inline">\(n_1 =1, n_0 =k,n_2=k-1\)</span>；即 <span class="math inline">\(n_1 =1, n_0 =\frac{n}{2},n_2={\frac{n}{2}-1}\)</span></p><p>当结点数<span class="math inline">\(n = 2k-1\)</span>个为奇数时，<span class="math inline">\(n_1 =0, n_0 =k,n_2=k-1\)</span>；即<span class="math inline">\(n_1 =0, n_0 =\frac{n+1}{2},n_2=\frac{n+1}{2}-1\)</span></p></li></ul><h3 id="二叉树的存储结构">2.4、二叉树的存储结构</h3><p><strong>二叉树的顺序存储</strong></p><p>​ 二叉树的顺序存储是指用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。</p><p>​ 依据二叉树的性质，<strong>满二叉树和完全二叉树用顺序存储比较合适</strong>，对一般的二叉树，为了让数组下标反映二叉树中结点之间的关系，只能添加一些空结点，造成存储空间的大量浪费。</p><p><strong>二叉树的链式存储</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;
    ElemType data;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lchild, *rchild;
&#125;BiTNode, *BiTree;</code></pre></div><p><strong>在含有<span class="math inline">\(n\)</span> 个结点的二叉链表中，有<span class="math inline">\(n+1\)</span>个空链域。</strong></p><h3 id="二叉树的遍历">2.5、二叉树的遍历</h3><p>二叉树的遍历是指按某条搜索路径访问树中的每个结点，使得每个结点均被访问一次，且仅被访问一次。</p><p>遍历一棵二叉树便要决定对根节点<span class="math inline">\(N\)</span> ,左子树 <span class="math inline">\(L\)</span> 和右子树 <span class="math inline">\(R\)</span> 的访问顺序，常见的遍历次序有 先序<span class="math inline">\((NLR)\)</span>、中序<span class="math inline">\((LNR)\)</span>、后序<span class="math inline">\((LRN)\)</span>三种遍历方法。<strong>其中的”序“是指访问根结点在何时被访问。三种遍历算法中，遍历左、右子树的顺序是固定的，只是访问根结点的顺序不同，所以叶子结点的先后顺序是完全相同的。</strong></p><h4 id="先序遍历nlr">先序遍历（NLR）</h4><blockquote><p>递归遍历</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;
        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        preOrder(root,res);
        <span class="hljs-keyword">return</span> res;
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>; 
        res.add(root.val);
        preOrder(root.left,res);
        preOrder(root.right,res);
    &#125;
&#125;</code></pre></div><blockquote><p>非递归遍历</p></blockquote><ul><li>首先根节点入栈。</li><li>此后，若栈不为空，则弹出栈顶元素访问。若栈顶元素右孩子不为空，则先入栈右孩子；若栈顶元素左孩子不为空，则再入栈左孩子。（由于栈后进先出的特性，入栈时先右后左，出栈处理时先左后右）</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;
        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); 
        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;
            Stack&lt;TreeNode&gt; nodeStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;TreeNode&gt;();
            TreeNode node;
            nodeStack.push(root);
            <span class="hljs-keyword">while</span> (!nodeStack.empty()) &#123;
                node = nodeStack.pop();
                list.add(node.val); <span class="hljs-comment">//根</span>
                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//右</span>
                    nodeStack.push(node.right);
                &#125;
                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//左</span>
                    nodeStack.push(node.left);
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> list;
    &#125;</code></pre></div><h4 id="中序遍历lnr">中序遍历（LNR）</h4><blockquote><p>递归遍历</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;
        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        inOrder(root, res);
        <span class="hljs-keyword">return</span> res;
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        inOrder(root.left, res);
        res.add(root.val);
        inOrder(root.right, res);
    &#125;
&#125;</code></pre></div><blockquote><p>非递归遍历</p></blockquote><p>思路：①沿着根的左孩子，依次 入栈，直至左孩子为空。此时说明已经找到可以输出的结点 ；②栈顶元素出栈并访问，若其右孩子为空，继续执行②，若其右孩子不为空，将右子树转执行①。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;
    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();
    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;TreeNode&gt; ();
    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;
    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> || !stack.empty()) &#123;
        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//一路向左，不空就入栈</span>
            stack.push(p);
            p = p.left;
        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//左孩子为空，可以访问当前结点，出栈</span>
            p = stack.pop();
            list.add(p.val);
            p = p.right; <span class="hljs-comment">//转向右孩子</span>
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> list;
&#125;</code></pre></div><p>将其中访问结点的操作<code>list.add(p.val)</code>，放在左孩子入栈前即为先序遍历</p><h4 id="后序遍历lrn">后序遍历（LRN）</h4><blockquote><p>递归遍历</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;
        List&lt;Integer&gt;res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        postOrder(root,res);
        <span class="hljs-keyword">return</span> res;
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt;res)</span> &#123;
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        postOrder(root.left,res);
        postOrder(root.right,res);
        res.add(root.val);
    &#125;
&#125;</code></pre></div><blockquote><p>非递归遍历</p></blockquote><p>方法一：按照先序遍历的做法，先根节点入栈，再右孩子入栈，再左孩子入栈，最后得到的遍历序列是 <code>根 左 右</code>, 若颠倒其中左右孩子入栈顺序可到最终的遍历顺序为 <code>根 右 左</code> ，再将其逆序（不直接输出，而是存入另一个栈中）可得到后序遍历序列 <code>左 右 根</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;
        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;TreeNode&gt;();
        TreeNode node; 
        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;
            stack.push(root);
            <span class="hljs-keyword">while</span> (!stack.empty()) &#123;
                node = stack.pop();
                list.add(node.val);
                <span class="hljs-comment">//入栈时顺序为：根左右，出栈收集时得到顺序为：根右左，最后逆序即可得到后序遍历序列</span>
                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;
                    stack.push(node.left);
                &#125;
                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;
                    stack.push(node.right);
                &#125;
            &#125;
        &#125;
    	Collections.reverse(list);<span class="hljs-comment">//逆序</span>
        <span class="hljs-keyword">return</span> list;
&#125;</code></pre></div><p>方法二：用一个栈实现。使用c指向栈顶结点，h跟踪刚出栈访问的结点。</p><p>对于后序序列 ：左 右 根，</p><ul><li>当栈顶元素的左孩子不为空且刚出栈访问的结点h不是栈顶结点c的左孩子 ，h也不是右孩子时（当h是右孩子时，说明右子树已经处理完了，左子树也一定处理完了），说明c的左子树还未后序遍历完，将左孩子入栈；</li><li>当栈顶元素的右孩子不为空且刚出栈的不是右孩子时，说明右子树未处理完，将右孩子入栈；</li><li>最后当左右孩子都处理完，或左右孩子均为空时，栈顶元素出栈访问</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;
        
        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;TreeNode&gt;();

        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list;

        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> root; <span class="hljs-comment">//跟踪最近出栈的结点</span>
        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//c指向栈顶结点</span>

        stack.push(h);
        <span class="hljs-keyword">while</span> (!stack.empty()) &#123;
            c = stack.peek(); 
            <span class="hljs-keyword">if</span> (c.left != <span class="hljs-literal">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) <span class="hljs-comment">//最近出栈访问的既不是c左孩子也不是c的右孩子，则c的左子树还没处理完</span>
                stack.push(c.left);
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c.right != <span class="hljs-literal">null</span> &amp;&amp; h != c.right) <span class="hljs-comment">//最近出栈访问的不是c的右孩子，则c的右子树还未处理完</span>
                stack.push(c.right); 
            <span class="hljs-keyword">else</span> &#123;	<span class="hljs-comment">//左右子树均处理完，或左右子树都为空时，处理当前结点</span>
                h = stack.pop();
                list.add(h.val);
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> list;
     &#125;</code></pre></div><h4 id="层序遍历">层序遍历</h4><ol type="1"><li>初始化一个辅助队列，根节点入队</li><li>若队列非空，队头结点出队并访问该结点，将其左右孩子分别插到队尾（如果有的话）</li><li>重复2直至队列为空</li></ol><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LeverOrder</span><span class="hljs-params">(BiTree T)</span> </span>&#123;
    <span class="hljs-built_in">InitQueue</span>(Q);
    BiTree p;
    <span class="hljs-built_in">EnQueue</span>(Q, T);
    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">IsEmpty</span>(Q)) &#123;
        <span class="hljs-built_in">DeQueue</span>(Q, p);
        <span class="hljs-built_in">visit</span>(p);
        <span class="hljs-keyword">if</span> (p-&gt;lchild != <span class="hljs-literal">NULL</span>) &#123;
            <span class="hljs-built_in">EnQueue</span>(p-&gt;lchild);
        &#125;
        <span class="hljs-keyword">if</span> (p-&gt;rchild != <span class="hljs-literal">NULL</span>) &#123;
            <span class="hljs-built_in">EnQueue</span>(p-&gt;rchild);
        &#125;
    &#125;
&#125;</code></pre></div><h4 id="由遍历序列构造二叉树">由遍历序列构造二叉树</h4><p>方法：先从前序、后序、层序序列中寻找根节点，再根据中序序列划分左右子树，再找左右子树的根节点，进一步划分。</p><ul><li>前序 + 中序： 前序： <u>根节点</u> 、左子树前序遍历序列、右子树前序遍历序列</li><li>后序 + 中序： 后序：左子树后序遍历序列、右子树后序遍历序列、<u>根节点</u></li><li>层序 + 中序： 层序： <u>根节点</u>、 左子树的根、右子树的根</li></ul><hr><details><summary>由后序和中序构造二叉树的代码实现</summary><p>对于一棵树：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250218185008400-2025-2-1818:50:22.png" srcset="https://catpaws.top/img/transpare.svg" lazyload style="zoom:80%"></p><p>其中序和后序列表如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250218185900079-2025-2-1818:59:06.png" srcset="https://catpaws.top/img/transpare.svg" lazyload style="zoom:80%"></p><p>中序区间记为：[inStart, inEnd]; 后序区间记为：[postStart, postEnd]</p><p>思路：</p><ul><li><p>后序序列的最后一个元素就是根节点的值。</p></li><li><p>在中序序列中找到根节点的位置，记为<code>rootIndex</code>。</p></li><li><p>切割中序数组，使用<code>rootIndex</code>将中序数组，切成中序左数组和中序右数组。</p><ul><li>中序左数组范围：[inStart, rootIndex - 1]，故左子树中的结点个数为：rootIndex - inStart。</li><li>中序右数组范围：[rootIndex + 1, inEnd]</li></ul></li><li><p>切割后序数组，按照左中序数组的长度切割，将其切为后序左数组和后序右数组</p><ul><li>后序左数组范围：[postStart, postStart + rootIndex - inStart - 1]</li><li>后序右数组范围：[postStart + rootIndex - inStart, postEnd]</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span>
<span class="hljs-comment">class TreeNode&#123;</span>
<span class="hljs-comment">    private int val;</span>
<span class="hljs-comment">    private TreeNode left;</span>
<span class="hljs-comment">    private  TreeNode right;</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">    public TreeNode() &#123;&#125;</span>
<span class="hljs-comment">    public TreeNode(int val) &#123;this.val = val;&#125;</span>
<span class="hljs-comment">    public TreeNode(int val, TreeNode left, TreeNode right) &#123;</span>
<span class="hljs-comment">        this.val = val;</span>
<span class="hljs-comment">        this.left = left;</span>
<span class="hljs-comment">        this.right = right;</span>
<span class="hljs-comment">    &#125;</span>
<span class="hljs-comment">&#125;</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-comment">//将中序列表保存在哈希表中，方便寻找根节点的索引。键为节点的值，值为在列表中的索引</span>
    Map&lt;Integer, Integer&gt; inorderArrayMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
    <span class="hljs-type">int</span>[] post; <span class="hljs-comment">// 将这两个都作为全局变量，不放进参数列表中</span>

    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorder, <span class="hljs-type">int</span>[] postorder)</span> &#123;
         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;
            inorderArrayMap.put(inorder[i],i); 
        &#125;
        post = postorder;
        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> buildTree(<span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, post.length - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">return</span> root;
    &#125;

    TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd, <span class="hljs-type">int</span> postStart, <span class="hljs-type">int</span> postEnd)</span> &#123;
        <span class="hljs-keyword">if</span> (inStart &gt; inEnd || postStart &gt; postEnd)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

        <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> post[postEnd]; <span class="hljs-comment">// 根据后序列表得到根节点</span>
        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal); <span class="hljs-comment">// 创建根节点</span>

        <span class="hljs-type">int</span> <span class="hljs-variable">rootIndex</span> <span class="hljs-operator">=</span> inorderArrayMap.get(rootVal); <span class="hljs-comment">// 返回根节点在中序序列中的索引</span>
        root.left = buildTree(inStart, rootIndex - <span class="hljs-number">1</span>, postStart, postStart + rootIndex - inStart - <span class="hljs-number">1</span>);
        root.right = buildTree(rootIndex + <span class="hljs-number">1</span>, inEnd, postStart + rootIndex - inStart, postEnd - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">return</span> root;
    &#125;
&#125;</code></pre></div></details><details><summary>由前序和中序构造二叉树的代码实现</summary><p>中序区间记为：[inStart, inEnd]; 前序区间记为：[preStart, preEnd]</p><p>思路同上：</p><ul><li>前序序列的第一个元素就是根节点的值。</li><li>在中序序列中找到根节点的位置，记为<code>rootIndex</code>。</li><li>切割中序数组，使用<code>rootIndex</code>将中序数组，切成中序左数组和中序右数组。<ul><li>中序左数组范围：[inStart, rootIndex - 1]，故左子树中的结点个数为：rootIndex - inStart。</li><li>中序右数组范围：[rootIndex + 1, inEnd]</li></ul></li><li>切割前序数组，按照中序左数组的长度切割，将其切为前序左数组和前序右数组<ul><li>前序左数组范围：[preStart + 1, preStart + rootIndex - inStart]</li><li>前序右数组范围：[preStart + rootIndex - inStart + 1, preEnd]</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    Map&lt;Integer, Integer&gt; inorderMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
    <span class="hljs-type">int</span> [] preList;
    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorder, <span class="hljs-type">int</span>[] inorder)</span> &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span>  <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;
            inorderMap.put(inorder[i], i);
        &#125;
        preList = preorder; 
        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> buildTree(<span class="hljs-number">0</span>, preorder.length - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.length - <span class="hljs-number">1</span>);
        <span class="hljs-keyword">return</span> root;
    &#125;

    <span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span> preStart, <span class="hljs-type">int</span> preEnd, <span class="hljs-type">int</span> inStart, <span class="hljs-type">int</span> inEnd)</span> &#123;
        <span class="hljs-keyword">if</span> (preStart &gt; preEnd || inStart &gt; inEnd) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

        <span class="hljs-type">int</span> <span class="hljs-variable">rootVal</span> <span class="hljs-operator">=</span> preList[preStart]; <span class="hljs-comment">//前序的第一个结点是根节点</span>
        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(rootVal);

        <span class="hljs-type">int</span> <span class="hljs-variable">rootIndex</span> <span class="hljs-operator">=</span> inorderMap.get(rootVal);
        node.left = buildTree(preStart + <span class="hljs-number">1</span>, preStart + rootIndex - inStart, inStart, rootIndex - <span class="hljs-number">1</span>);
        node.right = buildTree(preStart + rootIndex - inStart + <span class="hljs-number">1</span>, preEnd, rootIndex + <span class="hljs-number">1</span>, inEnd);
        <span class="hljs-keyword">return</span> node;
    &#125;
&#125;</code></pre></div></details><hr><blockquote><p>注意点</p></blockquote><ul><li><p>要唯一确定一棵二叉树，必须给出<strong>中序遍历序列</strong>，以及另一种遍历序列。</p></li><li><p>先序和后序不能唯一确定一棵二叉树，但可以确定二叉树中结点的<strong>祖先关系</strong>，如先序序列为 e bdc 和后序序列 bcd e,则e是bcd的祖先，b 和 d是兄弟，d是c的祖先；</p></li><li><p>前中后序遍历次序是访问根结点的顺序不同，而<u>访问左右子树的次序是固定的</u>，所以<strong>左子树中结点在右子树结点之前，所有叶子结点的次序相同</strong></p></li><li><p>前序为NLR，后序为LRN，<strong>若前序序列和后序序列刚好相反</strong>，则不可能有一个结点同时有左右孩子，即所有非叶结点都只有一个孩子，则其树高为结点个数（要么为NL和LN，要么为NR和RN），只有一个叶结点；<strong>若前序序列和后序序列相同</strong>，即NLR = LRN，则L和R都为空，该二叉树只有一个根结点。</p></li><li><p>一棵二叉树的<strong>前序序列和中序序列相同</strong>，即NLR = LNR，则所有非叶结点都只能只有右孩子。</p></li><li><p>先序的最后一个结点，中序的最后一个结点、后序的第一个结点</p><ul><li>二叉树先序遍历的最后一个结点，先从根结点开始沿右孩子走到底，若该结点没有左孩子则该结点为最后一个遍历的结点，若有左孩子，则最后一个结点在其左子树中，同样的方法寻找。</li><li>二叉树中序遍历的最后一个结点，一定是从根开始沿右孩子走到底的结点</li><li>二叉树后序遍历的第一个结点，先从根节点开始沿左孩子走到底，若其没有右孩子，则为第一个结点；若有右孩子，则第一个结点在其右子树中，同样的方法寻找。</li></ul></li><li><p>根据二叉树前序遍历和中序遍历的递归算法种递归工作栈的状态变化得出：<strong>前序序列和中序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序</strong>。 所以根据给定的先序序列 abcd，可以确定的中序序列有 <span class="math inline">\(\frac{1}{n+1} C_{2n}^{n}\)</span>种，即<span class="math inline">\(\frac{1}{5}C_{8}^{4} = 14\)</span>种，又由于根据先序序列和中序序列可以确定一棵二叉树，所以先序序列为abcd的二叉树有 14种。</p></li></ul><h3 id="线索二叉树">2.6、线索二叉树</h3><h4 id="定义">定义</h4><p>​ 传统的二叉链表存储仅能体现父子关系（从上到下），<strong>不能直接得到结点在遍历序列中的前驱或后继</strong>，只能从根结点开始进行一次遍历才能确定。将二叉链表中空闲的<span class="math inline">\(\color{red}n+1\)</span>个空闲指针域利用起来，将其指向遍历序列中的前驱或后继，方便从一个指定结点出发，找到其前驱、后继，就可以像遍历单链表那样方便地遍历二叉树。</p><p>​ <strong>线索，即指向遍历序列中前序或后继的指针。</strong>规定，若无左子树，lchild指向其前驱结点；若无右子树，rchild指向其后继节点。</p><p><strong>二叉树是逻辑结构，线索二叉树是存储结构</strong></p><h4 id="存储结构">存储结构</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadNode</span> &#123;
    Elemtype data;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadNode</span> *lchild, *rchild;
    <span class="hljs-type">int</span> ltag,rtag; <span class="hljs-comment">//左右线索标志，ltag为1时指针为线索，tag为0时，指针指向孩子。初始化时 tag都为0</span>
&#125;ThreadNode, *ThreadTree;</code></pre></div><p>手算画出线索二叉树：确定线索二叉树的类型，按照对应的遍历规则确定各结点的访问顺序，并写上编号，再将n+1 个空链域连上前驱和后继。</p><h4 id="二叉树的线索化">二叉树的线索化</h4><p>核心：<strong>对中序、先序、后序遍历算法的改造，当访问一个结点时，建立<u>该结点</u>和<u>其前驱</u>的线索信息。</strong></p><p>易错点：</p><ul><li><p>对最后一个结点rchild、rtag的处理</p></li><li><p>先序线索化中转圈的问题，当ltag = 0时才能对左子树进行先序线索化</p></li></ul><p><strong>中序线索化</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225174818508-2024-12-800:12:51.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20230225174818508" style="zoom:50%"></p><div class="code-wrapper"><pre><code class="hljs c++">ThreadNode *pre = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//全局变量 pre，指向当前结点的前驱结点</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatInThread</span><span class="hljs-params">(ThreadTree T)</span> </span>&#123;
    pre = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">if</span> (T != <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-built_in">InThread</span>(T); <span class="hljs-comment">//中序线索化</span>
        <span class="hljs-keyword">if</span> (pre-&gt;rchild == <span class="hljs-literal">NULL</span>)  <span class="hljs-comment">//处理遍历的最后一个结点</span>
            pre-&gt;rtag = <span class="hljs-number">1</span>;	
    &#125;
&#125;
<span class="hljs-comment">//中序遍历二叉树，一边遍历一边线索化</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InTread</span><span class="hljs-params">(ThreadTree T)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (T != <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-built_in">InThread</span>(T-&gt;lchild);
        <span class="hljs-built_in">visit</span>(T);
        <span class="hljs-built_in">InThread</span>(T-&gt;rchild);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ThreadNode *q)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (q-&gt;lchild == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//当前结点左子树为空，建立当前结点的前驱线索</span>
        q-&gt;lchild = pre;
        q-&gt;ltag = <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//建立前驱结点的后继线索</span>
        pre-&gt;rchild = q;
        pre-&gt;rtag = <span class="hljs-number">1</span>;
    &#125;
    pre = q; <span class="hljs-comment">//当前结点及其前驱已经处理完，开始准备下一个结点</span>
&#125;</code></pre></div><p><strong>先序线索化</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225175853143-2024-12-723:51:31.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20230225175853143" style="zoom:50%"></p><p>当q指针指向D，D没有左孩子，建立前驱线索 lchild 指向B，pre指向D；根据先序顺序，接下来该处理其左孩子，但在上步其左孩子已经指向了B，导致q再次指向B，出现了死循环。所以根据tag标志判断访问的是左子树还是前驱</p><div class="code-wrapper"><pre><code class="hljs c++">ThreadNode *pre = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//全局变量 pre，指向当前结点的前驱结点</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatPreThread</span><span class="hljs-params">(ThreadTree T)</span> </span>&#123;
	...同上
&#125;
<span class="hljs-comment">//先序遍历二叉树，一边遍历一边线索化</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preTread</span><span class="hljs-params">(ThreadTree T)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (T != <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-built_in">visit</span>(T);
        <span class="hljs-keyword">if</span> (T-&gt;ltag == <span class="hljs-number">0</span>)  <span class="hljs-comment">//lchid 不是前驱线索</span>
        	<span class="hljs-built_in">InThread</span>(T-&gt;lchild);
        <span class="hljs-built_in">InThread</span>(T-&gt;rchild);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ThreadNode *q)</span> </span>&#123;
	...同上
&#125;</code></pre></div><p><strong>后序线索化</strong></p><p>​ 同中序线索化，将中序遍历改为后序遍历即可。</p><h4 id="在线索二叉树中找前后驱">在线索二叉树中找前后驱</h4><p>若ltag或rtag为1，则lchild或rchild所指的就是其前驱或后继。</p><p><strong>中序线索二叉树 （LNR）</strong></p><ul><li><p>找p的前驱，若ltag = 0，则必有左孩子，前驱为左孩子中最后一个被访问的结点，即<strong>左子树最右下的结点</strong></p></li><li><p>找p的后继，若 rtag = 0，则必有右孩子，后继为右子树中第一个被访问的结点，即<strong>右子树中最左下的结点</strong></p></li></ul><p><strong>先序线索二叉树 (NLR)</strong></p><ul><li><p>找p的后继，若rtag = 0，则必有右孩子，若也有左孩子，则后继为左孩子；若无左孩子，则后继为右孩子。（有左为左。无右为右）</p></li><li><p>找p的前驱，若ltag = 0 且只有lchild和rchild两个指针域时无法找到其前驱。</p><p>要找到其前驱，需<strong>使用三叉链表，在每个结点中记录父节点信息</strong></p><ul><li>若能找到p的父节点，p是左孩子，则p的父节点就是p的前驱</li><li>若能找到p的父节点，p是右孩子且左孩子为空，则p的父节点就是p的前驱</li><li>若能找到p的父节点，p是右孩子且左孩子不为空，则<u>其左兄弟最后一个被遍历的结点即是p的前驱</u>。（先沿左兄弟的右孩子指针一直向下到最后一个，若此结点有左孩子，则再沿左孩子指针向下直到最后一个，依次类推，直至找到最后一个被遍历的结点）</li><li>如果p是根结点，则p无前驱。</li></ul></li></ul><p><strong>后序线索二叉树（LRN）</strong></p><ul><li><p>找p的前驱，若ltag = 0，则必有左孩子，若也有右孩子，则右孩子为其前驱；若没有右孩子，则左孩子为其前驱。（有右为右，无右为左）</p></li><li><p>找p的后继，若rtag = 0,且只有lchild和rchild两个指针域时无法找到其后继。 （<strong>同先序找前驱</strong>）</p><p>要找到其后继，需<strong>使用三叉链表，在每个结点中记录父节点信息</strong></p><ul><li>若能找到p的父节点，p是右孩子，则p的父节点就是p的后继</li><li>若能找到p的父节点，p是左孩子且右孩子为空，则p的父节点就是p的后继</li><li>若能找到p的父节点，p是左孩子且右孩子不为空，则<u>其右兄弟第一个被遍历的结点即是p的后继</u>。（先沿右兄弟的左孩子指针一直向下到最后一个，若此结点有右孩子，则再沿右孩子指针向下直到最后一个，依次类推，直至找到最后一个被遍历的结点）</li><li>如果p是根结点，则p无后继。</li></ul></li></ul><table><thead><tr class="header"><th></th><th>中序线索二叉树</th><th>先序线索二叉树</th><th>后序线索二叉树</th></tr></thead><tbody><tr class="odd"><td>找前驱</td><td>✔</td><td>✘</td><td>✔</td></tr><tr class="even"><td>找后继</td><td>✔</td><td>✔</td><td>✘</td></tr></tbody></table><p>后序线索二叉树的遍历仍需要栈的支持，后序找后继不一定能直接找到。</p><h2 id="三树森林">三、树、森林</h2><h3 id="树的逻辑结构">3.1、树的逻辑结构</h3><p><strong>树</strong>是n（n&gt;0）个结点的有限集合，n=0时，称为空树。在任意一棵非空树中应满足： 1）有且仅有一个特定的称为<strong>根</strong>的结点。 2）当n&gt;1时，其余结点可分为m（m&gt;0）个<strong>互不相交的有限集</strong>合T1,T2...Tm，其中每个集合本身又是一棵树，并且称为根结点的<strong>子树</strong>。</p><ul><li>树是一种递归定义的数据结构</li></ul><h3 id="树的存储结构">3.2、树的存储结构</h3><p><strong>双亲表示法（顺序存储）</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225200402386-2024-12-723:58:02.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20230225200402386" style="zoom:67%"></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;  <span class="hljs-comment">//树结点的定义</span>
    <span class="hljs-type">int</span> data;
    <span class="hljs-type">int</span> parent;
&#125;PTNode;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">//树的类型定义</span>
    PTNode nodes[MAX_TREE_SIZE]; 
    <span class="hljs-type">int</span> n; <span class="hljs-comment">//结点数</span>
&#125;</code></pre></div><p>每个结点中保存指向双亲的“指针”，其实就是使用<strong>静态数组</strong>存储。根节点固定存储在0，-1表示没有双亲。</p><ul><li>增加元素，将新元素放到数组末尾并保存双亲结点的位置。新增元素时无需按逻辑上的次序存储。</li><li>删除元素，若删除的是叶节点，可以使用数组最后一个元素覆盖当前结点的内容，并将总结点数减一，保证已存储的均有效，也方便遍历；若删除的是分支结点，则要找到其所有的子孙结点，也将它们全部删除。</li><li>查询孩子结点，需要从头遍历，判断每个位置的双亲结点和要查询的是否一致，依次找到所有的孩子节点。</li></ul><p>优点：查指定结点的双亲很方便；缺点：查指定结点的孩子结点只能从头遍历。</p><p><strong>孩子表示法（顺序+链式）</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225201513725-2024-12-723:58:12.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20230225201513725" style="zoom:50%"></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span>
<span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span>&#123; <span class="hljs-comment">//孩子链表结点的定义</span>
    <span class="hljs-type">int</span> child; <span class="hljs-comment">//孩子节点在数组中的位置</span>
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span> *next; <span class="hljs-comment">//指向下一个孩子</span>
&#125;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">//结点数组元素的定义</span>
    ElemType data;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span> *firstChild;
&#125;CTBox;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;
    CTBox nodes[MAX_TREE_SIZE];
    <span class="hljs-type">int</span> n,r; <span class="hljs-comment">//结点数和根的位置</span>
&#125;CTree;</code></pre></div><p>顺序存储各个结点，每个结点中保存孩子链表的头指针。</p><p>该存储结构找孩子方便，找双亲时需要遍历n个结点对应的孩子链表，在里面找是否有指定结点。</p><p><strong>孩子兄弟表示法 （链式存储）</strong></p><p>左孩子右兄弟</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-02-25_20-30-40-2024-12-723:58:19.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="Snipaste_2023-02-25_20-30-40" style="zoom:67%"></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span>&#123;
    ElemType data;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span> *firstchild, *nextsibling; <span class="hljs-comment">//第一个孩子 和 右兄弟指针</span>
&#125;CSNode, *CSTree;</code></pre></div><p>该种存储表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲比较麻烦（可以增设一个parent域指向父节点）。</p><h3 id="树森林和二叉树的转换">3.3、树、森林和二叉树的转换</h3><p>森林转换为二叉树：先将每棵树转换为二叉树，因为各个树之间是平级的，所以各个树的根节点可以相互看做兄弟结点，用右指针将各个根节点串联起来即可。</p><blockquote><p>森林转换为对应的二叉树，森林中叶子结点的个数对应二叉树中左指针为空的结点个数</p><p>高度为h的满二叉树，对应的森林所含树的个数为 h</p><p>一棵树转换为二叉树，树中每个非叶结点的最后一个孩子没有右孩子,且根结点没有右兄弟，故树中非叶节点个数 + 1 = 二叉树中右指针为空的结点个数</p><p>一个森林转换为二叉树，各个树的根节点可以相互看做兄弟，最后一棵树没有右兄弟，故森林中非叶结点个数 + 1= 二叉树中右指针为空的节点数</p><p>一棵树或森林转化为二叉树，其中叶结点的个数对应二叉树中左指针为空的结点数。</p><p>若树中任意两个叶结点都不存在相同的双亲，则树中的叶子数和其对应的二叉树中的叶子数相等</p><p>一个森林有 <span class="math inline">\(n\)</span>个结点，<span class="math inline">\(m\)</span>条边，则这个森林有$ n - m$ 棵树。（ 在树中，除了根节点外，每个顶点对应一条边）</p></blockquote><h3 id="树和森林的遍历">3.4、树和森林的遍历</h3><table><thead><tr class="header"><th>树</th><th>森林</th><th>二叉树</th></tr></thead><tbody><tr class="odd"><td>先序遍历</td><td>先序遍历</td><td>先序遍历</td></tr><tr class="even"><td>后序遍历</td><td>中序遍历</td><td>中序遍历</td></tr></tbody></table><h2 id="四树和二叉树的应用">四、树和二叉树的应用</h2><h3 id="哈夫曼树和哈夫曼编码">4.1、哈夫曼树和哈夫曼编码</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225211114726-2024-12-723:58:35.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20230225211114726" style="zoom:50%"></p><p>结点的权：有某种现实含义的数值（如：表示结点的重要性，出现次数等）</p><p>结点的带权路径长度：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积</p><p>树的带权路径长度：<strong>所有叶结点</strong>的带权路径长度之和 <span class="math inline">\(WPL = \sum_{i=1}^{n} w_i l_i\)</span></p><p><strong>在含有<span class="math inline">\(n\)</span>个带权叶结点的二叉树中，其中带权路径长度（<span class="math inline">\(WPL\)</span>）最小的二叉树称为哈夫曼树，也称最优二叉树</strong></p><p>特点：</p><ul><li>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度就越大。</li><li>构造过程中一共新建了 <span class="math inline">\(n-1\)</span>个结点，因此哈夫曼树的结点总数为 <span class="math inline">\(2n -1\)</span>。</li><li>哈夫曼树中，只有度为2和度为<span class="math inline">\(0\)</span>的结点，不存在度为 1 的结点。</li><li>哈夫曼树不唯一，但 <span class="math inline">\(WPL\)</span>必然相同且为最优。</li></ul><blockquote><p>度为m的哈夫曼树，其中只有度为 m和度为 <span class="math inline">\(0\)</span>的结点。有 n个叶结点时，由于总结点数 = <span class="math inline">\(n_0+n_m=m*n_m+1\)</span>，故有 <span class="math inline">\(\lceil \frac{n-1}{m-1}\rceil\)</span>个非叶结点。</p></blockquote><p>若没有一个编码是另一个编码的前缀，则称这样的编码为<strong>前缀编码</strong>。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225212551153-2024-12-723:58:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20230225212551153" style="zoom:50%"></p><p>由哈夫曼树得到哈夫曼编码。首先将每个出现的字符当做一个独立的结点，其权值为它出现的频度或次数，构造出对应的哈夫曼树。所有的字符都出现在叶结点中。可将字符的编码解释为从根到该字符的路径上边标记的序列，其中边标记为0表示 “转向左孩子”，边标记为1 表示“转向右孩子”。</p><p>哈夫曼树不唯一，因此哈夫曼编码不唯一。</p><blockquote><p>出现频度高的字符，其哈夫曼编码短；频度低的字符，编码长度更长。</p></blockquote><h3 id="并查集">4.2、并查集</h3><p>逻辑结构：元素之间为 “集合”关系。</p><p><strong>基本操作</strong>：</p><ul><li>初始化 Initial(S)：初始化并查集，将所有数组元素初始化为-1</li><li>Union （S, root1, root2）: <strong>“并”</strong>，把集合S中的子集 root2 并入子集 root1中，<strong>要求 root1 和root2不相交</strong></li><li>Find (S, x)：<strong>“查”</strong>，查找集合S中单元素x所在的子集合，并返回该子集合的名字。</li></ul><p><strong>存储结构</strong>：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225215722535-2024-12-800:03:19.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20230225215722535" style="zoom:67%"></p><p>​ 将每个集合组织成一棵树，通常用树（森林）的<strong>双亲表示法</strong>做为并查集的存储结构。通常用数组元素下标代表元素名，用根结点的小标代表子集合名，根结点的双亲结点为负数。</p><blockquote><p>并查集（Disjoint Set）是对逻辑结构 --- 集合 的具体实现，只进行 “并” 和 "查"两种基本操作</p><p>并 ：将两个不相交的集合合并为一个， 查：确定一个指定元素所属的集合</p></blockquote><p>其中查操作，通过不断向上寻找，找到所在树的根节点，根节点的数组下标代表该元素所属的集合。</p><p>并操作，只需将一个集合的根节点的双亲指针指向另一个集合的根节点即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 13</span>
<span class="hljs-type">int</span> UFSets[SIZE];  <span class="hljs-comment">//集合元素数组</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Initial</span> <span class="hljs-params">(<span class="hljs-type">int</span> s[])</span> </span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++) 
        s[i] = <span class="hljs-number">-1</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span> <span class="hljs-params">(<span class="hljs-type">int</span> s[],<span class="hljs-type">int</span> x)</span> </span>&#123;
    <span class="hljs-keyword">while</span> (s[x] &gt;<span class="hljs-number">0</span>) 
        x = s[x];  
    <span class="hljs-keyword">return</span> x;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span> <span class="hljs-params">(<span class="hljs-type">int</span> s[], <span class="hljs-type">int</span> root1, <span class="hljs-type">int</span> root2)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (root1 == root2) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//要求两个集合不同</span>
    s[root2] = root1; <span class="hljs-comment">//将根root1 连接在另一根 root2下</span>
&#125;
</code></pre></div><p>其中Find操作的最坏时间复杂度为<span class="math inline">\(O(n)\)</span>，最坏时间复杂度和树的高度有关。Union操作的时间复杂度为 <span class="math inline">\(O(1)\)</span>.</p><p><strong>并查集的优化</strong></p><p>​ 为了降低Find的时间复杂度，需要在每次Union操作构建树的时候，尽可能让树不长高。用根结点的<strong>绝对值</strong>表示树的结点总数，每次Union操作时都让小树合并到大树。</p><p>​ 压缩路径—-Find操作，先找到根节点，再将查找路径上所有结点都挂到根结点下。可使树的高度不超过<span class="math inline">\(O(α(n))\)</span>。<span class="math inline">\(α(n)\)</span>是一个增长很缓慢的函数，对于常见的n值，通常<span class="math inline">\(α(n) ≤ 4\)</span>，因此优化后并查集的Find、Union操作时间开销都很低</p><p>​ <img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-02-25_22-28-33-2024-12-800:03:31.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="Snipaste_2023-02-25_22-28-33"></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 13</span>
<span class="hljs-type">int</span> UFSets[SIZE];  <span class="hljs-comment">//集合元素数组</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Initial</span> <span class="hljs-params">(<span class="hljs-type">int</span> s[])</span> </span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++) 
        s[i] = <span class="hljs-number">-1</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span> <span class="hljs-params">(<span class="hljs-type">int</span> s[],<span class="hljs-type">int</span> x)</span> </span>&#123;
	<span class="hljs-type">int</span> root = x;
    <span class="hljs-keyword">while</span> (s[root] &gt; <span class="hljs-number">0</span>) root = s[root];  <span class="hljs-comment">//循环找到根</span>
    <span class="hljs-comment">//压缩路径</span>
    <span class="hljs-keyword">while</span> (x != root) &#123;
        <span class="hljs-type">int</span> t = s[x];
        s[x] = root;
        x = t;
    &#125;
    <span class="hljs-keyword">return</span> root;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span> <span class="hljs-params">(<span class="hljs-type">int</span> s[], <span class="hljs-type">int</span> root1, <span class="hljs-type">int</span> root2)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (root1 == root2) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//要求两个集合不同</span>
    <span class="hljs-keyword">if</span> (s[root2] &gt; s[root1]) &#123; <span class="hljs-comment">//root2结点更少，将root2合并到root1</span>
        s[root2] = root1;
        s[root1] += s[root2];
    &#125; <span class="hljs-keyword">else</span> &#123;
        s[root1] = root2;
        s[root2] += s[root1];
    &#125;
        
&#125;
</code></pre></div></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="category-chain-item">数据结构</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%A0%91/" class="print-no-link">#树</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" class="print-no-link">#二叉树</a> <a href="/tags/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91/" class="print-no-link">#线索二叉树</a> <a href="/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/" class="print-no-link">#哈夫曼树</a> <a href="/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="print-no-link">#并查集</a></div></div><div class="license-box my-3"><div class="license-title"><div>五、树和二叉树</div><div>https://catpaws.top/453281de/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年12月7日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/ce993eeb/" title="六、图"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">六、图</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/dac6dce7/" title="四、串"><span class="hidden-mobile">四、串</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://cdn.smartcis.cn/npm/twikoo@1.6.40/dist/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本站由<img src="/img/upyun_logo.png" srcset="https://catpaws.top/img/transpare.svg" lazyload style="width:auto;height:auto">提供CDN加速/云存储服务</a></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备2025059828号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61032302000087" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="police-icon"> <span>陕公网安备61032302000087号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//catpaws.top/blog-resource/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="//catpaws.top/blog-resource/js/loader.js"></script><script src="//catpaws.top/blog-resource/js/blurpicload.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://registry.npmmirror.com/oh-my-live2d/latest/files"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"https://catpaws.top/blog-resource/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"}}})</script></body></html>