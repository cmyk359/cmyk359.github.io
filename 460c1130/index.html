<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkai/dist/LXGWWenKai-Regular/result.css"><link rel="apple-touch-icon" sizes="76x76" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><link rel="icon" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="一、服务调用 Java发送http请求可以使⽤Spring提供的RestTemplate，使⽤的基本步骤如下：  注册RestTemplate到Spring容器 调⽤RestTemplate的API发送请求  用RestTemplate发送http请求，包含四部分信息：  ① 请求方式 ② 请求路径 ③ 请求参数 ④ 返回值类型  CartService 去调用 It"><meta property="og:type" content="article"><meta property="og:title" content="微服务"><meta property="og:url" content="https://catpaws.top/460c1130/index.html"><meta property="og:site_name" content="猫爪在上の书桌"><meta property="og:description" content="一、服务调用 Java发送http请求可以使⽤Spring提供的RestTemplate，使⽤的基本步骤如下：  注册RestTemplate到Spring容器 调⽤RestTemplate的API发送请求  用RestTemplate发送http请求，包含四部分信息：  ① 请求方式 ② 请求路径 ③ 请求参数 ④ 返回值类型  CartService 去调用 It"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205114251666-2025-2-511:43:25.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204214650433-2025-2-422:22:06.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204215600470-2025-2-422:22:11.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204215640696-2025-2-422:22:14.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204221636625-2025-2-422:22:26.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204222611291-2025-2-422:26:12.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204222821911-2025-2-422:28:23.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204223617696-2025-2-422:36:18.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204224124122-2025-2-422:41:41.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204224217779-2025-2-422:42:18.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204224406642-2025-2-422:44:07.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204224530813-2025-2-422:45:32.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204224842832-2025-2-422:48:48.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204225046745-2025-2-422:50:47.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204225120770-2025-2-422:51:21.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204225812687-2025-2-422:58:13.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204230850859-2025-2-423:08:52.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204231322595-2025-2-423:13:25.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204231841138-2025-2-423:18:47.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204231943536-2025-2-423:19:44.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204232123922-2025-2-423:21:25.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204232321363-2025-2-423:23:22.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204232548649-2025-2-423:25:57.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204232913465-2025-2-423:29:14.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233045536-2025-2-423:30:46.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233111051-2025-2-423:31:12.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233147280-2025-2-423:31:48.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233329924-2025-2-423:33:30.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233423314-2025-2-423:34:42.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233717814-2025-2-423:37:18.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205101329880-2025-2-510:13:55.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205101836988-2025-2-510:18:38.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205102028361-2025-2-510:20:31.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205102151605-2025-2-510:22:12.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205102318787-2025-2-510:23:19.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205102409302-2025-2-510:24:10.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/c63a587dec6aad303020e9c189bd2b1b9544518b/img/image-20250708211528653-2025-7-821:15:30.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205104346165-2025-2-510:43:47.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205104818068-2025-2-510:48:31.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205105231420-2025-2-510:52:57.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205105106335-2025-2-510:51:31.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205105326278-2025-2-510:53:27.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205105935054-2025-2-510:59:49.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205110306722-2025-2-511:03:07.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205110405106-2025-2-511:04:06.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205110450434-2025-2-511:04:51.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205110603765-2025-2-511:06:16.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111017652-2025-2-511:10:18.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111102271-2025-2-511:11:03.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111425351-2025-2-511:14:31.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111507034-2025-2-511:15:31.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111731892-2025-2-511:17:33.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111828535-2025-2-511:18:29.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101535636-2025-2-610:15:47.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101620493-2025-2-610:16:21.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101640224-2025-2-610:16:41.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101658752-2025-2-610:16:59.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205112354921-2025-2-511:24:09.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101746909-2025-2-610:17:47.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101802772-2025-2-610:18:03.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101823253-2025-2-610:18:24.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101855768-2025-2-610:18:56.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101942443-2025-2-610:19:43.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102034921-2025-2-610:20:36.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102045669-2025-2-610:20:46.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102112967-2025-2-610:21:13.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102130287-2025-2-610:21:43.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205113626096-2025-2-511:36:31.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102731634-2025-2-610:27:49.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102923519-2025-2-610:29:49.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206103221262-2025-2-610:32:22.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206104757749-2025-2-610:48:11.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206103827156-2025-2-610:38:49.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206105952552-2025-2-610:59:54.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206110054739-2025-2-611:00:55.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206110624648-2025-2-611:06:37.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206110816199-2025-2-611:08:17.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206112243669-2025-2-611:22:48.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206111635526-2025-2-611:16:36.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206113123686-2025-2-611:31:25.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206113911361-2025-2-611:39:37.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211094833670-2025-2-1110:40:16.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211095334972-2025-2-1109:53:36.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211095944590-2025-2-1109:59:45.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100207999-2025-2-1110:02:09.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100551228-2025-2-1110:05:52.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100738170-2025-2-1110:07:39.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100924951-2025-2-1110:09:26.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211101237979-2025-2-1110:12:39.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211101950426-2025-2-1110:19:51.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211101903956-2025-2-1110:19:05.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211104959780-2025-2-1110:50:01.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-2025-2-1110:54:01.jpg"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211105803927-2025-2-1110:58:24.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211105928820-2025-2-1110:59:30.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110016831-2025-2-1111:00:18.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110227010-2025-2-1111:02:28.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110514041-2025-2-1111:05:52.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110639183-2025-2-1111:06:52.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110745382-2025-2-1111:07:52.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211111205706-2025-2-1111:12:12.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211112238339-2025-2-1111:22:52.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211112640217-2025-2-1111:26:49.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211113655596-2025-2-1111:37:40.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211113816684-2025-2-1111:38:18.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211114120125-2025-2-1111:41:22.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211123649911-2025-2-1112:36:52.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211124025590-2025-2-1112:40:44.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211124457284-2025-2-1112:44:58.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211124655817-2025-2-1112:46:56.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211125033080-2025-2-1112:50:34.png"><meta property="article:published_time" content="2025-02-05T02:27:48.000Z"><meta property="article:modified_time" content="2025-07-13T02:54:24.275Z"><meta property="article:author" content="猫爪在上"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250205114251666-2025-2-511:43:25.png"><title>微服务 - 猫爪在上の书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/font.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/poem.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/cursor.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/loader.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/twikoo_beautify.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/indeximg-hover.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/wave-1.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/blurpicload.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/reward/iconfont.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/switch.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"https://catpaws.top/blog-resource/imgs/transparent.svg",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://leancloud.catpaws.top",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loader-container"><div class="loader"><div class="wrapper"><div class="catContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 733 673" class="catbody"><path fill="#212121" d="M111.002 139.5C270.502 -24.5001 471.503 2.4997 621.002 139.5C770.501 276.5 768.504 627.5 621.002 649.5C473.5 671.5 246 687.5 111.002 649.5C-23.9964 611.5 -48.4982 303.5 111.002 139.5Z"></path><path fill="#212121" d="M184 9L270.603 159H97.3975L184 9Z"></path><path fill="#212121" d="M541 0L627.603 150H454.397L541 0Z"></path></svg> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 158 564" class="tail"><path fill="#191919" d="M5.97602 76.066C-11.1099 41.6747 12.9018 0 51.3036 0V0C71.5336 0 89.8636 12.2558 97.2565 31.0866C173.697 225.792 180.478 345.852 97.0691 536.666C89.7636 553.378 73.0672 564 54.8273 564V564C16.9427 564 -5.4224 521.149 13.0712 488.085C90.2225 350.15 87.9612 241.089 5.97602 76.066Z"></path></svg><div class="text"><span class="bigzzz">Z</span> <span class="zzz">Z</span></div></div><div class="wallContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 500 126" class="wall"><line stroke-width="6" stroke="#7C7C7C" y2="3" x2="450" y1="3" x1="50"></line><line stroke-width="6" stroke="#7C7C7C" y2="85" x2="400" y1="85" x1="100"></line><line stroke-width="6" stroke="#7C7C7C" y2="122" x2="375" y1="122" x1="125"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="500" y1="43"></line><line stroke-width="6" stroke="#7C7C7C" y2="1.99391" x2="115.5" y1="43.0061" x1="115.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00002" x2="189" y1="43.0122" x1="189"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00612" x2="262.5" y1="43.0183" x1="262.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01222" x2="336" y1="43.0244" x1="336"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01833" x2="409.5" y1="43.0305" x1="409.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="153" y1="84.0122" x1="153"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="228" y1="84.0122" x1="228"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="303" y1="84.0122" x1="303"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="378" y1="84.0122" x1="378"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="192" y1="125.012" x1="192"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="267" y1="125.012" x1="267"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="342" y1="125.012" x1="342"></line></svg></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上の书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>个人主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://catpaws.top/blog-resource/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="微服务"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-02-05 10:27" pubdate>2025年2月5日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 23k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 195 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">微服务</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年7月13日 上午</p><div class="markdown-body"><meta name="referrer" , content="no-referrer"><h1 id="一服务调用">一、服务调用</h1><p>Java发送http请求可以使⽤Spring提供的RestTemplate，使⽤的基本步骤如下：</p><ul><li>注册RestTemplate到Spring容器</li><li>调⽤RestTemplate的API发送请求</li></ul><p>用RestTemplate发送http请求，包含四部分信息：</p><ul><li>① 请求方式</li><li>② 请求路径</li><li>③ 请求参数</li><li>④ 返回值类型</li></ul><p>CartService 去调用 ItemService中的方法：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204220304197-2025-2-422:21:55.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><p>后面会使用OpenFeign完成服务调用。</p><h1 id="二服务注册和发现">二、服务注册和发现</h1><p>当对一个服务进行多实例部署后，每个实例都有自己的IP或端⼝，使用RestTemplate发送http请求时需要指定路径，此时就十分困难了</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205114251666-2025-2-511:43:25.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205114251666" style="zoom:80%"></p><p>此时，每个<code>item-service</code>的实例其IP或端口不同，问题来了：</p><ul><li>item-service这么多实例，cart-service如何知道每一个实例的地址？</li><li>http请求要写url地址，<code>cart-service</code>服务到底该调用哪个实例呢？</li><li>如果在运行过程中，某一个<code>item-service</code>实例宕机，<code>cart-service</code>依然在调用该怎么办？</li><li>如果并发太高，<code>item-service</code>临时多部署了N台实例，<code>cart-service</code>如何知道新实例的地址？</li></ul><p>为了解决上述问题，就必须引入注册中心的概念了，接下来我们就一起来分析下注册中心的原理。</p><h2 id="注册中原理">2.1、注册中⼼原理</h2><p>在微服务远程调⽤的过程中，包括两个⻆⾊：</p><ul><li><p>服务提供者：提供接⼝供其它微服务访问，⽐如 item-service</p></li><li><p>服务消费者：调⽤其它微服务提供的接⼝，⽐如 cart-service</p></li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204214650433-2025-2-422:22:06.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204214650433" style="zoom:67%"></p><p>流程如下：</p><ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul><h2 id="服务注册nacos注册中">2.2、服务注册(Nacos注册中⼼)</h2><p>把<code>item-service</code>注册到Nacos，步骤如下：</p><ul><li>引入依赖</li><li>配置Nacos地址</li><li>重启</li></ul><h3 id="添加依赖">添加依赖</h3><p>在<code>item-service</code>的<code>pom.xml</code>中添加依赖：</p><div class="code-wrapper"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!--nacos 服务注册发现--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="配置nacos">配置Nacos</h3><p>在<code>item-service</code>的<code>application.yml</code>中添加nacos地址配置：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">item-service</span> <span class="hljs-comment"># 服务名称</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.181</span><span class="hljs-number">.100</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># nacos地址</span></code></pre></div><h3 id="启动服务实例">启动服务实例</h3><p>再配置一个<code>item-service</code>的部署实例，测试一个服务多个实例的情况。</p><p>重启<code>item-service</code>的两个实例，访问nacos控制台，可以发现服务注册成功：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204215600470-2025-2-422:22:11.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204215600470" style="zoom:67%"></p><p>点击详情，可以查看到<code>item-service</code>服务的两个实例信息：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204215640696-2025-2-422:22:14.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204215640696" style="zoom:67%"></p><h2 id="服务发现">2.3、服务发现</h2><p>服务的消费者要去nacos订阅服务，这个过程就是服务发现，步骤如下：</p><ul><li>引入依赖</li><li>配置Nacos地址</li><li>发现并调用服务</li></ul><h3 id="引入依赖">引入依赖</h3><p>服务发现除了要引入nacos依赖以外，由于还需要负载均衡，因此要引入SpringCloud提供的LoadBalancer依赖。</p><p>我们在<code>cart-service</code>中的<code>pom.xml</code>中添加下面的依赖：</p><div class="code-wrapper"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!--nacos 服务注册发现--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>可以发现，这里Nacos的依赖于服务注册时一致，这个依赖中同时包含了服务注册和发现的功能。因为任何一个微服务都可以调用别人，也可以被别人调用，即可以是调用者，也可以是提供者。</p><p>因此，等一会儿<code>cart-service</code>启动，同样会注册到Nacos</p><h3 id="配置nacos地址">配置Nacos地址</h3><p>在<code>cart-service</code>的<code>application.yml</code>中添加nacos地址配置：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:8848</span></code></pre></div><h3 id="发现并调用服务">发现并调用服务</h3><p>接下来，服务调用者<code>cart-service</code>就可以去订阅<code>item-service</code>服务了。不过item-service有多个实例，而真正发起调用时只需要知道一个实例的地址。</p><p>因此，服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问。常见的负载均衡算法有：</p><ul><li>随机</li><li>轮询</li><li>IP的hash</li><li>最近最少访问</li><li>...</li></ul><p>这里我们可以选择最简单的随机负载均衡。</p><p>另外，服务发现需要用到一个工具，<code>DiscoveryClient</code>，SpringCloud已经帮我们自动装配，我们可以直接注入使用</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204220132797-2025-2-422:22:20.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204220132797"><figcaption aria-hidden="true">image-20250204220132797</figcaption></figure><p>接下来，我们就可以对原来的远程调用做修改了，之前调用时我们需要写死服务提供者的IP和端口。但现在不需要了，我们通过DiscoveryClient发现服务实例列表，然后通过负载均衡算法，选择一个实例去调用：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204220208262-2025-2-422:22:22.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204220208262"><figcaption aria-hidden="true">image-20250204220208262</figcaption></figure><div class="note note-warning"><p>思考：当服务注册和发现中心宕机时，一个服务还能完成远程调用吗？</p><p>当一个服务首次发起远程调用时，会将服务中心返回的实例接口信息缓存下来，定期与服务中心交换这些服务的健康信息。此后再向相同服务发起调用时，会先从本地的缓存中获取对应接口信息，即使服务中心宕机，只要缓存信息有效，仍能完成远程调用。</p><p>若首次发起调用时服务中心就已经宕机，则得不到对应的服务信息，无法完成远程调用。</p></div><h1 id="三openfeign">三、OpenFeign</h1><p>之前利用RestTemplate实现了服务的远程调用，但是远程调用的代码太复杂了，而且这种调用方式，与原本的本地方法调用差异太大，编程时的体验也不统一，一会儿远程调用，一会儿本地调用。</p><p>因此，我们必须想办法改变远程调用的开发模式，让<strong>远程调用像本地方法调用一样简单</strong>。这就要用到<strong>OpenFeign</strong>组件了。</p><p>其实远程调用的关键点就在于四个：</p><ul><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ul><p>所以，OpenFeign就利用SpringMVC的相关注解来声明上述4个参数，然后基于动态代理帮我们生成远程调用的代码，而无需我们手动再编写，非常方便。</p><h2 id="快速入门">3.1、快速入门</h2><h3 id="引入依赖-1">引入依赖</h3><p>在<code>cart-service</code>服务的pom.xml中引入<code>OpenFeign</code>的依赖和<code>loadBalancer</code>依赖：</p><div class="code-wrapper"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!--openFeign--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--负载均衡器--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="启用openfeign">启用OpenFeign</h3><p>在<code>cart-service</code>的<code>CartApplication</code>启动类上添加注解，启动OpenFeign功能：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204221636625-2025-2-422:22:26.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204221636625" style="zoom:67%"></p><h3 id="编写openfeign客户端">编写OpenFeign客户端</h3><p><code>cart-service</code>中，定义一个新的接口，编写Feign客户端：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.hmall.cart.client;

<span class="hljs-keyword">import</span> com.hmall.cart.domain.dto.ItemDTO;
<span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;
<span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestParam;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-meta">@FeignClient(&quot;item-service&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ItemClient</span> &#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 通过item-service服务，根据商品ids查询商品列表</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ids</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@GetMapping(&quot;/items&quot;)</span>
    <span class="hljs-comment">//通过负载均衡获得一个服务实例，取得其ip地址和端口，再拼接上请求路径</span>
    <span class="hljs-comment">//声明请求参数为ids，并且设置返回数据类型为List&lt;ItemDTO&gt;</span>
    List&lt;ItemDTO&gt; <span class="hljs-title function_">getItemsByIds</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;ids&quot;)</span>Collection&lt;Long&gt; ids)</span>;
&#125;</code></pre></div><p>这里只需要声明接口，无需实现方法。接口中的几个关键信息：</p><ul><li><code>@FeignClient("item-service")</code> ：声明服务名称</li><li><code>@GetMapping</code> ：声明请求方式</li><li><code>@GetMapping("/items")</code> ：声明请求路径</li><li><code>@RequestParam("ids") Collection&lt;Long&gt; ids</code> ：声明请求参数</li><li><code>List&lt;ItemDTO&gt;</code> ：返回值类型</li></ul><p>有了上述信息，OpenFeign就可以利用动态代理帮我们实现这个方法，并且向<code>http://item-service/items</code>发送一个<code>GET</code>请求，携带ids为请求参数，并自动将返回值处理为<code>List&lt;ItemDTO&gt;</code>。</p><p>我们只需要直接调用这个方法，即可实现远程调用了。</p><h3 id="使用feignclient">使用FeignClient</h3><p>在<code>cart-service</code>的<code>com.hmall.cart.service.impl.CartServiceImpl</code>中改造代码，直接调用<code>ItemClient</code>的方法：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204222032840-2025-2-422:22:30.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204222032840"><figcaption aria-hidden="true">image-20250204222032840</figcaption></figure><p>feign替我们完成了服务拉取、负载均衡、发送http请求的所有工作。到了这里，我们不再需要RestTemplate了</p><h2 id="抽取feign客端">3.2、抽取Feign客⼾端</h2><p>之后拆分了交易微服务（<code>trade-service</code>），它也需要远程调用<code>item-service</code>中的根据id批量查询商品功能。这个需求与<code>cart-service</code>中是一样的。</p><p>因此，我们就需要在<code>trade-service</code>中再次定义<code>ItemClient</code>接口，这不是重复编码吗？ 有什么办法能加避免重复编码呢？</p><p>避免重复编码的办法就是<strong>抽取</strong>。不过这里有两种抽取思路：</p><ul><li>思路1：抽取到微服务之外的公共module</li><li>思路2：每个微服务自己抽取一个module</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204222611291-2025-2-422:26:12.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204222611291" style="zoom:67%"></p><p>方案1抽取更加简单，工程结构也比较清晰，但缺点是整个项目耦合度偏高。</p><p>方案2抽取相对麻烦，工程结构相对更复杂，但服务之间耦合度降低。</p><p>由于item-service已经创建好，无法继续拆分，因此这里我们采用方案1.</p><p>在 hmall 下定义⼀个新的module，命名为hm-api，然后把ItemDTO和ItemClient都拷⻉过来，最终结构如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204222821911-2025-2-422:28:23.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204222821911" style="zoom:67%"></p><p>现在，<strong>任何微服务要调⽤ item-service 中的接⼝，只需要引⼊ hm-api 模块依赖即可</strong>，⽆需⾃⼰编写Feign客⼾端了。</p><p>在 cart-service 的 pom.xml 中引⼊ hm-api 模块，删除 cart-service 中原来的ItemDTO和ItemClient</p><div class="code-wrapper"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!--feign模块--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hm-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>因为 ItemClient 现在定义到了 com.hmall.api.client 包下，⽽cart-service的启动类定义在 com.hmall.cart 包下，扫描不到 ItemClient 。需要在cart-service的启动类上添加声明，有两种⽅式：</p><ul><li><p>方式1：声明扫描包：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204223136419-2025-2-422:31:55.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204223136419"><figcaption aria-hidden="true">image-20250204223136419</figcaption></figure></li><li><p>方式2：声明要用的FeignClient</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204223153546-2025-2-422:31:56.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204223153546"><figcaption aria-hidden="true">image-20250204223153546</figcaption></figure></li></ul><h2 id="配置连接池">3.3、配置连接池</h2><p>Feign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：</p><ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>我们通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，我们使用OK Http.</p><h3 id="引入依赖-2">引入依赖</h3><p>在<code>cart-service</code>的<code>pom.xml</code>中引入依赖：</p><div class="code-wrapper"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!--OK http 的依赖 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="开启连接池">开启连接池</h3><p>在<code>cart-service</code>的<code>application.yml</code>配置文件中开启Feign的连接池功能：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">feign:</span>
  <span class="hljs-attr">okhttp:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启OKHttp功能</span></code></pre></div><p>重启服务，连接池就生效了。</p><h2 id="日志配置">3.4、日志配置</h2><p>OpenFeign只会在FeignClient所在包的日志级别为<strong>DEBUG</strong>时，才会输出日志。而且其日志级别有4级：</p><ul><li><strong>NONE</strong>：不记录任何日志信息，这是默认值。</li><li><strong>BASIC</strong>：仅记录请求的方法，URL以及响应状态码和执行时间</li><li><strong>HEADERS</strong>：在BASIC的基础上，额外记录了请求和响应的头信息</li><li><strong>FULL</strong>：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><p>Feign默认的日志级别就是NONE，所以默认我们看不到请求日志。</p><h3 id="定义日志级别">定义日志级别</h3><p>在hm-api模块下新建一个配置类，定义Feign的日志级别：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204223617696-2025-2-422:36:18.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204223617696" style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.hmall.api.config;

<span class="hljs-keyword">import</span> feign.Logger;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultFeignConfig</span> &#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> Logger.Level <span class="hljs-title function_">feignLogLevel</span><span class="hljs-params">()</span>&#123;
        <span class="hljs-keyword">return</span> Logger.Level.FULL;
    &#125;
&#125;</code></pre></div><h3 id="配置">配置</h3><p>要让日志级别生效，还需要配置这个类。有两种方式：</p><ul><li><strong>局部</strong>生效：在某个<code>FeignClient</code>中配置，只对当前<code>FeignClient</code>生效</li></ul><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-meta">@FeignClient(value = &quot;item-service&quot;, configuration = DefaultFeignConfig.class)</span></code></pre></div><ul><li><strong>全局</strong>生效：在<code>@EnableFeignClients</code>中配置，针对所有<code>FeignClient</code>生效。</li></ul><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-meta">@EnableFeignClients(defaultConfiguration = DefaultFeignConfig.class)</span></code></pre></div><h1 id="四网关路由">四、网关路由</h1><h2 id="认识网关">4.1、认识网关</h2><p>什么是网关？</p><p>顾明思议，网关就是<strong>网</strong>络的<strong>关</strong>口。数据在网络间传输，从一个网络传输到另一网络时就需要经过网关来做数据的<strong>路由和转发以及数据安全的校验</strong>。</p><p>更通俗的来讲，网关就像是以前园区传达室的大爷。</p><ul><li>外面的人要想进入园区，必须经过大爷的认可，如果你是不怀好意的人，肯定被直接拦截。</li><li>外面的人要传话或送信，要找大爷。大爷帮你带给目标人。</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204224124122-2025-2-422:41:41.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204224124122" style="zoom:80%"></p><p>现在，微服务网关就起到同样的作用。<strong>前端请求不能直接访问微服务，而是要请求网关</strong>：</p><ul><li>网关可以做安全控制，也就是登录身份校验，校验通过才放行</li><li>通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204224217779-2025-2-422:42:18.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204224217779" style="zoom:80%"></p><p>在SpringCloud当中，提供了两种网关实现方案：</p><ul><li>Netflix Zuul：早期实现，目前已经淘汰</li><li>SpringCloudGateway：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强。</li></ul><h2 id="快速入门-1">4.2、快速入门</h2><p>由于网关本身也是一个独立的微服务，因此也需要创建一个模块开发功能。大概步骤如下：</p><ul><li>创建网关微服务</li><li>引入SpringCloudGateway、NacosDiscovery依赖</li><li>编写启动类</li><li>配置网关路由</li></ul><h3 id="创建项目">创建项目</h3><p>在hmall下创建一个新的module，命名为hm-gateway，作为网关微服务：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204224406642-2025-2-422:44:07.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204224406642" style="zoom:67%"></p><h3 id="引入依赖-3">引入依赖</h3><p>在<code>hm-gateway</code>模块的<code>pom.xml</code>文件中引入依赖：</p><div class="code-wrapper"><pre><code class="hljs XML"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hmall<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hm-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-comment">&lt;!--common--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.heima<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hm-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--网关--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--nacos discovery--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--负载均衡--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><h3 id="添加启动类">添加启动类</h3><p>在<code>hm-gateway</code>模块的<code>com.hmall.gateway</code>包下新建一个启动类：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204224530813-2025-2-422:45:32.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204224530813" style="zoom:67%"></p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.hmall.gateway;

<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;

<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewayApplication</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        SpringApplication.run(GatewayApplication.class, args);
    &#125;
&#125;</code></pre></div><h3 id="配置路由">配置路由</h3><p>在<code>hm-gateway</code>模块的<code>resources</code>目录新建一个<code>application.yaml</code>文件，内容如下：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:8848</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">item</span> <span class="hljs-comment"># 路由规则id，自定义，唯一</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://item-service</span> <span class="hljs-comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span>
          <span class="hljs-attr">predicates:</span> <span class="hljs-comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/items/**,/search/**</span> <span class="hljs-comment"># 这里是以请求路径作为判断规则</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">cart</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://cart-service</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/carts/**</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">user</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://user-service</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/users/**,/addresses/**</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">trade</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://trade-service</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/orders/**</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">pay</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://pay-service</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/pay-orders/**</span></code></pre></div><h3 id="测试">测试</h3><p>启动GatewayApplication，以 http://localhost:8080 拼接微服务接口路径来测试。例如：</p><p>http://localhost:8080/items/page?pageNo=1&amp;pageSize=1</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204224842832-2025-2-422:48:48.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204224842832" style="zoom:80%"></p><p>此时，启动UserApplication、CartApplication，然后打开前端页面，发现相关功能都可以正常访问了</p><h2 id="路由过滤">4.3、路由过滤</h2><p>路由规则的定义语法如下：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">item</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://item-service</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/items/**,/search/**</span></code></pre></div><p>其中routes对应的类型如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204225046745-2025-2-422:50:47.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204225046745" style="zoom:80%"></p><p>是一个集合，也就是说可以定义很多路由规则。集合中的<code>RouteDefinition</code>就是具体的路由规则定义，其中常见的属性如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204225120770-2025-2-422:51:21.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204225120770" style="zoom:80%"></p><p>四个属性含义如下：</p><ul><li><code>id</code>：路由的唯一标示</li><li><code>predicates</code>：路由断言，其实就是匹配条件</li><li><code>filters</code>：路由过滤条件，后面讲</li><li><code>uri</code>：路由目标地址，<code>lb://</code>代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。</li></ul><p>这里重点关注<code>predicates</code>，也就是路由断言。SpringCloudGateway中支持的断言类型有很多：</p><table><thead><tr class="header"><th style="text-align:left"><strong>名称</strong></th><th style="text-align:left"><strong>说明</strong></th><th style="text-align:left"><strong>示例</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align:left">After</td><td style="text-align:left">是某个时间点后的请求</td><td style="text-align:left">- After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr class="even"><td style="text-align:left">Before</td><td style="text-align:left">是某个时间点之前的请求</td><td style="text-align:left">- Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr class="odd"><td style="text-align:left">Between</td><td style="text-align:left">是某两个时间点之前的请求</td><td style="text-align:left">- Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr class="even"><td style="text-align:left">Cookie</td><td style="text-align:left">请求必须包含某些cookie</td><td style="text-align:left">- Cookie=chocolate, ch.p</td></tr><tr class="odd"><td style="text-align:left">Header</td><td style="text-align:left">请求必须包含某些header</td><td style="text-align:left">- Header=X-Request-Id,</td></tr><tr class="even"><td style="text-align:left">Host</td><td style="text-align:left">请求必须是访问某个host（域名）</td><td style="text-align:left">- Host=<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr class="odd"><td style="text-align:left">Method</td><td style="text-align:left">请求方式必须是指定方式</td><td style="text-align:left">- Method=GET,POST</td></tr><tr class="even"><td style="text-align:left">Path</td><td style="text-align:left">请求路径必须符合指定规则</td><td style="text-align:left">- Path=/red/{segment},/blue/**</td></tr><tr class="odd"><td style="text-align:left">Query</td><td style="text-align:left">请求参数必须包含指定参数</td><td style="text-align:left">- Query=name, Jack或者- Query=name</td></tr><tr class="even"><td style="text-align:left">RemoteAddr</td><td style="text-align:left">请求者的ip必须是指定范围</td><td style="text-align:left">- RemoteAddr=192.168.1.1/24</td></tr><tr class="odd"><td style="text-align:left">weight</td><td style="text-align:left">权重处理</td><td style="text-align:left"></td></tr></tbody></table><h1 id="五网关登录校验">五、网关登录校验</h1><p>单体架构时我们只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，不再共享数据。也就意味着每个微服务都需要做登录校验，这显然不可取。</p><h2 id="鉴权思路分析">5.1、鉴权思路分析</h2><p>我们的登录是基于JWT来实现的，校验JWT的算法复杂，而且需要用到秘钥。如果每个微服务都去做登录校验，这就存在着两大问题：</p><ul><li>每个微服务都需要知道JWT的秘钥，不安全</li><li>每个微服务重复编写登录校验代码、权限校验代码，麻烦</li></ul><p>既然网关是所有微服务的入口，一切请求都需要先经过网关。我们完全可以把登录校验的工作放到网关去做，这样之前说的问题就解决了：</p><ul><li>只需要在网关和用户服务保存秘钥</li><li>只需要在网关开发登录校验功能</li></ul><p>此时，登录校验的流程如图：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204225509082-2025-2-422:55:54.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204225509082"><figcaption aria-hidden="true">image-20250204225509082</figcaption></figure><p>不过，这里存在几个问题：</p><ul><li>网关路由是配置的，请求转发是Gateway内部代码，我们如何在转发之前做登录校验？</li><li>网关校验JWT之后，如何将用户信息传递给微服务？</li><li>微服务之间也会相互调用，这种调用不经过网关，又该如何传递用户信息？</li></ul><p>这些问题将在接下来一一解决。</p><h2 id="网关过滤器">5.2、网关过滤器</h2><p>登录校验必须在请求转发到微服务之前做，否则就失去了意义。而网关的请求转发是<code>Gateway</code>内部代码实现的，要想在请求转发之前做登录校验，就必须了解<code>Gateway</code>内部工作的基本原理。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204225812687-2025-2-422:58:13.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204225812687" style="zoom:70%"></p><p>如图所示：</p><ol type="1"><li>客户端请求进入网关后由<code>HandlerMapping</code>对请求做判断，找到与当前请求匹配的路由规则（<strong><code>Route</code></strong>），然后将请求交给<code>WebHandler</code>去处理。</li><li><code>WebHandler</code>则会加载当前路由下需要执行的过滤器链（<strong><code>Filter chain</code></strong>），然后按照顺序逐一执行过滤器（后面称为<strong><code>Filter</code></strong>）。</li><li>图中<code>Filter</code>被虚线分为左右两部分，是因为<code>Filter</code>内部的逻辑分为<code>pre</code>和<code>post</code>两部分，分别会在请求路由到微服务<strong>之前</strong>和<strong>之后</strong>被执行。</li><li>只有所有<code>Filter</code>的<code>pre</code>逻辑都依次顺序执行通过后，请求才会被路由到微服务。</li><li>微服务返回结果后，再倒序执行<code>Filter</code>的<code>post</code>逻辑。</li><li>最终把响应结果返回。</li></ol><p>如图中所示，最终请求转发是有一个名为<code>NettyRoutingFilter</code>的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。<strong>如果我们能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到<code>NettyRoutingFilter</code>之前</strong>，这就符合我们的需求了！</p><p>那么，该如何实现一个网关过滤器呢？</p><p>网关过滤器链中的过滤器有两种：</p><ul><li><strong><code>GatewayFilter</code></strong>：路由过滤器，作用范围比较灵活，可以是任意指定的路由<code>Route</code>.</li><li><strong><code>GlobalFilter</code></strong>：全局过滤器，作用范围是所有路由，不可配置。</li></ul><blockquote><p><strong>注意</strong>：过滤器链之外还有一种过滤器，HttpHeadersFilter，用来处理传递到下游微服务的请求头。例如org.springframework.cloud.gateway.filter.headers.XForwardedHeadersFilter可以传递代理请求原本的host头到下游微服务</p></blockquote><p>其实<code>GatewayFilter</code>和<code>GlobalFilter</code>这两种过滤器的方法签名完全一致：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 处理请求并将其传递给下一个过滤器</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> exchange 当前请求的上下文，其中包含request、response等各种数据</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> chain 过滤器链，基于它向下传递请求</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 根据返回值标记当前请求是否被完成或拦截，chain.filter(exchange)就放行了。</span>
<span class="hljs-comment"> */</span>
Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span>;</code></pre></div><p><code>FilteringWebHandler</code>在处理请求时，会将<code>GlobalFilter</code>装饰为<code>GatewayFilter</code>，然后放到同一个过滤器链中，排序以后依次执行。</p><p><code>Gateway</code>内置的<code>GatewayFilter</code>过滤器使用起来非常简单，无需编码，只要在yaml文件中简单配置即可。而且其作用范围也很灵活，配置在哪个<code>Route</code>下，就作用于哪个<code>Route</code>.</p><p>例如，有一个过滤器叫做<code>AddRequestHeaderGatewayFilterFacotry</code>，顾明思议，就是添加请求头的过滤器，可以给请求添加一个请求头并传递到下游微服务。</p><p>使用的使用只需要在application.yaml中这样配置：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">test_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://test-service</span>
        <span class="hljs-attr">predicates:</span>
          <span class="hljs-string">-Path=/test/**</span>
        <span class="hljs-attr">filters:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=key,</span> <span class="hljs-string">value</span> <span class="hljs-comment"># 逗号之前是请求头的key，逗号之后是value</span></code></pre></div><p>如果想要让过滤器作用于所有的路由，则可以这样配置：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">default-filters:</span> <span class="hljs-comment"># default-filters下的过滤器可以作用于所有路由</span>
        <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=key,</span> <span class="hljs-string">value</span>
      <span class="hljs-attr">routes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">test_route</span>
        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://test-service</span>
        <span class="hljs-attr">predicates:</span>
          <span class="hljs-string">-Path=/test/**</span></code></pre></div><h2 id="自定义过滤器">5.3、自定义过滤器</h2><p>无论是<code>GatewayFilter</code>还是<code>GlobalFilter</code>都支持自定义，只不过<strong>编码</strong>方式、<strong>使用</strong>方式略有差别。</p><h3 id="自定义gatewayfilter">自定义GatewayFilter</h3><p>自定义<code>GatewayFilter</code>不是直接实现<code>GatewayFilter</code>，而是实现<code>AbstractGatewayFilterFactory</code>。最简单的方式是这样的：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintAnyGatewayFilterFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractGatewayFilterFactory</span>&lt;Object&gt; &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> GatewayFilter <span class="hljs-title function_">apply</span><span class="hljs-params">(Object config)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayFilter</span>() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;
                <span class="hljs-comment">// 获取请求</span>
                <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();
                <span class="hljs-comment">// 编写过滤器逻辑</span>
                System.out.println(<span class="hljs-string">&quot;过滤器执行了&quot;</span>);
                <span class="hljs-comment">// 放行</span>
                <span class="hljs-keyword">return</span> chain.filter(exchange);
            &#125;
        &#125;;
    &#125;
&#125;</code></pre></div><blockquote><p><strong>注意</strong>：该类的名称一定要以<code>GatewayFilterFactory</code>为后缀！</p></blockquote><p>然后在yaml配置中这样使用：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">default-filters:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">PrintAny</span> <span class="hljs-comment"># 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</span></code></pre></div><p>另外，这种过滤器还可以支持动态配置参数，不过实现起来比较复杂，示例：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintAnyGatewayFilterFactory</span> <span class="hljs-comment">// 父类泛型是内部类的Config类型</span>
                <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractGatewayFilterFactory</span>&lt;PrintAnyGatewayFilterFactory.Config&gt; &#123;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> GatewayFilter <span class="hljs-title function_">apply</span><span class="hljs-params">(Config config)</span> &#123;
        <span class="hljs-comment">// OrderedGatewayFilter是GatewayFilter的子类，包含两个参数：</span>
        <span class="hljs-comment">// - GatewayFilter：过滤器</span>
        <span class="hljs-comment">// - int order值：值越小，过滤器执行优先级越高</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderedGatewayFilter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GatewayFilter</span>() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;
                <span class="hljs-comment">// 获取config值</span>
                <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> config.getA();
                <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> config.getB();
                <span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> config.getC();
                <span class="hljs-comment">// 编写过滤器逻辑</span>
                System.out.println(<span class="hljs-string">&quot;a = &quot;</span> + a);
                System.out.println(<span class="hljs-string">&quot;b = &quot;</span> + b);
                System.out.println(<span class="hljs-string">&quot;c = &quot;</span> + c);
                <span class="hljs-comment">// 放行</span>
                <span class="hljs-keyword">return</span> chain.filter(exchange);
            &#125;
        &#125;, <span class="hljs-number">100</span>);
    &#125;

    <span class="hljs-comment">// 自定义配置属性，成员变量名称很重要，下面会用到</span>
    <span class="hljs-meta">@Data</span>
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>&#123;
        <span class="hljs-keyword">private</span> String a;
        <span class="hljs-keyword">private</span> String b;
        <span class="hljs-keyword">private</span> String c;
    &#125;
    <span class="hljs-comment">// 将变量名称依次返回，顺序很重要，将来读取参数时需要按顺序获取</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">shortcutFieldOrder</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> List.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);
    &#125;
        <span class="hljs-comment">// 返回当前配置类的类型，也就是内部的Config</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Class&lt;Config&gt; <span class="hljs-title function_">getConfigClass</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> Config.class;
    &#125;

&#125;</code></pre></div><p>然后在yaml文件中使用：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">default-filters:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">PrintAny=1,2,3</span> <span class="hljs-comment"># 注意，这里多个参数以&quot;,&quot;隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制</span></code></pre></div><p>上面这种配置方式参数必须严格按照shortcutFieldOrder()方法的返回参数名顺序来赋值。</p><p>还有一种用法，无需按照这个顺序，就是手动指定参数名：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">default-filters:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">PrintAny</span>
              <span class="hljs-attr">args:</span> <span class="hljs-comment"># 手动指定参数名，无需按照参数顺序</span>
                <span class="hljs-attr">a:</span> <span class="hljs-number">1</span>
                <span class="hljs-attr">b:</span> <span class="hljs-number">2</span>
                <span class="hljs-attr">c:</span> <span class="hljs-number">3</span></code></pre></div><h3 id="自定义globalfilter">自定义GlobalFilter</h3><p>自定义GlobalFilter则简单很多，直接实现GlobalFilter即可，而且也无法设置动态参数：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintAnyGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;
        <span class="hljs-comment">// 编写过滤器逻辑</span>
        System.out.println(<span class="hljs-string">&quot;未登录，无法访问&quot;</span>);
        <span class="hljs-comment">// 放行</span>
        <span class="hljs-comment">// return chain.filter(exchange);</span>

        <span class="hljs-comment">// 拦截</span>
        <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();
        response.setRawStatusCode(<span class="hljs-number">401</span>);
        <span class="hljs-keyword">return</span> response.setComplete();
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-comment">// 过滤器执行顺序，值越小，优先级越高</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
&#125;</code></pre></div><h2 id="登录校验">5.4、登录校验</h2><p>利用自定义<code>GlobalFilter</code>来完成登录校验。</p><h3 id="jwt工具">JWT工具</h3><p>登录校验需要用到JWT，而且JWT的加密需要秘钥和加密工具。这些在<code>hm-service</code>中已经有了，我们直接拷贝过来：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204230713436-2025-2-423:07:34.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204230713436"><figcaption aria-hidden="true">image-20250204230713436</figcaption></figure><p>具体作用如下：</p><ul><li><code>AuthProperties</code>：配置登录校验需要拦截的路径，因为不是所有的路径都需要登录才能访问</li><li><code>JwtProperties</code>：定义与JWT工具有关的属性，比如秘钥文件位置</li><li><code>SecurityConfig</code>：工具的自动装配</li><li><code>JwtTool</code>：JWT工具，其中包含了校验和解析<code>token</code>的功能</li><li><code>hmall.jks</code>：秘钥文件</li></ul><p>其中<code>AuthProperties</code>和<code>JwtProperties</code>所需的属性要在<code>application.yaml</code>中配置：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">hm:</span>
  <span class="hljs-attr">jwt:</span>
    <span class="hljs-attr">location:</span> <span class="hljs-string">classpath:hmall.jks</span> <span class="hljs-comment"># 秘钥地址</span>
    <span class="hljs-attr">alias:</span> <span class="hljs-string">hmall</span> <span class="hljs-comment"># 秘钥别名</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">hmall123</span> <span class="hljs-comment"># 秘钥文件密码</span>
    <span class="hljs-attr">tokenTTL:</span> <span class="hljs-string">30m</span> <span class="hljs-comment"># 登录有效期</span>
  <span class="hljs-attr">auth:</span>
    <span class="hljs-attr">excludePaths:</span> <span class="hljs-comment"># 无需登录校验的路径</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/search/**</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/users/login</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/items/**</span></code></pre></div><h3 id="登录校验过滤器">登录校验过滤器</h3><p>接下来，我们定义一个登录校验的过滤器：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204230850859-2025-2-423:08:52.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204230850859" style="zoom:80%"></p><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.hmall.gateway.filter;

<span class="hljs-keyword">import</span> com.hmall.common.exception.UnauthorizedException;
<span class="hljs-keyword">import</span> com.hmall.common.utils.CollUtils;
<span class="hljs-keyword">import</span> com.hmall.gateway.config.AuthProperties;
<span class="hljs-keyword">import</span> com.hmall.gateway.util.JwtTool;
<span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;
<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;
<span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;
<span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;
<span class="hljs-keyword">import</span> org.springframework.core.Ordered;
<span class="hljs-keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;
<span class="hljs-keyword">import</span> org.springframework.http.server.reactive.ServerHttpResponse;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> org.springframework.util.AntPathMatcher;
<span class="hljs-keyword">import</span> org.springframework.web.server.ServerWebExchange;
<span class="hljs-keyword">import</span> reactor.core.publisher.Mono;

<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-meta">@EnableConfigurationProperties(AuthProperties.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthGlobalFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JwtTool jwtTool;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AuthProperties authProperties;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AntPathMatcher</span> <span class="hljs-variable">antPathMatcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntPathMatcher</span>();

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;
        <span class="hljs-comment">// 1.获取Request</span>
        <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();
        <span class="hljs-comment">// 2.判断是否不需要拦截</span>
        <span class="hljs-keyword">if</span>(isExclude(request.getPath().toString()))&#123;
            <span class="hljs-comment">// 无需拦截，直接放行</span>
            <span class="hljs-keyword">return</span> chain.filter(exchange);
        &#125;
        <span class="hljs-comment">// 3.获取请求头中的token</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        List&lt;String&gt; headers = request.getHeaders().get(<span class="hljs-string">&quot;authorization&quot;</span>);
        <span class="hljs-keyword">if</span> (!CollUtils.isEmpty(headers)) &#123;
            token = headers.get(<span class="hljs-number">0</span>);
        &#125;
        <span class="hljs-comment">// 4.校验并解析token</span>
        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">try</span> &#123;
            userId = jwtTool.parseToken(token);
        &#125; <span class="hljs-keyword">catch</span> (UnauthorizedException e) &#123;
            <span class="hljs-comment">// 如果无效，拦截</span>
            <span class="hljs-type">ServerHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> exchange.getResponse();
            response.setRawStatusCode(<span class="hljs-number">401</span>);
            <span class="hljs-keyword">return</span> response.setComplete();
        &#125;

        <span class="hljs-comment">// TODO 5.如果有效，传递用户信息</span>
        System.out.println(<span class="hljs-string">&quot;userId = &quot;</span> + userId);
        <span class="hljs-comment">// 6.放行</span>
        <span class="hljs-keyword">return</span> chain.filter(exchange);
    &#125;

    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isExclude</span><span class="hljs-params">(String antPath)</span> &#123;
        <span class="hljs-keyword">for</span> (String pathPattern : authProperties.getExcludePaths()) &#123;
            <span class="hljs-keyword">if</span>(antPathMatcher.match(pathPattern, antPath))&#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
&#125;</code></pre></div><p>重启测试，会发现访问/items开头的路径，未登录状态下不会被拦截。访问其他路径则，未登录状态下请求会被拦截，并且返回<code>401</code>状态码。</p><h2 id="微服务获取用户">5.5、微服务获取用户</h2><p>现在，网关已经可以完成登录校验并获取登录用户身份信息。但是当网关将请求转发到微服务时，微服务又该如何获取用户身份呢？</p><p>由于网关发送请求到微服务依然采用的是<code>Http</code>请求，因此我们可以将用户信息以请求头的方式传递到下游微服务。然后微服务可以从请求头中获取登录用户信息。考虑到微服务内部可能很多地方都需要用到登录用户信息，因此我们可以利用SpringMVC的拦截器来实现登录用户信息获取，并存入ThreadLocal，方便后续使用。</p><p>处理流程如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204231322595-2025-2-423:13:25.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204231322595" style="zoom:80%"></p><p>因此，接下来我们要做的事情有：</p><ul><li>改造网关过滤器，在获取用户信息后保存到请求头，转发到下游微服务</li><li>编写微服务拦截器，拦截请求获取用户信息，保存到ThreadLocal后放行</li></ul><h3 id="保存用户到请求头">保存用户到请求头</h3><p>首先，我们修改登录校验拦截器的处理逻辑，保存用户信息到请求头中：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204231454706-2025-2-423:14:55.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204231454706"><figcaption aria-hidden="true">image-20250204231454706</figcaption></figure><h3 id="拦截器获取用户">拦截器获取用户</h3><p>在hm-common中已经有一个用于保存登录用户的ThreadLocal工具，其中已经提供了保存和获取用户的方法：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204231715841-2025-2-423:17:17.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204231715841"><figcaption aria-hidden="true">image-20250204231715841</figcaption></figure><p>接下来，我们只需要编写拦截器，获取用户信息并保存到<code>UserContext</code>，然后放行即可。</p><p>由于每个微服务都有获取登录用户的需求，因此拦截器我们直接写在<code>hm-common</code>中，并写好自动装配。这样微服务只需要引入<code>hm-common</code>就可以直接具备拦截器功能，无需重复编写。</p><p>在<code>hm-common</code>模块下定义一个拦截器：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204231841138-2025-2-423:18:47.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204231841138" style="zoom:80%"></p><p>具体代码如下：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.hmall.common.interceptor;

<span class="hljs-keyword">import</span> cn.hutool.core.util.StrUtil;
<span class="hljs-keyword">import</span> com.hmall.common.utils.UserContext;
<span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;

<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfoInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;
        <span class="hljs-comment">// 1.获取请求头中的用户信息</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;user-info&quot;</span>);
        <span class="hljs-comment">// 2.判断是否为空</span>
        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(userInfo)) &#123;
            <span class="hljs-comment">// 不为空，保存到ThreadLocal</span>
                UserContext.setUser(Long.valueOf(userInfo));
        &#125;
        <span class="hljs-comment">// 3.放行</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;
        <span class="hljs-comment">// 移除用户</span>
        UserContext.removeUser();
    &#125;
&#125;</code></pre></div><p>接着在<code>hm-common</code>模块下编写<code>SpringMVC</code>的配置类，配置登录拦截器：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204231943536-2025-2-423:19:44.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204231943536" style="zoom:80%"></p><p>具体代码如下：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.hmall.common.config;

<span class="hljs-keyword">import</span> com.hmall.common.interceptors.UserInfoInterceptor;
<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="hljs-keyword">import</span> org.springframework.web.servlet.DispatcherServlet;
<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;
<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@ConditionalOnClass(DispatcherServlet.class)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;
        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserInfoInterceptor</span>());
    &#125;
&#125;</code></pre></div><blockquote><p>不过，需要注意的是，这个配置类默认是不会生效的，因为它所在的包是com.hmall.common.config，与其它微服务的扫描包不一致，无法被扫描到，因此无法生效。 基于SpringBoot的自动装配原理，我们要将其添加到resources目录下的META-INF/spring.factories文件中：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204232123922-2025-2-423:21:25.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204232123922" style="zoom:72%"></p><p>内容如下：</p><div class="code-wrapper"><pre><code class="hljs Properties"><span class="hljs-attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span>
<span class="hljs-string">  com.hmall.common.config.MyBatisConfig,\</span>
<span class="hljs-string">  com.hmall.common.config.MvcConfig</span></code></pre></div></blockquote><h2 id="openfeign传递用户">5.6、OpenFeign传递用户</h2><p>前端发起的请求都会经过网关再到微服务，由于我们之前编写的过滤器和拦截器功能，微服务可以轻松获取登录用户信息。</p><p>但有些业务是比较复杂的，请求到达微服务后还需要调用其它多个微服务。比如下单业务，流程如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204232321363-2025-2-423:23:22.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204232321363" style="zoom:80%"></p><p>下单的过程中，需要调用商品服务扣减库存，调用购物车服务清理用户购物车。而清理购物车时必须知道当前登录的用户身份。但是，<strong>订单服务调用购物车时并没有传递用户信息</strong>，购物车服务无法知道当前用户是谁！</p><p>由于微服务获取用户信息是通过拦截器在请求头中读取，因此要想实现微服务之间的用户信息传递，就<strong>必须在微服务发起调用时把用户信息存入请求头</strong>。</p><p>微服务之间调用是基于OpenFeign来实现的，并不是我们自己发送的请求。我们如何才能让每一个由OpenFeign发起的请求自动携带登录用户信息呢？</p><p>这里要借助Feign中提供的一个拦截器接口：<code>feign.RequestInterceptor</code></p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RequestInterceptor</span> &#123;

  <span class="hljs-comment">/**</span>
<span class="hljs-comment">   * Called for every request. </span>
<span class="hljs-comment">   * Add data using methods on the supplied &#123;<span class="hljs-doctag">@link</span> RequestTemplate&#125;.</span>
<span class="hljs-comment">   */</span>
  <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(RequestTemplate template)</span>;
&#125;</code></pre></div><p>我们只需要实现这个接口，然后实现apply方法，利用<code>RequestTemplate</code>类来添加请求头，将用户信息保存到请求头中。这样以来，每次OpenFeign发起请求的时候都会调用该方法，传递用户信息。</p><p>在<code>hm-api</code>模块的<code>com.hmall.api.config.DefaultFeignConfig</code>中编写这个拦截器：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204232548649-2025-2-423:25:57.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204232548649" style="zoom:80%"></p><p>在<code>com.hmall.api.config.DefaultFeignConfig</code>中添加一个Bean：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> RequestInterceptor <span class="hljs-title function_">userInfoRequestInterceptor</span><span class="hljs-params">()</span>&#123;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestInterceptor</span>() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(RequestTemplate template)</span> &#123;
            <span class="hljs-comment">// 获取登录用户</span>
            <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserContext.getUser();
            <span class="hljs-keyword">if</span>(userId == <span class="hljs-literal">null</span>) &#123;
                <span class="hljs-comment">// 如果为空则直接跳过</span>
                <span class="hljs-keyword">return</span>;
            &#125;
            <span class="hljs-comment">// 如果不为空则放入请求头中，传递给下游微服务</span>
            template.header(<span class="hljs-string">&quot;user-info&quot;</span>, userId.toString());
        &#125;
    &#125;;
&#125;</code></pre></div><p>现在微服务之间通过OpenFeign调用时也会传递登录用户信息了。（其实就是拦截下来OpenFeign的转发请求，然后再请求头中添加上user-info字段后放行）</p><h1 id="六配置管理">六、配置管理</h1><p>到目前为止我们已经解决了微服务相关的几个问题：</p><ul><li>微服务远程调用</li><li>微服务注册、发现</li><li>微服务请求路由、负载均衡</li><li>微服务登录用户信息传递</li></ul><p>不过，现在依然还有几个问题需要解决：</p><ul><li>网关路由在配置文件中写死了，如果变更必须重启微服务</li><li>某些业务配置在配置文件中写死了，每次修改都要重启服务</li><li>每个微服务都有很多重复的配置，维护成本高</li></ul><p>这些问题都可以通过统一的<strong>配置管理器服务</strong>解决。而Nacos不仅仅具备注册中心功能，也具备配置管理的功能：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204232913465-2025-2-423:29:14.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204232913465" style="zoom:80%"></p><p>微服务共享的配置可以统一交给Nacos保存和管理，在Nacos控制台修改配置后，Nacos会将配置变更推送给相关的微服务，并且无需重启即可生效，实现配置热更新。</p><p>网关的路由同样是配置，因此同样可以基于这个功能实现动态路由功能，无需重启网关即可修改路由配置。</p><div class="note note-warning"><p>当本地配置文件内容和Nacos中的配置相同时哪个生效？若从Nacos中导入多个配置文件，其中有的配置重复，哪个生效？</p><p>遵守一个原则：外部优先，先导入优先。</p><p>当本地配置与Nacos配置冲突时，以外部导入的Nacos配置为准；当多个配置文件中的配置冲突时，以先导入的配置为准。</p></div><h2 id="配置共享">6.1、配置共享</h2><p>我们可以把微服务共享的配置抽取到Nacos中统一管理，这样就不需要每个微服务都重复配置了。分为两步：</p><ul><li>在Nacos中添加共享配置</li><li>微服务拉取配置</li></ul><h3 id="添加共享配置">添加共享配置</h3><p>以cart-service为例，我们看看有哪些配置是重复的，可以抽取的：</p><p>首先是jdbc相关配置：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233045536-2025-2-423:30:46.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204233045536" style="zoom:80%"></p><p>然后是日志配置：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233111051-2025-2-423:31:12.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204233111051" style="zoom:80%"></p><p>然后是swagger以及OpenFeign的配置：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233147280-2025-2-423:31:48.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204233147280" style="zoom:80%"></p><p>在nacos控制台分别添加这些配置，首先是jdbc相关配置，在<code>配置管理</code>-&gt;<code>配置列表</code>中点击<code>+</code>新建一个配置：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233329924-2025-2-423:33:30.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204233329924" style="zoom:80%"></p><p>在弹出的表单中填写信息：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233423314-2025-2-423:34:42.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204233423314" style="zoom:80%"></p><p>其中详细的配置如下：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://$&#123;hm.db.host:192.168.150.101&#125;:$&#123;hm.db.port:3306&#125;/$&#123;hm.db.database&#125;?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">$&#123;hm.db.un:root&#125;</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">$&#123;hm.db.pw:123&#125;</span>
<span class="hljs-attr">mybatis-plus:</span>
  <span class="hljs-attr">configuration:</span>
    <span class="hljs-attr">default-enum-type-handler:</span> <span class="hljs-string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span>
  <span class="hljs-attr">global-config:</span>
    <span class="hljs-attr">db-config:</span>
      <span class="hljs-attr">update-strategy:</span> <span class="hljs-string">not_null</span>
      <span class="hljs-attr">id-type:</span> <span class="hljs-string">auto</span></code></pre></div><p>注意这里的jdbc的相关参数并没有写死，例如：</p><ul><li><code>数据库ip</code>：通过<code>$&#123;hm.db.host:192.168.150.101&#125;</code>配置了默认值为<code>192.168.150.101</code>，同时允许通过<code>$&#123;hm.db.host&#125;</code>来覆盖默认值</li><li><code>数据库端口</code>：通过<code>$&#123;hm.db.port:3306&#125;</code>配置了默认值为<code>3306</code>，同时允许通过<code>$&#123;hm.db.port&#125;</code>来覆盖默认值</li><li><code>数据库database</code>：可以通过<code>$&#123;hm.db.database&#125;</code>来设定，无默认值</li></ul><p>然后是统一的日志配置，命名为<code>shared-log.yaml</code>，配置内容如下：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">logging:</span>
  <span class="hljs-attr">level:</span>
    <span class="hljs-attr">com.hmall:</span> <span class="hljs-string">debug</span>
  <span class="hljs-attr">pattern:</span>
    <span class="hljs-attr">dateformat:</span> <span class="hljs-string">HH:mm:ss:SSS</span>
  <span class="hljs-attr">file:</span>
    <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;logs/$&#123;spring.application.name&#125;&quot;</span></code></pre></div><p>然后是统一的swagger配置，命名为<code>shared-swagger.yaml</code>，配置内容如下：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">knife4j:</span>
  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>
  <span class="hljs-attr">openapi:</span>
    <span class="hljs-attr">title:</span> <span class="hljs-string">$&#123;hm.swagger.title:黑马商城接口文档&#125;</span>
    <span class="hljs-attr">description:</span> <span class="hljs-string">$&#123;hm.swagger.description:黑马商城接口文档&#125;</span>
    <span class="hljs-attr">email:</span> <span class="hljs-string">$&#123;hm.swagger.email:zhanghuyi@itcast.cn&#125;</span>
    <span class="hljs-attr">concat:</span> <span class="hljs-string">$&#123;hm.swagger.concat:虎哥&#125;</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">https://www.itcast.cn</span>
    <span class="hljs-attr">version:</span> <span class="hljs-string">v1.0.0</span>
    <span class="hljs-attr">group:</span>
      <span class="hljs-attr">default:</span>
        <span class="hljs-attr">group-name:</span> <span class="hljs-string">default</span>
        <span class="hljs-attr">api-rule:</span> <span class="hljs-string">package</span>
        <span class="hljs-attr">api-rule-resources:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-string">$&#123;hm.swagger.package&#125;</span></code></pre></div><p>注意，这里的swagger相关配置我们没有写死，例如：</p><ul><li><code>title</code>：接口文档标题，我们用了<code>$&#123;hm.swagger.title&#125;</code>来代替，将来可以用由户手动指定</li><li><code>email</code>：联系人邮箱，我们用了<code>$&#123;hm.swagger.email:``zhanghuyi@itcast.cn``&#125;</code>，默认值是<code>zhanghuyi@itcast.cn</code>，同时允许用户利用<code>$&#123;hm.swagger.email&#125;</code>来覆盖。</li></ul><h3 id="拉取共享配置">拉取共享配置</h3><div class="note note-info"><p>更新：springboot &gt;= 2.4.0版本，已经不使用bootstrap.yml作为启动配置文件了，参考：<a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/issues/2905">#2905</a>，确有必要时，需主动加入依赖spring-cloud-starter-bootstrap包。</p><p>Nacos也支持使用<code>spring.config.import</code>直接导入配置文件</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">config:</span>
    <span class="hljs-attr">import:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">nacos:xxxx.yaml?group=&quot;分组&quot;</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">nacos:xxxx.yaml?group=&quot;分组&quot;</span></code></pre></div><p>或者</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">spring.config.import[0]</span>=<span class="hljs-string">nacos:springclouddemo2023x.properties?group=DEFAULT_GROUP</span>
<span class="hljs-attr">spring.config.import[1]</span>=<span class="hljs-string">nacos:&#123;dataId1&#125;?group=&#123;group1&#125;</span>
<span class="hljs-attr">spring.config.import[2]</span>=<span class="hljs-string">nacos:&#123;dataId2&#125;?group=&#123;group2&#125;</span></code></pre></div><p><a target="_blank" rel="noopener" href="https://nacos.io/docs/v2.5/ecology/use-nacos-with-spring-cloud/#_top">参考</a></p></div><p>接下来，我们要在微服务拉取共享配置。将拉取到的共享配置与本地的<code>application.yaml</code>配置合并，完成项目上下文的初始化。</p><p>不过，需要注意的是，读取Nacos配置是SpringCloud上下文（<code>ApplicationContext</code>）初始化时处理的，发生在项目的引导阶段。然后才会初始化SpringBoot上下文，去读取<code>application.yaml</code>。</p><p>也就是说引导阶段，<code>application.yaml</code>文件尚未读取，根本不知道nacos 地址，该如何去加载nacos中的配置文件呢？</p><p>SpringCloud在初始化上下文的时候会先读取一个名为<code>bootstrap.yaml</code>(或者<code>bootstrap.properties</code>)的文件，如果我们将nacos地址配置到<code>bootstrap.yaml</code>中，那么在项目引导阶段就可以读取nacos中的配置了。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250204233717814-2025-2-423:37:18.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250204233717814" style="zoom:80%"></p><p>因此，微服务整合Nacos配置管理的步骤如下，以cart-service微服务为例：</p><p>1）引入依赖：</p><p>在cart-service模块引入依赖：</p><div class="code-wrapper"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!--nacos配置管理--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--读取bootstrap文件--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2）新建bootstrap.yaml</p><p>在cart-service中的resources目录新建一个bootstrap.yaml文件：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205101329880-2025-2-510:13:55.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205101329880" style="zoom:80%"></p><p>内容如下：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">cart-service</span> <span class="hljs-comment"># 服务名称</span>
  <span class="hljs-attr">profiles:</span>
    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span> <span class="hljs-comment"># nacos地址</span>
      <span class="hljs-attr">config:</span>
        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span>
        <span class="hljs-attr">shared-configs:</span> <span class="hljs-comment"># 共享配置</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-jdbc.yaml</span> <span class="hljs-comment"># 共享mybatis配置</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-log.yaml</span> <span class="hljs-comment"># 共享日志配置</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-swagger.yaml</span> <span class="hljs-comment"># 共享日志配置</span></code></pre></div><p>3）修改application.yaml</p><p>由于一些配置挪到了bootstrap.yaml，因此application.yaml需要修改为：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8082</span>
<span class="hljs-attr">feign:</span>
  <span class="hljs-attr">okhttp:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启OKHttp连接池支持</span>
<span class="hljs-attr">hm:</span>
  <span class="hljs-attr">swagger:</span>
    <span class="hljs-attr">title:</span> <span class="hljs-string">购物车服务接口文档</span>
    <span class="hljs-attr">package:</span> <span class="hljs-string">com.hmall.cart.controller</span>
  <span class="hljs-attr">db:</span>
    <span class="hljs-attr">database:</span> <span class="hljs-string">hm-cart</span></code></pre></div><p>重启服务，发现所有配置都生效了。</p><h2 id="配置热更新">6.2、配置热更新</h2><p>有很多的业务相关参数，将来可能会根据实际情况临时调整。例如购物车业务，购物车数量有一个上限，默认是10。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205101710519-2025-2-510:17:11.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205101710519"><figcaption aria-hidden="true">image-20250205101710519</figcaption></figure><p>现在这里购物车是写死的固定值，我们应该将其配置在配置文件中，方便后期修改。</p><p>但现在的问题是，即便写在配置文件中，修改了配置还是需要重新打包、重启服务才能生效。能不能不用重启，直接生效呢？</p><p>这就要用到Nacos的配置热更新能力了，分为两步：</p><ul><li>在Nacos中添加配置</li><li>在微服务读取配置</li></ul><h3 id="添加配置到nacos">添加配置到Nacos</h3><p>首先，我们在nacos中添加一个配置文件，将购物车的上限数量添加到配置中：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205101836988-2025-2-510:18:38.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205101836988" style="zoom:80%"></p><p>注意文件的dataId格式：</p><div class="code-wrapper"><pre><code class="hljs Plain">[服务名]-[spring.active.profile].[后缀名]</code></pre></div><p>文件名称由三部分组成：</p><ul><li><strong><code>服务名</code></strong>：当前是购物车服务，所以是<code>cart-service</code></li><li><strong><code>spring.active.profile</code></strong>：就是spring boot中的<code>spring.active.profile</code>，可以省略，则所有profile共享该配置</li><li><strong><code>后缀名</code></strong>：例如yaml</li></ul><p>这里我们直接使用<code>cart-service.yaml</code>这个名称，则不管是dev还是local环境都可以共享该配置。</p><p>配置内容如下：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">hm:</span>
  <span class="hljs-attr">cart:</span>
    <span class="hljs-attr">maxAmount:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 购物车商品数量上限</span></code></pre></div><h3 id="配置热更新-1">配置热更新</h3><p>接着，我们在微服务中读取配置，实现配置热更新。</p><p>在<code>cart-service</code>中新建一个属性读取类：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205102028361-2025-2-510:20:31.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205102028361" style="zoom:80%"></p><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.hmall.cart.config;

<span class="hljs-keyword">import</span> lombok.Data;
<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;

<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@ConfigurationProperties(prefix = &quot;hm.cart&quot;)</span>  <span class="hljs-comment">//配置批量绑定</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CartProperties</span> &#123;
    <span class="hljs-keyword">private</span> Integer maxAmount;
&#125;</code></pre></div><p>接着，在业务中使用该属性加载类：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205102151605-2025-2-510:22:12.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205102151605" style="zoom:80%"></p><h3 id="测试-1">测试</h3><p>测试，向购物车中添加多个商品：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205102318787-2025-2-510:23:19.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205102318787" style="zoom:80%"></p><p>我们在nacos控制台，将购物车上限配置为5：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205102409302-2025-2-510:24:10.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205102409302" style="zoom:80%"></p><p>无需重启，再次测试购物车功能：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205102440893-2025-2-510:24:42.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205102440893"><figcaption aria-hidden="true">image-20250205102440893</figcaption></figure><p>加入成功！</p><p>无需重启服务，配置热更新就生效了！</p><h2 id="数据隔离">6.3、数据隔离</h2><p>需求描述：</p><ul><li>项目有多套环境：dev，test，prod</li><li>每个微服务，同一种配置，在每套环境的值都不一样。<ul><li>如：datbase.properties</li><li>如：common.properties·</li></ul></li><li>项目可以通过切换环境，加载本环境的配置</li></ul><p>那么如何区分多套环境、多种微服务、多种配置呢？</p><p>Nacos中的命名空间可以用来区分各种环境；每个命名空间中可以定义多个组，可以用来区分多个微服务；每个组中可以存在多个配置文件，作为该微服务的各种配置。</p><p><img src="https://gitee.com/cmyk359/img/raw/c63a587dec6aad303020e9c189bd2b1b9544518b/img/image-20250708211528653-2025-7-821:15:30.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>比如：对应订单微服务，总共有三个环境：dev、test、prod，在不同环境中导入的配置文件也不同。具体配置如下：使用<code>profiles.active</code>指定当前所处的环境，连接Nacos配置中心时引用该配置的值，进入对应的命名空间（环境）。写三套配置，使用<code>activate.on-profile</code>指定当前配置在哪个环境下生效。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">profiles:</span>
    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span>  <span class="hljs-comment">#指定当前环境</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">service-order</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.181</span><span class="hljs-number">.100</span><span class="hljs-string">:8848</span>
      <span class="hljs-attr">config:</span>
        <span class="hljs-attr">namespace:</span> <span class="hljs-string">$&#123;spring.profiles.active:public&#125;</span>

<span class="hljs-meta">---</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">config:</span>
    <span class="hljs-attr">import:</span>
      <span class="hljs-comment">##导入order分组（order微服务）的相关配置文件</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">nacos:shared-jdbc.yaml?group=order</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">nacos:shared-common.yaml?group=order</span>
    <span class="hljs-attr">activate:</span>
      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">dev</span> <span class="hljs-comment"># dev环境下生效</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">config:</span>
    <span class="hljs-attr">import:</span>
      <span class="hljs-comment">##导入order分组（order微服务）的相关配置文件</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">nacos:shared-jdbc.yaml?group=order</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">nacos:shared-common.yaml?group=order</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">nacos:service-order.yaml?group=order</span>
    <span class="hljs-attr">activate:</span>
      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">test</span> <span class="hljs-comment"># test环境下生效</span>
<span class="hljs-meta">---</span>
<span class="hljs-attr">spring:</span>
  <span class="hljs-attr">config:</span>
    <span class="hljs-attr">import:</span>
      <span class="hljs-comment">##导入order分组（order微服务）的相关配置文件</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">nacos:service-order.yaml?group=order</span>
    <span class="hljs-attr">activate:</span>
      <span class="hljs-attr">on-profile:</span> <span class="hljs-string">prod</span> <span class="hljs-comment"># prod环境下生效</span></code></pre></div><h2 id="动态路由">6.4、动态路由</h2><p>网关的路由配置全部是在项目启动时由<code>org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator</code>在项目启动的时候加载，并且一经加载就会缓存到内存中的路由表内（一个Map），不会改变。也不会监听路由变更，所以，无法利用之前的配置热更新来实现路由更新。</p><p>因此，我们必须监听Nacos的配置变更，然后手动把最新的路由更新到路由表中。这里有两个难点：</p><ul><li>如何监听Nacos配置变更？</li><li>如何把路由信息更新到路由表？</li></ul><h3 id="监听nacos配置变更">监听Nacos配置变更</h3><p>在Nacos官网中给出了手动监听Nacos配置变更的<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/sdk.html">SDK</a></p><p>如果希望 Nacos 推送配置变更，可以使用 Nacos 动态监听配置接口来实现。</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addListener</span><span class="hljs-params">(String dataId, String group, Listener listener)</span></code></pre></div><p>请求参数说明：</p><table><thead><tr class="header"><th style="text-align:left"><strong>参数名</strong></th><th style="text-align:left"><strong>参数类型</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align:left">dataId</td><td style="text-align:left">string</td><td style="text-align:left">配置 ID，保证全局唯一性，只允许英文字符和 4 种特殊字符（"."、":"、"-"、"_"）。不超过 256 字节。</td></tr><tr class="even"><td style="text-align:left">group</td><td style="text-align:left">string</td><td style="text-align:left">配置分组，一般是默认的DEFAULT_GROUP。</td></tr><tr class="odd"><td style="text-align:left">listener</td><td style="text-align:left">Listener</td><td style="text-align:left">监听器，配置变更进入监听器的回调函数。</td></tr></tbody></table><p>示例代码：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">serverAddr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;serverAddr&#125;&quot;</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;dataId&#125;&quot;</span>;
<span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;group&#125;&quot;</span>;
<span class="hljs-comment">// 1.创建ConfigService，连接Nacos</span>
<span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();
properties.put(<span class="hljs-string">&quot;serverAddr&quot;</span>, serverAddr);
<span class="hljs-type">ConfigService</span> <span class="hljs-variable">configService</span> <span class="hljs-operator">=</span> NacosFactory.createConfigService(properties);
<span class="hljs-comment">// 2.读取配置</span>
<span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> configService.getConfig(dataId, group, <span class="hljs-number">5000</span>);
<span class="hljs-comment">// 3.添加配置监听器</span>
configService.addListener(dataId, group, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Listener</span>() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveConfigInfo</span><span class="hljs-params">(String configInfo)</span> &#123;
        <span class="hljs-comment">// 配置变更的通知处理</span>
                System.out.println(<span class="hljs-string">&quot;recieve1:&quot;</span> + configInfo);
        &#125;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getExecutor</span><span class="hljs-params">()</span> &#123;
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        &#125;
&#125;);</code></pre></div><p>由于我们采用了<code>spring-cloud-starter-alibaba-nacos-config</code>自动装配，因此<code>ConfigService</code>已经在<code>com.alibaba.cloud.nacos.NacosConfigAutoConfiguration</code>中自动创建好了：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205104346165-2025-2-510:43:47.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205104346165" style="zoom:80%"></p><p>因此，只要我们拿到<code>NacosConfigManager</code>就等于拿到了<code>ConfigService</code>，第一步就实现了</p><p>第二步，编写监听器。虽然官方提供的SDK是ConfigService中的addListener，不过项目第一次启动时不仅仅需要添加监听器，也需要读取配置，因此建议使用的API是这个：</p><div class="code-wrapper"><pre><code class="hljs Java">String <span class="hljs-title function_">getConfigAndSignListener</span><span class="hljs-params">(</span>
<span class="hljs-params">    String dataId, // 配置文件id</span>
<span class="hljs-params">    String group, // 配置组，走默认</span>
<span class="hljs-params">    <span class="hljs-type">long</span> timeoutMs, // 读取配置的超时时间</span>
<span class="hljs-params">    Listener listener // 监听器</span>
<span class="hljs-params">)</span> <span class="hljs-keyword">throws</span> NacosException;</code></pre></div><p>既可以配置监听器，并且会根据dataId和group读取配置并返回。我们就可以在项目启动时先更新一次路由，后续随着配置变更通知到监听器，完成路由更新。</p><h3 id="更新路由">更新路由</h3><p>更新路由要用到<code>org.springframework.cloud.gateway.route.RouteDefinitionWriter</code>这个接口：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> org.springframework.cloud.gateway.route;

<span class="hljs-keyword">import</span> reactor.core.publisher.Mono;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Spencer Gibb</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">RouteDefinitionWriter</span> &#123;
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 更新路由到路由表，如果路由id重复，则会覆盖旧的路由</span>
<span class="hljs-comment">     */</span>
        Mono&lt;Void&gt; <span class="hljs-title function_">save</span><span class="hljs-params">(Mono&lt;RouteDefinition&gt; route)</span>;
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 根据路由id删除某个路由</span>
<span class="hljs-comment">     */</span>
        Mono&lt;Void&gt; <span class="hljs-title function_">delete</span><span class="hljs-params">(Mono&lt;String&gt; routeId)</span>;

&#125;</code></pre></div><p>这里更新的路由，也就是RouteDefinition，之前我们见过，包含下列常见字段：</p><ul><li>id：路由id</li><li>predicates：路由匹配规则</li><li>filters：路由过滤器</li><li>uri：路由目的地</li></ul><p>将来我们保存到Nacos的配置也要符合这个对象结构，将来我们以JSON来保存，格式如下：</p><div class="code-wrapper"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span>
  <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;item&quot;</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;predicates&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span>
    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Path&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_genkey_0&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/items/**&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_genkey_1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/search/**&quot;</span><span class="hljs-punctuation">&#125;</span>
  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;filters&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lb://item-service&quot;</span>
<span class="hljs-punctuation">&#125;</span></code></pre></div><p>以上JSON配置就等同于：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">gateway:</span>
      <span class="hljs-attr">routes:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">item</span>
          <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://item-service</span>
          <span class="hljs-attr">predicates:</span>
            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/items/**,/search/**</span></code></pre></div><h3 id="实现动态路由">实现动态路由</h3><p>首先， 我们在网关gateway引入依赖：</p><div class="code-wrapper"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!--统一配置管理--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-comment">&lt;!--加载bootstrap--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>然后在网关<code>gateway</code>的<code>resources</code>目录创建<code>bootstrap.yaml</code>文件，内容如下：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">gateway</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span>
      <span class="hljs-attr">config:</span>
        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span>
        <span class="hljs-attr">shared-configs:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-log.yaml</span> <span class="hljs-comment"># 共享日志配置</span></code></pre></div><p>接着，修改<code>gateway</code>的<code>resources</code>目录下的<code>application.yml</code>，把之前的路由移除，最终内容如下：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 端口</span>
<span class="hljs-attr">hm:</span>
  <span class="hljs-attr">jwt:</span>
    <span class="hljs-attr">location:</span> <span class="hljs-string">classpath:hmall.jks</span> <span class="hljs-comment"># 秘钥地址</span>
    <span class="hljs-attr">alias:</span> <span class="hljs-string">hmall</span> <span class="hljs-comment"># 秘钥别名</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">hmall123</span> <span class="hljs-comment"># 秘钥文件密码</span>
    <span class="hljs-attr">tokenTTL:</span> <span class="hljs-string">30m</span> <span class="hljs-comment"># 登录有效期</span>
  <span class="hljs-attr">auth:</span>
    <span class="hljs-attr">excludePaths:</span> <span class="hljs-comment"># 无需登录校验的路径</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/search/**</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/users/login</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/items/**</span></code></pre></div><p>然后，在<code>gateway</code>中定义配置监听器：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205104818068-2025-2-510:48:31.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205104818068" style="zoom:80%"></p><p>其代码如下：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.hmall.gateway.routers;


<span class="hljs-keyword">import</span> cn.hutool.json.JSONUtil;
<span class="hljs-keyword">import</span> com.alibaba.cloud.nacos.NacosConfigManager;
<span class="hljs-keyword">import</span> com.alibaba.nacos.api.config.listener.Listener;
<span class="hljs-keyword">import</span> com.alibaba.nacos.api.exception.NacosException;
<span class="hljs-keyword">import</span> lombok.RequiredArgsConstructor;
<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;
<span class="hljs-keyword">import</span> org.springframework.cloud.gateway.route.RouteDefinition;
<span class="hljs-keyword">import</span> org.springframework.cloud.gateway.route.RouteDefinitionWriter;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> reactor.core.publisher.Mono;

<span class="hljs-keyword">import</span> javax.annotation.PostConstruct;
<span class="hljs-keyword">import</span> java.util.HashSet;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Set;
<span class="hljs-keyword">import</span> java.util.concurrent.Executor;

<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-meta">@RequiredArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicRouteLoader</span> &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> NacosConfigManager configManager;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">dataId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;gateway-routes.json&quot;</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DEFAULT_GROUP&quot;</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RouteDefinitionWriter writer; <span class="hljs-comment">//用来更新路由信息</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Set&lt;String&gt; routeIds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();


    <span class="hljs-meta">@PostConstruct</span> <span class="hljs-comment">//添加了该注解的方法，在当前这个bean初始化后执行</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initRouteConfigListener</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NacosException &#123;
        <span class="hljs-comment">//1.项目启动时，先拉取初始配置，并且添加监听器</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">originConfigInfo</span> <span class="hljs-operator">=</span> configManager.getConfigService()
                .getConfigAndSignListener(dataId, group, <span class="hljs-number">5000</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Listener</span>() &#123;
                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-keyword">public</span> Executor <span class="hljs-title function_">getExecutor</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//返回一个线程池，由这个线程池执行</span>
                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
                    &#125;

                    <span class="hljs-meta">@Override</span>
                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveConfigInfo</span><span class="hljs-params">(String configInfo)</span> &#123;
                        <span class="hljs-comment">//2.监听到配置变更，更新路由表</span>
                        updateConfigInfo(configInfo);
                    &#125;
                &#125;);
        <span class="hljs-comment">//3.第一次拉取到的配置，更新至路由表</span>
        updateConfigInfo(originConfigInfo);
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateConfigInfo</span><span class="hljs-params">(String configInfo)</span> &#123;
        log.info(<span class="hljs-string">&quot;监听到路由信息变更：&#123;&#125;&quot;</span>,configInfo);
        <span class="hljs-comment">//1.解析配置文件，转化为RouteDefinition的对象列表</span>
        List&lt;RouteDefinition&gt; routeDefinitions = JSONUtil.toList(configInfo, RouteDefinition.class);

        <span class="hljs-comment">//2.删除原有的路由信息</span>
        <span class="hljs-keyword">for</span> (String routeId: routeIds) &#123;
            writer.delete(Mono.just(routeId)).subscribe();
        &#125;
        routeIds.clear();

        <span class="hljs-comment">//3.更新路由信息</span>
        <span class="hljs-keyword">for</span> (RouteDefinition routeDefinition: routeDefinitions) &#123;
            <span class="hljs-comment">//3.1更新路由表</span>
            writer.save(Mono.just(routeDefinition)).subscribe();
            <span class="hljs-comment">//3.2 记录路由id，便于下次更新时删除</span>
            routeIds.add(routeDefinition.getId());
        &#125;
    &#125;
&#125;
</code></pre></div><p>重启网关，任意访问一个接口。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205105231420-2025-2-510:52:57.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205105231420" style="zoom:80%"></p><p>发现是404，无法访问。</p><p>接下来，直接在Nacos控制台添加路由，路由文件名为gateway-routes.json，类型为json：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205105106335-2025-2-510:51:31.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205105106335" style="zoom:80%"></p><p>配置内容如下：</p><div class="code-wrapper"><pre><code class="hljs JSON"><span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">&#123;</span>
        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;item&quot;</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;predicates&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span>
            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Path&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_genkey_0&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/items/**&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_genkey_1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/search/**&quot;</span><span class="hljs-punctuation">&#125;</span>
        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;filters&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lb://item-service&quot;</span>
    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">&#123;</span>
        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cart&quot;</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;predicates&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span>
            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Path&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_genkey_0&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/carts/**&quot;</span><span class="hljs-punctuation">&#125;</span>
        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;filters&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lb://cart-service&quot;</span>
    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">&#123;</span>
        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;user&quot;</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;predicates&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span>
            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Path&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_genkey_0&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/users/**&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;_genkey_1&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/addresses/**&quot;</span><span class="hljs-punctuation">&#125;</span>
        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;filters&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lb://user-service&quot;</span>
    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">&#123;</span>
        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;trade&quot;</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;predicates&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span>
            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Path&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_genkey_0&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/orders/**&quot;</span><span class="hljs-punctuation">&#125;</span>
        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;filters&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lb://trade-service&quot;</span>
    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">&#123;</span>
        <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pay&quot;</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;predicates&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span>
            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Path&quot;</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;_genkey_0&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/pay-orders/**&quot;</span><span class="hljs-punctuation">&#125;</span>
        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;filters&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lb://pay-service&quot;</span>
    <span class="hljs-punctuation">&#125;</span>
<span class="hljs-punctuation">]</span></code></pre></div><p>无需重启网关，稍等几秒钟后，再次访问刚才的地址： <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205105326278-2025-2-510:53:27.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205105326278" style="zoom:80%">网关路由成功了！</p><h1 id="七微服务保护">七、微服务保护</h1><p>在微服务远程调用的过程中，还存在几个问题需要解决。</p><p>首先是<strong>业务健壮性</strong>问题：</p><p>例如在之前的查询购物车列表业务中，购物车服务需要查询最新的商品信息，与购物车数据做对比，提醒用户。大家设想一下，如果商品服务查询时发生故障，查询购物车列表在调用商品服 务时，是不是也会异常？从而导致购物车查询失败。但从业务角度来说，为了提升用户体验，即便是商品查询失败，购物车列表也应该正确展示出来，哪怕是不包含最新的商品信息。</p><p>还有<strong>级联失败</strong>问题：</p><p>还是查询购物车的业务，假如商品服务业务并发较高，占用过多Tomcat连接。可能会导致商品服务的所有接口响应时间增加，延迟变高，甚至是长时间阻塞直至查询失败。</p><p>此时查询购物车业务需要查询并等待商品查询结果，从而导致查询购物车列表业务的响应时间也变长，甚至也阻塞直至无法访问。而此时如果查询购物车的请求较多，可能导致购物车服务的Tomcat连接占用较多，所有接口的响应时间都会增加，整个服务性能很差， 甚至不可用。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205105935054-2025-2-510:59:49.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205105935054" style="zoom:80%"></p><p>依次类推，整个微服务群中与购物车服务、商品服务等有调用关系的服务可能都会出现问题，最终导致整个集群不可用。这就是<strong>级联失败</strong>问题，或者叫<strong>雪崩</strong>问题。</p><p>保证服务运行的健壮性，避免级联失败导致的雪崩问题，就属于微服务保护。</p><h2 id="微服务保护方案">7.1、微服务保护方案</h2><p>微服务保护的方案有很多，比如：</p><ul><li>请求限流</li><li>线程隔离</li><li>服务熔断</li></ul><p>这些方案或多或少都会导致服务的体验上略有下降，比如请求限流，降低了并发上限；线程隔离，降低了可用资源数量；服务熔断，降低了服务的完整度，部分服务变的不可用或弱可用。因此这些方案都属于服务<strong>降级</strong>的方案。但通过这些方案，服务的健壮性得到了提升。</p><p>接下来，就逐一了解这些方案的原理。</p><h3 id="请求限流">请求限流</h3><p>服务故障最重要原因，就是并发太高！解决了这个问题，就能避免大部分故障。当然，接口的并发不是一直很高，而是突发的。因此请求限流，就是<strong>限制或控制</strong>接口访问的并发流量，避免服务因流量激增而出现故障。</p><p>请求限流往往会有一个限流器，数量高低起伏的并发请求曲线，经过限流器就变的非常平稳。这就像是水电站的大坝，起到蓄水的作用，可以通过开关控制水流出的大小，让下游水流始终维持在一个平稳的量。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205110306722-2025-2-511:03:07.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205110306722" style="zoom:80%"></p><h3 id="线程隔离">线程隔离</h3><p>当一个业务接口响应时间长，而且并发高时，就可能耗尽服务器的线程资源，导致服务内的其它接口受到影响。所以我们必须把这种影响降低，或者缩减影响的范围。线程隔离正是解决这个问题的好办法。</p><p>线程隔离的思想来自轮船的舱壁模式：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205110405106-2025-2-511:04:06.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205110405106" style="zoom:80%"></p><p>轮船的船舱会被隔板分割为N个相互隔离的密闭舱，假如轮船触礁进水，只有损坏的部分密闭舱会进水，而其他舱由于相互隔离，并不会进水。这样就把进水控制在部分船体，避免了整个船舱进水而沉没。</p><p>为了避免某个接口故障或压力过大导致整个服务不可用，我们可以限定每个接口可以使用的资源范围，也就是将其“隔离”起来。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205110450434-2025-2-511:04:51.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205110450434" style="zoom:80%"></p><p>如图所示，我们给查询购物车业务限定可用线程数量上限为20，这样即便查询购物车的请求因为查询商品服务而出现故障，也不会导致服务器的线程资源被耗尽，不会影响到其它接口。</p><h3 id="服务熔断">服务熔断</h3><p>线程隔离虽然避免了雪崩问题，但故障服务（商品服务）依然会拖慢购物车服务（服务调用方）的接口响应速度。而且商品查询的故障依然会导致查询购物车功能出现故障，购物车业务也变的不可用了。</p><p>所以，我们要做两件事情：</p><ul><li><strong>编写服务降级逻辑</strong>：就是服务调用失败后的处理逻辑，根据业务场景，可以抛出异常，也可以返回友好提示或默认数据。</li><li><strong>异常统计和熔断</strong>：统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑。</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205110603765-2025-2-511:06:16.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205110603765" style="zoom:80%"></p><h2 id="sentinel">7.2、Sentinel</h2><p>微服务保护的技术有很多，但在目前国内使用较多的还是Sentinel。</p><h3 id="介绍和安装">介绍和安装</h3><p>Sentinel是阿里巴巴开源的一款服务保护框架，目前已经加入SpringCloudAlibaba中。<a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/">官方网站</a></p><p>Sentinel 的使用可以分为两个部分:</p><ul><li><strong>核心库</strong>（Jar包）：不依赖任何框架/库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。在项目中引入依赖即可实现服务限流、隔离、熔断等功能。</li><li><strong>控制台</strong>（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等。</li></ul><p>为了方便监控微服务，我们先把Sentinel的控制台搭建出来。</p><p>1）下载jar包</p><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/releases">下载地址</a></p><p>运行</p><p>2）运行</p><p>将jar包放在任意非中文、不包含特殊字符的目录下，重命名为<code>sentinel-dashboard.jar</code>。</p><p>然后运行如下命令启动控制台：</p><div class="code-wrapper"><pre><code class="hljs Shell">java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar</code></pre></div><p>其它启动时可配置参数可参考<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%A1%B9">官方文档</a></p><p>3）访问</p><p>访问<a target="_blank" rel="noopener" href="http://localhost:8080">http://localhost:8090</a>页面，就可以看到sentinel的控制台了：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111017652-2025-2-511:10:18.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205111017652" style="zoom:80%"></p><p>需要输入账号和密码，默认都是：sentinel</p><p>登录后，即可看到控制台，默认会监控sentinel-dashboard服务本身：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111102271-2025-2-511:11:03.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205111102271" style="zoom:80%"></p><blockquote><p>注：sentinel 必须跟微服务处在同一个网络中。</p></blockquote><h3 id="微服务整合">微服务整合</h3><p>我们在<code>cart-service</code>模块中整合sentinel，连接<code>sentinel-dashboard</code>控制台，步骤如下：</p><p>1）引入sentinel依赖</p><div class="code-wrapper"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!--sentinel--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> 
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2）配置控制台</p><p>修改application.yaml文件，添加下面内容：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span> 
    <span class="hljs-attr">sentinel:</span>
      <span class="hljs-attr">transport:</span>
        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8090</span></code></pre></div><p>3）访问<code>cart-service</code>的任意端点</p><p>重启<code>cart-service</code>，然后访问查询购物车接口，sentinel的客户端就会将服务访问的信息提交到<code>sentinel-dashboard</code>控制台。并展示出统计信息：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111425351-2025-2-511:14:31.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205111425351" style="zoom:80%"></p><p>点击簇点链路菜单，会看到下面的页面：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111507034-2025-2-511:15:31.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205111507034" style="zoom:80%"></p><p>在微服务架构中，服务之间通过网络通信互相调用形成了一条条调用链路，每个服务节点都可以看作是这条链路上的一个“簇点”。所谓簇点链路，就是单机调用链路，是一次请求进入服务后经过的每一个被<code>Sentinel</code>监控的资源。默认情况下，<code>Sentinel</code>会监控<code>SpringMVC</code>的每一个<code>Endpoint</code>（controller接口）。</p><p>不过，需要注意的是，我们的SpringMVC接口是按照Restful风格设计，因此购物车的查询、删除、修改等接口全部都是<code>/carts</code>路径：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111731892-2025-2-511:17:33.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205111731892" style="zoom:80%"></p><p>默认情况下Sentinel会把路径作为簇点资源的名称，无法区分路径相同但请求方式不同的接口，查询、删除、修改等都被识别为一个簇点资源，这显然是不合适的。</p><p>所以我们可以选择打开Sentinel的请求方式前缀，把<code>请求方式 + 请求路径</code>作为簇点资源名：</p><p>首先，在<code>cart-service</code>的<code>application.yml</code>中添加下面的配置：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">sentinel:</span>
      <span class="hljs-attr">transport:</span>
        <span class="hljs-attr">dashboard:</span> <span class="hljs-string">localhost:8090</span>
      <span class="hljs-attr">http-method-specify:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启请求方式前缀</span></code></pre></div><p>然后，重启服务，通过页面访问购物车的相关接口，可以看到sentinel控制台的簇点链路发生了变化：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205111828535-2025-2-511:18:29.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205111828535" style="zoom:80%"></p><h3 id="请求限流实现">请求限流实现</h3><p>在簇点链路后面点击流控按钮，即可对其做限流配置：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101535636-2025-2-610:15:47.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250206101535636" style="zoom:80%"></p><p>在弹出的菜单中这样填写：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101620493-2025-2-610:16:21.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>这样就把查询购物车列表这个簇点资源的流量限制在了每秒6个，也就是最大QPS为6.</p><p>我们利用Jemeter做限流测试，我们每秒发出10个请求：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101640224-2025-2-610:16:41.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>最终监控结果如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101658752-2025-2-610:16:59.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>可以看出<code>GET:/carts</code>这个接口的通过QPS稳定在6附近，而拒绝的QPS在4附近，符合我们的预期。</p><h3 id="线程隔离实现">线程隔离实现</h3><p>限流可以降低服务器压力，尽量减少因并发流量引起的服务故障的概率，但并不能完全避免服务故障。一旦某个服务出现故障，我们必须隔离对这个服务的调用，避免发生雪崩。</p><p>比如，查询购物车的时候需要查询商品，为了避免因商品服务出现故障导致购物车服务级联失败，我们可以把购物车业务中查询商品的部分隔离起来，限制可用的线程资源：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205112354921-2025-2-511:24:09.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250205112354921" style="zoom:80%"></p><p>这样，即便商品服务出现故障，最多导致查询购物车业务故障，并且可用的线程资源也被限定在一定范围，不会导致整个购物车服务崩溃。</p><p>所以，我们要对查询商品的FeignClient接口做线程隔离。</p><h4 id="openfeign整合sentinel">OpenFeign整合Sentinel</h4><p>修改cart-service模块的application.yml文件，开启Feign的sentinel功能：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">feign:</span>
  <span class="hljs-attr">sentinel:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启feign对sentinel的支持</span></code></pre></div><blockquote><p>需要注意的是，默认情况下SpringBoot项目的tomcat最大线程数是200，允许的最大连接是8492，单机测试很难打满。</p><p>所以我们需要配置一下cart-service模块的application.yml文件，修改tomcat连接：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8082</span>
  <span class="hljs-attr">tomcat:</span>
    <span class="hljs-attr">threads:</span>
      <span class="hljs-attr">max:</span> <span class="hljs-number">50</span> <span class="hljs-comment"># 允许的最大线程数</span>
    <span class="hljs-attr">accept-count:</span> <span class="hljs-number">50</span> <span class="hljs-comment"># 最大排队等待数量</span>
    <span class="hljs-attr">max-connections:</span> <span class="hljs-number">100</span> <span class="hljs-comment"># 允许的最大连接</span></code></pre></div></blockquote><p>然后重启cart-service服务，可以看到查询商品的FeignClient自动变成了一个簇点资源：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101746909-2025-2-610:17:47.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="配置线程隔离">配置线程隔离</h4><p>接下来，点击查询商品的FeignClient对应的簇点资源后面的流控按钮：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101802772-2025-2-610:18:03.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>在弹出的表单中填写下面内容：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101823253-2025-2-610:18:24.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250206101823253" style="zoom:80%"></p><p>注意，这里勾选的是并发线程数限制，也就是说这个查询功能最多使用5个线程，而不是5QPS。如果查询商品的接口每秒处理2个请求，则5个线程的实际QPS在10左右，而超出的请求自然会被拒绝。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101855768-2025-2-610:18:56.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250206101855768" style="zoom:80%"></p><p>我们利用Jemeter测试，每秒发送100个请求：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101909204-2025-2-610:19:10.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250206101909204"><figcaption aria-hidden="true">image-20250206101909204</figcaption></figure><p>最终测试结果如下：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101928213-2025-2-610:19:29.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250206101928213"><figcaption aria-hidden="true">image-20250206101928213</figcaption></figure><p>进入查询购物车的请求每秒大概在100，而在查询商品时却只剩下每秒10左右，符合我们的预期。</p><p>此时如果我们通过页面访问购物车的其它接口，例如添加购物车、修改购物车商品数量，发现不受影响：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206101942443-2025-2-610:19:43.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250206101942443"></p><p>响应时间非常短，这就证明线程隔离起到了作用，尽管查询购物车这个接口并发很高，但是它能使用的线程资源被限制了，因此不会影响到其它接口。</p><h3 id="服务熔断实现">服务熔断实现</h3><p>之前利用线程隔离对查询购物车业务进行隔离，保护了购物车服务的其它接口。由于查询商品的功能耗时较高（我们模拟了500毫秒延时），再加上线程隔离限定了线程数为5，导致接口吞吐能力有限，最终QPS只有10左右。这就导致了几个问题：</p><p>第一，超出的QPS上限的请求就只能抛出异常，从而导致购物车的查询失败。但从业务角度来说，即便没有查询到最新的商品信息，购物车也应该展示给用户，用户体验更好。也就是给查询失败设置一个<strong>降级处理</strong>逻辑。</p><p>第二，由于查询商品的延迟较高（模拟的500ms），从而导致查询购物车的响应时间也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。对于商品服务这种不太健康的接口，我们应该直接停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口<strong>熔断</strong>。</p><h4 id="编写降级逻辑">编写降级逻辑</h4><p>触发限流或熔断后的请求不一定要直接报错，也可以返回一些默认数据或者友好提示，用户体验会更好。</p><p>给FeignClient编写失败后的降级逻辑有两种方式：</p><ul><li>方式一：FallbackClass，无法对远程调用的异常做处理</li><li>方式二：FallbackFactory，可以对远程调用的异常做处理，我们一般选择这种方式。</li></ul><p><strong>步骤一</strong>：在hm-api模块中给<code>ItemClient</code>定义降级处理类，实现<code>FallbackFactory</code>：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102017583-2025-2-610:20:18.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250206102017583"><figcaption aria-hidden="true">image-20250206102017583</figcaption></figure><p>代码如下：</p><div class="code-wrapper"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.hmall.api.client.fallback;

<span class="hljs-keyword">import</span> com.hmall.api.client.ItemClient;
<span class="hljs-keyword">import</span> com.hmall.api.dto.ItemDTO;
<span class="hljs-keyword">import</span> com.hmall.api.dto.OrderDetailDTO;
<span class="hljs-keyword">import</span> com.hmall.common.exception.BizIllegalException;
<span class="hljs-keyword">import</span> com.hmall.common.utils.CollUtils;
<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;
<span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FallbackFactory;

<span class="hljs-keyword">import</span> java.util.Collection;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemClientFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FallbackFactory</span>&lt;ItemClient&gt; &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> ItemClient <span class="hljs-title function_">create</span><span class="hljs-params">(Throwable cause)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemClient</span>() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> List&lt;ItemDTO&gt; <span class="hljs-title function_">queryItemByIds</span><span class="hljs-params">(Collection&lt;Long&gt; ids)</span> &#123;
                log.error(<span class="hljs-string">&quot;远程调用ItemClient#queryItemByIds方法出现异常，参数：&#123;&#125;&quot;</span>, ids, cause);
                <span class="hljs-comment">// 查询购物车允许失败，查询失败，返回空集合</span>
                <span class="hljs-keyword">return</span> CollUtils.emptyList();
            &#125;

            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deductStock</span><span class="hljs-params">(List&lt;OrderDetailDTO&gt; items)</span> &#123;
                <span class="hljs-comment">// 库存扣减业务需要触发事务回滚，查询失败，抛出异常</span>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizIllegalException</span>(cause);
            &#125;
        &#125;;
    &#125;
&#125;</code></pre></div><p><strong>步骤二</strong>：在<code>hm-api</code>模块中的<code>com.hmall.api.config.DefaultFeignConfig</code>类中将<code>ItemClientFallback</code>注册为一个<code>Bean</code>：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102034921-2025-2-610:20:36.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p><strong>步骤三</strong>：在<code>hm-api</code>模块中的<code>ItemClient</code>接口中使用<code>ItemClientFallbackFactory</code>：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102045669-2025-2-610:20:46.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>重启后，再次测试，发现被限流的请求不再报错，走了降级逻辑：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102112967-2025-2-610:21:13.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>但是未被限流的请求延时依然很高，导致最终的平局响应时间较长。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102130287-2025-2-610:21:43.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="服务熔断-1">服务熔断</h4><p>查询商品的RT较高（模拟的500ms），从而导致查询购物车的RT也变的很长。这样不仅拖慢了购物车服务，消耗了购物车服务的更多资源，而且用户体验也很差。</p><p>对于商品服务这种不太健康的接口，我们应该停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口<strong>熔断</strong>。当商品服务接口恢复正常后，再允许调用。这其实就是<strong>断路器</strong>的工作模式了。</p><p>Sentinel中的断路器不仅可以统计某个接口的<strong>慢请求比例</strong>，还可以统计<strong>异常请求比例</strong>。当这些比例超出阈值时，就会<strong>熔断</strong>该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。</p><p>断路器的工作状态切换有一个状态机来控制：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250205113626096-2025-2-511:36:31.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>状态机包括三个状态：</p><ul><li><strong>closed</strong>：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li><li><strong>open</strong>：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态</li><li><strong>half-open</strong>：半开状态，放行一次请求，根据执行结果来判断接下来的操作。<ul><li>请求成功：则切换到closed状态</li><li>请求失败：则切换到open状态</li></ul></li></ul><p>我们可以在控制台通过点击簇点后的<strong><code>熔断</code></strong>按钮来配置熔断策略：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102225807-2025-2-610:22:26.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><p>在弹出的表格中这样填写：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102244916-2025-2-610:22:46.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><p>这种是按照慢调用比例来做熔断，上述配置的含义是：</p><ul><li>RT（Response Time）超过200毫秒的请求调用就是慢调用</li><li>统计最近1000ms内的最少5次请求，如果慢调用比例不低于0.5，则触发熔断</li><li>熔断持续时长20s</li></ul><p>配置完成后，再次利用Jemeter测试，可以发现：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102256395-2025-2-610:22:57.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><p>在一开始一段时间是允许访问的，后来触发熔断后，查询商品服务的接口通过QPS直接为0，所有请求都被熔断了。而查询购物车的本身并没有受到影响。</p><p>此时整个购物车查询服务的平均RT影响不大：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102313371-2025-2-610:23:14.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><h1 id="八分布式事务">八、分布式事务</h1><p>首先分析项目中下单业务整体流程：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102731634-2025-2-610:27:49.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>由于订单、购物车、商品分别在三个不同的微服务，而每个微服务都有自己独立的数据库，因此下单过程中就会跨多个数据库完成业务。而每个微服务都会执行自己的本地事务：</p><ul><li>交易服务：下单事务</li><li>购物车服务：清理购物车事务</li><li>库存服务：扣减库存事务</li></ul><p>整个业务中，各个本地事务是有关联的。因此每个微服务的本地事务，也可以称为<strong>分支事务</strong>。多个有关联的分支事务一起就组成了<strong>全局事务</strong>。我们必须保证整个全局事务同时成功或失败。</p><p>我们知道每一个分支事务就是传统的<strong>单体事务</strong>，都可以满足ACID特性，但全局事务跨越多个服务、多个数据库，是否还能满足呢？</p><p>来做一个测试，先进入购物车页面：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206102923519-2025-2-610:29:49.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>目前有4个购物车，然结算下单，进入订单结算页面：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206103018461-2025-2-610:30:46.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><p>然后将购物车中某个商品的库存修改为<code>0</code>：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206103040482-2025-2-610:30:48.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><p>然后，提交订单，最终因库存不足导致下单失败：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206103144332-2025-2-610:31:45.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><p>然后我们去查看购物车列表，发现购物车数据依然被清空了，并未回滚：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206103221262-2025-2-610:32:22.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>事务并未遵循ACID的原则，归其原因就是参与事务的多个子业务在不同的微服务，跨越了不同的数据库。虽然每个单独的业务都能在本地遵循ACID，但是<u>它们互相之间没有感知，不知道有人失败了，无法保证最终结果的统一，也就无法遵循ACID的事务特性了</u>。</p><p>这就是分布式事务问题，出现以下情况之一就可能产生分布式事务问题：</p><ul><li>业务跨多个服务实现</li><li>业务跨多个数据源实现</li></ul><h2 id="认识seata">8.1、认识Seata</h2><p>决分布式事务的方案有很多，但实现起来都比较复杂，因此我们一般会使用开源的框架来解决分布式事务问题。在众多的开源分布式事务框架中，功能最完善、使用最多的就是阿里巴巴在2019年开源的<a target="_blank" rel="noopener" href="https://seata.apache.org/zh-cn/docs/overview/what-is-seata/">Seata</a>了。</p><p>其实分布式事务产生的一个重要原因，就是参与事务的多个分支事务互相无感知，不知道彼此的执行状态。因此解决分布式事务的思想非常简单：</p><p>就是找一个统一的<strong>事务协调者</strong>，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206104757749-2025-2-610:48:11.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>大多数的分布式事务框架都是基于这个理论来实现的。Seata也不例外，在Seata的事务管理中有三个重要的角色：</p><ul><li><strong>TC (Transaction Coordinator) -</strong> <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。</li><li><strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。</li><li><strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong>管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><blockquote><p>TM监控整个方法的开始和结束，当方法开始时向TC报告开启全局事务；在方法执行结束后，向TC报告全局事务结束，TC根据各个分支事务RM的执行情况，判断各个分支事务应该提交还是回滚。</p></blockquote><p>Seata的工作架构如图所示：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206103827156-2025-2-610:38:49.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>其中，<strong>TM</strong>和<strong>RM</strong>可以理解为Seata的客户端部分，引入到参与事务的微服务依赖中即可。将来<strong>TM</strong>和<strong>RM</strong>就会协助微服务，实现本地分支事务与<strong>TC</strong>之间交互，实现事务的提交或回滚。</p><p>而<strong>TC</strong>服务则是事务协调中心，是一个独立的微服务，需要单独部署。</p><h3 id="部署tc服务">部署TC服务</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1S142197x7?spm_id_from=333.788.player.switch&amp;vd_source=51d78ede0a0127d1839d6abf9204d1ee&amp;p=80">参考视频</a></p><h3 id="微服务集成seata">微服务集成Seata</h3><p>参与分布式事务的每一个微服务都需要集成Seata，我们以<code>trade-service</code>为例。</p><h4 id="引入依赖-4">引入依赖</h4><p>为了方便各个微服务集成seata，我们需要把seata配置共享到nacos，因此<code>trade-service</code>模块不仅仅要引入seata依赖，还要引入nacos依赖:</p><div class="code-wrapper"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!--统一配置管理--&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-comment">&lt;!--读取bootstrap文件--&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
  <span class="hljs-comment">&lt;!--seata--&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="改造配置">改造配置</h4><p>首先在nacos上添加一个共享的seata配置，命名为<code>shared-seata.yaml</code>：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206105952552-2025-2-610:59:54.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250206105952552" style="zoom:80%"></p><p>内容如下：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">seata:</span>
  <span class="hljs-attr">registry:</span> <span class="hljs-comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span>
    <span class="hljs-attr">type:</span> <span class="hljs-string">nacos</span> <span class="hljs-comment"># 注册中心类型 nacos</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:8848</span> <span class="hljs-comment"># nacos地址</span>
      <span class="hljs-attr">namespace:</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># namespace，默认为空</span>
      <span class="hljs-attr">group:</span> <span class="hljs-string">DEFAULT_GROUP</span> <span class="hljs-comment"># 分组，默认是DEFAULT_GROUP</span>
      <span class="hljs-attr">application:</span> <span class="hljs-string">seata-server</span> <span class="hljs-comment"># seata服务名称</span>
      <span class="hljs-attr">username:</span> <span class="hljs-string">nacos</span>
      <span class="hljs-attr">password:</span> <span class="hljs-string">nacos</span>
  <span class="hljs-attr">tx-service-group:</span> <span class="hljs-string">hmall</span> <span class="hljs-comment"># 事务组名称</span>
  <span class="hljs-attr">service:</span>
    <span class="hljs-attr">vgroup-mapping:</span> <span class="hljs-comment"># 事务组与tc集群的映射关系</span>
      <span class="hljs-attr">hmall:</span> <span class="hljs-string">&quot;default&quot;</span></code></pre></div><p>然后，改造trade-service模块，添加bootstrap.yaml：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206110054739-2025-2-611:00:55.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250206110054739" style="zoom:80%"></p><p>内容如下:</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">trade-service</span> <span class="hljs-comment"># 服务名称</span>
  <span class="hljs-attr">profiles:</span>
    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span>
  <span class="hljs-attr">cloud:</span>
    <span class="hljs-attr">nacos:</span>
      <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span> <span class="hljs-comment"># nacos地址</span>
      <span class="hljs-attr">config:</span>
        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment"># 文件后缀名</span>
        <span class="hljs-attr">shared-configs:</span> <span class="hljs-comment"># 共享配置</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-jdbc.yaml</span> <span class="hljs-comment"># 共享mybatis配置</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-log.yaml</span> <span class="hljs-comment"># 共享日志配置</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-swagger.yaml</span> <span class="hljs-comment"># 共享日志配置</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">dataId:</span> <span class="hljs-string">shared-seata.yaml</span> <span class="hljs-comment"># 共享seata配置</span></code></pre></div><p>可以看到这里加载了共享的seata配置。</p><p>然后改造application.yaml文件，内容如下：</p><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">8085</span>
<span class="hljs-attr">feign:</span>
  <span class="hljs-attr">okhttp:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启OKHttp连接池支持</span>
  <span class="hljs-attr">sentinel:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启Feign对Sentinel的整合</span>
<span class="hljs-attr">hm:</span>
  <span class="hljs-attr">swagger:</span>
    <span class="hljs-attr">title:</span> <span class="hljs-string">交易服务接口文档</span>
    <span class="hljs-attr">package:</span> <span class="hljs-string">com.hmall.trade.controller</span>
  <span class="hljs-attr">db:</span>
    <span class="hljs-attr">database:</span> <span class="hljs-string">hm-trade</span></code></pre></div><p>参考上述办法分别改造<code>hm-cart</code>和<code>hm-item</code>两个微服务模块。</p><h4 id="添加数据库表">添加数据库表</h4><p>seata的客户端在解决分布式事务的时候需要记录一些中间数据，保存在数据库中。因此我们要先准备一个这样的表。</p><p>将<code>seata-at.sql</code>分别文件导入hm-trade、hm-cart、hm-item三个数据库中。结果如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206110624648-2025-2-611:06:37.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>至此为止，微服务整合的工作就完成了。可以参考上述方式对<code>hm-item</code>和<code>hm-cart</code>模块完成整合改造。</p><h4 id="测试-2">测试</h4><p>接下来就是测试的分布式事务的时候了。</p><p>找到<code>trade-service</code>模块下的<code>com.hmall.trade.service.impl.OrderServiceImpl</code>类中的<code>createOrder</code>方法，也就是下单业务方法。</p><p>将其上的<code>@Transactional</code>注解改为Seata提供的<code>@GlobalTransactional</code>：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206110816199-2025-2-611:08:17.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p><code>@GlobalTransactional</code>注解就是在标记事务的起点，将来TM就会基于这个方法判断全局事务范围，初始化全局事务。</p><p>我们重启<code>trade-service</code>、<code>item-service</code>、<code>cart-service</code>三个服务。再次测试，发现分布式事务的问题解决了！</p><p>那么，Seata是如何解决分布式事务的呢？</p><p>Seata支持四种不同的分布式事务解决方案：</p><ul><li><strong>XA</strong></li><li><strong>TCC</strong></li><li><strong>AT</strong></li><li><strong>SAGA</strong></li></ul><p>此处只分析<code>XA</code>模式和<code>AT</code>模式的现原理。</p><h2 id="xa模式">8.2、XA模式</h2><p>XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的TM与局部的RM之间的接口，几乎所有主流的关系型数据库都对 XA 规范 提供了支持。实现的原理都是基于两阶段提交。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206112243669-2025-2-611:22:48.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>一阶段：</p><ul><li>事务协调者通知每个事务参与者执行本地事务</li><li>本地事务执行完成后报告事务执行状态给事务协调者，<strong>此时事务不提交，继续持有数据库锁</strong></li></ul><p>二阶段：</p><ul><li>事务协调者基于一阶段的报告来判断下一步操作</li><li>如果一阶段都成功，则通知所有事务参与者，提交事务</li><li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li></ul><h4 id="原理分析">原理分析</h4><p>Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206111635526-2025-2-611:16:36.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p><code>RM</code>一阶段的工作：</p><ol type="1"><li>注册分支事务到<code>TC</code></li><li><strong>执行分支业务sql但不提交</strong></li><li>报告执行状态到<code>TC</code></li></ol><p><code>TC</code>二阶段的工作：</p><ul><li><code>TC</code>检测各分支事务执行状态<ul><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务</li></ul></li></ul><p><code>RM</code>二阶段的工作：</p><ul><li>接收<code>TC</code>指令，提交或回滚事务</li></ul><h4 id="优缺点">优缺点</h4><p><code>XA</code>模式的优点是什么？</p><ul><li>事务的强一致性，满足ACID原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p><code>XA</code>模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul><h4 id="实现">实现</h4><p>Seata的starter已经完成了XA模式的自动装配，实现非常简单，步骤如下：</p><ol type="1"><li>修改application.yml文件（每个参与事务的微服务），开启XA模式：</li></ol><div class="code-wrapper"><pre><code class="hljs YAML"><span class="hljs-attr">seata:</span>
  <span class="hljs-attr">data-source-proxy-mode:</span> <span class="hljs-string">XA</span></code></pre></div><ol start="2" type="1"><li>给发起全局事务的入口方法添加<code>@GlobalTransactional</code>注解，本例中是OrderServicelmpl中的create方法：</li></ol><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206113123686-2025-2-611:31:25.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250206113123686" style="zoom:80%"></p><ol start="3" type="1"><li>重启服务并测试</li></ol><h2 id="at模式">8.3、AT模式</h2><p>Seata主推的是AT模式，AT模式同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷。</p><h4 id="原理分析-1">原理分析</h4><p>基本流程图：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206113911361-2025-2-611:39:37.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250206113911361" style="zoom:80%"></p><p>阶段一<code>RM</code>的工作：</p><ul><li>注册分支事务</li><li><strong>记录undo-log（数据快照）</strong></li><li>执行业务sql并<strong>提交</strong></li><li>报告事务状态</li></ul><p>阶段二提交时<code>RM</code>的工作：</p><ul><li>删除undo-log即可</li></ul><p>阶段二回滚时<code>RM</code>的工作：</p><ul><li>根据undo-log恢复数据到更新前</li></ul><blockquote><p>AT模式可能会出现短暂的数据不一致。如一阶段分支事务RM1执行sql并提交了，但分支事务RM2执行出错，需要等到二阶段回滚时才能保持与原来的数据一致。但由于RM1已经提交了事务，数据已经发生了变化，若此时有其他线程查询数据，会得到错误的结果。</p></blockquote><h4 id="流程梳理">流程梳理</h4><p>我们用一个真实的业务来梳理下AT模式的原理。</p><p>比如，现在有一个数据库表，记录用户余额：</p><table><thead><tr class="header"><th style="text-align:left"><strong>id</strong></th><th style="text-align:left"><strong>money</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align:left">1</td><td style="text-align:left">100</td></tr></tbody></table><p>其中一个分支业务要执行的SQL为：</p><div class="code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">update</span> tb_account <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> money <span class="hljs-operator">-</span> <span class="hljs-number">10</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span></code></pre></div><p>AT模式下，当前分支事务执行流程如下：</p><p><strong>一阶段</strong>：</p><ol type="1"><li><code>TM</code>发起并注册全局事务到<code>TC</code></li><li><code>TM</code>调用分支事务</li><li>分支事务准备执行业务SQL</li><li><code>RM</code>拦截业务SQL，根据where条件查询原始数据，形成快照。</li></ol><div class="code-wrapper"><pre><code class="hljs JSON"><span class="hljs-punctuation">&#123;</span>
  <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;money&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100</span>
<span class="hljs-punctuation">&#125;</span></code></pre></div><ol start="5" type="1"><li><p><code>RM</code>执行业务SQL，提交本地事务，释放数据库锁。此时 money = 90</p></li><li><p><code>RM</code>报告本地事务状态给<code>TC</code></p></li></ol><p><strong>二阶段</strong>：</p><ol type="1"><li><code>TM</code>通知<code>TC</code>事务结束</li><li><code>TC</code>检查分支事务状态<ol type="1"><li>如果都成功，则立即删除快照</li><li>如果有分支事务失败，需要回滚。读取快照数据（{"id": 1, "money": 100}），将快照恢复到数据库。此时数据库再次恢复为100</li></ol></li></ol><p>流程图如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206114246134-2025-2-611:42:47.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><h4 id="at与xa的区别">AT与XA的区别</h4><p>简述<code>AT</code>模式与<code>XA</code>模式最大的区别是什么？</p><ul><li><code>XA</code>模式一阶段不提交事务，锁定资源；<code>AT</code>模式一阶段直接提交，不锁定资源。</li><li><code>XA</code>模式依赖数据库机制实现回滚；<code>AT</code>模式利用数据快照实现数据回滚。</li><li><code>XA</code>模式强一致；<code>AT</code>模式最终一致</li></ul><p>可见，AT模式使用起来更加简单，无业务侵入，性能更好。因此企业90%的分布式事务都可以用AT模式来解决。</p><h4 id="实现-1">实现</h4><ol type="1"><li><p>添加seata-at.sql到微服务对应的数据库中：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206114846418-2025-2-611:48:49.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p></li><li><p>修改application.yml文件，将事务模式修改为AT模式：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206114917923-2025-2-611:49:24.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p></li></ol><h1 id="九mq基础">九、MQ基础</h1><p>​ 微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要<strong>等待</strong>服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们称这种调用方式为<strong>同步调用</strong>，也可以叫<strong>同步通讯</strong>。但在很多场景下，可能需要采用<strong>异步通讯</strong>的方式。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211094833670-2025-2-1110:40:16.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><ul><li>同步通讯：就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话。</li><li>异步通讯：就如同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应。因此你可以多线操作，同时跟多人聊天。</li></ul><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发微信可以同时与多个人收发微信，但是往往响应会有延迟。</p><p>如果我们的业务需要实时得到服务提供方的响应，则应该选择同步通讯（同步调用）。而如果我们追求更高的效率，并且不需要实时响应，则应该选择异步通讯（异步调用）。</p><h2 id="初识mq">9.1、初识MQ</h2><h3 id="同步调用">同步调用</h3><p>目前项目中服务直接的调用都是基于OpenFeign的调用都属于是同步调用，以<strong>余额支付功能</strong>为例来分析，整个服务的流程如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211095334972-2025-2-1109:53:36.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><ul><li>支付服务需要先调用用户服务完成余额扣减</li><li>然后支付服务自己要更新支付流水单的状态</li><li>然后支付服务调用交易服务，更新业务订单状态为已支付</li></ul><p>三个步骤依次执行，其中就存在3个问题：</p><ol type="1"><li><p>拓展性差</p><p>目前的业务相对简单，但是随着业务规模扩大，产品的功能也在不断完善。如果之后添加需求：</p><ul><li><p>用户支付成功后以短信或者其它方式通知用户，告知支付成功。</p></li><li><p>增加积分或金币的概念，用户支付成功后，给用户以积分奖励或者返还金币</p></li><li><p>.....</p></li></ul><p>如果按照以上的服务调用方法，每次有新的需求，现有支付逻辑都要跟着变化，代码经常变动。最终支付业务会越来越臃肿：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211095944590-2025-2-1109:59:45.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></li><li><p>性能下降</p><p>由于采用了同步调用，调用者需要等待服务提供者执行完返回结果后，才能继续向下执行，也就是说每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100207999-2025-2-1110:02:09.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></li><li><p><strong>级联失败</strong></p><p>由于是基于OpenFeign调用交易服务、通知服务。耦合性太高，一个服务失败会影响其他服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。这就是同步调用的<strong>级联失败</strong>问题。</p></li></ol><p>而要解决这些问题，我们就必须用<strong>异步调用</strong>的方式来代替<strong>同步调用</strong>。</p><h3 id="异步调用">异步调用</h3><p>异步调用方式其实就是基于<strong>消息通知</strong>的方式，一般包含三个角色：</p><ul><li>消息发送者：投递消息的人，就是原来的调用方</li><li>消息代理：管理、暂存、转发消息，可以把它理解成微信服务器</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供方</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100551228-2025-2-1110:05:52.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息代理。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。</p><p>这样，发送消息的人和接收消息的人就完全解耦了。</p><p>还是以余额支付业务为例：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100738170-2025-2-1110:07:39.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>除了扣减余额、更新支付流水单状态以外，其它调用逻辑全部取消。而是改为发送一条消息到Broker。而相关的微服务都可以订阅消息通知，一旦消息到达Broker，则会分发给每一个订阅了的微服务，处理各自的业务。</p><p>假如后序增加了新的需求，比如要在支付成功后更新用户积分。支付代码完全不用变更，而仅仅是让积分服务也订阅消息即可：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100924951-2025-2-1110:09:26.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>不管后期增加了多少消息订阅者，作为支付服务来讲，执行问扣减余额、更新支付流水状态后，发送消息即可。业务耗时仅仅是这三部分业务耗时，仅仅100ms，大大提高了业务性能。</p><p>另外，不管是交易服务、通知服务，还是积分服务，他们的业务与支付关联度低。现在采用了异步调用，解除了耦合，他们即便执行过程中出现了故障，也不会影响到支付服务。</p><p>综上，异步调用的优势包括：</p><ul><li>耦合度更低</li><li>性能更好</li><li>业务拓展性强</li><li>故障隔离，避免级联失败</li></ul><p>当然，异步通信也并非完美无缺，它存在下列缺点：</p><ul><li>完全依赖于Broker的可靠性、安全性和性能</li><li>架构复杂，后期维护和调试麻烦</li></ul><h3 id="技术选型">技术选型</h3><p>消息Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为MQ.</p><p>目比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种MQ的对比：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211101237979-2025-2-1110:12:39.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><p>目前国内消息队列使用最多的还是RabbitMQ，再加上其各方面都比较均衡，稳定性也好，因此选择RabbitMQ来学习。</p><h2 id="rabbitmq">9.2、RabbitMQ</h2><p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件，<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">官网地址</a></p><p>RabbitMQ对应的架构如图：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211101950426-2025-2-1110:19:51.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>其中包含几个概念：</p><ul><li><strong><code>publisher</code></strong>：生产者，也就是发送消息的一方</li><li><strong><code>consumer</code></strong>：消费者，也就是消费消息的一方</li><li><strong><code>queue</code></strong>：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li><strong><code>exchange</code></strong>：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li><strong><code>virtual host</code></strong>：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li></ul><h3 id="安装">安装</h3><p>基于Docker来安装RabbitMQ，使用下面的命令即可：</p><div class="code-wrapper"><pre><code class="hljs bash">docker run \
 -e RABBITMQ_DEFAULT_USER=itheima \
 -e RABBITMQ_DEFAULT_PASS=123321 \
 -v mq-plugins:/plugins \
 --name mq \
 --hostname mq \
 -p 15672:15672 \
 -p 5672:5672 \
 --network hm-net\
 -d \
 rabbitmq:3.8-management</code></pre></div><p>在创建MQ镜像时，将其添加到项目的网络<code>hm-net</code>中了。在安装命令中有两个映射的端口：</p><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li></ul><p>安装完成后，我们访问 <code>http://服务器ip:15672</code> 即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。</p><p>登录后即可看到管理控制台总览页面：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211101903956-2025-2-1110:19:05.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h3 id="测试收发消息">测试收发消息</h3><h4 id="交换机">交换机</h4><p>打开Exchanges选项卡，可以看到已经存在很多交换机：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211104959780-2025-2-1110:50:01.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>点击任意交换机，即可进入交换机详情页面。利用控制台中的publish message 发送一条消息：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/未命名绘图-2025-2-1110:54:01.jpg" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>这里是由控制台模拟了生产者发送的消息。由于没有消费者存在，最终消息丢失了，这样说明交换机没有存储消息的能力。</p><h4 id="队列">队列</h4><p>打开<code>Queues</code>选项卡，新建一个队列：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211105803927-2025-2-1110:58:24.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>命名为<code>hello.queue1</code>：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211105928820-2025-2-1110:59:30.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>再以相同的方式，创建一个队列，密码为<code>hello.queue2</code>，最终队列列表如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110016831-2025-2-1111:00:18.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>此时，再次向<code>amq.fanout</code>交换机发送一条消息。会发现消息依然没有到达队列！！</p><p>怎么回事呢？</p><p>发送到交换机的消息，只会路由到与其绑定的队列，因此仅仅创建队列是不够的，我们还需要将其与交换机绑定。</p><h4 id="绑定关系">绑定关系</h4><p>点击<code>Exchanges</code>选项卡，点击<code>amq.fanout</code>交换机，进入交换机详情页，然后点击<code>Bindings</code>菜单，在表单中填写要绑定的队列名称：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110227010-2025-2-1111:02:28.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110313851-2025-2-1111:03:15.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><p>相同的方式，将hello.queue2也绑定到改交换机。最终，绑定结果如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110313851-2025-2-1111:03:15.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><h4 id="发送消息">发送消息</h4><p>再次回到exchange页面，找到刚刚绑定的<code>amq.fanout</code>，点击进入详情页，再次发送一条消息：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110514041-2025-2-1111:05:52.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>回到<code>Queues</code>页面，可以发现<code>hello.queue</code>中已经有一条消息了：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110639183-2025-2-1111:06:52.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>点击队列名称，进入详情页，查看队列详情，点击get message，可以看到消息到达队列了：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211110745382-2025-2-1111:07:52.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>这个时候如果有消费者监听了MQ的<code>hello.queue1</code>或<code>hello.queue2</code>队列，自然就能接收到消息了。</p><h3 id="数据隔离-1">数据隔离</h3><h4 id="用户管理">用户管理</h4><p>点击<code>Admin</code>选项卡，首先会看到RabbitMQ控制台的用户管理界面：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211111205706-2025-2-1111:12:12.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>这里的用户都是RabbitMQ的管理或运维人员。目前只有安装RabbitMQ时添加的<code>admin</code>这个用户。仔细观察用户表格中的字段，如下：</p><ul><li><code>Name</code>：<code>admin</code>，也就是用户名</li><li><code>Tags</code>：<code>administrator</code>，说明<code>admin</code>用户是超级管理员，拥有所有权限</li><li><code>Can access virtual host</code>： <code>/</code>，可以访问的<code>virtual host</code>，这里的<code>/</code>是默认的<code>virtual host</code></li></ul><p>当只搭建一套MQ集群，供多个不同项目同时使用时，为了避免互相干扰， 我们会利用<code>virtual host</code>的隔离特性，将不同项目隔离。一般会做两件事情：</p><ul><li>给每个项目创建独立的运维账号，将管理权限分离。</li><li>给每个项目创建不同的<code>virtual host</code>，将每个项目的数据隔离。</li></ul><h4 id="配置virtual-host">配置virtual host</h4><p>给当前项目创建一个新的用户，命名为<code>hmall</code>：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211112238339-2025-2-1111:22:52.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>此时hmall⽤⼾没有任何 virtual host 的访问权限：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211112640217-2025-2-1111:26:49.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>接下来为hmall用户配置权限</p><p>首先退出当前admin用户，切换到刚刚创建的hmall用户登录，然后点击<code>Virtual Hosts</code>菜单，进入<code>virtual host</code>管理页：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211113429386-2025-2-1111:34:52.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250211113429386"><figcaption aria-hidden="true">image-20250211113429386</figcaption></figure><p>可以看到目前只有一个默认的<code>virtual host</code>，名字为 <code>/</code>。</p><p>为hmall给黑马商城项目创建一个单独的<code>virtual host</code>，而不是使用默认的<code>/</code>。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211113655596-2025-2-1111:37:40.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>创建完成后如图：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211113816684-2025-2-1111:38:18.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>由于我们是登录<code>hmall</code>账户后创建的<code>virtual host</code>，因此回到<code>users</code>菜单，你会发现当前用户已经具备了对<code>/hmall</code>这个<code>virtual host</code>的访问权限了：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211114120125-2025-2-1111:41:22.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>此时，点击页面右上角的<code>virtual host</code>下拉菜单，切换<code>virtual host</code>为 <code>/hmall</code>：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211114221894-2025-2-1111:42:24.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><p>然后再次查看queues选项卡，会发现之前的队列已经看不到了：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211114256298-2025-2-1111:42:57.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><p>这就是基于<code>virtual host</code>的隔离效果。</p><h2 id="springamqp">9.3、SpringAMQP</h2><p>将来开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。</p><p>由于<code>RabbitMQ</code>采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与<code>RabbitMQ</code>交互。并且<code>RabbitMQ</code>官方也提供了各种不同语言的客户端。</p><p>但是，RabbitMQ官方提供的Java客户端编码相对复杂，一般生产环境下我们更多会结合Spring来使用。而Spring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。</p><p>SpringAMQP的<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-amqp/">官方地址</a></p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul><h3 id="导入demo">导入Demo</h3><p><a target="_blank" rel="noopener" href="https://gitee.com/cmyk359/mq-demo">Demo地址</a></p><p>项目结构如图：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211123012687-2025-2-1112:30:25.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250211123012687"><figcaption aria-hidden="true">image-20250211123012687</figcaption></figure><p>包括三部分：</p><ul><li>mq-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><p>在父工程中已经添加了SpringAMQP的相关依赖，子工程中就可以直接使用了。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="快速入门-2">快速入门</h3><p>在之前的案例中，都是经过交换机发送消息到队列。为了测试方便，直接向队列发送消息，跳过交换机。</p><ul><li>publisher直接发送消息到队列</li><li>消费者监听并处理队列中的消息</li></ul><blockquote><p><strong>注意</strong>：这种模式一般测试使用，很少在生产中使用。</p></blockquote><p>为了方便测试，先在控制台新建一个队列：simple.queue。接下来，就可以利用Java代码收发消息了。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211123649911-2025-2-1112:36:52.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="消息发送">消息发送</h4><p>首先配置MQ地址，在<code>publisher</code>服务的<code>application.yml</code>中添加配置：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.181</span><span class="hljs-number">.100</span> <span class="hljs-comment"># 你的虚拟机IP</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span>
    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/hmall</span> <span class="hljs-comment"># 虚拟主机</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">hmall</span> <span class="hljs-comment"># 用户名</span>
    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span> <span class="hljs-comment"># 密码</span></code></pre></div><p>然后在<code>publisher</code>服务中编写测试类<code>SpringAmqpTest</code>，并利用<code>RabbitTemplate</code>实现消息发送：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAmqpTest</span> &#123;
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessage</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-comment">//1.队列名</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;
        <span class="hljs-comment">//2.消息</span>
        <span class="hljs-type">ItemDoc</span> <span class="hljs-variable">itemDoc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemDoc</span>();
        itemDoc.setName(<span class="hljs-string">&quot;测试数据&quot;</span>);
        <span class="hljs-comment">//3.发送</span>
        rabbitTemplate.convertAndSend(queueName,itemDoc);
    &#125;
&#125;</code></pre></div><p>打开控制台，可以看到消息已经发送到队列中：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211124025590-2025-2-1112:40:44.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="消息接收">消息接收</h4><p>首先配置MQ地址，在<code>consumer</code>服务的<code>application.yml</code>中添加配置：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.181</span><span class="hljs-number">.100</span> <span class="hljs-comment"># 你的虚拟机IP</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span>
    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/hmall</span> <span class="hljs-comment"># 虚拟主机</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">hmall</span> <span class="hljs-comment"># 用户名</span>
    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span> <span class="hljs-comment"># 密码</span></code></pre></div><p>然后在<code>consumer</code>服务的<code>com.itheima.consumer.listener</code>包中新建一个类<code>SpringRabbitListener</code>，代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;
    <span class="hljs-comment">// 利用RabbitListener注解来声明要监听的队列信息</span>
    <span class="hljs-comment">// 将来一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</span>
    <span class="hljs-comment">// 可以看到方法体中接收的就是消息体的内容</span>
    <span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueueMessage</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;
        System.out.println(<span class="hljs-string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);
    &#125;
&#125;</code></pre></div><h4 id="测试-3">测试</h4><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息。最终consumer收到消息：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211124457284-2025-2-1112:44:58.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h3 id="workqueues模型">WorkQueues模型</h3><p>Work queues，任务模型。简单来说就是让<strong>多个消费者</strong>绑定到一个队列，共同消费队列中的消息。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211124655817-2025-2-1112:46:56.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p><p>此时就可以使用WorkQueues模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p><p>接下来模拟WorkQueue，实现一个队列绑定多个消费者</p><p>基本思路如下：</p><ol type="1"><li>在RabbitMQ的控制台创建一个队列，名为work.queue</li><li>在publisher服务中定义测试方法，发送50条消息到work.queue</li><li>在consumer服务中定义两个消息监听者，都监听work.queue队列</li></ol><p>首先，我们在控制台创建一个新的队列，命名为<code>work.queue</code>：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211125033080-2025-2-1112:50:34.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="消息发送-1">消息发送</h4><p>循环发送消息，模拟大量消息堆积现象。在publisher服务中的SpringAmqpTest类中添加一个测试方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">     * workQueue</span>
<span class="hljs-comment">     * 向队列中不停发送消息，模拟消息堆积。</span>
<span class="hljs-comment">     */</span>
<span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWorkQueue</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;
    <span class="hljs-comment">// 队列名称</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;
    <span class="hljs-comment">// 消息</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, message_&quot;</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;
        <span class="hljs-comment">// 发送消息，每20毫秒发送一次，相当于每秒发送50条消息</span>
        rabbitTemplate.convertAndSend(queueName, message + i);
        Thread.sleep(<span class="hljs-number">20</span>);
    &#125;
&#125;</code></pre></div><h1 id="十mq高级">十、MQ高级</h1><h1 id="十一elasticsearch">十一、Elasticsearch</h1><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="category-chain-item">微服务</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>微服务</div><div>https://catpaws.top/460c1130/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年2月5日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://catpaws.top/blog-resource/twikoo1.6.42/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本站由<img src="/img/upyun_logo.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="width:auto;height:auto">提供CDN加速/云存储服务</a></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备2025059828号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61032302000087" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="police-icon"> <span>陕公网安备61032302000087号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//catpaws.top/blog-resource/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="//catpaws.top/blog-resource/js/loader.js"></script><script src="//catpaws.top/blog-resource/js/blurpicload.js"></script><script src="//catpaws.top/blog-resource/js/axios.min.js"></script><script src="/js/boot.js"></script><!DOCTYPE html><html><head><style>#matechat-iframe-container{position:fixed;top:0;left:0;width:100%;height:100%;z-index:10000;opacity:0;visibility:hidden;transition:opacity .3s ease,visibility .3s ease}#matechat-iframe-container.active{opacity:1;visibility:visible}.matechat-iframe{width:100%;height:100%;border:none;background:#fff}#matechat-iframe-container.active .matechat-close-btn{opacity:1}body.matechat-open{overflow:hidden}</style></head><body><div id="matechat-iframe-container"><iframe class="matechat-iframe" src="https://chat.catpaws.top" allow="microphone" title="芙芙来帮你"></iframe></div><script>document.addEventListener("DOMContentLoaded",(function(){const e=document.getElementById("oml2d-stage"),t=document.getElementById("matechat-iframe-container");function n(){t.classList.remove("active"),document.body.classList.remove("matechat-open")}e?t?(e.addEventListener("click",(function(){t.classList.add("active"),document.body.classList.add("matechat-open")})),document.addEventListener("keydown",(function(e){"Escape"===e.key&&n()})),window.addEventListener("message",(function(e){"closeMateChat"!==e.data&&"close"!==e.data.type||n()})),t.addEventListener("click",(function(e){e.target===this&&n()}))):console.error("matechat-iframe-container 元素未找到"):console.error("oml2d-stage 元素未找到")}))</script><script data-pjax src="https://catpaws.top/blog-resource/live2d/index.min.js"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"https://catpaws.top/blog-resource/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"}}})</script></body></html><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>