<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><link rel="icon" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="1、什么时候考虑使用哈希表？  需要频繁检查某个元素是否在数据集中出现过，或者需要确保元素唯一性。 根据元素特征进行分类 需要统计元素（数字、字符、字符串、对象等）出现的次数。 需要存储元素与其位置（下标、路径、状态等）的映射关系，以便后续快速访问。 需要求交集、并集、差集，或者判断子集关系。 需要建立两组对象之间的对应关系，或者需要存储子问题的结果以避免重复计算（动态规划、递归"><meta property="og:type" content="article"><meta property="og:title" content="三、哈希表"><meta property="og:url" content="https://catpaws.top/4f3efbd5/index.html"><meta property="og:site_name" content="猫爪在上の书桌"><meta property="og:description" content="1、什么时候考虑使用哈希表？  需要频繁检查某个元素是否在数据集中出现过，或者需要确保元素唯一性。 根据元素特征进行分类 需要统计元素（数字、字符、字符串、对象等）出现的次数。 需要存储元素与其位置（下标、路径、状态等）的映射关系，以便后续快速访问。 需要求交集、并集、差集，或者判断子集关系。 需要建立两组对象之间的对应关系，或者需要存储子问题的结果以避免重复计算（动态规划、递归"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240806111930840-2024-8-611:19:34.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250715121347398-2025-7-1512:14:06.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250727092355124-2025-7-2709:23:56.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250716104724873-2025-7-1610:47:30.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250716105421644-2025-7-1610:55:04.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250716111718395-2025-7-1611:17:22.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250727103531203-2025-7-2710:35:36.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250727104003050-2025-7-2710:40:04.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250729103216117-2025-7-2910:32:27.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250729110716530-2025-7-2911:07:18.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250729111742354-2025-7-2911:17:54.png"><meta property="article:published_time" content="2025-07-15T02:34:44.000Z"><meta property="article:modified_time" content="2025-09-14T02:12:46.953Z"><meta property="article:author" content="猫爪在上"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240806111930840-2024-8-611:19:34.png"><title>三、哈希表 - 猫爪在上の书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/font.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/poem.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/cursor.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/loader.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/twikoo_beautify.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/indeximg-hover.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/wave-1.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/blurpicload.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/reward/iconfont.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/switch.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"https://catpaws.top/blog-resource/imgs/transparent.svg",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://leancloud.catpaws.top",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="wrapper"></div><div id="loader-container"><div class="loader"><div class="wrapper"><div class="catContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 733 673" class="catbody"><path fill="#212121" d="M111.002 139.5C270.502 -24.5001 471.503 2.4997 621.002 139.5C770.501 276.5 768.504 627.5 621.002 649.5C473.5 671.5 246 687.5 111.002 649.5C-23.9964 611.5 -48.4982 303.5 111.002 139.5Z"></path><path fill="#212121" d="M184 9L270.603 159H97.3975L184 9Z"></path><path fill="#212121" d="M541 0L627.603 150H454.397L541 0Z"></path></svg> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 158 564" class="tail"><path fill="#191919" d="M5.97602 76.066C-11.1099 41.6747 12.9018 0 51.3036 0V0C71.5336 0 89.8636 12.2558 97.2565 31.0866C173.697 225.792 180.478 345.852 97.0691 536.666C89.7636 553.378 73.0672 564 54.8273 564V564C16.9427 564 -5.4224 521.149 13.0712 488.085C90.2225 350.15 87.9612 241.089 5.97602 76.066Z"></path></svg><div class="text"><span class="bigzzz">Z</span> <span class="zzz">Z</span></div></div><div class="wallContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 500 126" class="wall"><line stroke-width="6" stroke="#7C7C7C" y2="3" x2="450" y1="3" x1="50"></line><line stroke-width="6" stroke="#7C7C7C" y2="85" x2="400" y1="85" x1="100"></line><line stroke-width="6" stroke="#7C7C7C" y2="122" x2="375" y1="122" x1="125"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="500" y1="43"></line><line stroke-width="6" stroke="#7C7C7C" y2="1.99391" x2="115.5" y1="43.0061" x1="115.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00002" x2="189" y1="43.0122" x1="189"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00612" x2="262.5" y1="43.0183" x1="262.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01222" x2="336" y1="43.0244" x1="336"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01833" x2="409.5" y1="43.0305" x1="409.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="153" y1="84.0122" x1="153"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="228" y1="84.0122" x1="228"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="303" y1="84.0122" x1="303"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="378" y1="84.0122" x1="378"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="192" y1="125.012" x1="192"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="267" y1="125.012" x1="267"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="342" y1="125.012" x1="342"></line></svg></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上の书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>个人主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://catpaws.top/blog-resource/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="三、哈希表"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-07-15 10:34" pubdate>2025年7月15日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.8k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 32 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">三、哈希表</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年9月14日 上午</p><div class="markdown-body"><meta name="referrer" , content="no-referrer"><p>1、什么时候考虑使用哈希表？</p><ul><li>需要频繁检查某个元素是否在数据集中出现过，或者需要确保元素唯一性。</li><li>根据元素特征进行分类</li><li>需要统计元素（数字、字符、字符串、对象等）出现的次数。</li><li>需要存储元素与其位置（下标、路径、状态等）的映射关系，以便后续快速访问。</li><li>需要求交集、并集、差集，或者判断子集关系。</li><li>需要建立两组对象之间的对应关系，或者需要存储子问题的结果以避免重复计算（动态规划、递归优化）</li></ul><hr><p>2、哪些数据结构可以做哈希表？</p><ul><li>数组</li><li>set集合</li><li>map集合</li></ul><div class="note note-info"><p>当值的范围较小时使用数组，直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的。</p><p>当没有规定值的范围时，应该采用HashSet，如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。在此基础上既要保存值又要保存其出现的位置、次数等时，应使用HashMap。</p></div><h2 id="有效的字母异位词"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">有效的字母异位词</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240806111930840-2024-8-611:19:34.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><blockquote><p><code>s</code> 和 <code>t</code> 仅包含小写字母</p></blockquote><p>思路：字符串中都是小写字母 a ~ z，用数组当哈希表，a对应数组下标0，b对应数组下标1，以此类推。先遍历第一个字符串，对每个字符在哈希表中的值+1，再遍历第二个字符串，对每个字符在哈希表中的值-1；最后若哈希表中元素全为0，则为有效的字母异位词。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(String s, String t)</span> &#123;
    <span class="hljs-keyword">if</span> (s.length() != t.length()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//长度不同，一定不是</span>
    <span class="hljs-type">int</span> tags[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>]; <span class="hljs-comment">//数组元素默认初始化为0</span>
    <span class="hljs-type">char</span>[] chars_s = s.toCharArray();
    <span class="hljs-type">char</span>[] chars_t = t.toCharArray();

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars_s.length; i++) &#123;
        tags[chars_s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] ++;
    &#125;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; chars_t.length; i++) &#123;
        tags[chars_t[i] - <span class="hljs-string">&#x27;a&#x27;</span>] --;
    &#125;

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tags.length; i++) &#123;
        <span class="hljs-keyword">if</span> (tags[i] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div><h2 id="字母异位词分组"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">字母异位词分组</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250715121347398-2025-7-1512:14:06.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：每组的异位词都有共同点：每组中的字符串只是字母顺序不同，但对应的字母个数相同，在遍历字符串数组的时候就可以根据这个共同点进行分类。<strong>一旦需要根据特征分类，就需要考虑散列表</strong>。<strong>以共同特征为键，以具有共同特征的元素集合为值。</strong></p><ul><li><p>对于同组的字符串，若对字母进行排序后，会得到相同的结果。故散列表的键可以选为排序后的字符串。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;
    Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (String str : strs) &#123;
        <span class="hljs-type">char</span>[] chars = str.toCharArray();
        Arrays.sort(chars);
        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);
        List&lt;String&gt; list = map.getOrDefault(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;());
        list.add(str);
        map.put(key, list);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());
&#125;</code></pre></div></li><li><p>同组中的每个字符串所含对应的字母个数相同，统计每个字符串中各个字母的个数并组成字符串，作为哈希表的键。如"eat"对应的键为"100010...010...0"</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;
        Map&lt;String, List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, List&lt;String&gt;&gt;();
        <span class="hljs-keyword">for</span> (String str: strs) &#123;
            <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];
            <span class="hljs-type">char</span>[] chars = str.toCharArray();
            <span class="hljs-comment">//统计字母个数</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : chars) 
                count[c -<span class="hljs-string">&#x27;a&#x27;</span>]++;
            <span class="hljs-comment">//构造key</span>
            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : count) &#123;
                sb.append((<span class="hljs-type">char</span>)num);
                sb.append(<span class="hljs-string">&quot;#&quot;</span>);      
            &#125;  
            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> sb.toString();
            List&lt;String&gt; list = map.getOrDefault(key,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;());
            list.add(str);
            map.put(key,list);
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;String&gt;&gt;(map.values());
    &#125;
&#125;</code></pre></div></li></ul><h2 id="两个数组的交集"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">两个数组的交集</a></h2><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 它们的 <u>交集</u>。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以不考虑输出结果的顺序 。</p><p>思路：</p><ul><li>由于交集中每个元素是唯一的，故需要使用哈希表保存结果，并进行<strong>去重</strong>。先将数组一的值都放到哈希表中，再遍历数组二的每个元素，判断是否在哈希表中存在，若存在则放入结果（不重复放入）。</li><li>由于题中规定了元素值的范围为1000以内，可以使用数组来充当哈希表。</li></ul><div class="code-wrapper"><pre><code class="hljs java">===========================使用数组==========================
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;
        <span class="hljs-type">int</span>[] hash1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1002</span>];
        <span class="hljs-type">int</span>[] hash2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1002</span>];
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums1)
            hash1[i]++;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i : nums2)
            hash2[i]++;
        List&lt;Integer&gt; resList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1002</span>; i++)
            <span class="hljs-keyword">if</span>(hash1[i] &gt; <span class="hljs-number">0</span> &amp;&amp; hash2[i] &gt; <span class="hljs-number">0</span>)
                resList.add(i);
        <span class="hljs-keyword">return</span> resList.stream().mapToInt(x-&gt;x).toArray();
    &#125;
&#125;
========================使用HashSet==============================
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] intersection(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2) &#123;
        HashSet&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
        HashSet&lt;Integer&gt; resultSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();

        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums1) 
            set1.add(i);
        
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : nums2) 
            <span class="hljs-keyword">if</span> (set1.contains(j)) 
                resultSet.add(j);
        
        <span class="hljs-keyword">return</span> resultSet.stream().mapToInt(x -&gt; x).toArray();
    &#125;
&#125;</code></pre></div><h2 id="快乐数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/">快乐数</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250727092355124-2025-7-2709:23:56.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p><strong>关键：找出过程中重复的数字，避免进入循环。</strong></p><ul><li><p>方法一：集合法</p><p>初始化HashSet，将n放入集合中，将当前数字每个位置的平方和加入集合。重复求各个位置平方和以及加入集合的操作，直至出现1时，返回true；或者，新数字已经在集合中存在时，返回false</p><p>复杂度分析：假设从 n 到 1 或无限循环重复的第一个数一共需要经过 x 步变换，则时间复杂度为<span class="math inline">\(O(x)\)</span>，空间复杂度为：<span class="math inline">\(O(x)\)</span>，<u>其所需空间可能大到无法存储</u>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//递归</span>
<span class="hljs-keyword">private</span> Set&lt;Integer&gt; flag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();

<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (flag.contains(n))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    flag.add(n);
    <span class="hljs-type">int</span> <span class="hljs-variable">part</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, nextNum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;
        part = n % <span class="hljs-number">10</span>;
        n = n / <span class="hljs-number">10</span>;
        nextNum += part * part;
    &#125;
    <span class="hljs-keyword">return</span> isHappy(nextNum);
&#125;

<span class="hljs-comment">//迭代</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;
    Set&lt;Integer&gt; flags = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span>) &#123;
        flags.add(n);
        <span class="hljs-type">int</span> <span class="hljs-variable">part</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, nextN = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;
            part = n % <span class="hljs-number">10</span>;
            nextN += part * part;
            n = n / <span class="hljs-number">10</span>;
        &#125;
        n = nextN;
        <span class="hljs-keyword">if</span> (flags.contains(n)) 
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//进入无限循环</span>
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div></li></ul><p>方法二：双指针法</p><p>把转换过程中的每一个数看作单链表的一个节点，将1看作单链表的最后一个元素，如果无法从n转换为 1，说明单链表中存在环。</p><p>使用<strong>快慢指针</strong>slow和fast进行有无环的判断。当slow不等于fast时，<strong>slow每次转化一次，fast每次转化两次</strong>；当slow等于fast时，若slow为1，则是快乐数，否则不是。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250716104724873-2025-7-1610:47:30.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>复杂度分析：假设从 n 到 1 或无限循环重复的第一个数一共需要经过 x 步变换，则时间复杂度为<span class="math inline">\(O(x)\)</span>，空间复杂度为：<span class="math inline">\(O(1)\)</span>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> n, fast = n;
    <span class="hljs-keyword">do</span> &#123;
        slow = convert(slow);
        fast = convert(convert(fast));
    &#125;<span class="hljs-keyword">while</span>(slow != fast);

    <span class="hljs-keyword">return</span> slow == <span class="hljs-number">1</span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">convert</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">part</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, nextN = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;
        part = n % <span class="hljs-number">10</span>;
        nextN += part * part;
        n = n / <span class="hljs-number">10</span>;
    &#125;
    <span class="hljs-keyword">return</span> nextN;
&#125;</code></pre></div><h2 id="两数之和"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">两数之和</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250716105421644-2025-7-1610:55:04.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：遍历数组，<u>记录已经遍历过的元素</u>，同时判断当前元素的剩余部分是否存在（是否已经遍历过），若存在，则返回这两数的下标。由于要查找当前元素是否存在，且同时可以得到所在下标，故使用<strong>HashMap</strong>作为哈希表，<u>元素值作为key，下标作为value</u>。</p><blockquote><p>补充：由于是在已遍历过的元素中查找另一半，若当前元素的另一半存在且未遍历到，那么当之后遍历到另一半时，仍会找到这一组有效的组合。如target是6，nums中有2和4，且4在2后，当遍历到2时，已遍历到的元素中没有4，先不返回结果。当遍历到4时就会在已遍历元素中找到2，此时再返回。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;
    <span class="hljs-type">int</span> res[]  = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];
    Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">part</span> <span class="hljs-operator">=</span> target - nums[i];
        <span class="hljs-comment">//在已遍历到的集合中查找另一半</span>
        <span class="hljs-keyword">if</span> ( map.containsKey(part)) &#123;
            res[<span class="hljs-number">0</span>] = i;
            res[<span class="hljs-number">1</span>] = map.get(part);
            <span class="hljs-keyword">break</span>;
        &#125;
        map.put(nums[i],i);
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h2 id="四数相加-ii"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">四数相加 II</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250716111718395-2025-7-1611:17:22.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：</p><ul><li><p>暴力解法就是同时处理四个数组，使用四个for循环，时间复杂度太高。</p></li><li><p>换一种思路：对应第一个数组中每个元素x，判断是否能在剩余三个数组中各取一个元素找到之和为 -x的组合，这个组合出现了多少次，若-x的组合出现了 n次，则已经找了n个满足条件的元组。一次统计三个数组中是否有和为-x的组合，需要使用三个for循环，时间复杂度为<span class="math inline">\(O(n^3)\)</span>。</p><p>由于既要保存值，值的大小未知，且还要保存这个值出现的次数，故使用HashMap作为哈希表。</p></li><li><p>再进一步优化，<strong>可以将四个数组两两分为一组，先将前两个数组中各元素的和以及出现的次数用HashMap保存起来，再计算后两个数组元素的和（若为x），则在哈希表中查找是否有值为-x的组合</strong>，若存在则最终符合的元组数+=-x出现的次数。</p></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fourSumCount</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span>[] nums3, <span class="hljs-type">int</span>[] nums4)</span> &#123;
    Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
    <span class="hljs-type">int</span> sum, sum_c;
    <span class="hljs-comment">//统计nums1和nums2中各元素的和及其出现次数</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums1) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : nums2) &#123;
            sum = i + j;
            sum_c = map.getOrDefault(sum, <span class="hljs-number">0</span>);
            map.put(sum, sum_c + <span class="hljs-number">1</span>);
            <span class="hljs-comment">//map.put(i + j, map.getOrDefault(i + j, 0) + 1)</span>
        &#125;
    &#125;

    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//记录最终满足条件的元组个数</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : nums3) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : nums4) &#123;
            count += map.getOrDefault(<span class="hljs-number">0</span>-i-j, <span class="hljs-number">0</span>);
        &#125;
    &#125;

    <span class="hljs-keyword">return</span> count;
&#125;</code></pre></div><h2 id="三数之和"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">三数之和</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250727103531203-2025-7-2710:35:36.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>题目要求结果中不能包含重复的三元组，关键是<strong>去重</strong>。</p><p>思路：</p><p>1、哈希法。先使用两层for循环记录数组中两个元素a+b的值，再使用哈希法确定0-(a+b)是否在数组中出现过。但是这种方法会产生重复的三元组，根据题目要求，需要进行去重。</p><p>去重逻辑：</p><ul><li>第一个数的去重，由于数组已排序，相同数字相邻，当当前数与前一数相同时，跳过当前循环</li><li>使用set作为哈希表，并存储已遍历的第二个数，自动过滤重复值，对第二个数去重</li><li>第三个数由<code>complement = -nums[i] - nums[j]</code>计算得出，由前两个数唯一确定</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;
        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        Arrays.sort(nums); <span class="hljs-comment">// 关键：排序是去重的基础</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;
        
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">2</span>; i++) &#123;
            <span class="hljs-comment">// 第一个数去重：跳过重复值</span>
            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;
            
            Set&lt;Integer&gt; seen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(); <span class="hljs-comment">// 哈希表：存储第二个数</span>
            
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;
                <span class="hljs-type">int</span> <span class="hljs-variable">complement</span> <span class="hljs-operator">=</span> -nums[i] - nums[j]; <span class="hljs-comment">// 计算第三个数</span>
                
                <span class="hljs-comment">// 检查第三个数是否在哈希表中</span>
                <span class="hljs-keyword">if</span> (seen.contains(complement)) &#123;
                    result.add(Arrays.asList(nums[i], complement, nums[j]));
                &#125;
                seen.add(nums[j]); <span class="hljs-comment">// 将当前数加入哈希表</span>
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> result;
    &#125;</code></pre></div><hr><p>2、双指针法。首先对数组排序，然后有一层for循环，i从下标0的地方开始，同时将一个下标left定义在i+1的位置上，将下标right定义在数组结尾的位置上。</p><p>还是在数组中找到三个数a、b、c，使得a+b+c=0，这里相当于a=nums[i]、b=nums[left]、c=nums[right]。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250727104003050-2025-7-2710:40:04.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>如何移动left和right呢？</p><ul><li>如果nums[i] + nums[left] + nums[right] &gt; 0 ，说明 此时三数之和大了，因为数组排过序了，所以right下标就应该向左移动，这样才能让三数之和小一些。</li><li>如果 nums[i] + nums[left] + nums[right] &lt; 0 ，说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些。</li><li>如果 nums[i] + nums[left] + nums[right] = 0 ，说明找到了一个符合条件的三元组，<strong>将其加入结果集并对b 和 c进行去重。</strong></li><li>直到left与right相遇为止。</li></ul><p>去重逻辑分析</p><ul><li><p>对第一个数字a的去重，判断逻辑为<code>i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]</code>，若它与前一个元素相同则跳过。由于组成元组的值可以重复（只要他们是不同的数组元素），若将判断逻辑改为<code>nums[i] == nums[i+1]</code> ，因为left就等于i+1，此时相当于判断元组中是否由值相等的元素，有就跳过，这会漏掉符合条件的元组，如(-1, -1, 2)</p></li><li><p>对于第二、三个数字b和c的去重。当收集了一个元组后，需要<strong>持续移动</strong>left和right跳过相同的数字防止重复。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250729103216117-2025-7-2910:32:27.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//判断条件中要有 left &lt; right，防止在某些情况下（如：-2，1，1，1，1），left直接移动到末尾或right移动到首部</span>
<span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])
    left++; <span class="hljs-comment">//left去重,跳过右侧相同的元素</span>

<span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])
    right--; <span class="hljs-comment">//right去重，跳过左侧相同的元素</span></code></pre></div></li></ul><p>完整代码：</p><div class="code-wrapper"><pre><code class="hljs python">public static <span class="hljs-type">List</span>&lt;<span class="hljs-type">List</span>&lt;Integer&gt;&gt; threeSum(<span class="hljs-built_in">int</span>[] nums) &#123;
    Arrays.sort(nums); //升序排序
    <span class="hljs-type">List</span>&lt;<span class="hljs-type">List</span>&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
    
    <span class="hljs-built_in">int</span> left, right;
    //判断 i、left、right三个位置相加是否为<span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
        <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; //数组值递增
        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>; //i位置去重
        left = i + <span class="hljs-number">1</span>;
        right = nums.length - <span class="hljs-number">1</span>;
        //left不断向右移动，right不断向左移动
        <span class="hljs-keyword">while</span> (left &lt; right) &#123;
            <span class="hljs-built_in">int</span> <span class="hljs-built_in">sum</span> =  nums[i] + nums[left] + nums[right];
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &lt; <span class="hljs-number">0</span>) left++; // 和太小，将left右移
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sum</span> &gt; <span class="hljs-number">0</span>) right--; //和太大，将right左移
            <span class="hljs-keyword">else</span> &#123; // 和为<span class="hljs-number">0</span>，收集结果
                  result.add(Arrays.asList(nums[i],nums[left],nums[right]));

                  // 对b 和 c的重逻辑应该放在找到一个三元组之后
                  <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>])
                  left++; //left去重,跳过右侧相同的元素
                  <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>])
                  right--; //right去重，跳过左侧相同的元素

                  left++;
                  right--;
                 &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> result;
&#125;</code></pre></div><h2 id="四数之和"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">四数之和</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250729110716530-2025-7-2911:07:18.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>四数之和，和三数之和是一个思路，都是使用双指针法, 基本解法就是在三数之和的基础上<strong>再套一层for循环</strong>。</p><p>与三数之和不同，target并不固定为0，而是输入的指定值。进行剪枝时，策略有所变化：</p><ul><li>对i进行剪枝时，只满足 nums[i] &gt; target 并不能pass掉这个元组，若nums[i] &lt; 0 ,可能与后面某些数相加会变小，也可能变为target。需要同时满足<code>nums[i] &gt; 0</code> 和 <code>nums[i] &gt; targe</code>才可以排除这个数字。</li><li>对j进行剪枝时，要用<code>nums[i]+nums[j]</code>作为一个整体来和target比较，与i的剪枝策略相同，需要满足<code>nums[i] + nums[j] &gt; 0 &amp;&amp; nums[i] + nums[j] &gt; target</code></li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250729111742354-2025-7-2911:17:54.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">fourSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;
    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    Arrays.sort(nums);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;
        <span class="hljs-comment">//i的剪枝</span>
        <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt; target) <span class="hljs-keyword">break</span>;
        <span class="hljs-comment">//i的去重</span>
        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;
            <span class="hljs-comment">//内部循环与三数之和逻辑基本相同</span>
            <span class="hljs-comment">//j的剪枝</span>
            <span class="hljs-keyword">if</span> (nums[i] + nums[j] &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] + nums[j] &gt; target) <span class="hljs-keyword">break</span>;
            <span class="hljs-comment">//j的去重</span>
            <span class="hljs-keyword">if</span> (j &gt; i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;
            <span class="hljs-comment">//双指针移动寻找符合条件的四元组</span>
            <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> j + <span class="hljs-number">1</span>, right = nums.length - <span class="hljs-number">1</span>;
            <span class="hljs-keyword">while</span> (left &lt; right) &#123;
                <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[i] + nums[j] + nums[left] + nums[right];
                <span class="hljs-keyword">if</span> (sum &gt; target) right --;
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; target) left ++;
                <span class="hljs-keyword">else</span> &#123;
                    result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));

                    <span class="hljs-comment">//left和right的去重</span>
                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;
                    <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;
                    left++;
                    right--;
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> result;
&#125;</code></pre></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/leetcode/" class="category-chain-item">leetcode</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>三、哈希表</div><div>https://catpaws.top/4f3efbd5/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年7月15日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/36b020a8/" title="四、字符串"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">四、字符串</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/f6253398/" title="Dubbo"><span class="hidden-mobile">Dubbo</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://catpaws.top/blog-resource/twikoo1.6.42/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本站由<img src="/img/upyun_logo.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="width:auto;height:auto">提供CDN加速/云存储服务</a></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备2025059828号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61032302000087" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="police-icon"> <span>陕公网安备61032302000087号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//catpaws.top/blog-resource/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="//catpaws.top/blog-resource/js/loader.js"></script><script src="//catpaws.top/blog-resource/js/blurpicload.js"></script><script src="//catpaws.top/blog-resource/js/axios.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://catpaws.top/blog-resource/live2d/index.min.js"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"https://catpaws.top/blog-resource/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"}}})</script></body></html>