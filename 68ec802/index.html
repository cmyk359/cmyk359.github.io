<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://catpaws.top/blog-resource/imgs/webicon.png"><link rel="icon" href="https://catpaws.top/blog-resource/imgs/webicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="image-20240509183750447  一、maven 1.1、概述 Maven是apache旗下的一个开源项目，是一款用于管理和构建java项目的工具。 作用：  依赖管理。方便快捷的管理项目依赖的资源（jar包），避免版本冲突问题。只需将要使用的jar包的依赖加入pom.xml中，maven会自动下载导入，方便对其进行管理 统一项目结构。提供标准、统一的项"><meta property="og:type" content="article"><meta property="og:title" content="JavaWeb基础（二）后端相关"><meta property="og:url" content="https://catpaws.top/68ec802/index.html"><meta property="og:site_name" content="猫爪在上de书桌"><meta property="og:description" content="image-20240509183750447  一、maven 1.1、概述 Maven是apache旗下的一个开源项目，是一款用于管理和构建java项目的工具。 作用：  依赖管理。方便快捷的管理项目依赖的资源（jar包），避免版本冲突问题。只需将要使用的jar包的依赖加入pom.xml中，maven会自动下载导入，方便对其进行管理 统一项目结构。提供标准、统一的项"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240501100246270-2024-5-918:50:55.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240501100401906-2024-5-918:51:02.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240501114000111-2024-5-918:51:58.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240501191754933-2024-5-918:52:11.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20241209153920637-2024-12-915:39:21.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20241209154118637-2024-12-915:41:19.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20241209154458280-2024-12-915:45:15.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20241209155024205-2024-12-915:50:40.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20241209161110433-2024-12-916:11:40.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20241209163302625-2024-12-916:33:03.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240506100818823-2024-5-918:56:37.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240506230923099-2024-5-919:03:10.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240507104834966-2024-5-919:03:49.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240509213323666-2024-5-921:33:46.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20230113151533948-2024-5-923:53:24.png"><meta property="article:published_time" content="2024-12-09T04:25:40.000Z"><meta property="article:modified_time" content="2024-12-11T13:17:28.428Z"><meta property="article:author" content="猫爪在上"><meta property="article:tag" content="Spring"><meta property="article:tag" content="Springboot原理"><meta property="article:tag" content="IOC"><meta property="article:tag" content="DI"><meta property="article:tag" content="MyBatis"><meta property="article:tag" content="Maven"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240501100246270-2024-5-918:50:55.png"><title>JavaWeb基础（二）后端相关 - 猫爪在上de书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/font.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/poem.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/shubiao.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/loader.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://tntpv22c.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loader-container"><div class="loader"><div class="wrapper"><div class="catContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 733 673" class="catbody"><path fill="#212121" d="M111.002 139.5C270.502 -24.5001 471.503 2.4997 621.002 139.5C770.501 276.5 768.504 627.5 621.002 649.5C473.5 671.5 246 687.5 111.002 649.5C-23.9964 611.5 -48.4982 303.5 111.002 139.5Z"></path><path fill="#212121" d="M184 9L270.603 159H97.3975L184 9Z"></path><path fill="#212121" d="M541 0L627.603 150H454.397L541 0Z"></path></svg> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 158 564" class="tail"><path fill="#191919" d="M5.97602 76.066C-11.1099 41.6747 12.9018 0 51.3036 0V0C71.5336 0 89.8636 12.2558 97.2565 31.0866C173.697 225.792 180.478 345.852 97.0691 536.666C89.7636 553.378 73.0672 564 54.8273 564V564C16.9427 564 -5.4224 521.149 13.0712 488.085C90.2225 350.15 87.9612 241.089 5.97602 76.066Z"></path></svg><div class="text"><span class="bigzzz">Z</span> <span class="zzz">Z</span></div></div><div class="wallContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 500 126" class="wall"><line stroke-width="6" stroke="#7C7C7C" y2="3" x2="450" y1="3" x1="50"></line><line stroke-width="6" stroke="#7C7C7C" y2="85" x2="400" y1="85" x1="100"></line><line stroke-width="6" stroke="#7C7C7C" y2="122" x2="375" y1="122" x1="125"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="500" y1="43"></line><line stroke-width="6" stroke="#7C7C7C" y2="1.99391" x2="115.5" y1="43.0061" x1="115.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00002" x2="189" y1="43.0122" x1="189"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00612" x2="262.5" y1="43.0183" x1="262.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01222" x2="336" y1="43.0244" x1="336"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01833" x2="409.5" y1="43.0305" x1="409.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="153" y1="84.0122" x1="153"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="228" y1="84.0122" x1="228"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="303" y1="84.0122" x1="303"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="378" y1="84.0122" x1="378"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="192" y1="125.012" x1="192"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="267" y1="125.012" x1="267"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="342" y1="125.012" x1="342"></line></svg></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上de书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://catpaws.top/blog-resource/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="JavaWeb基础（二）后端相关"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-12-09 12:25" pubdate>2024年12月9日 中午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 22k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 180 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">JavaWeb基础（二）后端相关</h1><p id="updated-time" class="note note-info">本文最后更新于 2024年12月11日 晚上</p><div class="markdown-body"><meta name="referrer" , content="no-referrer"><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509183750447-2024-5-918:38:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509183750447"><figcaption aria-hidden="true">image-20240509183750447</figcaption></figure><h2 id="一maven">一、maven</h2><h3 id="概述">1.1、概述</h3><p><strong>Maven</strong>是apache旗下的一个开源项目，是一款用于管理和构建java项目的工具。</p><p>作用：</p><ul><li><p>依赖管理。方便快捷的管理项目依赖的资源（jar包），避免版本冲突问题。只需将要使用的jar包的依赖加入<code>pom.xml</code>中，maven会自动下载导入，方便对其进行管理</p></li><li><p>统一项目结构。提供标准、统一的项目结构</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501100246270-2024-5-918:50:55.png" srcset="/img/loading.gif" lazyload alt="image-20240501100246270" style="zoom:80%"></p></li><li><p>项目构建标准跨平台（Linux、Windows、MacOS）的自动化项目构建方式。提供多平台通用的项目构建指令</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501100401906-2024-5-918:51:02.png" srcset="/img/loading.gif" lazyload alt="image-20240501100401906" style="zoom:80%"></p></li></ul><h3 id="安装步骤">1.2、安装步骤</h3><ol type="1"><li><p>下载解压 apache-maven-3.6.1-bin.zip</p></li><li><p>配置本地仓库：修改 conf/settings.xml 中的 <code>&lt;localRepository&gt;</code>为一个指定目录。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>E:\develop\apache-maven-3.6.1\mvn_repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre></div></li><li><p>配置阿里云私服：修改 conf/settings.xml 中的 <code>&lt;mirrors&gt;</code>标签，为其添加如下子标签：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre></div></li><li><p>配置环境变量：MAVEN_HOME 为maven的解压目录，并将其bin目录加入PATH环境变量。</p></li></ol><h3 id="在idea中配置maven环境">1.3、在idea中配置Maven环境</h3><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501102342977-2024-5-918:51:05.png" srcset="/img/loading.gif" lazyload alt="image-20240501102342977"><figcaption aria-hidden="true">image-20240501102342977</figcaption></figure><h3 id="maven坐标">1.4、Maven坐标</h3><ul><li><p>什么是坐标</p><ul><li>Maven 中的坐标是<strong>资源的唯一标识，通过该坐标可以唯一定位资源位置。</strong></li><li>使用坐标来定义项目或引入项目中需要的依赖。</li></ul></li><li><p>Maven坐标主要组成</p><ul><li>groupld：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</li><li>artifactld：定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）</li><li>version：定义当前项目版本号</li></ul><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">groupld</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupld</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">artifactid</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactid</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li></ul><h3 id="idea导入maven项目">1.5、IDEA导入Maven项目</h3><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501105109534-2024-5-918:51:09.png" srcset="/img/loading.gif" lazyload alt="image-20240501105109534"><figcaption aria-hidden="true">image-20240501105109534</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501105243121-2024-5-918:51:15.png" srcset="/img/loading.gif" lazyload alt="image-20240501105243121"><figcaption aria-hidden="true">image-20240501105243121</figcaption></figure><h3 id="依赖管理">1.6、依赖管理</h3><h4 id="依赖配置">依赖配置</h4><p>依赖：当前项目运行所需要的jar包，一个项目中可以引入多个依赖。</p><p>配置：</p><ol type="1"><li>在 pom.xml 中编写 <code>&lt;dependencies&gt;</code>标签</li><li>在<code>&lt;dependencies&gt;</code> 标签中使用<code>&lt;dependency&gt;</code> 引入坐标</li><li>定义坐标的groupld，artifactld，version</li></ol><p>​ 需要什么依赖就去 <a target="_blank" rel="noopener" href="https://mvnrepository.com/">Maven仓库</a>搜索下载对应的依赖，添加到pox.xml文件的<code>&lt;dependencies&gt;</code>中，maven会下载导入该依赖。如：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven_project_01<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    
	<span class="hljs-comment">&lt;!--    将依赖在这里添加--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p>​</p><h4 id="依赖传递">依赖传递</h4><p>依赖具有传递性：</p><ul><li>直接依赖：在当前项目中通过依赖配置建立的依赖关系</li><li>间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源</li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209150346440-2024-12-915:04:23.png" srcset="/img/loading.gif" lazyload alt="image-20241209150346440"><figcaption aria-hidden="true">image-20241209150346440</figcaption></figure><p>排除依赖：</p><p>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本。projectA不想使用projectB中的某个依赖时，可以使用<code>&lt;exclusions&gt;</code>排除依赖</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209150632297-2024-12-915:06:33.png" srcset="/img/loading.gif" lazyload alt="image-20241209150632297"><figcaption aria-hidden="true">image-20241209150632297</figcaption></figure><h4 id="依赖范围">依赖范围</h4><p>依赖的jar包，默认情况下，可以在任何地方使用。可以通过<code>&lt;scope&gt;...&lt;/scope&gt;</code>设置其作用范围。</p><p>作用范围：</p><ul><li>主程序范围有效。（main文件夹范围内）</li><li>测试程序范围有效。（test文件夹范围内）</li><li>是否参与打包运行。（package指令范围内）</li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209150812630-2024-12-915:08:13.png" srcset="/img/loading.gif" lazyload alt="image-20241209150812630"><figcaption aria-hidden="true">image-20241209150812630</figcaption></figure><h4 id="生命周期">生命周期</h4><p>Maven的生命周期就是为了对所有的maven项目构建过程进行抽象和统一。</p><p>Maven中有3套<strong>相互独立</strong>的生命周期：</p><ul><li>clean：清理工作。</li><li>default：核心工作，如：编译、测试、打包、安装、部署等。</li><li>site：生成报告、发布站点等。</li></ul><p>每套生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段。</p><blockquote><p>在同一套生命周期中，当运行后面的阶段时，前面的阶段都会运行。</p><p>如：运行package阶段会运行之前的compile和test阶段，并不会运行clean阶段，因为它们属于不同的生命周期</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209151204171-2024-12-915:12:10.png" srcset="/img/loading.gif" lazyload alt="image-20241209151204171"><figcaption aria-hidden="true">image-20241209151204171</figcaption></figure><p>一些重要的什么周期阶段的职责：</p><ul><li>clean：移除上一次构建生成的文件</li><li>compile：编译项目源代码</li><li>test：使用合适的单元测试框架运行测试（junit）</li><li>package：将编译后的文件打包，如：jar、war等</li><li>install：安装项目到本地仓库</li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209151350389-2024-12-915:13:51.png" srcset="/img/loading.gif" lazyload alt="image-20241209151350389"><figcaption aria-hidden="true">image-20241209151350389</figcaption></figure><p>执行指定声明周期的两种方式</p><ul><li>在idea中，右侧的maven工具栏，选中对应的生命周期，双击执行。</li><li>在命令行中，通过命令执行。</li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-09_15-16-08-2024-12-915:19:29.png" srcset="/img/loading.gif" lazyload alt="PixPin_2024-12-09_15-16-08"><figcaption aria-hidden="true">PixPin_2024-12-09_15-16-08</figcaption></figure><p>如果想要跳过某些阶段，如在package的过程中跳过test阶段，点击test，再点击小闪电即可跳过该模块</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501114000111-2024-5-918:51:58.png" srcset="/img/loading.gif" lazyload alt="image-20240501114000111" style="zoom:80%"></p><h2 id="二http协议">二、HTTP协议</h2><p><code>H</code>yper <code>T</code>ext <code>T</code>ransfer <code>P</code>rotocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。</p><h3 id="http请求的数据格式">2.1、HTTP请求的数据格式</h3><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209152227266-2024-12-915:22:28.png" srcset="/img/loading.gif" lazyload alt="image-20241209152227266"><figcaption aria-hidden="true">image-20241209152227266</figcaption></figure><p>包含三部分：</p><ul><li><p>请求行</p><p>第一行，由三部分组成：请求方式、资源路径和协议。</p></li><li><p>请求头</p><p>第二行开始，格式为 key : value</p></li><li><p>请求体</p><p>Post方式所特有的，用来存放请求参数。</p></li></ul><blockquote><ul><li>请求方式-GET：请求参数在<strong>请求行</strong>中，没有请求体，如：<code>/brand/findAll？name=OPPO&amp;status=1</code>，GET请求大小是有限制的。</li><li>请求方式-POST：请求参数在<strong>请求体</strong>中，POST请求大小是没有限制的。</li></ul></blockquote><p>常见的请求头的含义<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501190830361-2024-5-918:52:08.png" srcset="/img/loading.gif" lazyload alt="image-20240501190830361"></p><h3 id="http响应的数据格式">2.2、HTTP响应的数据格式</h3><p>包含三部分：</p><ul><li><p>响应行</p><p>位于相应数据第一行，包含协议、状态码和相关描述。</p></li><li><p>响应头</p><p>从第二行开始，格式为：key : value</p></li><li><p>响应体</p><p>最后一部分，存放相应数据</p></li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501191754933-2024-5-918:52:11.png" srcset="/img/loading.gif" lazyload alt="image-20240501191754933" style="zoom:80%"></p><p>响应状态码 <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/chapter/13553">状态码大全</a></p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501192042349-2024-5-918:52:15.png" srcset="/img/loading.gif" lazyload alt="image-20240501192042349"><figcaption aria-hidden="true">image-20240501192042349</figcaption></figure><p>响应头格式</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501191939039-2024-5-918:52:20.png" srcset="/img/loading.gif" lazyload alt="image-20240501191939039"><figcaption aria-hidden="true">image-20240501191939039</figcaption></figure><h3 id="http解析">2.3、HTTP解析</h3><p>​ 现在主要通过Web服务器来完成。<strong>Web服务器</strong>对HTTP协议操作进行封装，简化web程序开发；可以部署web项目，对外提供网上信息浏览服务。<strong>Tomcat</strong>一个轻量级的web服务器，支持servlet、jsp等少量javaEE规范。也被称为web容器、servlet容器。</p><h2 id="三请求响应">三、请求响应</h2><h3 id="请求参数">3.1、请求参数</h3><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240503090114509-2024-5-918:52:26.png" srcset="/img/loading.gif" lazyload alt="image-20240503090114509"><figcaption aria-hidden="true">image-20240503090114509</figcaption></figure><h4 id="简单参数">简单参数</h4><ul><li><p>原始方式</p><p>在原始的web程序中，获取请求参数，需要通过<code>HttpServletRequest</code>对象手动获取。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>（<span class="hljs-string">&quot;/simpleParam&quot;</span>）
<span class="hljs-keyword">public</span> String simpleParam（HttpServletRequest request）&#123;
    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> request.getParameter（<span class="hljs-string">&quot;name&quot;</span>）;
    <span class="hljs-type">String</span> <span class="hljs-variable">ageStr</span> <span class="hljs-operator">=</span> request.getParameter（<span class="hljs-string">&quot;age&quot;</span>）;
    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> Integer.parseint（ageStr）;
    System.out.println（name+<span class="hljs-string">&quot;：&quot;</span>+age）;
    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>；
&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209153920637-2024-12-915:39:21.png" srcset="/img/loading.gif" lazyload alt="image-20241209153920637" style="zoom:80%"></p></li><li><p>SpringBoot方式</p><p>简单参数：参数名与形参变量名相同，定义形参即可接收参数。</p><div class="code-wrapper"><pre><code class="hljs java">@ RequestMapping(<span class="hljs-string">&quot;/simpleParam&quot;</span>)
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">simpleParam</span><span class="hljs-params">(String name , Integer age)</span>&#123;
	System.out.println(name+<span class="hljs-string">&quot;: &quot;</span>+age);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;   
&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209154118637-2024-12-915:41:19.png" srcset="/img/loading.gif" lazyload alt="image-20241209154118637" style="zoom:80%"></p><p>若传递的参数和函数形参变量名不同，则得到的值为<code>null</code>。若要使用两个不同的参数名，则使用<code>@RequestParam</code>完成映射。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/simpleParam&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">simpleParam</span><span class="hljs-params">(</span>
<span class="hljs-params">    //会将请求参数中name属性的值，映射到username这个变量上</span>
<span class="hljs-params">    <span class="hljs-meta">@RequestParam(value = &quot;name&quot;, required = false)</span> String username, </span>
<span class="hljs-params">    <span class="hljs-type">int</span> age)</span> &#123;
    
    System.out.println(username+<span class="hljs-string">&quot;:&quot;</span>+age);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;
&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209154458280-2024-12-915:45:15.png" srcset="/img/loading.gif" lazyload alt="image-20241209154458280" style="zoom:80%"></p></li></ul><h4 id="实体参数">实体参数</h4><blockquote><p>简单实体参数</p></blockquote><p>​ 当传递参数太多或者具有某种结构属性时，可以将其封装为一个实体对象。创建实体类xxx，在其中定义与请求参数名相同的属性名，设置get和set方法，springboot会自动请求参数封装到一个对象中。即：请求参数名与形参对象属性名相同，定义POJO接收即可</p><div class="code-wrapper"><pre><code class="hljs java">Public <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Integer age;
&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>（<span class="hljs-string">&quot;/simplePojo&quot;</span>）
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">simplePojo</span><span class="hljs-params">(User user)</span> &#123;
    System.out.println(user);
    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>;
&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209155024205-2024-12-915:50:40.png" srcset="/img/loading.gif" lazyload alt="image-20241209155024205" style="zoom:80%"></p><blockquote><p>复杂实体参数</p></blockquote><p>当一个类的属性是另一个类的对象时，传递的参数是复杂实体参数。请求参数名与形参对象属性名相同，按照对象<strong>层次结构关系</strong>即可接收嵌套POJO属性参数。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Integer age;
    <span class="hljs-keyword">private</span> Address address;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;
    <span class="hljs-keyword">private</span> String province;
    <span class="hljs-keyword">private</span> String city;
&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>（<span class="hljs-string">&quot;/complexPojo&quot;</span>）
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">complesPojo</span><span class="hljs-params">(User user)</span> &#123;
    System.out.println(user);
    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>;
&#125;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209155618690-2024-12-915:56:40.png" srcset="/img/loading.gif" lazyload alt="image-20241209155618690"><figcaption aria-hidden="true">image-20241209155618690</figcaption></figure><h4 id="数组集合参数">数组集合参数</h4><p>请求参数名与<strong>形参数组名称</strong>相同且请求参数为多个，定义数组类型形参即可接收参数</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/arrayParam&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">arrayParam</span><span class="hljs-params">(String[]hobby)</span>&#123;
    System.out.println（Arrays.toString(hobby));
    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>;
&#125;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209160226768-2024-12-916:02:40.png" srcset="/img/loading.gif" lazyload alt="image-20241209160226768"><figcaption aria-hidden="true">image-20241209160226768</figcaption></figure><p>也可使用集合接收参数。默认用数组接收，要使用集合接收时，需使用<code>@RequestParam</code>绑定参数关系</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/arrayParam&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">arrayParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> List&lt;String&gt;hobby)</span>&#123;
    System.out.println（Arrays.toString(hobby));
    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>;
&#125;</code></pre></div><h4 id="日期参数">日期参数</h4><p>使用<code>@DateTimeFormat</code>注解完成日期参数格式转换</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/dateParam&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">dateParam</span><span class="hljs-params">(</span>
<span class="hljs-params">    //指定前端传递的日期格式，请求参数名称和形参名称保持一致</span>
<span class="hljs-params">    <span class="hljs-meta">@DateTimeFormat</span>（pattern =<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span>LocalDateTime updateTime)&#123;
 	System.out.println(updateTime);
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;
&#125;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209160746102-2024-12-916:08:40.png" srcset="/img/loading.gif" lazyload alt="image-20241209160746102"><figcaption aria-hidden="true">image-20241209160746102</figcaption></figure><h4 id="json参数">JSON参数</h4><p>后端使用实体对象接收JSON数据，JSON数据<code>键名</code>与形参<code>对象属性名</code>相同，同时使用<code>@RequestBody</code>标识</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Integer age;
    <span class="hljs-keyword">private</span> Address address;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;
    <span class="hljs-keyword">private</span> String province;
    <span class="hljs-keyword">private</span> String city;
&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>（<span class="hljs-string">&quot;/jsonParam&quot;</span>）
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">jsonParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> &#123;
    System.out.println(user);
    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>;
&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209161110433-2024-12-916:11:40.png" srcset="/img/loading.gif" lazyload alt="image-20241209161110433" style="zoom:80%"></p><p>传递JSON参数使用post方法，json格式的数据需要在请求体中传递到后端。在postman中传递JSON数据的方法</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240503103956956-2024-5-918:53:24.png" srcset="/img/loading.gif" lazyload alt="image-20240503103956956"><figcaption aria-hidden="true">image-20240503103956956</figcaption></figure><h4 id="路径参数">路径参数</h4><p>通过请求URL直接传递参数，使用<code>&#123;...&#125;</code>来标识该路径参数，需要使用<code>@PathVariable</code>获取路径参数</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/path/&#123;id&#125;&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">pathParam</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> &#123;
 	System.out.println(id);
    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>;  
&#125;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209161510698-2024-12-916:15:11.png" srcset="/img/loading.gif" lazyload alt="image-20241209161510698"><figcaption aria-hidden="true">image-20241209161510698</figcaption></figure><p>有多个路径参数时：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/path/&#123;id&#125;/&#123;name&#125;&quot;)</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title function_">pathParam</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id, <span class="hljs-meta">@PathVariable</span> String name)</span> &#123;
 	System.out.println(id);
    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>;  
&#125;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209161804011-2024-12-916:18:29.png" srcset="/img/loading.gif" lazyload alt="image-20241209161804011"><figcaption aria-hidden="true">image-20241209161804011</figcaption></figure><h3 id="响应数据">3.2、响应数据</h3><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209162140240-2024-12-916:21:41.png" srcset="/img/loading.gif" lazyload alt="image-20241209162140240"><figcaption aria-hidden="true">image-20241209162140240</figcaption></figure><p><code>@ResponseBody</code></p><ul><li><p>类型：<strong>方法注解</strong>，<strong>类注解</strong></p></li><li><p>位置：Controller方法上/类上</p></li><li><p>作用：将<strong>方法返回值</strong>直接响应，<u>如果返回值类型是 实体对象/集合，将会转换为JSON格式响应</u></p></li><li><p>说明：<code>@RestController = @Controller + @ResponseBody</code></p></li></ul><h4 id="设置统一响应结果">设置统一响应结果</h4><p>对于不同的返回数据，有不同的返回格式，前端解析时需要按照不同方法操作，不便开发和维护</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240503110657053-2024-5-918:53:37.png" srcset="/img/loading.gif" lazyload alt="image-20240503110657053"><figcaption aria-hidden="true">image-20240503110657053</figcaption></figure><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.pojo;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> Result</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO 统一响应结果封装类</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> 86152</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/5/3 11:08</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;
    <span class="hljs-keyword">private</span> Integer code; <span class="hljs-comment">//1 成功， 0 失败</span>
    <span class="hljs-keyword">private</span> String msg;<span class="hljs-comment">//提示信息</span>
    <span class="hljs-keyword">private</span> Object data;<span class="hljs-comment">//响应数据 data</span>

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Result</span><span class="hljs-params">()</span> &#123;&#125;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Result</span><span class="hljs-params">(Integer code, String msg, Object data)</span> &#123;
        <span class="hljs-built_in">this</span>.code = code;
        <span class="hljs-built_in">this</span>.msg = msg;
        <span class="hljs-built_in">this</span>.data = data;
    &#125;

    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> code;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCode</span><span class="hljs-params">(Integer code)</span> &#123;
        <span class="hljs-built_in">this</span>.code = code;
    &#125;

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMsg</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> msg;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMsg</span><span class="hljs-params">(String msg)</span> &#123;
        <span class="hljs-built_in">this</span>.msg = msg;
    &#125;

    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> data;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(Object data)</span> &#123;
        <span class="hljs-built_in">this</span>.data = data;
    &#125;

    <span class="hljs-comment">//静态方法，方便快速创建Result对象</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;sucess&quot;</span>,<span class="hljs-literal">null</span>);
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">(Object data)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;sucess&quot;</span>,data);
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">error</span><span class="hljs-params">(String msg)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">0</span>,msg,<span class="hljs-literal">null</span>);
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result&#123;&quot;</span> +
                <span class="hljs-string">&quot;code=&quot;</span> + code +
                <span class="hljs-string">&quot;, msg=&#x27;&quot;</span> + msg + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +
                <span class="hljs-string">&quot;, data=&quot;</span> + data +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;
&#125;
</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResponseController</span> &#123;

    <span class="hljs-meta">@RequestMapping(&quot;/getAddress&quot;)</span>
    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-type">Address</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>();
        address.setProvince(<span class="hljs-string">&quot;陕西省&quot;</span>);
        address.setCity(<span class="hljs-string">&quot;西安&quot;</span>);
        <span class="hljs-keyword">return</span> Result.success(address);
    &#125;
&#125;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240503111753128-2024-5-918:53:42.png" srcset="/img/loading.gif" lazyload alt="image-20240503111753128"><figcaption aria-hidden="true">image-20240503111753128</figcaption></figure><h2 id="四分层解耦">四、分层解耦</h2><h3 id="三层架构">4.1、三层架构</h3><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209162222532-2024-12-916:22:23.png" srcset="/img/loading.gif" lazyload alt="image-20241209162222532"><figcaption aria-hidden="true">image-20241209162222532</figcaption></figure><ul><li>controller：控制层，接收前端发送的请求，对请求进行处理，并响应数据。</li><li>service：业务逻辑层，处理具体的业务逻辑。</li><li>dao：数据访问层（Data Access Object）（持久层），负责数据访问操作，包括数据的增、删、改、查。</li></ul><h3 id="ioc控制翻转">4.2、IOC（控制翻转）*</h3><p>之前Controller层调用Service层方法是通过在类内主动创建一个特定的Service对象，并调用该对象的方法来实现的（service层调dao层的方法同理）。在这种方式下，若service层增加新的实现类，在Controller层使用该类时，需修改之前的创建对象，改为new 新对象。每次变动 , 都需要修改大量代码 .耦合度高。<strong>传统方式下是程序主动去创建依赖对象，控制权在程序员手上。<code>IOC</code>这种<code>设计思想</code>是将设计好的对象交给IOC容器（或spring容器）管理，由IOC容器来控制对象的创建，成为IOC容器的bean。</strong>此时，程序不再具有主动性，而是被动的接收对象，把主动权交给了调用者。</p><p>没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方。所谓控制反转就是：<strong>获得依赖对象的方式反转了，由主动的编程变成被动的接收.</strong>。</p><p>Springboot中通过<code>注解</code>将类交给IOC容器，在运行时创建对象。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240504154537635-2024-5-918:53:55.png" srcset="/img/loading.gif" lazyload alt="image-20240504154537635"><figcaption aria-hidden="true">image-20240504154537635</figcaption></figure><h3 id="di依赖注入">4.3、DI（依赖注入）*</h3><p>​ <strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>。loC的一个重点是在系统运行中，<strong>动态的向某个对象提供它所需要的其他对象</strong>，这一点是通过DI（Dependency Injection，依赖注入）来实现的。Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p><p>​ 通过在需要注入的类属性上添加<strong>自动注入的注解</strong>，spring就会在运行时适当的时候从IOC容器中创建一个bean，并注入到该属性中。</p><ul><li><p><code>@Autowired</code>注解，默认是按照类型进行，如果存在多个相同类型的bean，将会报出如下错误</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209162514910-2024-12-916:25:40.png" srcset="/img/loading.gif" lazyload alt="image-20241209162514910"><figcaption aria-hidden="true">image-20241209162514910</figcaption></figure></li></ul><p>如果同类型的bean存在多个，可以通过以下几种方案完成注入</p><ul><li><code>@Primary</code> 指定bean的优先级，添加该注解，说明优先注入同类型中的哪个bean</li><li><code>@Qualifier（"bean的名称"）+ @Autowired</code>，两个注解配合使用，指定要注入bean的名称（创建时没有指定时，默认为类名首字母小写）</li><li><code>@Resource（name-"bean的名称"</code>，<span class="citation" data-cites="Resource是JDK的注解">@Resource是JDK的注解</span>，默认你按照名称注入</li></ul><h2 id="五mysql">五、<a href="https://catpaws.top/8d742da7/">MySQL</a></h2><h2 id="六mybatis">六、<a href="web-02-Mybatis.md">MyBatis</a></h2><h3 id="快速入门">6.1、快速入门</h3><h4 id="连接配置">连接配置</h4><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">application.propoties</span>
<span class="hljs-comment">#驱动类名称</span>
<span class="hljs-string">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span>
<span class="hljs-comment">#数据库连接的url</span>
<span class="hljs-string">spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_01?serverTimezone=Hongkong&amp;amp;useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8</span>
<span class="hljs-comment">#连接数据库的用户名</span>
<span class="hljs-string">spring.datasource.username=root</span>
<span class="hljs-comment">#连接数据库的密码</span>
<span class="hljs-string">spring.datasource.password=liuhao123</span>
<span class="hljs-comment">#配置mybatis的日志，指定输出到控制台</span>
<span class="hljs-string">mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span>


<span class="hljs-string">pom.xml相关</span>
<span class="hljs-string">需手动指定MySQL连接的版本</span>
<span class="hljs-string">&lt;dependency&gt;</span>
    <span class="hljs-string">&lt;groupId&gt;com.mysql&lt;/groupId&gt;</span>
    <span class="hljs-string">&lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;</span>
    <span class="hljs-string">&lt;version&gt;8.0.32&lt;/version&gt;</span>
    <span class="hljs-string">&lt;scope&gt;runtime&lt;/scope&gt;</span>
<span class="hljs-string">&lt;/dependency&gt;</span>
</code></pre></div><h4 id="配置mysql提示">配置MySQL提示</h4><p>默认在mybatis中编写SQL语句是不识别的。可以做如下配置:</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209163040488-2024-12-916:31:19.png" srcset="/img/loading.gif" lazyload alt="image-20241209163040488"><figcaption aria-hidden="true">image-20241209163040488</figcaption></figure><p>当完成语言注入后，在sql语句中输入表名时，MyBatis并没有给出提示甚至报红，无法识别。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209163302625-2024-12-916:33:03.png" srcset="/img/loading.gif" lazyload alt="image-20241209163302625" style="zoom:67%"></p><p>产生的原因是Idea和数据库没有建立连接，不识别表信息。需要在Idea中配置MySQL数据库连接</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209163420385-2024-12-916:34:21.png" srcset="/img/loading.gif" lazyload alt="image-20241209163420385"><figcaption aria-hidden="true">image-20241209163420385</figcaption></figure><h4 id="jdbc和mybatis">JDBC和Mybatis</h4><p>JDBC：（Java DataBase Connectivity），就是使用Java语言操作关系型数据库的一套API。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209163537712-2024-12-916:35:38.png" srcset="/img/loading.gif" lazyload alt="image-20241209163537712"><figcaption aria-hidden="true">image-20241209163537712</figcaption></figure><p>它是sun公司官方定义的一套操作所有关系型数据库的<strong>规范</strong>即接口。各个数据库厂商去实现这套接口，提供数据库驱动ar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240505094254808-2024-5-918:54:23.png" srcset="/img/loading.gif" lazyload alt="image-20240505094254808"><figcaption aria-hidden="true">image-20240505094254808</figcaption></figure><h4 id="数据库连接池">数据库连接池</h4><p>​ 数据库连接池是个容器，负责分配、管理数据库连接（Connection）。它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏</p><p>优势：</p><ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209163852325-2024-12-916:39:10.png" srcset="/img/loading.gif" lazyload alt="image-20241209163852325"><figcaption aria-hidden="true">image-20241209163852325</figcaption></figure><p>常见产品：</p><ul><li><p>C3P0</p></li><li><p>DBCP</p></li><li><p>Druid</p><p>由阿里巴巴开源的数据库连接池项目，功能强大，性能优秀，是Java语言最好的数据库连接池之一。</p></li><li><p>Hikari</p><p>SpringBoot默认采用的数据库连接池</p></li></ul><p>切换Druid数据库连接池</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.19<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="lombok">LomBok</h4><p>​ Lombok是一个实用的Java类库，能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，并可以自动化生成日志变量，简化java开发、提高效率。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209164307613-2024-12-916:43:08.png" srcset="/img/loading.gif" lazyload alt="image-20241209164307613"><figcaption aria-hidden="true">image-20241209164307613</figcaption></figure><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="mybatis基础操作crud">6.2、MyBatis基础操作（CRUD）</h3><p><strong>使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。</strong></p><p><strong>选择何种方式来配置映射，以及认为是否应该要统一映射语句定义的形式，完全取决于你和你的团队。 换句话说，永远不要拘泥于一种方式，你可以很轻松的在基于注解和 XML 的语句映射方式间自由移植和切换。</strong></p><h4 id="使用注解开发">使用注解开发</h4><h5 id="删除操作">删除操作</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;

    <span class="hljs-meta">@Delete(&quot;delete from emp where id = #&#123;id&#125;&quot;)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(Integer id)</span>;

&#125;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240505162729553-2024-5-918:54:45.png" srcset="/img/loading.gif" lazyload alt="image-20240505162729553"><figcaption aria-hidden="true">image-20240505162729553</figcaption></figure><p>预编译sql性能更高（会将优化后的sql缓存起来），更安全（防止sql注入）</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240505165633607-2024-5-918:54:49.png" srcset="/img/loading.gif" lazyload alt="image-20240505165633607"><figcaption aria-hidden="true">image-20240505165633607</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240505165445199-2024-5-918:54:54.png" srcset="/img/loading.gif" lazyload alt="image-20240505165445199"><figcaption aria-hidden="true">image-20240505165445199</figcaption></figure><h5 id="新增操作">新增操作</h5><p>主键返回：<span class="citation" data-cites="Options注解只能搭配Insert语句使用">@Options注解只能搭配Insert语句使用</span>，会自动将生成的主键值，赋值给emp对象的id属性。经过Options注解，Mybatis会自动把数据库生成的主键值写入到实体类中。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;
	<span class="hljs-comment">//主键返回：将当前创建记录的主键封装在emp对象的id属性中，可以通过get方法获取</span>
    <span class="hljs-meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span>
    
    <span class="hljs-comment">//有多个参数时，使用对应的实体类封装起来，通过参数占位符获取对象的属性</span>
    <span class="hljs-meta">@Insert(&quot;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time)&quot; +</span>
<span class="hljs-meta">            &quot;values (#&#123;username&#125;,#&#123;name&#125;,#&#123;gender&#125;,#&#123;image&#125;,#&#123;job&#125;,#&#123;entrydate&#125;,#&#123;deptId&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;)&quot;)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(Emp emp)</span>;
&#125;</code></pre></div><h5 id="更新操作">更新操作</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;
    <span class="hljs-comment">//更新员工信息</span>
    <span class="hljs-meta">@Update(&quot;update emp &quot; +</span>
<span class="hljs-meta">            &quot;set username = #&#123;username&#125;, name = #&#123;name&#125;, gender = #&#123;gender&#125;, image = #&#123;image&#125;, job = #&#123;job&#125;, entrydate = #&#123;entrydate&#125;, dept_id = #&#123;deptId&#125;, update_time = #&#123;updateTime&#125;&quot; +</span>
<span class="hljs-meta">            &quot; where id = #&#123;id&#125;;&quot;)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(Emp emp)</span>;
&#125;</code></pre></div><h5 id="查询操作">查询操作</h5><p>1、根据id查询员工</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;
    <span class="hljs-comment">//将查询到的记录封装到实体类Emp的一个对象中</span>
    <span class="hljs-meta">@Select(&quot;select * from emp where  id = #&#123;id&#125;&quot;)</span>
    <span class="hljs-keyword">public</span> Emp <span class="hljs-title function_">getUserById</span><span class="hljs-params">(Integer id)</span>;
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectTest</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> empMapper.getUserById(<span class="hljs-number">19</span>);
        System.out.println(emp);
    &#125;
&#125;</code></pre></div><p>查看封装结果：由于数据库采用下划线命名，而java使用驼峰命名，两者名称不一致，数据没有封装进去</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240505172402159-2024-12-921:38:01.png" srcset="/img/loading.gif" lazyload alt="image-20240505172402159"><figcaption aria-hidden="true">image-20240505172402159</figcaption></figure><ul><li>实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。</li><li>如果实体类属性名 和 数据库表查询返回的字段名不一致，不能自动封装。</li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209164557149-2024-12-916:45:58.png" srcset="/img/loading.gif" lazyload alt="image-20241209164557149"><figcaption aria-hidden="true">image-20241209164557149</figcaption></figure><ul><li><p>方案一：给字段起别名，让别名与实体类属性保持一致</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime from emp where  id = #&#123;uid&#125;&quot;)</span>
<span class="hljs-keyword">public</span> Emp <span class="hljs-title function_">getUserById</span><span class="hljs-params">(Integer id)</span>;</code></pre></div></li><li><p>方案二：通过<code>@Results</code>和<code>@Result</code>进行手动封装</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Results(&#123;</span>
<span class="hljs-meta">        @Result(column = &quot;dept_id&quot;,property = &quot;deptId&quot;),</span>
<span class="hljs-meta">        @Result(column = &quot;create_time&quot;,property = &quot;createTime&quot;),</span>
<span class="hljs-meta">        @Result(column = &quot;update_time&quot;,property = &quot;updateTime&quot;)</span>
<span class="hljs-meta">&#125;)</span>
<span class="hljs-meta">@Select(&quot;select * from emp where id = #&#123;id&#125;&quot;)</span>
<span class="hljs-keyword">public</span> Emp <span class="hljs-title function_">getUserById</span><span class="hljs-params">(Integer id)</span>;</code></pre></div></li><li><p><label><input type="checkbox" checked>方案三：开启MyBatis驼峰命名自动映射开关，完成 a_cloumn ----&gt; aColumn (推荐)</label></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#application.properties</span>

<span class="hljs-comment">#开启mybatis驼峰命名自动映射开关 a_cloumn ----&gt; aColumn</span>
<span class="hljs-string">mybatis.configuration.map-underscore-to-camel-case=true</span>
</code></pre></div></li></ul><p>2、复杂查询</p><p>例：要求查询员工，且：</p><ul><li>根据输入的 员工姓名、员工性别、入职时间 搜索满足条件的员工信息。</li><li>其中 员工姓名，支持模糊匹配；性别 进行精确查询；入职时间进行范围查询。</li><li>支持分页查询。</li><li>并对查询的结果，根据最后修改时间进行倒序排序。</li></ul><p>对应的SQL语句：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span>
<span class="hljs-keyword">from</span> emp 
<span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span><span class="hljs-string">&#x27;%张%&#x27;</span>
		<span class="hljs-keyword">and</span> gender<span class="hljs-operator">=</span><span class="hljs-number">1</span> 
		<span class="hljs-keyword">and</span> entrydate <span class="hljs-keyword">between</span><span class="hljs-string">&#x27;2010-01-01&#x27;</span>
		<span class="hljs-keyword">and</span><span class="hljs-string">&#x27;2020-01-01&#x27;</span>
<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> update_time <span class="hljs-keyword">desc</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * &quot; +</span>
<span class="hljs-meta">            &quot;from emp &quot; +</span>
<span class="hljs-meta">            &quot;where name like concat(&#x27;$&#x27;,#&#123;name&#125;,&#x27;$&#x27;) and gender = #&#123;gender&#125; and entrydate between #&#123;begin&#125; and #&#123;end&#125; &quot; +</span>
<span class="hljs-meta">            &quot;order by  update_time desc&quot;)</span>
    <span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title function_">getUserList</span><span class="hljs-params">(String name, <span class="hljs-type">short</span> gender, LocalDate begin, LocalDate end)</span>;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209165105204-2024-12-916:51:19.png" srcset="/img/loading.gif" lazyload alt="image-20241209165105204"><figcaption aria-hidden="true">image-20241209165105204</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240505180035515-2024-5-918:55:12.png" srcset="/img/loading.gif" lazyload alt="image-20240505180035515"><figcaption aria-hidden="true">image-20240505180035515</figcaption></figure><h5 id="补充">补充</h5><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240505180332250-2024-5-918:55:46.png" srcset="/img/loading.gif" lazyload alt="image-20240505180332250"><figcaption aria-hidden="true">image-20240505180332250</figcaption></figure><p><span class="citation" data-cites="Param的作用就是">@Param的作用就是</span><strong>给参数命名</strong>，比如在mapper里面某方法A（int id），当添加注解后A（<span class="citation" data-cites="Param">@Param</span>("userId") int id），也就是说外部想要取出传入的id值，<strong>只需要取它的参数名userId就可以了</strong>。将参数值传如SQL语句中，通过#{userId}进行取值给SQL的参数赋值。</p><ul><li>方法存在多个参数，所有参数前面必须加上 <span class="citation" data-cites="Param">@Param</span>("")注解</li></ul><p>当使用@Param给参数命名后，在xml或注解形式下使用 #{}取值</p><p><strong>XML形式下</strong>：</p><ul><li><strong><span class="citation" data-cites="Param注解单一属性">@Param注解单一属性</span></strong><ul><li>这里给参数配置@param注解后，Mybatis会自动将参数封装成<strong>Map类型</strong>，而@param注解的值会成为Map中的key，因此在sql中可以通过配置的注解值来使用参数。</li><li>使用注解传递参数,这时是不涉及单独一个类型的,所以<strong>去掉parameterType属性</strong></li></ul></li><li><strong><span class="citation" data-cites="Param注解JavaBean对象">@Param注解JavaBean对象</span></strong><ul><li>当参数是JavaBean类型时，使用@param注解后就不能直接使用，而是要通过<strong>点取值</strong>的方式。</li><li>在没有注解时，可以直接使用该JavaBean的属性</li></ul></li></ul><h4 id="使用xml文件开发">使用XML文件开发</h4><p>使用XML文件开发，需要遵循以下规范</p><ul><li>XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）。</li><li>XML映射文件的namespace属性为Mapper接口全限定名一致。</li><li>XML映射文件中sql语句的id与Mapper 接口中的方法名一致，并保持返回类型一致。</li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209165322631-2024-12-916:53:23.png" srcset="/img/loading.gif" lazyload alt="image-20241209165322631"><figcaption aria-hidden="true">image-20241209165322631</figcaption></figure><p>使用mybatis完成数据库操作是通过执行mapper接口中的方法，但这个方法并没有指定实际执行的sql语句，<code>关键是如何找到该方法对应的sql语句并执行.</code></p><p>通过遵守xml映射文件的三条规范，可以保证在调用Mapper接口中的方法时，mybatis框架会自动查找与namespace属性值与这个接口全类名相同的xml文件，在该xml文件中找到id属性值与方法名相同的sql语句，最终运行这条sql语句从而完成对数据库的操作。</p><blockquote><p>步骤</p></blockquote><ol type="1"><li>在resources下创建与mapper相同的包结构，此时创建的是目录，各级直接要用<code>/</code>分隔，而不是<code>.</code>，这样创建的才是分等级的文件结构</li></ol><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240505181114981-2024-5-918:55:57.png" srcset="/img/loading.gif" lazyload alt="image-20240505181114981"><figcaption aria-hidden="true">image-20240505181114981</figcaption></figure><p>​ 2、创建与mapper接口名称相同的xml文件</p><p>​ 首先添加xml约束</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span>
<span class="hljs-meta">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span>
<span class="hljs-meta">  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></code></pre></div><p>添加mapper标签，获取对应的mapper接口的全限定名：</p><p>右键mapper接口，选择<code>Copy Reference</code>即可</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240505184351463-2024-5-918:55:58.png" srcset="/img/loading.gif" lazyload alt="image-20240505184351463"><figcaption aria-hidden="true">image-20240505184351463</figcaption></figure><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span>
<span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span>
<span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>

<span class="hljs-comment">&lt;!--使用namespace 将mapper接口与xml文件绑定起来--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mapper.EmpMapper&quot;</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p>3、添加sql语句</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span>
<span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span>
<span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>

<span class="hljs-comment">&lt;!--使用namespace 将mapper接口与xml文件绑定起来--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mapper.EmpMapper&quot;</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- 使用id绑定到EmpMapper接口中的getUserList方法，返回值类型设置为Emp类   --&gt;</span>
    <span class="hljs-comment">&lt;!--resultType ：单条记录所封装的类型（全限定名）    --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.pojo.Emp&quot;</span>&gt;</span>
            select *
            from emp
            where name like concat(&#x27;$&#x27;,#&#123;name&#125;,&#x27;$&#x27;) and gender = #&#123;gender&#125; and entrydate 						between #&#123;begin&#125; and #&#123;end&#125;
            order by  update_time desc
    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h3 id="动态sql">6.3、动态sql</h3><p><strong>什么是动态SQL：动态SQL就是根据不同的条件组装生成不同的SQL语句</strong></p><p>所谓动态SQL，本质还是SQL语句，只是我们可以在SQL层面，执行一些逻辑代码。</p><blockquote><p>主要元素</p></blockquote><ul><li>if ，where，set</li><li>foreach</li><li>sql，include</li></ul><h4 id="ifwhereset">IF，where，set</h4><p>使用动态 SQL 最常见情景是根据条件<strong>包含 where 子句的一部分</strong>。</p><p><code>&lt;if test="判断条件"&gt; where 子句的一部分 &lt;/if&gt;</code></p><p>根据判断条件是否为真来动态添加对应的sql代码。</p><p>注：test判断条件中使用的是<u>实体类中的属性名</u>而不是数据库表的字段名</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240505210552447-2024-5-918:55:59.png" srcset="/img/loading.gif" lazyload alt="image-20240505210552447"><figcaption aria-hidden="true">image-20240505210552447</figcaption></figure><p>例1：根据用户输入的查询条件获得用户列表。若输入了用户名，则按照用户名模糊查询；若输入了性别，同时按性别查询；若输入了入职时间，同时按照入职时间查询；若不输入参数，则查询所有员工。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.pojo.Emp&quot;</span>&gt;</span>
    select *
    from emp
    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span>
            name like concat(&#x27;$&#x27;,#&#123;name&#125;,&#x27;$&#x27;)
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span>
            and gender = #&#123;gender&#125;
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin != null and end != null&quot;</span>&gt;</span>
            and entrydate between #&#123;begin&#125; and #&#123;end&#125;
        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>
    order by update_time desc;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>例2：动态更新员工表，若传入了对应字段的值，则更新；否则保持不变。</p><p>与where中遇到的情况类似，若只有第一个if标签有效则预编译sql如下，会将其中的逗号保留，造成sql语法错误</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240505210252503-2024-5-918:56:00.png" srcset="/img/loading.gif" lazyload alt="image-20240505210252503"><figcaption aria-hidden="true">image-20240505210252503</figcaption></figure><p>使用set标签解决</p><p><code>&lt;set&gt;</code>：动态地在行首插入SET关键字，并会删掉额外的逗号。（用在update语句中）</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span>&gt;</span>
    update emp
    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span>username = #&#123;username&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span> name = #&#123;name&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span>gender = #&#123;gender&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;image != null&quot;</span>&gt;</span>image = #&#123;image&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;job != null&quot;</span>&gt;</span>job = #&#123;job&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;entrydate != null&quot;</span>&gt;</span>entrydate = #&#123;entrydate&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span>dept_id = #&#123;deptId&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateTime != null&quot;</span>&gt;</span>update_time = #&#123;updateTime&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>
    where id = #&#123;id&#125;;
<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></div><h4 id="foreach">foreach</h4><ul><li>动态 SQL 的另一个常见使用场景是<strong>对集合进行遍历</strong>（尤其是在构建 IN 条件语句的时候）。</li><li>它允许你指定一个集合，声明可以在元素体内使用的<strong>集合项（item）</strong>和<strong>索引（index）</strong>变量。</li><li>它也允许你<strong>指定开头与结尾的字符串</strong>以及<strong>集合项迭代之间的分隔符</strong>。</li></ul><p>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有以下3种情况：</p><ul><li><p><strong>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list 。</strong></p></li><li><p><strong>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array 。</strong></p></li><li><p><strong>如果传入的参数是多个的时候，就需要把它们封装成一个Map了，当然单参数也可以封装成Map。实际上在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key。</strong></p></li></ul><p>当然在作为入参时可以使用@Param("keyName")来设置键，设置keyName后，list和array将会失效</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240505212015373-2024-5-918:56:14.png" srcset="/img/loading.gif" lazyload alt="image-20240505212015373"><figcaption aria-hidden="true">image-20240505212015373</figcaption></figure><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36631553/article/details/105680200">使用foreach进行批量操作</a></p><h4 id="sql片段">SQL片段</h4><p>有时候，我们要将一些功能的部分抽取出来，方便复用。同时这些公共部分若要修改，只需修改一处即可。</p><p>1、使用SQL标签抽取公共部分</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;commenSelect&quot;</span>&gt;</span>
    select id,
    username,
    password,
    name,
    gender,
    image,
    job,
    entrydate,
    dept_id,
    create_time,
    update_time
    from emp
<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span></code></pre></div><p>2、在需要使用的地方 使用 include标签引用即可</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    根据id查询用户 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.pojo.Emp&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;commenSelect&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
    where id = #&#123;uid&#125;
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>注意点：</p><ul><li>最好基于单表来定义SQL片段</li><li>其中不要包含where标签</li></ul><h3 id="idea插件">6.4、idea插件</h3><p>MybatisX 是一款基于 IDEA的快速开发Mybatis的插件，为效率而生。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209195949274-2024-12-920:00:40.png" srcset="/img/loading.gif" lazyload alt="image-20241209195949274"><figcaption aria-hidden="true">image-20241209195949274</figcaption></figure><blockquote><p>直接在xml中生成Mapper接口中的方法对应的标签</p></blockquote><p>安装了MyBatisX插件后，在mapper接口中添加一个方法后，使用<code>alt+shift+enter</code>可直接在对应的xml文件中生成该方法对应的标签</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240505220350091-2024-5-918:56:28.png" srcset="/img/loading.gif" lazyload alt="image-20240505220350091"><figcaption aria-hidden="true">image-20240505220350091</figcaption></figure><blockquote><p>在xml文件中开启sql提示</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240505220829405-2024-5-918:56:32.png" srcset="/img/loading.gif" lazyload alt="image-20240505220829405"><figcaption aria-hidden="true">image-20240505220829405</figcaption></figure><blockquote><p>添加操作日志</p></blockquote><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240506100818823-2024-5-918:56:37.png" srcset="/img/loading.gif" lazyload alt="image-20240506100818823" style="zoom:80%"></p><p>添加<code>@Slf4j</code>注解后，可以在方法内直接使用 <code>log</code>对象的<code>info或debug</code>方法输入日志。（不要用system.out）</p><h2 id="七整合demo">七、整合Demo</h2><h3 id="请求路径管理">7.1、请求路径管理</h3><p><span class="citation" data-cites="RequestMapping">@RequestMapping</span></p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209200052266-2024-12-920:01:16.png" srcset="/img/loading.gif" lazyload alt="image-20241209200052266"><figcaption aria-hidden="true">image-20241209200052266</figcaption></figure><blockquote><p>注：一个完整的请求路径，应该是类上的<code>@RequestMapping</code>的value属性+方法上的<code>@RequestMapping</code>的value属性。</p></blockquote><h3 id="restful-风格">7.2、RestFul 风格</h3><p><strong>概念</strong></p><p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，<strong>只是一种风格</strong>。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p><strong>功能</strong></p><p>资源：互联网所有的事物都可以被抽象为资源</p><p>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</p><p>分别对应 添加、 删除、修改、查询。</p><ul><li><p><strong>传统方式操作资源</strong> ：通过<strong>不同的参数</strong>来实现不同的效果！<strong>方法单一，post 和 get</strong></p><p>​ http://127.0.0.1/item/queryItem.action?id=1 查询,GET</p><p>​ http://127.0.0.1/item/saveItem.action 新增,POST</p><p>​ http://127.0.0.1/item/updateItem.action 更新,POST</p><p>​ http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST</p></li><li><p><strong>使用RESTful操作资源</strong> ：可以通过<strong>不同的请求方式</strong>来实现不同的效果！如下：<strong>请求地址一样，但是功能可以不同</strong>！</p><p>​ http://127.0.0.1/item/1 查询,GET</p><p>​ http://127.0.0.1/item 新增,POST</p><p>​ http://127.0.0.1/item 更新,PUT</p><p>​ http://127.0.0.1/item/1 删除,DELETE</p></li></ul><h3 id="分页查询">7.3、分页查询</h3><h4 id="原始方式">原始方式</h4><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240506144301718-2024-5-918:56:45.png" srcset="/img/loading.gif" lazyload alt="image-20240506144301718"><figcaption aria-hidden="true">image-20240506144301718</figcaption></figure><h4 id="使用分页插件pagehelper">使用分页插件PageHelper</h4><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20220525181646324-2024-5-918:56:50.png" srcset="/img/loading.gif" lazyload alt="image-20220525181646324"><figcaption aria-hidden="true">image-20220525181646324</figcaption></figure><p><a target="_blank" rel="noopener" href="https://pagehelper.github.io/docs/">查看</a></p><p>其核心原理是将传入的页码和条数赋值给一个Page对象，并保存到本地线程ThreadLocal中。接下来，PageHelper会进入Mybatis的拦截器环节，在拦截器中获取并处理刚才保存在ThreadLocal中的分页参数。这些分页参数会与原本的SQL语句和内部已经定义好的SQL进行拼接，从而完成带有分页处理的SQL语句的构建。</p><p><strong>PageHelper注意事项</strong></p><p>使用pagehelper进行分页的时候推荐使用 PageHelper.startPage(1, 10); 这种方式；</p><p>另外<strong>startPage语句最好紧挨着查询语句，避免中间抛出异常，没有办法清除ThreadLocal中当前线程的page对象。</strong></p><p>步骤：</p><p>1、编写正常查询语句</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;
    <span class="hljs-meta">@Select(&quot;select * from emp&quot;)</span>
    List&lt;Emp&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span>;
&#125;</code></pre></div><p>2、在service层使用PageHelper进行分页查询</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmpServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EmpService</span> &#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> EmpMapper empMapper;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> PageBean <span class="hljs-title function_">page</span><span class="hljs-params">(Integer page, Integer pageSize)</span> &#123;
        <span class="hljs-comment">//1、配置分页参数</span>
        PageHelper.startPage(page,pageSize);

        <span class="hljs-comment">//2、执行查询</span>
         <span class="hljs-comment">//规定获得分页查询结果对象用page封装，其继承了ArrayList，增加了自己的属性</span>
         Page&lt;<span class="hljs-type">Emp</span> <span class="hljs-variable">empList</span> <span class="hljs-operator">=</span> empMapper.list();

        <span class="hljs-comment">//3、封装PageBean对象</span>
        <span class="hljs-type">PageBean</span> <span class="hljs-variable">pageBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageBean</span>(p.getTotal(), p.getResult());
        <span class="hljs-keyword">return</span> pageBean;
    &#125;

&#125;</code></pre></div><h3 id="文件上传">7.4、文件上传</h3><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240506171942500-2024-5-918:56:54.png" srcset="/img/loading.gif" lazyload alt="image-20240506171942500"><figcaption aria-hidden="true">image-20240506171942500</figcaption></figure><p>前端表单：</p><ul><li>大文件提交方式要选择<code>post</code></li><li>文件编码格式<code>enctype</code>必须选择<code>multipart/form-data</code>，使用默认值只会将文件名提交到服务器</li><li>使用一个 type属性为<code>file</code>的组件来选择文件进行上传</li></ul><p>后端接收到的是临时文件，在表单中有三个标签，会将其数据保存在三个对应的临时文件中上传结束后会将其删除<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240506173248059-2024-5-918:56:59.png" srcset="/img/loading.gif" lazyload alt="image-20240506173248059"></p><h4 id="本地存储">本地存储</h4><p>使用<code>MutipartFile</code>类的<code>transferTo()</code>方法，将当前对象保存为指定路径下的文件</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span>
<span class="hljs-keyword">public</span> Result <span class="hljs-title function_">upload</span><span class="hljs-params">(String username, Integer age, MultipartFile image)</span> <span class="hljs-keyword">throws</span> IOException &#123;
    
    <span class="hljs-comment">//1、获取上传文件原始名</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> image.getOriginalFilename();
    
    <span class="hljs-comment">//2、构造新的唯一的文件名（uuid+文件后缀）</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>);
    <span class="hljs-type">String</span> <span class="hljs-variable">suffix</span> <span class="hljs-operator">=</span> originalFilename.substring(index);
    <span class="hljs-type">String</span> <span class="hljs-variable">newFileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + suffix;

    log.info(<span class="hljs-string">&quot;所提交的表单信息为:&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,username,age,newFileName);

    <span class="hljs-comment">//3、将文件保存在本地目录 D:/videos/目录下</span>
    image.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/videos/&quot;</span>+newFileName));
    <span class="hljs-keyword">return</span> Result.success();
&#125;</code></pre></div><p>在SpringBoot中，文件上传，默认单个文件允许最大大小为<code>1MB</code>.当上传文件大小超过时，会抛出异常</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240506175756491-2024-5-918:57:03.png" srcset="/img/loading.gif" lazyload alt="image-20240506175756491"><figcaption aria-hidden="true">image-20240506175756491</figcaption></figure><p>如果需要上传大文件，可以在配置文件中设置</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#配置单个文件最大上传大小</span>
<span class="hljs-string">spring.servlet.multipart.max-file-size=10MB</span>
<span class="hljs-comment">#配置单个请求最大上传文件大小（一次请求可以上传多个文件）</span>
<span class="hljs-string">spring.servlet.multipart.max-request-size=100B</span></code></pre></div><p>postman测试文件上传</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240506180504095-2024-5-918:57:08.png" srcset="/img/loading.gif" lazyload alt="image-20240506180504095"><figcaption aria-hidden="true">image-20240506180504095</figcaption></figure><h4 id="阿里云oss存储">阿里云OSS存储</h4><p>见本地代码</p><h3 id="配置文件">7.5、配置文件</h3><h4 id="参数配置化">参数配置化</h4><p>将需要用到的参数硬编码在java代码中，当代码量庞大，参数需要修改时，维护代价大，不便管理。</p><p>解决方法：将参数及其值添加到项目配置文件中，java代码中不直接写值，而是采用外部注入的方式</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240506220341750-2024-5-919:02:24.png" srcset="/img/loading.gif" lazyload alt="image-20240506220341750"><figcaption aria-hidden="true">image-20240506220341750</figcaption></figure><h4 id="yml配置文件">yml配置文件</h4><p>常见配置文件格式对比</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209165802973-2024-12-916:58:04.png" srcset="/img/loading.gif" lazyload alt="image-20241209165802973"><figcaption aria-hidden="true">image-20241209165802973</figcaption></figure><p>YML基本语法：</p><ul><li>大小写敏感</li><li>数值前边必须有空格，作为分隔符 冒号后必须有空格</li><li>使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格）</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li>#表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul><p>YML数据格式</p><ul><li><p>对象/Map集合</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">user:</span>
 <span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span>
 <span class="hljs-attr">age:</span> <span class="hljs-number">18</span>
 <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span>
<span class="hljs-comment"># 统一缩进，类似于python语法，用缩进表示结构关系</span></code></pre></div></li><li><p>数组/List/Set集合</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">hobby:</span>
  <span class="hljs-string">-java</span>
  <span class="hljs-string">-game</span>
  <span class="hljs-string">-sport</span>
<span class="hljs-comment">#元素成员前有一个短杠 -</span></code></pre></div></li></ul><p>使用<code>application.yml</code>替换<code>application.properties</code></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">application:</span>
    <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-employeemanagement</span>
  <span class="hljs-comment">#数据库连接配置</span>
  <span class="hljs-attr">datasource:</span>
    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>
    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>
    <span class="hljs-attr">password:</span> <span class="hljs-string">liuhao123</span>
  <span class="hljs-comment">#文件上传配置</span>
  <span class="hljs-attr">servlet:</span>
    <span class="hljs-attr">multipart:</span>
      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">10MB</span> <span class="hljs-comment">#配置单个文件最大上传大小</span>
      <span class="hljs-attr">max-request-size:</span> <span class="hljs-string">100MB</span> <span class="hljs-comment">#配置单个请求最大上传文件大小（一次请求可以上传多个文件）</span>

<span class="hljs-comment">#mybatis配置</span>
<span class="hljs-attr">mybatis:</span>
  <span class="hljs-attr">configuration:</span>
    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="hljs-comment">#配置mybatis的日志，指定输出到控制台</span>
    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment">#开启mybatis驼峰命名自动映射开关 a_cloumn ----&gt; aColumn</span>

<span class="hljs-comment">#阿里云OSS配置</span>
<span class="hljs-comment">#aliyun:</span>
<span class="hljs-comment">#  oss:</span>
<span class="hljs-comment">#    endpoint: xxxxxx</span>
<span class="hljs-comment">#    accessKeyId: xxxxxx</span>
<span class="hljs-comment">#    accessKeySecret: xxxxxx</span>
<span class="hljs-comment">#    bucketName: xxxxxxx</span>
</code></pre></div><h4 id="配置信息注入">配置信息注入</h4><p><code>@ConfigurationProperties</code>与<code>@Value</code></p><p>相同点：都是用来注入外部配置的属性的。</p><p>不同点：</p><ul><li><span class="citation" data-cites="Value注解只能一个一个的进行外部属性的注入">@Value注解只能一个一个的进行外部属性的注入</span>。（如果相关配置只有几个，用这个也可）</li><li><span class="citation" data-cites="ConfigurationProperties可以批量的将外部的属性配置注入到bean对象的属性中">@ConfigurationProperties可以批量的将外部的属性配置注入到bean对象的属性中</span>。（要获得配置信息，在对应类中注入该bean对象，调用其get方法即可）</li></ul><p>使用<code>@ConfigurationProperties</code>将配置文件中配置项的值自动注入到bean对象的属性中</p><p>前提：</p><ul><li>配置文件中key的名字与实体类的属性名相同</li><li>为实体类提供get和set方法（使用<code>@Data</code>注解）</li><li>将实体类交个IOC容器管理，成为IOC容器的bean对象 （使用<code>@Component</code>注解）</li><li>指定配置项的前缀：使用<code>ConfigurationProperties(prefix ="xxxx")</code></li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240506222720114-2024-5-919:02:54.png" srcset="/img/loading.gif" lazyload alt="image-20240506222720114"><figcaption aria-hidden="true">image-20240506222720114</figcaption></figure><p>添加如下注解，在完成实体类定义后，添加配置项时会生成提示信息</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="登录校验">7.6、登录校验</h3><p>登录时根据用户名和密码查询数据库，若返回信息为null，则用户名或密码错误；不为null，则数据库中存在记录，登录成功。但是由于客户端和服务器直接交互是基于HTTP协议的，而HTTP协议又是无状态的协议，两个访问直接没有关联。即使登录失败，也可以在地址栏中输入页面地址直接访问。登录操作形同虚设。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240506230923099-2024-5-919:03:10.png" srcset="/img/loading.gif" lazyload alt="image-20240506230923099" style="zoom:80%"></p><h4 id="会话技术">会话技术</h4><ul><li>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。</li><li>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。</li><li>会话跟踪方案：<ul><li>客户端会话跟踪技术：Cookie</li><li>服务端会话跟踪技术：Session</li><li>令牌技术</li></ul></li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209170355187-2024-12-917:04:10.png" srcset="/img/loading.gif" lazyload alt="image-20241209170355187"><figcaption aria-hidden="true">image-20241209170355187</figcaption></figure><p>​</p><p>会话跟踪方案对比</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240507095823985-2024-5-919:03:26.png" srcset="/img/loading.gif" lazyload alt="image-20240507095823985"><figcaption aria-hidden="true">image-20240507095823985</figcaption></figure><blockquote><p>Cookie</p></blockquote><p>1、浏览器在第一次访问服务器时，在服务端保存相关访问数据，在给浏览器的响应头中通过Set-Cookie自动将服务端保存的信息响应给浏览器</p><p>2、浏览器识别响应头中的Set-Cookie，将其中的数据自动保存在本地Cookie</p><p>3、以后每次发起服务端访问请求都会通过请求头中的Cookie携带本地数据到服务端，在服务端获得该Cookie的值，进行判断</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//设置Cookie</span>
<span class="hljs-meta">@GetMapping(&quot;/c1&quot;)</span>
<span class="hljs-keyword">public</span> Result <span class="hljs-title function_">cookie1</span><span class="hljs-params">(HttpServletResponse response)</span>&#123;
    response.addCookie(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;login_username&quot;</span>,<span class="hljs-string">&quot;itheima&quot;</span>)); <span class="hljs-comment">//设置Cookie/响应Cookie</span>
    <span class="hljs-keyword">return</span> Result.success();
&#125;

<span class="hljs-comment">//获取Cookie</span>
<span class="hljs-meta">@GetMapping(&quot;/c2&quot;)</span>
<span class="hljs-keyword">public</span> Result <span class="hljs-title function_">cookie2</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;
    Cookie[] cookies = request.getCookies();
    <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;
        <span class="hljs-keyword">if</span>(cookie.getName().equals(<span class="hljs-string">&quot;login_username&quot;</span>))&#123;
            System.out.println(<span class="hljs-string">&quot;login_username: &quot;</span>+cookie.getValue()); <span class="hljs-comment">//输出name为login_username的cookie</span>
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> Result.success();
&#125;
</code></pre></div><blockquote><p>Session</p></blockquote><p>Session是基于Cookie实现的，Session会话对象保存在服务器端，浏览器访问服务器时，可以在服务器中获取对应的Session对象。</p><p>1、浏览器第一次访问服务器时session不存在，服务器会自动创建一个会话对象Session，每个session都有一个id，服务器通过Cookie将SessionId响应给浏览器。（在响应头中增加一条Set-Cookie，其内容就是SessionID）</p><p>2、浏览器解析响应头，将Cookie保存在本地</p><p>3、在浏览器每次访问服务器时都会将本地Cookie数据获取出来，携带到服务端。服务端从中获取SessionID，从众多的Session中找到当前请求对应的会话对象Session。</p><p>这样就可以通过Session在同一个会话的多次请求直接传共享数据</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/s1&quot;)</span>
<span class="hljs-keyword">public</span> Result <span class="hljs-title function_">session1</span><span class="hljs-params">(HttpSession session)</span>&#123;
    log.info(<span class="hljs-string">&quot;HttpSession-s1: &#123;&#125;&quot;</span>, session.hashCode());

    session.setAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>, <span class="hljs-string">&quot;tom&quot;</span>); <span class="hljs-comment">//往session中存储数据</span>
    <span class="hljs-keyword">return</span> Result.success();
&#125;

<span class="hljs-meta">@GetMapping(&quot;/s2&quot;)</span>
<span class="hljs-keyword">public</span> Result <span class="hljs-title function_">session2</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;
    <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();
    log.info(<span class="hljs-string">&quot;HttpSession-s2: &#123;&#125;&quot;</span>, session.hashCode());

    <span class="hljs-type">Object</span> <span class="hljs-variable">loginUser</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>); <span class="hljs-comment">//从session中获取数据</span>
    log.info(<span class="hljs-string">&quot;loginUser: &#123;&#125;&quot;</span>, loginUser);
    <span class="hljs-keyword">return</span> Result.success(loginUser);
&#125;</code></pre></div><blockquote><p>令牌技术</p></blockquote><p>​ 用户登录成功后生成令牌，并将令牌响应前端，前端将令牌保存起来，在以后的每一次请求中都要携带令牌。首先服务端对接收到的令牌进行校验，若令牌有效则放行，否则进行拦截，跳转至指定页面。</p><p>JWT</p><ul><li>全称：JSON Web Token（https://jwt.io/）</li><li>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。</li><li>组成：<ul><li>第一部分：Header（头），记录令牌类型、签名算法等。例如：{"alg"："HS256"，"type"："JWT"}</li><li>第二部分：Payload（有效载荷），携带一些自定义信息、默认信息等。例如：{"id"："1"，"username"："Tom"}</li><li>第三部分：Signature（签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，<strong>通过指定签名算法计算而来</strong>。</li></ul></li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209170933608-2024-12-917:09:34.png" srcset="/img/loading.gif" lazyload alt="image-20241209170933608"><figcaption aria-hidden="true">image-20241209170933608</figcaption></figure><p>1、添加依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    JWT令牌    --&gt;</span>
<span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-api --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2、生成JWT令牌</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">JwtGenTest</span><span class="hljs-params">()</span> &#123;
    Map&lt;String, Object&gt; claims = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
    claims.put(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-number">1</span>);
    claims.put(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;Tom&quot;</span>);
    <span class="hljs-type">String</span> <span class="hljs-variable">jwt</span> <span class="hljs-operator">=</span> Jwts.builder()
            .signWith(SignatureAlgorithm.HS256, <span class="hljs-string">&quot;itheima&quot;</span>) <span class="hljs-comment">//指定编码格式和秘钥</span>
            .setClaims(claims) <span class="hljs-comment">//添加自定义内容（有效载荷）</span>
            .setExpiration(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis() + <span class="hljs-number">12</span>*<span class="hljs-number">3600</span>*<span class="hljs-number">1000</span>)) <span class="hljs-comment">//令牌有效期</span>
            .compact();
    <span class="hljs-comment">//eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNzE1MDkyOTg2LCJ1c2VybmFtZSI6IlRvbSJ9.vZkW8LOXOGODIhbuy4MSrL5BR6638eJM9uOJNnBScAc</span>
    System.out.println(jwt);
&#125;</code></pre></div><p>3、校验令牌</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseJwtTest</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-type">String</span> <span class="hljs-variable">jwt</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNzE1MDkyOTg2LCJ1c2VybmFtZSI6IlRvbSJ9.vZkW8LOXOGODIhbuy4MSrL5BR6638eJM9uOJNnBScAc&quot;</span>;
    
    <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> Jwts.parser()
        .setSigningKey(<span class="hljs-string">&quot;itheima&quot;</span>) <span class="hljs-comment">//指定签名秘钥</span>
        .parseClaimsJws(jwt) <span class="hljs-comment">//解析秘钥</span>
        .getBody(); <span class="hljs-comment">//获得其中的自定义数据</span>
    System.out.println(claims);
&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240507104834966-2024-5-919:03:49.png" srcset="/img/loading.gif" lazyload alt="image-20240507104834966" style="zoom:80%"></p><p>4、生成JWT工具类，使用时调用其中的方法即可</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//JwtUtils.java</span>


<span class="hljs-keyword">import</span> io.jsonwebtoken.Claims;
<span class="hljs-keyword">import</span> io.jsonwebtoken.Jwts;
<span class="hljs-keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;
<span class="hljs-keyword">import</span> java.util.Date;
<span class="hljs-keyword">import</span> java.util.Map;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtUtils</span> &#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">signKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itheima&quot;</span>; <span class="hljs-comment">//设置秘钥</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Long</span> <span class="hljs-variable">expire</span> <span class="hljs-operator">=</span> <span class="hljs-number">43200000L</span>; <span class="hljs-comment">//设置秘钥过期时间</span>

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 生成JWT令牌</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> claims JWT第二部分负载 payload 中存储的内容</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">generateJwt</span><span class="hljs-params">(Map&lt;String, Object&gt; claims)</span>&#123;
        <span class="hljs-type">String</span> <span class="hljs-variable">jwt</span> <span class="hljs-operator">=</span> Jwts.builder()
                .addClaims(claims)
                .signWith(SignatureAlgorithm.HS256, signKey)
                .setExpiration(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis() + expire))
                .compact();
        <span class="hljs-keyword">return</span> jwt;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 解析JWT令牌</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jwt JWT令牌</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JWT第二部分负载 payload 中存储的内容</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Claims <span class="hljs-title function_">parseJWT</span><span class="hljs-params">(String jwt)</span>&#123;
        <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> Jwts.parser()
                .setSigningKey(signKey)
                .parseClaimsJws(jwt)
                .getBody();
        <span class="hljs-keyword">return</span> claims;
    &#125;
&#125;</code></pre></div><p>5、登录成功下发令牌，登录失败返回错误信息</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginController</span> &#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> EmpService empService;

    <span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span>
    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Emp emp)</span> &#123;
        <span class="hljs-type">Emp</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> empService.getByUsernameAndPassword(emp);
        <span class="hljs-comment">//登录成功，生成令牌，下发令牌</span>
        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;
            Map&lt;String, Object&gt; claims = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
            claims.put(<span class="hljs-string">&quot;id&quot;</span>,e.getId());
            claims.put(<span class="hljs-string">&quot;name&quot;</span>,e.getName());
            claims.put(<span class="hljs-string">&quot;username&quot;</span>,e.getUsername());
            <span class="hljs-type">String</span> <span class="hljs-variable">jwt</span> <span class="hljs-operator">=</span> JwtUtils.generateJwt(claims); <span class="hljs-comment">//生成的Jwt令牌中已经包含了员工信息</span>
            <span class="hljs-keyword">return</span> Result.success(jwt);
        &#125;
        <span class="hljs-comment">//登录失败，返回错误信息</span>
        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;用户名或密码错误&quot;</span>);
    &#125;
&#125;</code></pre></div><h4 id="过滤器实现登录校验">过滤器实现登录校验</h4><p>过滤器（Filter）</p><ul><li>概念：<strong>Filter过滤器</strong>，是JavaWeb三大组件（Servlet、Filter、Listener）之一。</li><li>过滤器可以把对资源的请求<strong>拦截</strong>下来，从而实现一些特殊的功能。</li><li>过滤器一般完成一些<strong>通用</strong>的操作，比如：登录校验、统一编码处理、敏感字符处理等。</li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209170705008-2024-12-917:07:06.png" srcset="/img/loading.gif" lazyload alt="image-20241209170705008"><figcaption aria-hidden="true">image-20241209170705008</figcaption></figure><blockquote><p>快速入门</p></blockquote><p>步骤：</p><ol type="1"><li>定义Filter：定义一个类，实现 Filter 接口，并重写其所有方法。（只有三个：init，doFilter，destroy）</li><li>配置Filter：Filter类上加@webFilter注解，配置拦截资源的路径。引导类上加@ServletComponentScan开启Servlet组件支持。</li></ol><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209171051916-2024-12-917:10:53.png" srcset="/img/loading.gif" lazyload alt="image-20241209171051916"><figcaption aria-hidden="true">image-20241209171051916</figcaption></figure><p>注：一定要继承 <code>javax.servlet</code>的Filter</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240507111913871-2024-5-919:04:04.png" srcset="/img/loading.gif" lazyload alt="image-20240507111913871"><figcaption aria-hidden="true">image-20240507111913871</figcaption></figure><blockquote><p>过滤器细节（过滤器执行流程、过滤器拦截路径、过滤器链）</p></blockquote><ol type="1"><li><p><strong>过滤器执行流程</strong></p><p>请求----&gt;放行前逻辑 ----&gt;放行 -----&gt;访问Web资源 -----&gt;放行后逻辑</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240507113959486-2024-5-919:04:08.png" srcset="/img/loading.gif" lazyload alt="image-20240507113959486"><figcaption aria-hidden="true">image-20240507113959486</figcaption></figure></li><li><p><strong>过滤器拦截路径</strong></p><p>Filter可以根据需求，配置不同的拦截资源路径：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-09_17-13-19-2024-12-917:14:29.png" srcset="/img/loading.gif" lazyload alt="PixPin_2024-12-09_17-13-19"><figcaption aria-hidden="true">PixPin_2024-12-09_17-13-19</figcaption></figure></li><li><p><strong>过滤器链</strong></p><p>一个web应用中，配置了多个过滤器，就形成了一个过滤器链。</p><ul><li>介绍：一个web应用中，可以配置多个过滤器，这多个过滤器就形成了一个过滤器链。</li><li>顺序：注解配置的Filter，|优先级是按照过滤器类名（字符串）的自然排序。</li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209171527241-2024-12-917:15:40.png" srcset="/img/loading.gif" lazyload alt="image-20241209171527241"><figcaption aria-hidden="true">image-20241209171527241</figcaption></figure></li></ol><blockquote><p>登录拦截实现</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240507114549100-2024-5-919:04:23.png" srcset="/img/loading.gif" lazyload alt="image-20240507114549100"><figcaption aria-hidden="true">image-20240507114549100</figcaption></figure><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.filter;

<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;
<span class="hljs-keyword">import</span> com.example.pojo.Result;
<span class="hljs-keyword">import</span> com.example.utils.JwtUtils;
<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;
<span class="hljs-keyword">import</span> org.springframework.util.StringUtils;

<span class="hljs-keyword">import</span> javax.servlet.*;
<span class="hljs-keyword">import</span> javax.servlet.annotation.WebFilter;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;
<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;
<span class="hljs-keyword">import</span> java.io.IOException;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> LoginCheckFilter</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> 86152</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/5/7 16:02</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span>
<span class="hljs-comment"> */</span>

<span class="hljs-meta">@Slf4j</span>
<span class="hljs-meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginCheckFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;

        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;
        <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">resp</span>  <span class="hljs-operator">=</span> (HttpServletResponse) response;

        <span class="hljs-comment">//1、获得请求的路径URL</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> req.getRequestURI().toString();
        log.info(<span class="hljs-string">&quot;请求路径为&#123;&#125;&quot;</span>,url);

        <span class="hljs-comment">//2、判断是否为登录请求。判断请求ur1中是否包含login，如果包含，说明是登录操作，放行。</span>
        <span class="hljs-keyword">if</span>(url.contains(<span class="hljs-string">&quot;login&quot;</span>)) &#123;
            log.info(<span class="hljs-string">&quot;登录操作，放行....&quot;</span>);
            chain.doFilter(request,response);
            <span class="hljs-keyword">return</span>;<span class="hljs-comment">//放行后不必返回执行后续代码</span>
        &#125;

        <span class="hljs-comment">//3、获取请求头中的令牌(token)</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> req.getHeader(<span class="hljs-string">&quot;token&quot;</span>);

        <span class="hljs-comment">//4、判断令牌是否存在，如果不存在返回错误结果（未登录）</span>
        <span class="hljs-keyword">if</span>(!StringUtils.hasLength(token)) &#123;
            log.info(<span class="hljs-string">&quot;请求头中token为空，返回未登录的信息&quot;</span>);
            <span class="hljs-type">Result</span> <span class="hljs-variable">notLogin</span> <span class="hljs-operator">=</span> Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);
            <span class="hljs-comment">//手动转换 javaBean --&gt; JSON ，使用FastJSON</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">notLoginStr</span> <span class="hljs-operator">=</span> JSON.toJSONString(notLogin);
            resp.getWriter().write(notLoginStr);
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-comment">//5、解析令牌</span>
        <span class="hljs-keyword">try</span> &#123;
            JwtUtils.parseJWT(token);
        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123; <span class="hljs-comment">//jwt解析失败</span>
            log.info(<span class="hljs-string">&quot;令牌解析失败，返回未登录的信息&quot;</span>);
            <span class="hljs-type">Result</span> <span class="hljs-variable">notLogin</span> <span class="hljs-operator">=</span> Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);
            <span class="hljs-comment">//手动转换 javaBean --&gt; JSON ，使用FastJSON</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">notLoginStr</span> <span class="hljs-operator">=</span> JSON.toJSONString(notLogin);
            resp.getWriter().write(notLoginStr);
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-comment">//6、放行</span>
        log.info(<span class="hljs-string">&quot;令牌合法，放行....&quot;</span>);
        chain.doFilter(request, response);
    &#125;
&#125;
</code></pre></div><h4 id="拦截器实现登录校验">拦截器实现登录校验</h4><blockquote><p>快速入门</p></blockquote><p>步骤：</p><ol type="1"><li><p>定义拦截器，实现Handlerinterceptor接口，并重写其所有方法。</p></li><li><p>注册拦截器</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209171639829-2024-12-917:17:23.png" srcset="/img/loading.gif" lazyload alt="image-20241209171639829"><figcaption aria-hidden="true">image-20241209171639829</figcaption></figure></li></ol><blockquote><p>拦截器详解</p></blockquote><p>拦截路径：</p><p>拦截器可以根据需求，配置不同的拦截路径：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span>&#123;
  registry.addInterceptor(loginCheckInterceptor)
      .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>) <span class="hljs-comment">//需要拦截哪些资源</span>
      .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>); <span class="hljs-comment">//不需要拦截哪些资源</span>
&#125;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209172035778-2024-12-917:20:37.png" srcset="/img/loading.gif" lazyload alt="image-20241209172035778"><figcaption aria-hidden="true">image-20241209172035778</figcaption></figure><p>多个拦截器的执行顺序：</p><p>当拦截器添加后，会被封装成一个注册器<code>InterceptorRegistration</code>，它有一个order属性，用来控制当前拦截器的执行顺序，默认为0，即按照添加顺序执行。<strong>order越小，执行优先级越高</strong>。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241211211406367-2024-12-1121:15:20.png" srcset="/img/loading.gif" lazyload alt="image-20241211211406367"><figcaption aria-hidden="true">image-20241211211406367</figcaption></figure><p>拦截器执行流程</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209172125513-2024-12-917:21:26.png" srcset="/img/loading.gif" lazyload alt="image-20241209172125513"><figcaption aria-hidden="true">image-20241209172125513</figcaption></figure><p>Filter 与 Interceptor对比</p><ul><li>接口规范不同：过滤器需要实现Filter接口，而拦截器需要实现Handlerinterceptor接口。</li><li>拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源。</li></ul><blockquote><p>实现登录校验</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240507170311521-2024-5-817:18:26.png" srcset="/img/loading.gif" lazyload alt="image-20240507170311521"><figcaption aria-hidden="true">image-20240507170311521</figcaption></figure><p>1、定义拦截器，在preHandle方法中编写拦截逻辑</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span>
<span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginCheckInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;
    
    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//目标资源方法执行前执行，放回true：放行，返回false：不放行</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;

        <span class="hljs-comment">//1、获得请求的路径URL</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> req.getRequestURI().toString();
        log.info(<span class="hljs-string">&quot;请求路径为&#123;&#125;&quot;</span>,url);

        <span class="hljs-comment">//2、判断是否为登录请求。判断请求ur1中是否包含login，如果包含，说明是登录操作，放行。</span>
        <span class="hljs-keyword">if</span>(url.contains(<span class="hljs-string">&quot;login&quot;</span>)) &#123;
            log.info(<span class="hljs-string">&quot;登录操作，放行....&quot;</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;

        <span class="hljs-comment">//3、获取请求头中的令牌(token)</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> req.getHeader(<span class="hljs-string">&quot;token&quot;</span>);

        <span class="hljs-comment">//4、判断令牌是否存在，如果不存在返回错误结果（未登录）</span>
        <span class="hljs-keyword">if</span>(!StringUtils.hasLength(token)) &#123;
            log.info(<span class="hljs-string">&quot;请求头中token为空，返回未登录的信息&quot;</span>);
            <span class="hljs-type">Result</span> <span class="hljs-variable">notLogin</span> <span class="hljs-operator">=</span> Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);
            <span class="hljs-comment">//手动转换 javaBean --&gt; JSON ，使用FastJSON</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">notLoginStr</span> <span class="hljs-operator">=</span> JSON.toJSONString(notLogin);
            resp.getWriter().write(notLoginStr);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//不放行</span>
        &#125;

        <span class="hljs-comment">//5、解析令牌</span>
        <span class="hljs-keyword">try</span> &#123;
            JwtUtils.parseJWT(token);
        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123; <span class="hljs-comment">//jwt解析失败</span>
            log.info(<span class="hljs-string">&quot;令牌解析失败，返回未登录的信息&quot;</span>);
            <span class="hljs-type">Result</span> <span class="hljs-variable">notLogin</span> <span class="hljs-operator">=</span> Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);
            <span class="hljs-comment">//手动转换 javaBean --&gt; JSON ，使用FastJSON</span>
            <span class="hljs-type">String</span> <span class="hljs-variable">notLoginStr</span> <span class="hljs-operator">=</span> JSON.toJSONString(notLogin);
            resp.getWriter().write(notLoginStr);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//不放行</span>
        &#125;

        <span class="hljs-comment">//6、放行</span>
        log.info(<span class="hljs-string">&quot;令牌合法，放行....&quot;</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//目标资源方法执行后执行</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;
        System.out.println(<span class="hljs-string">&quot;postHandle....&quot;</span>);
    &#125;

    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//视图渲染完毕后执行，最后执行</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;
        System.out.println(<span class="hljs-string">&quot;afterCompletion....&quot;</span>);
    &#125;
&#125;
</code></pre></div><p>2、注册拦截器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//配置类</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;

    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">//拦截器对象自动注入</span>
    LoginCheckInterceptor loginCheckInterceptor;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;
        registry.addInterceptor(loginCheckInterceptor)
            .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)  <span class="hljs-comment">//需要拦截的路径</span>
            .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>); <span class="hljs-comment">//不需要拦截的路径</span>
    &#125;
&#125;
</code></pre></div><h3 id="异常处理">7.7、异常处理</h3><p>定义全局异常处理器，对项目中出现的异常进行处理，并返回格式化的错误信息</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240507172946016-2024-5-817:17:26.png" srcset="/img/loading.gif" lazyload alt="image-20240507172946016"><figcaption aria-hidden="true">image-20240507172946016</figcaption></figure><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span>  <span class="hljs-comment">//声明当前类是一个全局异常处理器</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;

    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span> <span class="hljs-comment">//指定所捕获的异常类型：当前捕获所有异常</span>
    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">ex</span><span class="hljs-params">(Exception e)</span> &#123;
        e.printStackTrace();
        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;操作失败，请联系管理员！&quot;</span>);
    &#125;
&#125;</code></pre></div><h2 id="八spring事务管理">八、Spring事务管理</h2><p>与数据库的事务概念相同</p><p><strong>事务</strong> 是一组操作的集合，它是一个不可分割的工作单位，这些操作要么同时成功，要么同时失败。</p><p>操作：</p><ul><li>开启事务（一组操作开始前，开启事务）：start transaction/begin；</li><li>提交事务（这组操作全部成功后，提交事务）：commit；</li><li>回滚事务（中间任何一个操作出现异常，回滚事务）：rollback；</li></ul><h3 id="transactional">8.1、<span class="citation" data-cites="Transactional">@Transactional</span></h3><ul><li>位置：业务（service）层的方法上、类上、接口上</li><li>作用：将当前方法交给spring进行事务管理，<strong>方法执行前，开启事务；成功执行完毕，提交事务；出现异常，回滚事务</strong>。</li></ul><p>注解作用在方法上，将当前方法交给Spring进行事务管理</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>方法
<span class="hljs-meta">@override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Integer id)</span>&#123;
	<span class="hljs-comment">//1.删除部门</span>
	deptMapper.delete(id);
    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<span class="hljs-comment">//模拟抛出异常</span>
	<span class="hljs-comment">//2.根据部门id，删除部门下的员工信息</span>
    empMapper.deleteByDeptId(id);
&#125;</code></pre></div><p>作用在类上，将这个类的所有方法都交给Spring进行事务管理</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>
<span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeptServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DeptService</span>&#123;&#125;</code></pre></div><p>作用在接口上，将这个接口所有的实现类的所有方法都交给Spring进行事务管理</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Deptservice</span> &#123;&#125;</code></pre></div><p>案例：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240508095827014-2024-5-809:58:27.png" srcset="/img/loading.gif" lazyload alt="image-20240508095827014"><figcaption aria-hidden="true">image-20240508095827014</figcaption></figure><p>若一个方法需要多次修改数据库（执行多条DML语句），为了保证原子性，需要在该方法上添加<code>@Transactional</code>注解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span> <span class="hljs-comment">//开启Spring事务</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Integer id)</span> &#123;
    deptMapper.deleteDeptById(id); <span class="hljs-comment">//根据部门id删除部门</span>
    empMapper.deleteByDeptId(id); <span class="hljs-comment">//同时删除该部门下的所有员工</span>
&#125;</code></pre></div><h3 id="rollbackfor属性">8.2、rollbackFor属性</h3><p>默认情况下，只有出现<code>RuntimeException</code>才回滚异常。rollbackFor属性用于控制出现何种异常类型，回滚事务。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209172929990-2024-12-917:29:40.png" srcset="/img/loading.gif" lazyload alt="image-20241209172929990"><figcaption aria-hidden="true">image-20241209172929990</figcaption></figure><h3 id="propagation属性">8.3、propagation属性</h3><p>事务传播行为，若一个事务方法A调用了另一个事务方法B，B应该加入A的事务中，还是新建一个事务，这就是事务的传播行为问题。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240508104656427-2024-5-810:47:26.png" srcset="/img/loading.gif" lazyload alt="image-20240508104656427"><figcaption aria-hidden="true">image-20240508104656427</figcaption></figure><p>常用：前两个属性</p><ul><li><p>REQUIRED：大部分情况下都是用该传播行为即可。</p></li><li><p>REQUIRES_NEW：<strong>当我们不希望事务之间相互影响时</strong>，可以使用该传播行为。比如：下订单前需要记录日志，不论订单保存成功与否，都需要保证日志记录能够记录成功。</p><blockquote><p>当前方法的事务设置该属性后，调用该方法，会先挂起已有的事务，为该方法创建一个新的事务，当新事物提交或回滚后，再执行挂起的事务</p></blockquote></li></ul><h2 id="九aop">九、AOP</h2><h3 id="aop基础">9.1、AOP基础</h3><h4 id="概述-1">概述</h4><p><strong>AOP</strong>：<strong>A</strong>spect <strong>O</strong>riented <strong>P</strong>rogramming（面向切面编程、面向方面编程），其实就是面向特定方法编程。</p><p>使用场景：</p><ul><li>记录操作日志</li><li>权限控制</li><li>事务管理</li><li>.....</li></ul><p>优势：</p><ul><li>代码无入侵</li><li>减少重复代码</li><li>提高开发效率</li><li>维护方便</li></ul><p>例如：部分功能运行较慢，定位执行耗时较长的业务方法，此时需要统计每一个业务方法的执行耗时</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209173503658-2024-12-917:35:40.png" srcset="/img/loading.gif" lazyload alt="image-20241209173503658"><figcaption aria-hidden="true">image-20241209173503658</figcaption></figure><p>AOP的解决方案：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209173611618-2024-12-917:36:40.png" srcset="/img/loading.gif" lazyload alt="image-20241209173611618"><figcaption aria-hidden="true">image-20241209173611618</figcaption></figure><h4 id="快速入门-1">快速入门</h4><p>Spring AOP快速入门：统计各个业务层方法执行耗时</p><ol type="1"><li><p>导入AOP依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- AOP--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>编写AOP程序：针对特定方法根据业务需要进行编程</p><div class="code-wrapper"><pre><code class="hljs java">
<span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Aspect</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeAspect</span> &#123;

    <span class="hljs-meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span> <span class="hljs-comment">//指定</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">recordTime</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;
        <span class="hljs-comment">//1、获得方法运行开始时间</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();

        <span class="hljs-comment">//2、运行原始方法</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> joinPoint.proceed(); <span class="hljs-comment">//执行切入点方法，</span>

        <span class="hljs-comment">//3、获取方法结束时间，计算运行耗时</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        log.info(joinPoint.getSignature()+<span class="hljs-string">&quot;方法执行耗时为:&#123;&#125;ms&quot;</span>,end-begin);
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;
</code></pre></div></li></ol><h4 id="核心概念">核心概念</h4><ul><li>连接点：JoinPoint，<strong>可以被AOP控制的方法</strong>（暗含方法执行时的相关信息）</li><li>通知：Advice，指哪些重复的逻辑，也就是<strong>共性功能</strong>（最终体现为一个方法）</li><li>切入点：Pointcut，<strong>匹配连接点的条件</strong>，通知仅会在切入点方法执行时被应用</li><li>切面：Aspect，描述通知与切入点的对应关系（<strong>通知+切入点</strong>）</li><li>目标对象：Target，通知所应用的对象</li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209201837028-2024-12-920:18:40.png" srcset="/img/loading.gif" lazyload alt="image-20241209201837028"><figcaption aria-hidden="true">image-20241209201837028</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209201913094-2024-12-920:19:20.png" srcset="/img/loading.gif" lazyload alt="image-20241209201913094"><figcaption aria-hidden="true">image-20241209201913094</figcaption></figure><h4 id="aop执行流程">AOP执行流程</h4><p>AOP是基于<code>动态代理</code>实现的，程序运行时会针对目标对象生成<code>代理对象</code>，按照通知中的逻辑对原始方法进行增强，执行时所注入的不再是目标对象而是增强后的代理对象，调用方法时使用的也是代理对象中的方法</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240508115303160-2024-5-811:53:26.png" srcset="/img/loading.gif" lazyload alt="image-20240508115303160"><figcaption aria-hidden="true">image-20240508115303160</figcaption></figure><h3 id="aop进阶">9.2、AOP进阶</h3><h4 id="通知的类型">通知的类型</h4><ol type="1"><li><span class="citation" data-cites="Around">@Around</span>：环绕通知，此注解标注的通知方法在目标方法前、后都被执行</li><li><span class="citation" data-cites="Before">@Before</span>：前置通知，此注解标注的通知方法在目标方法前被执行</li><li><span class="citation" data-cites="After">@After</span>：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行（又称为最终执行）</li><li><span class="citation" data-cites="AfterReturning">@AfterReturning</span>：返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行（正常返回后执行）</li><li><span class="citation" data-cites="AfterThrowing">@AfterThrowing</span>：异常后通知，此注解标注的通知方法发生异常后执行（发生异常时执行，与上一个互斥）</li></ol><blockquote><p>注意</p><ul><li><span class="citation" data-cites="Around环绕通知需要自己调用ProceedingJoinPoint.proceed">@Around环绕通知需要自己调用ProceedingJoinPoint.proceed</span>（）来让原始方法执行，其他通知不需要考虑目标方法执行</li><li><span class="citation" data-cites="Around环绕通知方法的返回值">@Around环绕通知方法的返回值</span>，必须指定为object，来接收原始方法的返回值。（手动将原始方法的返回值return）</li></ul></blockquote><h4 id="通知顺序">通知顺序</h4><p>当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行。</p><p>执行顺序：</p><ol type="1"><li>不同切面类中，默认按照切面类的类名字母排序：<ul><li>目标方法前的通知方法：字母排名靠前的先执行</li><li>目标方法后的通知方法：字母排名靠前的后执行</li></ul></li><li>用<code>@Order（数字）</code>加在切面类上来控制顺序<ul><li>目标方法前的通知方法：数字小的先执行</li><li>目标方法后的通知方法：数字小的后执行</li></ul></li></ol><h4 id="切入点">切入点</h4><p>每个通知中都必须通过切入点表达式指定要增强的方法，每个都需要写一个表达式，臃肿且不变修改，可以将切入点表达式抽取出来，可供多个切面类使用</p><p><span class="citation" data-cites="PintCut">@PintCut</span></p><p>该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切入点表达式即可。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209180045106-2024-12-918:00:50.png" srcset="/img/loading.gif" lazyload alt="image-20241209180045106"><figcaption aria-hidden="true">image-20241209180045106</figcaption></figure><p><strong>切入点表达式</strong></p><ul><li><p>描述切入点方法的一种表达式</p></li><li><p>作用：主要用来<strong>决定项目中的哪些方法需要加入通知</strong></p></li><li><p>常见形式</p><ul><li><p>execution(...)：根据方法的签名来匹配</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209202517446-2024-12-920:25:40.png" srcset="/img/loading.gif" lazyload alt="image-20241209202517446"><figcaption aria-hidden="true">image-20241209202517446</figcaption></figure></li><li><p><span class="citation" data-cites="annotation">@annotation</span>(...)：根据注解匹配</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209202542532-2024-12-920:25:48.png" srcset="/img/loading.gif" lazyload alt="image-20241209202542532"><figcaption aria-hidden="true">image-20241209202542532</figcaption></figure></li></ul></li></ul><h5 id="切入点表达式-execution">切入点表达式-execution</h5><p>execution 主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，语法为：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209202845076-2024-12-920:28:46.png" srcset="/img/loading.gif" lazyload alt="image-20241209202845076"><figcaption aria-hidden="true">image-20241209202845076</figcaption></figure><p>其中带<code>？</code>的表示可以省略的部分</p><ul><li>访问修饰符：可省略（比如：public、protected）</li><li>包名.类名：可省略</li><li>throws 异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）</li></ul><p>可以使用通配符描述切入点</p><ul><li><p><code>*</code> ：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的<strong>一个参数</strong>，也可以<u>通配包、类、方法名的一部分</u>。</p><div class="code-wrapper"><pre><code class="hljs java">execution(* com.*.service.update(*))</code></pre></div></li><li><p><code>..</code>：多个连续的任意符号，可以通配任意层级的包，或任意类型、<strong>任意个数的参数</strong></p><div class="code-wrapper"><pre><code class="hljs java">execution(* com.itheima..DeptService.*(..))</code></pre></div></li></ul><blockquote><p>根据业务需要，可以使用 且（&amp;&amp;）、或（||）、非（！）来组合比较复杂的切入点表达式。</p></blockquote><p>书写建议：</p><ul><li>所有业务<strong>方法名</strong>在命名时尽量<strong>规范</strong>，方便切入点表达式快速匹配。如：查询类方法都是find开头，更新类方法都是update开头。</li><li>描述切入点方法通常<strong>基于接口描述</strong>，而不是直接描述实现类，<strong>增强拓展性</strong>。</li><li>在满足业务需要的前提下，<strong>尽量缩小切入点的匹配范围</strong>。如：包名匹配尽量不使用..，使用*匹配单个包。</li></ul><h5 id="切入点表达式-annotation">切入点表达式-<span class="citation" data-cites="annotation">@annotation</span></h5><p><span class="citation" data-cites="annotation切入点表达式">@annotation切入点表达式</span>，用于匹配标识有<strong>特定注解</strong>的方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@annotation(com.itheima.anno.Log)</span> <span class="hljs-comment">//括号内为注解的全类名</span></code></pre></div><p>因此，可以自定义一个注解，用作标识</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target(ElementType.METHOD)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Log &#123;
&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Before</span>（<span class="hljs-string">&quot;@annotation（com.itheima.anno.Log）&quot;</span>）
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;
    log.info(<span class="hljs-string">&quot;before....&quot;</span>);
&#125;</code></pre></div><p>这种方法十分灵活，对于一些命名不规范的方法，采用<code>execution表达式</code>来匹配需要添加多个表达式，十分冗长。此时可以使用 <code>@annotation</code>切入点表达式来匹配，只需在要匹配的方法上添加自定义注解即可。</p><h4 id="连接点">连接点</h4><p>​ 在Spring中用<code>JoinPoint</code>抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。</p><ul><li>对于@Around 通知,获取连接点信息只能使用 <code>ProceedingJoinPoint</code></li><li>对于其他四种通知，获取连接点信息只能使用 <code>JoinPoint</code>，它是<code>ProceedingJoinPoint</code> 的父类型</li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209205048611-2024-12-920:51:02.png" srcset="/img/loading.gif" lazyload alt="image-20241209205048611"><figcaption aria-hidden="true">image-20241209205048611</figcaption></figure><h3 id="案例">9.3、案例</h3><p>​ 将案例中 <strong>增、删、改</strong> 相关接口的操作日志记录到数据库表中。</p><p>​ 日志信息包含：操作人、操作时间、执行方法的全类名、执行方法名、方法运行时参数、返回值、方法执行时长</p><ul><li>需要对所有业务类中的增、删、改方法添加统一功能，使用AOP技术最为方便</li><li>需要获得方法的返回值和方法的执行时长，故应该采用<code>@Arround</code>环绕通知</li><li>由于增、删、改方法名没有规律，可以自定义注解（<span class="citation" data-cites="Log">@Log</span>）完成目标方法匹配，使用<code>@annotation</code>切入点表达式</li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240508170551209-2024-5-817:06:49.png" srcset="/img/loading.gif" lazyload alt="image-20240508170551209"><figcaption aria-hidden="true">image-20240508170551209</figcaption></figure><p>准备：</p><ul><li><p>AOP依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- AOP--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>日志表</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 操作日志表</span>
<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> operate_log(
    id <span class="hljs-type">int</span> unsigned <span class="hljs-keyword">primary</span> key auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span>,
    operate_user <span class="hljs-type">int</span> unsigned comment <span class="hljs-string">&#x27;操作人ID&#x27;</span>,
    operate_time datetime comment <span class="hljs-string">&#x27;操作时间&#x27;</span>,
    class_name <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) comment <span class="hljs-string">&#x27;操作的类名&#x27;</span>,
    method_name <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) comment <span class="hljs-string">&#x27;操作的方法名&#x27;</span>,
    method_params <span class="hljs-type">varchar</span>(<span class="hljs-number">1000</span>) comment <span class="hljs-string">&#x27;方法参数&#x27;</span>,
    return_value <span class="hljs-type">varchar</span>(<span class="hljs-number">2000</span>) comment <span class="hljs-string">&#x27;返回值&#x27;</span>,
    cost_time <span class="hljs-type">bigint</span> comment <span class="hljs-string">&#x27;方法执行耗时, 单位:ms&#x27;</span>
) comment <span class="hljs-string">&#x27;操作日志表&#x27;</span>;</code></pre></div></li></ul><p>编码：</p><ul><li><p>自定义注解<code>@Log</code>用作标识</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target(ElementType.METHOD)</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Log &#123;
&#125;</code></pre></div></li><li><p>定义日志表的实体类<code>OperateLog</code>，定义操作数据库的Mapper接口<code>OperateLogMapper</code>，在接口中定义插入方法即可。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperateLog</span> &#123;
    <span class="hljs-keyword">private</span> Integer id; <span class="hljs-comment">//ID</span>
    <span class="hljs-keyword">private</span> Integer operateUser; <span class="hljs-comment">//操作人ID</span>
    <span class="hljs-keyword">private</span> LocalDateTime operateTime; <span class="hljs-comment">//操作时间</span>
    <span class="hljs-keyword">private</span> String className; <span class="hljs-comment">//操作类名</span>
    <span class="hljs-keyword">private</span> String methodName; <span class="hljs-comment">//操作方法名</span>
    <span class="hljs-keyword">private</span> String methodParams; <span class="hljs-comment">//操作方法参数</span>
    <span class="hljs-keyword">private</span> String returnValue; <span class="hljs-comment">//操作方法返回值</span>
    <span class="hljs-keyword">private</span> Long costTime; <span class="hljs-comment">//操作耗时</span>
&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OperateLogMapper</span> &#123;

    <span class="hljs-comment">//插入日志数据</span>
    <span class="hljs-meta">@Insert(&quot;insert into operate_log (operate_user, operate_time, class_name, method_name, method_params, return_value, cost_time) &quot; +</span>
<span class="hljs-meta">            &quot;values (#&#123;operateUser&#125;, #&#123;operateTime&#125;, #&#123;className&#125;, #&#123;methodName&#125;, #&#123;methodParams&#125;, #&#123;returnValue&#125;, #&#123;costTime&#125;);&quot;)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(OperateLog log)</span>;

&#125;</code></pre></div></li><li><p>定义切面类，完成记录操作日志的逻辑</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-meta">@Aspect</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> HttpServletRequest request;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> OperateLogMapper operateLogMapper;

    <span class="hljs-meta">@Around(&quot;@annotation(com.example.anno.Log)&quot;)</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">recordLog</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;
        <span class="hljs-comment">//获得操作者id</span>
            <span class="hljs-comment">//通过对请求头中JWT令牌解析，获得当前操作者的id</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">JwtToken</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);
        <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> JwtUtils.parseJWT(JwtToken);
        <span class="hljs-type">Integer</span> <span class="hljs-variable">operatorUser</span> <span class="hljs-operator">=</span>(Integer) claims.get(<span class="hljs-string">&quot;id&quot;</span>);

        <span class="hljs-comment">//操作执行的时间</span>
        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">operateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now();

        <span class="hljs-comment">//所操作的类名</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> joinPoint.getClass().getName();
        <span class="hljs-comment">//所执行的方法名</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();
        <span class="hljs-comment">//方法传入的参数</span>
        Object[] args = joinPoint.getArgs();
        <span class="hljs-type">String</span> <span class="hljs-variable">methodParams</span> <span class="hljs-operator">=</span> Arrays.toString(args);

        <span class="hljs-comment">//调用原始目标方法运行</span>
        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> joinPoint.proceed();
        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();
        <span class="hljs-comment">//返回值</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> JSON.toJSONString(result);
        <span class="hljs-comment">//方法执行耗时</span>
        <span class="hljs-type">Long</span> <span class="hljs-variable">costTime</span> <span class="hljs-operator">=</span> end - begin;

        <span class="hljs-comment">//记录操作日志</span>
        <span class="hljs-type">OperateLog</span> <span class="hljs-variable">operateLog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OperateLog</span>(<span class="hljs-literal">null</span>,operatorUser,operateTime,className,methodName,methodParams,returnValue,costTime);
        operateLogMapper.insert(operateLog);
        log.info(<span class="hljs-string">&quot;记录操作日志：&#123;&#125;&quot;</span>,operateLog);

        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;
</code></pre></div></li><li><p>在部门管理和员工管理的Controller中，在执行增、删、改的方法上添加自定义注解<code>@Log</code>，当访问这些接口时会自动记录日志。如：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240508171422153-2024-5-817:14:26.png" srcset="/img/loading.gif" lazyload alt="image-20240508171422153"><figcaption aria-hidden="true">image-20240508171422153</figcaption></figure></li></ul><h2 id="十springboot原理探究">十、Springboot原理探究</h2><h3 id="配置优先级">10.1、配置优先级</h3><p><strong>优先级：低→高</strong></p><ul><li>application.yaml（忽略）</li><li>application.yml</li><li>application.properties</li><li>java系统属性（-Dxxx=xxx）</li><li>命令行参数（--xxx=xxx）</li></ul><p>在SpringBoot 中支持三种格式的配置文件：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-09_20-57-21-2024-12-920:58:40.png" srcset="/img/loading.gif" lazyload alt="PixPin_2024-12-09_20-57-21"><figcaption aria-hidden="true">PixPin_2024-12-09_20-57-21</figcaption></figure><p>SpringBoot除了支持配置文件属性配置，还支持<strong>Java系统属性</strong>和<strong>命令行参数</strong>的方式进行属性配置。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209210111973-2024-12-921:01:40.png" srcset="/img/loading.gif" lazyload alt="image-20241209210111973"><figcaption aria-hidden="true">image-20241209210111973</figcaption></figure><h3 id="bean管理">10.2、Bean管理</h3><h4 id="bean的获取">bean的获取</h4><p>​ 默认情况下，Spring项目启动时，会把bean都创建好放在IOC容器中，如果想要主动获取这些bean可以通过如下方式：</p><ul><li><p>根据name获取bean</p><div class="code-wrapper"><pre><code class="hljs java">Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span></code></pre></div></li><li><p>根据类型获取bean</p><div class="code-wrapper"><pre><code class="hljs java">&lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span></code></pre></div></li><li><p>根据name获取bean（带类型转换）</p><div class="code-wrapper"><pre><code class="hljs java">&lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span></code></pre></div></li></ul><blockquote><p>注意：上述所说的【Spring项目启动时，会把其中的bean都创建好】还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的bean而言。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootWebConfig2ApplicationTests</span> &#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> ApplicationContext applicationContext; <span class="hljs-comment">//IOC容器对象</span>

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetBean</span><span class="hljs-params">()</span>&#123;
        <span class="hljs-comment">//根据bean的名称获取，bean名称默认为类名首字母小写</span>
        <span class="hljs-type">DeptController</span> <span class="hljs-variable">bean1</span> <span class="hljs-operator">=</span> (DeptController) applicationContext.getBean(<span class="hljs-string">&quot;deptController&quot;</span>);
        System.out.println(bean1);

        <span class="hljs-comment">//根据bean的类型获取</span>
        <span class="hljs-type">DeptController</span> <span class="hljs-variable">bean2</span> <span class="hljs-operator">=</span> applicationContext.getBean(DeptController.class);
        System.out.println(bean2);

        <span class="hljs-comment">//根据bean的名称 及 类型获取</span>
        <span class="hljs-type">DeptController</span> <span class="hljs-variable">bean3</span> <span class="hljs-operator">=</span> applicationContext.getBean(
            <span class="hljs-string">&quot;deptController&quot;</span>, DeptController.class);
        System.out.println(bean3);
    &#125;
&#125;</code></pre></div><p>三种方式获得的是同一个bean对象，说明IOC容器中改bean对象只有一个，是<code>单例</code>的</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509091138415-2024-5-909:11:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509091138415"><figcaption aria-hidden="true">image-20240509091138415</figcaption></figure><h4 id="bean的作用域">bean的作用域</h4><p>Spring支持五种作用域，后三种在web环境才生效：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209210632428-2024-12-921:06:40.png" srcset="/img/loading.gif" lazyload alt="image-20241209210632428"><figcaption aria-hidden="true">image-20241209210632428</figcaption></figure><p>可以通过<code>@Scope</code>注解来进行配置作用域：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span> <span class="hljs-comment">//通过@Scope注解来进行配置作用域</span>
<span class="hljs-meta">@RestController</span>
<span class="hljs-meta">@RequestMapping(&quot;/depts&quot;)</span>
&#125;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeptController</span> f</code></pre></div><blockquote><p>注意：</p><ol type="i"><li><p>默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化（延迟到第一次使用时）。</p></li><li><p>prototype的bean，每一次使用该bean的时候都会创建一个新的实例。</p></li><li><p>实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性。</p></li></ol></blockquote><h4 id="第三方bean">第三方bean</h4><p>如果要管理的bean对象来自于第三方（不是自定义的），是无法用@Component及衍生注解声明bean的，就需要用到<code>@Bean</code>注解。</p><p>若要管理的第三方bean对象，建议对这些bean进行集中分类配置，可以通过@Configuration注解声明一个配置类。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209211050702-2024-12-921:10:51.png" srcset="/img/loading.gif" lazyload alt="image-20241209211050702"><figcaption aria-hidden="true">image-20241209211050702</figcaption></figure><blockquote><ol type="i"><li>通过@Bean注解的name或value属性可以声明bean的名称，如果不指定，<strong><u>默认bean的名称就是方法名</u></strong>。</li><li><u>如果第三方bean需要依赖其它bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。</u></li></ol></blockquote><p>将第三方操作XML文件的工具类交给spring管理，使用时直接自动注入，不用再自己创建对象。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//配置类</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonConfig</span> &#123;

    <span class="hljs-comment">//声明第三方bean</span>
    <span class="hljs-meta">@Bean</span> <span class="hljs-comment">//将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean</span>
          <span class="hljs-comment">//通过@Bean注解的name/value属性指定bean名称, 如果未指定, 默认是方法名</span>
    <span class="hljs-keyword">public</span> SAXReader <span class="hljs-title function_">reader</span><span class="hljs-params">(DeptService deptService)</span>&#123;
        System.out.println(deptService);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();
    &#125;

&#125;</code></pre></div><p>测试</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootWebConfig2ApplicationTests</span> &#123;


    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> SAXReader saxReader;

    <span class="hljs-comment">//第三方bean的管理</span>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testThirdBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;
        <span class="hljs-comment">//SAXReader saxReader = new SAXReader();</span>
        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(<span class="hljs-built_in">this</span>.getClass().getClassLoader().getResource(<span class="hljs-string">&quot;1.xml&quot;</span>));
        <span class="hljs-type">Element</span> <span class="hljs-variable">rootElement</span> <span class="hljs-operator">=</span> document.getRootElement();
        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> rootElement.element(<span class="hljs-string">&quot;name&quot;</span>).getText();
        <span class="hljs-type">String</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> rootElement.element(<span class="hljs-string">&quot;age&quot;</span>).getText();

        System.out.println(name + <span class="hljs-string">&quot; : &quot;</span> + age);
    &#125;
&#125;</code></pre></div><p>补充：读写XML文档主要依赖于<code>org.dom4j.io</code>包，有DOMReader和SAXReader两种方式。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Dom4j--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.dom4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dom4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="springboot原理">10.3、springboot原理</h3><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509095011100-2024-5-909:50:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509095011100"><figcaption aria-hidden="true">image-20240509095011100</figcaption></figure><h4 id="起步依赖">起步依赖</h4><p>SpringBoot官方的起步依赖都遵循一样的命名规范，都以<code>spring-boot-starter-</code>开头</p><p>原理：起步依赖背后使用的其实就是<code>Maven的传递依赖机制</code>。假设B依赖于C，而A又依赖于B，那么A无需明确声明对C的依赖，而是通过B依赖于C。因此看似只添加了一个依赖，但实际上通过传递依赖，我们已经引入了一堆的依赖。</p><h4 id="自动配置">自动配置</h4><h5 id="概述-2">概述</h5><p>SpringBoot的自动配置就是当spring容器启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230114205745221-2024-5-912:20:02.png" srcset="/img/loading.gif" lazyload alt="image-20230114205745221"><figcaption aria-hidden="true">image-20230114205745221</figcaption></figure><h5 id="常见方案">常见方案</h5><blockquote><p>方案一：<span class="citation" data-cites="ComponentScan">@ComponentScan</span> 组件扫描</p></blockquote><p><span class="citation" data-cites="ComponentScan组件扫描">@ComponentScan组件扫描</span></p><p>在类上添加@Component注解来声明bean对象，同时使用@ComponentScan保证<span class="citation" data-cites="Component注解能被Spring的组件扫描到">@Component注解能被Spring的组件扫描到</span>，将其中的对象交给Spring管理，实现自动配置。</p><p>如果采用以上这种方式来完成自动配置，那我们进行项目开发时，当需要引入大量的第三方的依赖，就需要在启动类上配置N多要扫描的包，这种方式会很繁琐。而且这种大面积的扫描性能也比较低。</p><p><strong>SpringBoot中并没有采用以上这种方案。</strong></p><blockquote><p>方案二：<span class="citation" data-cites="Import">@Import</span> 导入</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509123913221-2024-5-912:39:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509123913221"><figcaption aria-hidden="true">image-20240509123913221</figcaption></figure><p>1). 使用@Import导入普通类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Import(TokenParser.class)</span> <span class="hljs-comment">//导入的类会被Spring加载到IOC容器中</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootWebConfig2Application</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        SpringApplication.run(SpringbootWebConfig2Application.class, args);
    &#125;
&#125;</code></pre></div><p>2). 使用@Import导入配置类：</p><ul><li><p>配置类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeaderConfig</span> &#123;
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> HeaderParser <span class="hljs-title function_">headerParser</span><span class="hljs-params">()</span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeaderParser</span>();
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> HeaderGenerator <span class="hljs-title function_">headerGenerator</span><span class="hljs-params">()</span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeaderGenerator</span>();
    &#125;
&#125;</code></pre></div></li><li><p>启动类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Import(HeaderConfig.class)</span> <span class="hljs-comment">//导入配置类</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootWebConfig2Application</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        SpringApplication.run(SpringbootWebConfig2Application.class, args);
    &#125;
&#125;</code></pre></div></li></ul><p>3). 使用@Import导入ImportSelector接口实现类：</p><ul><li><p>ImportSelector接口实现类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportSelector</span> &#123;
    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;
        <span class="hljs-comment">//返回值字符串数组（数组中封装了全限定名称的类）</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;com.example.HeaderConfig&quot;</span>&#125;;
    &#125;
&#125;</code></pre></div><blockquote><p>将要加载的类定义在一份文件中，最终读取这份文件，将文件中的字符串读取处理，封装在String数组中返回即可</p></blockquote></li><li><p>启动类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Import(MyImportSelector.class)</span> <span class="hljs-comment">//导入ImportSelector接口实现类</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootWebConfig2Application</span> &#123;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        SpringApplication.run(SpringbootWebConfig2Application.class, args);
    &#125;
&#125;
</code></pre></div></li></ul><p>4). 使用第三方依赖提供的 <span class="citation" data-cites="EnableXxxxx注解">@EnableXxxxx注解</span>，其中封装了@import</p><ul><li><p>第三方依赖中提供的注解@EnableXxxxx</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target(ElementType.TYPE)</span>
<span class="hljs-meta">@Import(MyImportSelector.class)</span><span class="hljs-comment">//指定要导入哪些bean对象或配置类</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableHeaderConfig &#123; 
&#125;</code></pre></div></li><li><p>在使用时只需在启动类上加上@EnableXxxxx注解即可</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableHeaderConfig</span>  <span class="hljs-comment">//使用第三方依赖提供的Enable开头的注解</span>
<span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootWebConfig2Application</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        SpringApplication.run(SpringbootWebConfig2Application.class, args);
    &#125;
&#125;
</code></pre></div></li></ul><h5 id="原理分析">原理分析</h5><h6 id="源码跟踪">源码跟踪</h6><p>通过源码跟踪的形式来剖析下SpringBoot底层到底是如何完成自动配置的。</p><p>要搞清楚SpringBoot的自动配置原理，要从SpringBoot启动类上使用的核心注解<code>@SpringBootApplication</code>开始分析：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230115001439110-2024-5-911:55:46.png" srcset="/img/loading.gif" lazyload alt="image-20230115001439110"><figcaption aria-hidden="true">image-20230115001439110</figcaption></figure><p>在@SpringBootApplication注解中包含了：</p><ul><li>元注解</li><li><span class="citation" data-cites="SpringBootConfiguration">@SpringBootConfiguration</span></li><li><span class="citation" data-cites="EnableAutoConfiguration">@EnableAutoConfiguration</span></li><li><span class="citation" data-cites="ComponentScan">@ComponentScan</span></li></ul><p>我们先来看第一个注解：<span class="citation" data-cites="SpringBootConfiguration">@SpringBootConfiguration</span></p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230115001950076-2024-5-911:53:46.png" srcset="/img/loading.gif" lazyload alt="image-20230115001950076"><figcaption aria-hidden="true">image-20230115001950076</figcaption></figure><blockquote><p><span class="citation" data-cites="SpringBootConfiguration注解中使用了">@SpringBootConfiguration注解中使用了</span><span class="citation" data-cites="Configuration">@Configuration</span>，表明SpringBoot启动类就是一个配置类。</p><p><span class="citation" data-cites="Indexed注解">@Indexed注解</span>，是用来加速应用启动的（不用关心）。</p></blockquote><p>接下来再先看@ComponentScan注解：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230115002450993-2024-5-911:54:46.png" srcset="/img/loading.gif" lazyload alt="image-20230115002450993"><figcaption aria-hidden="true">image-20230115002450993</figcaption></figure><blockquote><p><span class="citation" data-cites="ComponentScan注解是用来进行组件扫描的">@ComponentScan注解是用来进行组件扫描的</span>，扫描启动类所在的包及其子包下所有被@Component及其衍生注解声明的类。</p><p>SpringBoot启动类，之所以具备扫描包功能，就是因为包含了@ComponentScan注解。</p></blockquote><p>最后我们来看看@EnableAutoConfiguration注解（自动配置核心注解）：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230115002743115-2024-5-911:50:46.png" srcset="/img/loading.gif" lazyload alt="image-20230115002743115"><figcaption aria-hidden="true">image-20230115002743115</figcaption></figure><blockquote><p>使用@Import注解，导入了实现ImportSelector接口的实现类。</p><p>AutoConfigurationImportSelector类是ImportSelector接口的实现类。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230115003242549-2024-5-911:51:46.png" srcset="/img/loading.gif" lazyload alt="image-20230115003242549"><figcaption aria-hidden="true">image-20230115003242549</figcaption></figure></blockquote><p>AutoConfigurationImportSelector类中重写了ImportSelector接口的<code>selectImports()</code>方法：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230115003348288-2024-5-911:58:46.png" srcset="/img/loading.gif" lazyload alt="image-20230115003348288"><figcaption aria-hidden="true">image-20230115003348288</figcaption></figure><blockquote><p>selectImports()方法底层调用getAutoConfigurationEntry()方法，获取可自动配置的配置类信息集合</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230115003704385-2024-5-912:06:46.png" srcset="/img/loading.gif" lazyload alt="image-20230115003704385"><figcaption aria-hidden="true">image-20230115003704385</figcaption></figure><blockquote><p>getAutoConfigurationEntry()方法通过调用getCandidateConfigurations(annotationMetadata, attributes)方法获取在配置文件中配置的所有自动配置类的集合</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230115003903302-2024-5-911:52:46.png" srcset="/img/loading.gif" lazyload alt="image-20230115003903302"><figcaption aria-hidden="true">image-20230115003903302</figcaption></figure><blockquote><p>getCandidateConfigurations方法的功能：</p><p>获取所有基于META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件、META-INF/spring.factories文件中配置类的集合</p></blockquote><p>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件和META-INF/spring.factories文件这两个文件在哪里呢？</p><ul><li>通常在引入的起步依赖中，都有包含以上两个文件</li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230129090835964-2024-5-912:03:46.png" srcset="/img/loading.gif" lazyload alt="image-20230129090835964"><figcaption aria-hidden="true">image-20230129090835964</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230115064329460-2024-5-911:56:46.png" srcset="/img/loading.gif" lazyload alt="image-20230115064329460"><figcaption aria-hidden="true">image-20230115064329460</figcaption></figure><p><strong>自动配置源码小结</strong></p><p>自动配置原理源码入口就是@SpringBootApplication注解，在这个注解中封装了3个注解，分别是：</p><ul><li><span class="citation" data-cites="SpringBootConfiguration">@SpringBootConfiguration</span><ul><li>声明当前类是一个配置类</li></ul></li><li><span class="citation" data-cites="ComponentScan">@ComponentScan</span><ul><li>进行组件扫描（SpringBoot中默认扫描的是启动类所在的当前包及其子包）</li></ul></li><li><span class="citation" data-cites="EnableAutoConfiguration">@EnableAutoConfiguration</span><ul><li>封装了@Import注解（Import注解中指定了一个ImportSelector接口的实现类）<ul><li>在实现类重写的selectImports()方法，读取当前项目下所有依赖jar包中<em>META-INF/spring.factories</em>、<em>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</em>两个文件里面定义的配置类（配置类中定义了@Bean注解标识的方法）。根据<code>特定条件</code>决定可以导入哪些配置类，接口中的selectImports()方法返回的就是可以导入的配置类名。</li></ul></li></ul></li></ul><blockquote><p>从Spring Boot 2.7开始，AutoConfigurationImportSelector不再从/META-INF/spring.factories加载自动配置类，而是开始使用新的/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件，直接在里面添加自动配置类的全限定类名即可。</p></blockquote><p>当SpringBoot程序启动时，就会加载配置文件当中所定义的配置类，并将这些配置类信息(类的全限定名)封装到String类型的数组中，最终通过@Import注解将这些配置类全部加载到Spring的IOC容器中，交给IOC容器管理。</p><p>但是在两个文件中定义的配置类非常多，而且每个配置类中又可以定义很多的bean，这些bean并不会都注册到Spring的IOC容器中。 在声明bean对象时，上面有加一个以<code>@Conditional开头</code>的注解，这种注解的作用就是按照条件进行装配，只有满足条件之后，才会将bean注册到Spring的IOC容器中（下面会详细来讲解）</p><h6 id="conditional"><span class="citation" data-cites="Conditional">@Conditional</span></h6><ul><li>作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到Spring IOC容器中。</li><li>位置：方法、类</li><li><code>@Conditional</code> <strong>本身是一个父注解，派生出大量的子注解</strong>：<ul><li><code>@ConditionalOnClass</code>：判断环境中是否有对应字节码文件，才注册bean到IOC容器。</li><li><code>@ConditionalOnMissingBean</code>：判断环境中没有对应的bean（类型或名称），才注册bean到IOC容器。</li><li><code>@ConditionalOnProperty</code>：判断配置文件中有对应属性和值，才注册bean到IOC容器。</li></ul></li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509121245446-2024-5-912:12:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509121245446"><figcaption aria-hidden="true">image-20240509121245446</figcaption></figure><h4 id="案例自定义starter">案例：自定义Starter</h4><p>场景：在实际开发中，经常会定义一些公共组件，提供给各个项目团队使用。而在SpringBoot的项目中，一般会将这些公共组件封装为SpringBoot 的 starter。</p><p>需求：自定义<code>aliyun-oss-spring-boot-starter</code>，完成阿里云OSS操作工具类<code>AliyunOSSUtils</code>的自动配置</p><p>目标：引入起步依赖引入之后，要想使用阿里云OSS，注入<code>AliyunOsSutils</code>直接使用即可。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209211734419-2024-12-921:17:35.png" srcset="/img/loading.gif" lazyload alt="image-20241209211734419"><figcaption aria-hidden="true">image-20241209211734419</figcaption></figure><blockquote><p>SpringBoot官方starter命名： spring-boot-starter-xxxx</p><p>第三组织提供的starter命名： xxxx-spring-boot-starter</p></blockquote><p>分析mybatis的依赖是如何加载的</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509181251283-2024-5-918:13:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509181251283"><figcaption aria-hidden="true">image-20240509181251283</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230115225703863-2024-5-918:14:03.png" srcset="/img/loading.gif" lazyload alt="image-20230115225703863"><figcaption aria-hidden="true">image-20230115225703863</figcaption></figure><blockquote><p>Mybatis提供了配置类，并且也提供了springboot会自动读取的配置文件。当SpringBoot项目启动时，会读取到spring.factories配置文件中的配置类并加载配置类，生成相关bean对象注册到IOC容器中。</p><p>结果：我们可以直接在SpringBoot程序中使用Mybatis自动配置的bean对象。</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209211958547-2024-12-921:19:59.png" srcset="/img/loading.gif" lazyload alt="image-20241209211958547"><figcaption aria-hidden="true">image-20241209211958547</figcaption></figure><p>1、创建 aliyun-oss-springboot-start 模块</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509181625217-2024-5-918:16:26.png" srcset="/img/loading.gif" lazyload alt="image-20240509181625217"><figcaption aria-hidden="true">image-20240509181625217</figcaption></figure><p>2、创建 aliyun-oss-spring-boot-autoconfigure 模块</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509182110887-2024-5-918:21:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509182110887"><figcaption aria-hidden="true">image-20240509182110887</figcaption></figure><ol type="1"><li><p>在pom.xml文件中添加相关依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span>
<span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aliyun.oss<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

        <span class="hljs-comment">&lt;!--  引入web开发起步依赖      --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!--        添加阿里云OSS依赖  --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aliyun.oss<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.15.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- lombok --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>
</code></pre></div></li><li><p>修改AliOSSProperties.java 和 AliOSSUtiles.java中的代码</p><p>这两个类都不用再使用@Component注解， 在SpringBoot项目中，并不会去扫描com.aliyun.oss这个包，不扫描这个包那类上的注解也就失去了作用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.aliyun.oss;

<span class="hljs-keyword">import</span> lombok.Data;
<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> AliOSSProperties</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> 86152</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/5/6 22:28</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span>
<span class="hljs-comment"> */</span>
<span class="hljs-meta">@Data</span>
<span class="hljs-meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSProperties</span> &#123;
    <span class="hljs-keyword">private</span> String endpoint;
    <span class="hljs-keyword">private</span> String accessKeyId;
    <span class="hljs-keyword">private</span> String accessKeySecret;
    <span class="hljs-keyword">private</span> String bucketName;
&#125;
</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.aliyun.oss;

<span class="hljs-keyword">import</span> com.aliyun.oss.OSS;
<span class="hljs-keyword">import</span> com.aliyun.oss.OSSClientBuilder;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;
<span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;

<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.io.InputStream;
<span class="hljs-keyword">import</span> java.util.UUID;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 阿里云 OSS 工具类</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSUtils</span> &#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 实现上传图片到OSS</span>
<span class="hljs-comment">     */</span>

    <span class="hljs-keyword">private</span> AliOSSProperties aliOSSProperties;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAliOSSProperties</span><span class="hljs-params">(AliOSSProperties aliOSSProperties)</span> &#123;
        <span class="hljs-built_in">this</span>.aliOSSProperties = aliOSSProperties;
    &#125;

    <span class="hljs-keyword">public</span> AliOSSProperties <span class="hljs-title function_">getAliOSSProperties</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> aliOSSProperties;
    &#125;

    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile file)</span> <span class="hljs-keyword">throws</span> IOException &#123;
        <span class="hljs-comment">//获取阿里云OSS配置信息</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">endpoint</span> <span class="hljs-operator">=</span> aliOSSProperties.getEndpoint();
        <span class="hljs-type">String</span> <span class="hljs-variable">accessKeyId</span> <span class="hljs-operator">=</span> aliOSSProperties.getAccessKeyId();
        <span class="hljs-type">String</span> <span class="hljs-variable">accessKeySecret</span> <span class="hljs-operator">=</span> aliOSSProperties.getAccessKeySecret();
        <span class="hljs-type">String</span> <span class="hljs-variable">bucketName</span> <span class="hljs-operator">=</span> aliOSSProperties.getBucketName();
        <span class="hljs-comment">// 获取上传的文件的输入流</span>
        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> file.getInputStream();

        <span class="hljs-comment">// 避免文件覆盖</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> file.getOriginalFilename();
        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));

        <span class="hljs-comment">//上传文件到 OSS</span>
        <span class="hljs-type">OSS</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);
        ossClient.putObject(bucketName, fileName, inputStream);

        <span class="hljs-comment">//文件访问路径</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> endpoint.split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;//&quot;</span> + bucketName + <span class="hljs-string">&quot;.&quot;</span> + endpoint.split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;/&quot;</span> + fileName;
        <span class="hljs-comment">// 关闭ossClient</span>
        ossClient.shutdown();
        <span class="hljs-keyword">return</span> url;<span class="hljs-comment">// 把上传到oss的路径返回</span>
    &#125;

&#125;
</code></pre></div></li><li><p>添加配置类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.aliyun.oss;

<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;
<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> AliyunOSSAutoconfiguration</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO 自动配置类</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> 86152</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/5/9 17:28</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span>
<span class="hljs-comment"> */</span>

<span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@EnableConfigurationProperties(AliOSSProperties.class)</span>  <span class="hljs-comment">//将AliOSSProperties导入IOC容器，称为IOC容器中的bean</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSAutoConfiguration</span> &#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-comment">//第三方bean要使用其他bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。</span>
    <span class="hljs-keyword">public</span> AliOSSUtils <span class="hljs-title function_">aliOSSUtils</span><span class="hljs-params">(AliOSSProperties aliOSSProperties)</span> &#123;  
        <span class="hljs-type">AliOSSUtils</span> <span class="hljs-variable">aliOSSUtils</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AliOSSUtils</span>();
        aliOSSUtils.setAliOSSProperties(aliOSSProperties);<span class="hljs-comment">//手动设置私有属性aliOSSProperties</span>
        <span class="hljs-keyword">return</span> aliOSSUtils;
    &#125;
&#125;
</code></pre></div></li><li><p>创建自动配置文件：<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>，将配置类添加进入，Spring启动的时候就会扫描这个文件，将其中的类交给Spring容器管理，称为IOC容器中的bean</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509182812818-2024-5-918:28:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509182812818"><figcaption aria-hidden="true">image-20240509182812818</figcaption></figure></li></ol><p>5、测试</p><p>在项目pom文件中导入 aliyun-oss-springboot-starter依赖，使用@Autowired在运行中获取AliOSSUtils对象完成文件上传</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509183259325-2024-5-918:33:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509183259325"><figcaption aria-hidden="true">image-20240509183259325</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509183330365-2024-5-918:34:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509183330365"><figcaption aria-hidden="true">image-20240509183330365</figcaption></figure><h2 id="后端开发总结">1.12、后端开发总结</h2><p>到此基于SpringBoot进行web后端开发的相关知识我们已经学习完毕了。下面我们一起针对这段web课程做一个总结。</p><p>我们来回顾一下关于web后端开发，我们都学习了哪些内容，以及每一块知识，具体是属于哪个框架的。</p><p>web后端开发现在基本上都是基于标准的三层架构进行开发的，在三层架构当中，Controller控制器层负责接收请求响应数据，Service业务层负责具体的业务逻辑处理，而Dao数据访问层也叫持久层，就是用来处理数据访问操作的，来完成数据库当中数据的增删改查操作。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230114180044897-2024-5-920:42:46.png" srcset="/img/loading.gif" lazyload alt="image-20230114180044897"><figcaption aria-hidden="true">image-20230114180044897</figcaption></figure><blockquote><p>在三层架构当中，前端发起请求首先会到达Controller(不进行逻辑处理)，然后Controller会直接调用Service 进行逻辑处理， Service再调用Dao完成数据访问操作。</p></blockquote><p>如果我们在执行具体的业务处理之前，需要去做一些通用的业务处理，比如：我们要进行统一的登录校验，我们要进行统一的字符编码等这些操作时，我们就可以借助于Javaweb当中三大组件之一的过滤器Filter或者是Spring当中提供的拦截器Interceptor来实现。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230114191737227-2024-5-920:41:47.png" srcset="/img/loading.gif" lazyload alt="image-20230114191737227"><figcaption aria-hidden="true">image-20230114191737227</figcaption></figure><p>而为了实现三层架构层与层之间的解耦，我们学习了Spring框架当中的第一大核心：IOC控制反转与DI依赖注入。</p><blockquote><p>所谓控制反转，指的是将对象创建的控制权由应用程序自身交给外部容器，这个容器就是我们常说的IOC容器或Spring容器。</p><p>而DI依赖注入指的是容器为程序提供运行时所需要的资源。</p></blockquote><p>除了IOC与DI我们还讲到了AOP面向切面编程，还有Spring中的事务管理、全局异常处理器，以及传递会话技术Cookie、Session以及新的会话跟踪解决方案JWT令牌，阿里云OSS对象存储服务，以及通过Mybatis持久层架构操作数据库等技术。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230114192921673-2024-5-920:45:46.png" srcset="/img/loading.gif" lazyload alt="image-20230114192921673"><figcaption aria-hidden="true">image-20230114192921673</figcaption></figure><p>我们在学习这些web后端开发技术的时候，我们都是基于主流的SpringBoot进行整合使用的。而SpringBoot又是用来简化开发，提高开发效率的。像过滤器、拦截器、IOC、DI、AOP、事务管理等这些技术到底是哪个框架提供的核心功能？</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230114193609782-2024-5-920:44:46.png" srcset="/img/loading.gif" lazyload alt="image-20230114193609782"><figcaption aria-hidden="true">image-20230114193609782</figcaption></figure><blockquote><p>Filter过滤器、Cookie、 Session这些都是传统的JavaWeb提供的技术。</p><p>JWT令牌、阿里云OSS对象存储服务，是现在企业项目中常见的一些解决方案。</p><p>IOC控制反转、DI依赖注入、AOP面向切面编程、事务管理、全局异常处理、拦截器等，这些技术都是 Spring Framework框架当中提供的核心功能。</p><p>Mybatis就是一个持久层的框架，是用来操作数据库的。</p></blockquote><p>在Spring框架的生态中，对web程序开发提供了很好的支持，如：全局异常处理器、拦截器这些都是Spring框架中web开发模块所提供的功能，而Spring框架的web开发模块，我们也称为：SpringMVC</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230114195143418-2024-5-920:43:46.png" srcset="/img/loading.gif" lazyload alt="image-20230114195143418"><figcaption aria-hidden="true">image-20230114195143418</figcaption></figure><blockquote><p>SpringMVC不是一个单独的框架，它是Spring框架的一部分，是Spring框架中的web开发模块，是用来简化原始的Servlet程序开发的。</p></blockquote><p>外界俗称的SSM，就是由：SpringMVC、Spring Framework、Mybatis三块组成。</p><p>基于传统的SSM框架进行整合开发项目会比较繁琐，而且效率也比较低，所以在现在的企业项目开发当中，基本上都是直接基于SpringBoot整合SSM进行项目开发的。</p><p>到此我们web后端开发的内容就已经全部讲解结束了。</p><h2 id="十一maven高级">十一、Maven高级</h2><h2 id="分模块开发与设计">11.1、分模块开发与设计</h2><p>​ 对于开发一个大型的电商项目，里面可能就包括了商品模块的功能、搜索模块的功能、购物车模块、订单模块、用户中心等等。如果这些所有的业务代码我们都在一个 Java 项目当中编写，项目管理和维护起来将会非常的困难。而且对一些通用的工具类以及通用的组件，难以共享复用。</p><p>​ 采用分模块开发，可以将商品的相关功能放在商品模块当中，搜索的相关业务功能我都封装在搜索模块当中，还有像购物车模块、订单模块。而为了组件的复用，也可以将项目当中的实体类、工具类以及定义的通用的组件都单独的抽取到一个模块当中。</p><p>​ 如果当前这个模块，比如订单模块需要用到这些实体类以及工具类或者这些通用组件，此时直接在订单模块当中引入工具类的坐标就可以了。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509213323666-2024-5-921:33:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509213323666" style="width:95%"></p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509213240413-2024-5-921:32:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509213240413"><figcaption aria-hidden="true">image-20240509213240413</figcaption></figure><blockquote><p>步骤1：创建Maven模块 tlias-pojo，存放实体类。</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230113101216305-2024-5-921:41:43.png" srcset="/img/loading.gif" lazyload alt="image-20230113101216305"><figcaption aria-hidden="true">image-20230113101216305</figcaption></figure><blockquote><p>步骤2：创建Maven模块 tlias-utils，存放相关工具类。</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230113102113451-2024-5-921:42:30.png" srcset="/img/loading.gif" lazyload alt="image-20230113102113451"><figcaption aria-hidden="true">image-20230113102113451</figcaption></figure><blockquote><p>步骤3：在需要的项目中引入模块</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509214402937-2024-5-921:44:03.png" srcset="/img/loading.gif" lazyload alt="image-20240509214402937"><figcaption aria-hidden="true">image-20240509214402937</figcaption></figure><h2 id="继承与聚合">11.2、继承与聚合</h2><h3 id="继承">继承</h3><p>在案例项目分模块开发之后，在lias-pojo、tlias-utils、tlias-web-management中都引入了一个依赖 lombok 的依赖。我们在三个模块中分别配置了一次。</p><p>如果是做一个大型的项目，这三个模块当中重复的依赖可能会很多很多。如果每一个 Maven 模块里面，我们都来单独的配置一次，功能虽然能实现，但是配置是比较<strong>繁琐</strong>的。 Maven 的继承用来解决该问题的。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509225135625-2024-5-922:51:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509225135625"><figcaption aria-hidden="true">image-20240509225135625</figcaption></figure><h4 id="继承关系实现">继承关系实现</h4><p>在Maven中是持多重继承的。让自己创建的三个模块，都继承tlias-parent，而tlias-parent 再继承 spring-boot-starter-parent。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230113113004727-2024-5-922:55:46.png" srcset="/img/loading.gif" lazyload alt="image-20230113113004727"><figcaption aria-hidden="true">image-20230113113004727</figcaption></figure><blockquote><p>步骤一：创建父工程模块</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509225851531-2024-5-922:58:52.png" srcset="/img/loading.gif" lazyload alt="image-20240509225851531"><figcaption aria-hidden="true">image-20240509225851531</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509230119583-2024-5-923:01:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509230119583"><figcaption aria-hidden="true">image-20240509230119583</figcaption></figure><blockquote><p>步骤二：在子工程的pom.xml文件中，继承父工程</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509225702655-2024-5-922:57:03.png" srcset="/img/loading.gif" lazyload alt="image-20240509225702655"><figcaption aria-hidden="true">image-20240509225702655</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509230637887-2024-5-923:06:39.png" srcset="/img/loading.gif" lazyload alt="image-20240509230637887"><figcaption aria-hidden="true">image-20240509230637887</figcaption></figure><p>注：在ralativePath中，使用<code>../</code>返回当前pom文件的上一级，可以在文件管理器中查看目录结构，正确填写父工程pom文件的路径</p><blockquote><p>步骤三：在父工程中配置各个子工程共有的依赖</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509231011187-2024-5-923:10:36.png" srcset="/img/loading.gif" lazyload alt="image-20240509231011187"><figcaption aria-hidden="true">image-20240509231011187</figcaption></figure><h4 id="版本锁定">版本锁定</h4><p>在父工程中集中管理一些依赖的版本，在子工程中，直接使用该依赖而不再需要指定属性。当版本需要变更时，只需修改父工程中设定的版本号即可，不用去修改每个子工程中的版本号。</p><p>在maven中，可以在父工程的pom文件中通过 <code>&lt;dependencyManagement&gt;</code> 来统一管理依赖版本。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509233543781-2024-5-923:36:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509233543781"><figcaption aria-hidden="true">image-20240509233543781</figcaption></figure><p>父工程：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--统一管理依赖版本--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-comment">&lt;!--JWT令牌--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></code></pre></div><p>子工程：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-comment">&lt;!--JWT令牌--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><blockquote><p>注意：</p><ul><li><p>在父工程中所配置的 <code>&lt;dependencyManagement&gt;</code> 只能统一管理依赖版本，并不会将这个依赖直接引入进来。 这点和 <code>&lt;dependencies&gt;</code> 是不同的。</p></li><li><p>子工程要使用这个依赖，还是需要使用 <code>&lt;dependencies&gt;</code> 引入，只是此时就无需指定 <code>&lt;version&gt;</code> 版本号了，父工程统一管理。变更依赖版本，只需在父工程中统一变更。</p></li></ul></blockquote><p>我们也可以通过<code>自定义属性及属性引用</code>的形式，在父工程中将依赖的版本号进行集中管理维护。当父工程管理的依赖很多时，要修改版本号，不需要在<code>&lt;dependencyManagement&gt;</code>标签中找到该依赖再去修改版本号，直接修改自定义属性即可。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509233515708-2024-5-923:35:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509233515708"><figcaption aria-hidden="true">image-20240509233515708</figcaption></figure><p>1). 自定义属性</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">lombok.version</span>&gt;</span>1.18.24<span class="hljs-tag">&lt;/<span class="hljs-name">lombok.version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></code></pre></div><p>2). 引用属性</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>查看Spring框架的版本管理方式：先使用自定义标签设置依赖版本号，使用时通过<code>$&#123;&#125;</code>获取自定义标签的值</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509233651035-2024-5-923:37:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509233651035"><figcaption aria-hidden="true">image-20240509233651035</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509233741269-2024-5-923:38:46.png" srcset="/img/loading.gif" lazyload alt="image-20240509233741269"><figcaption aria-hidden="true">image-20240509233741269</figcaption></figure><h3 id="聚合">聚合</h3><p>项目分模块开发后，最后打包上线，需要让<u>每个模块</u>都执行maven的<code>package</code>生命周期，安装到本地仓库，才能实现成功打包，若仓库中缺失某个模块打包后的jar包，最终项目就会打包失败。</p><p>如果开发一个大型项目，拆分的模块很多，模块之间的依赖关系错综复杂，那此时要进行项目的打包、安装操作，是非常繁琐的。maven的聚合就是来解决这个问题的，通过maven的聚合就可以轻松实现项目的一键构建（清理、编译、测试、打包、安装等）。</p><h4 id="介绍">介绍</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230113151533948-2024-5-923:53:24.png" srcset="/img/loading.gif" lazyload alt="image-20230113151533948" style="zoom:80%"></p><ul><li><strong>聚合：</strong>将多个模块组织成一个整体，同时进行项目的构建。</li><li><strong>聚合工程：</strong>一个不具有业务功能的“空”工程（有且仅有一个pom文件） 【PS：一般来说，继承关系中的父工程与聚合关系中的聚合工程是同一个】</li><li><strong>作用：</strong>快速构建项目（无需根据依赖关系手动构建，直接在聚合工程上构建即可）</li></ul><h4 id="实现">实现</h4><p>在maven中，我们可以在聚合工程中通过 <code>&lt;moudules&gt;</code> 设置当前聚合工程所包含的子模块的名称。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509235523700-2024-5-923:55:24.png" srcset="/img/loading.gif" lazyload alt="image-20240509235523700"><figcaption aria-hidden="true">image-20240509235523700</figcaption></figure><p>我们可以在 tlias-parent中，添加如下配置，来指定当前聚合工程，需要聚合的模块：</p><div class="code-wrapper"><pre><code class="hljs java">&lt;!--聚合其他模块--&gt;
&lt;modules&gt;
    &lt;<span class="hljs-keyword">module</span>&gt;../tlias-pojo&lt;/<span class="hljs-keyword">module</span>&gt;
    &lt;<span class="hljs-keyword">module</span>&gt;../tlias-utils&lt;/<span class="hljs-keyword">module</span>&gt;
    &lt;<span class="hljs-keyword">module</span>&gt;../tlias-web-management&lt;/<span class="hljs-keyword">module</span>&gt;
&lt;/modules&gt;</code></pre></div><p>此时要进行编译、打包、安装操作，就无需在每一个模块上操作了。只需要在聚合工程上，统一进行操作就可以了。</p><h3 id="继承与聚合对比">继承与聚合对比</h3><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509235806269-2024-5-923:58:07.png" srcset="/img/loading.gif" lazyload alt="image-20240509235806269"><figcaption aria-hidden="true">image-20240509235806269</figcaption></figure><h2 id="私服">11.3、私服</h2><h3 id="介绍-1">介绍</h3><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240510000150698-2024-5-1000:02:46.png" srcset="/img/loading.gif" lazyload alt="image-20240510000150698"><figcaption aria-hidden="true">image-20240510000150698</figcaption></figure><h3 id="资源的上传和下载">资源的上传和下载</h3><h4 id="步骤分析">步骤分析</h4><p>资源上传与下载，我们需要做三步配置，执行一条指令。</p><p>第一步配置：在maven的配置文件中配置访问私服的用户名、密码。</p><p>第二步配置：在maven的配置文件中配置连接私服的地址(url地址)。</p><p>第三步配置：在项目的pom.xml文件中配置上传资源的位置(url地址)。</p><p>配置好了上述三步之后，要上传资源到私服仓库，就执行执行maven生命周期：deploy。</p><blockquote><p>私服仓库说明：</p><ul><li>RELEASE：存储自己开发的RELEASE发布版本的资源。</li><li>SNAPSHOT：存储自己开发的SNAPSHOT发布版本的资源。</li><li>Central：存储的是从中央仓库下载下来的依赖。</li></ul></blockquote><blockquote><p>项目版本说明：</p><ul><li>RELEASE(发布版本)：功能趋于稳定、当前更新停止，可以用于发行的版本，存储在私服中的RELEASE仓库中。</li><li>SNAPSHOT(快照版本)：功能不稳定、尚处于开发中的版本，即快照版本，存储在私服的SNAPSHOT仓库中。</li></ul></blockquote><h4 id="具体操作">具体操作</h4><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1m84y1w7Tb?p=199&amp;spm_id_from=pageDriver&amp;vd_source=51d78ede0a0127d1839d6abf9204d1ee">b站课程</a></p><p>使用私服，需要在maven的settings.xml配置文件中，做如下配置：</p><ol type="1"><li><p>需要在 <strong>servers</strong> 标签中，配置访问私服的个人凭证(访问的用户名和密码)</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>maven-releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span>
    
<span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>maven-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span></code></pre></div></li><li><p>在 <strong>mirrors</strong> 中只配置我们自己私服的连接地址(如果之前配置过阿里云，需要直接替换掉)</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>maven-public<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre></div></li><li><p>需要在 <strong>profiles</strong> 中，增加如下配置，来指定snapshot快照版本的依赖，依然允许使用</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>allow-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>
        	<span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>maven-public<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span>
            	<span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span>
            	<span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span></code></pre></div></li><li><p>如果需要上传自己的项目到私服上，需要在项目的pom.xml文件中，增加如下配置，来配置项目发布的地址(也就是私服的地址)</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- release版本的发布地址 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>maven-releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-releases/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!-- snapshot版本的发布地址 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>maven-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-snapshots/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span></code></pre></div></li><li><p>发布项目，直接运行 deploy 生命周期即可 (发布时，建议跳过单元测试)</p></li></ol></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/JavaWeb/" class="category-chain-item">JavaWeb</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Spring/" class="print-no-link">#Spring</a> <a href="/tags/Springboot%E5%8E%9F%E7%90%86/" class="print-no-link">#Springboot原理</a> <a href="/tags/IOC/" class="print-no-link">#IOC</a> <a href="/tags/DI/" class="print-no-link">#DI</a> <a href="/tags/MyBatis/" class="print-no-link">#MyBatis</a> <a href="/tags/Maven/" class="print-no-link">#Maven</a></div></div><div class="license-box my-3"><div class="license-title"><div>JavaWeb基础（二）后端相关</div><div>https://catpaws.top/68ec802/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年12月9日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/1bff3c65/" title="MyBatis"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">MyBatis</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/4b1cca40/" title="JavaWeb基础（一）前端相关"><span class="hidden-mobile">JavaWeb基础（一）前端相关</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://cdn.smartcis.cn/npm/twikoo@1.6.40/dist/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本站由<img src="/img/upyun_logo.png" srcset="/img/loading.gif" lazyload style="width:auto;height:auto">提供CDN加速/云存储服务</a></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备2025059828号</a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//catpaws.top/blog-resource/js/yinghua.js"></script><script src="//catpaws.top/blog-resource/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="//catpaws.top/blog-resource/js/loader.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://unpkg.com/oh-my-live2d"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"https://catpaws.top/blog-resource/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"},idleTips:{interval:15e3,message:function(){return axios.get("https://v1.hitokoto.cn?c=i").then((function(t){return t.data.hitokoto})).catch((function(t){console.error(t)}))}}}})</script></body></html>