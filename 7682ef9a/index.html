<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://catpaws.top/blog-resource/imgs/webicon.png"><link rel="icon" href="https://catpaws.top/blog-resource/imgs/webicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="数据结构目录： 一、绪论 二、线性表 三、栈和队列 四、串 五、树和二叉树 六、图 七、查找 八、排序 一、线性表的定义和基本操作 1.1、线性表的定义 线性表 是有相同数据类型的n个数据元素的有限序列。其中n为表长，一般表示为 L &#x3D; (a1,a2,a3,...,an)。 从线性表的定义可以看出，线性表的特点：  表中元素的数据类型相同，每个元素占有相同大"><meta property="og:type" content="article"><meta property="og:title" content="二、线性表"><meta property="og:url" content="https://catpaws.top/7682ef9a/index.html"><meta property="og:site_name" content="猫爪在上の书桌"><meta property="og:description" content="数据结构目录： 一、绪论 二、线性表 三、栈和队列 四、串 五、树和二叉树 六、图 七、查找 八、排序 一、线性表的定义和基本操作 1.1、线性表的定义 线性表 是有相同数据类型的n个数据元素的有限序列。其中n为表长，一般表示为 L &#x3D; (a1,a2,a3,...,an)。 从线性表的定义可以看出，线性表的特点：  表中元素的数据类型相同，每个元素占有相同大"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20221020091225136-2024-12-615:11:00.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20221020091611880-2024-12-615:15:34.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2022-10-20_09-25-23-2024-12-615:16:29.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20221020095402713-2024-12-615:20:17.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20221020100322600-2024-12-615:20:39.png"><meta property="article:published_time" content="2024-12-06T06:33:58.000Z"><meta property="article:modified_time" content="2025-04-10T09:43:53.379Z"><meta property="article:author" content="猫爪在上"><meta property="article:tag" content="线性表"><meta property="article:tag" content="单链表"><meta property="article:tag" content="双链表"><meta property="article:tag" content="循环链表"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20221020091225136-2024-12-615:11:00.png"><title>二、线性表 - 猫爪在上の书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/font.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/poem.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/shubiao.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/loader.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/twikoo_beautify.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/indeximg-hover.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/wave.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/blurpicload.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"https://catpaws.top/blog-resource/imgs/transparent.svg",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://leancloud.catpaws.top",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loader-container"><div class="loader"><div class="wrapper"><div class="catContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 733 673" class="catbody"><path fill="#212121" d="M111.002 139.5C270.502 -24.5001 471.503 2.4997 621.002 139.5C770.501 276.5 768.504 627.5 621.002 649.5C473.5 671.5 246 687.5 111.002 649.5C-23.9964 611.5 -48.4982 303.5 111.002 139.5Z"></path><path fill="#212121" d="M184 9L270.603 159H97.3975L184 9Z"></path><path fill="#212121" d="M541 0L627.603 150H454.397L541 0Z"></path></svg> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 158 564" class="tail"><path fill="#191919" d="M5.97602 76.066C-11.1099 41.6747 12.9018 0 51.3036 0V0C71.5336 0 89.8636 12.2558 97.2565 31.0866C173.697 225.792 180.478 345.852 97.0691 536.666C89.7636 553.378 73.0672 564 54.8273 564V564C16.9427 564 -5.4224 521.149 13.0712 488.085C90.2225 350.15 87.9612 241.089 5.97602 76.066Z"></path></svg><div class="text"><span class="bigzzz">Z</span> <span class="zzz">Z</span></div></div><div class="wallContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 500 126" class="wall"><line stroke-width="6" stroke="#7C7C7C" y2="3" x2="450" y1="3" x1="50"></line><line stroke-width="6" stroke="#7C7C7C" y2="85" x2="400" y1="85" x1="100"></line><line stroke-width="6" stroke="#7C7C7C" y2="122" x2="375" y1="122" x1="125"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="500" y1="43"></line><line stroke-width="6" stroke="#7C7C7C" y2="1.99391" x2="115.5" y1="43.0061" x1="115.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00002" x2="189" y1="43.0122" x1="189"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00612" x2="262.5" y1="43.0183" x1="262.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01222" x2="336" y1="43.0244" x1="336"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01833" x2="409.5" y1="43.0305" x1="409.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="153" y1="84.0122" x1="153"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="228" y1="84.0122" x1="228"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="303" y1="84.0122" x1="303"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="378" y1="84.0122" x1="378"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="192" y1="125.012" x1="192"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="267" y1="125.012" x1="267"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="342" y1="125.012" x1="342"></line></svg></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上の书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>个人主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://catpaws.top/blog-resource/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="二、线性表"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-12-06 14:33" pubdate>2024年12月6日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 31 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">二、线性表</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年4月10日 下午</p><div class="markdown-body"><meta name="referrer" content="no-referrer"><p>数据结构目录：</p><p><a href="https://catpaws.top/bfab103e/">一、绪论</a></p><p><a href="https://catpaws.top/7682ef9a/">二、线性表</a></p><p><a href="https://catpaws.top/d403458d/">三、栈和队列</a></p><p><a href="https://catpaws.top/dac6dce7/">四、串</a></p><p><a href="https://catpaws.top/453281de/">五、树和二叉树</a></p><p><a href="https://catpaws.top/ce993eeb/">六、图</a></p><p><a href="https://catpaws.top/24d4ba7c/">七、查找</a></p><p><a href="https://catpaws.top/978a1655/">八、排序</a></p><h2 id="一线性表的定义和基本操作">一、线性表的定义和基本操作</h2><h3 id="线性表的定义">1.1、线性表的定义</h3><p><strong>线性表</strong> 是有<strong>相同数据类型</strong>的n个<strong>数据元素</strong>的<strong>有限序列</strong>。其中n为表长，一般表示为 L = (a1,a2,a3,...,an)。</p><p>从线性表的定义可以看出，线性表的特点：</p><ul><li>表中元素的数据类型相同，每个元素占有相同大小的存储空间。</li><li>表中元素都是数据元素，每个元素都是单个元素。</li><li>表中的元素个数有限。</li><li>表中元素具有逻辑上的顺序性，表中元素有其先后顺序。</li></ul><blockquote><p>线性表是一种<em>逻辑结构</em>，表示元素之间一对一的相邻关系。</p><p>顺序表和链表是指<em>存储结构</em>，是线性表不同存储结构下的实现。</p></blockquote><h3 id="线性表的基本操作">1.2、线性表的基本操作</h3><p>基本操作：创销、增删、查</p><ul><li>initList(&amp;L)：初始化表</li><li>destoryList(&amp;L)：销毁操作</li><li>listInsert(&amp;L,i,e) : 插入元素，在第i个位置插入元素e</li><li>listDelete(&amp;L,i,&amp;e)：删除第i个位置的元素，并用e返回删除元素的值。</li><li>getElem(L,i)：按位查找，获取表中第i个位置的元素值</li><li>locateElem(L,e)：按值查找，在表中查找具有给定关键字值的元素</li><li>empty(L)：判空</li><li>length(L)：获取表长</li><li>printList(L)：按顺序输出表中元素的值</li></ul><h2 id="二顺序表">二、顺序表</h2><h3 id="顺序表的定义">2.1、顺序表的定义</h3><p>​ 线性表的顺序表示 --- 顺序表 ：用一组<strong>地址连续</strong>的存储单元依次存储线性表中的数据元素，使得在逻辑上相邻的元素在物理位置上也相邻。</p><p>​ 若线性表L存储的起始地址为 LOC(A)，则第i个元素存储的起始地址为 LOC(A) + (i - 1) * sizeof(ElemType)。</p><blockquote><p>注：线性表中元素的位序是从1开始的，而数组元素的下标是从0开始的。</p></blockquote><h3 id="顺序表的存储结构">2.2、顺序表的存储结构</h3><p>顺序表使用一维数组存储数据元素，该数组可以是<strong>静态分配</strong>的，也可以是<strong>动态分配</strong>的。</p><p>静态分配：</p><p>数组的大小已事先确定，一旦空间占满，再加入新的数据将会产生溢出，进而导致程序崩溃。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;
    ElemType data[MaxSize];
    <span class="hljs-type">int</span> lenght;		<span class="hljs-comment">//顺序表的当前长度</span>
&#125;SqList;

SqList L;
<span class="hljs-built_in">initList</span>(L); <span class="hljs-comment">//由于会有脏数据，初始化时表当当前长度lenght必须设置为0</span>
<span class="hljs-comment">//其他操作</span></code></pre></div><p>​</p><p>动态分配：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> InitSize 100</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;
    ElemType *data;
    <span class="hljs-type">int</span> MaxSize, length;<span class="hljs-comment">//数组的最大容量和当前个数</span>
&#125; SeqList;

SeqList L; <span class="hljs-comment">//系统在内存中开辟了包含 *data,MaxSize,length这些变量的存储空间</span>
<span class="hljs-built_in">initList</span>(L); <span class="hljs-comment">//初始化，给以上变量赋值</span>


<span class="hljs-comment">//初始化</span>
L.data = (ElemType *) <span class="hljs-built_in">malloc</span> (<span class="hljs-built_in">sizeof</span>(ElemType) * InitSize);</code></pre></div><ul><li><p>此时存储空间不是在一开始就确定的，而是在程序执行过程中，在数组初始化过程通过动态存储分配语句分配的，一旦数据空间占满，就<strong>另开辟一块更大的空间，将数据元素拷贝过去，释放原来的空间</strong>，从而达到扩容的目的，而不用为线性表一次划分所有空间。</p></li><li><p><strong>动态分配方式不是链式存储</strong>，同样属于顺序存储结构，其物理结构没有发生变化，依然是随机存取方式，只是分配的空间大小可以在运行时决定。</p></li></ul><h3 id="顺序表的特点">2.3、顺序表的特点</h3><ul><li><p><strong>随机访问</strong>：可以在 <em>O(1)</em> 内找到第i个元素</p></li><li><p>存储密度高，每个结点只存储数据元素，不用像链表那样消耗空间存储指针。</p></li><li><p>扩容不方便，<strong>静态分配不可以扩容，动态分配扩容时间复杂度也很高</strong></p></li><li><p>插入删除元素不方便，需要大量移动元素</p></li><li><p>由于难以估计所需空间的大小，必须预先分配较大的空间，往往使空间不能得到充分利用。</p></li></ul><h3 id="顺序表上基本操作的实现">2.4、顺序表上基本操作的实现</h3><p>​ 插入操作：在顺序表L的第i个位置 (<strong>1&lt;= i &lt;= L.length+1)</strong> 插入元素e，成功返回true，否则返回false。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insertList</span> <span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> data)</span> </span>&#123;
    <span class="hljs-comment">//顺序表中，可以插入的位置 为 [1,length+1], index 为位序</span>
    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">1</span> || index &gt; L.length<span class="hljs-number">+1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (index &gt;= Maxsize)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-comment">//从最后一个位置的元素开始，将位置index 到 length的元素都向后移动：移动元素个数为 length - index + 1</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = L.length; i &gt;= index; i--) &#123;
        L.data[i] = L.data[i<span class="hljs-number">-1</span>];
    &#125;
    L.data[index - <span class="hljs-number">1</span>] = data;
    L.length ++;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div><p>​ 删除操作：删除顺序表L中第i个位置 ( <strong>1&lt;= i &lt;= L.length</strong>)，若成功删除返回true，并将被删除元素用引用变量e返回。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">deleteList</span> <span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> &amp;data)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">1</span> || index &gt; L.length)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    data = L.data[index];
    <span class="hljs-comment">//从第index+1个位置开始，将其后的元素向前移动，移动元素个数为： length - index</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; L.length; i++) &#123;
        L.data[i<span class="hljs-number">-1</span>] = L.data[i];
    &#125;
    L.length --;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div><h2 id="三链表">三、链表</h2><p>线性表的链式表示 --- 链表</p><h3 id="单链表的定义">3.1、单链表的定义</h3><p>​ 它通过一组<strong>任意</strong>的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，除了存放元素自身的信息外，还需存放一个指向其后继的<strong>指针</strong>。</p><p>单链表的结点结构如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> &#123;</span>
    <span class="hljs-type">int</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> *<span class="hljs-title">next</span>;</span>
&#125;

<span class="hljs-comment">//增加一个新结点</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> *<span class="hljs-title">p</span> =</span> (<span class="hljs-keyword">struct</span> Lnode *)<span class="hljs-built_in">malloc</span>(siezof(<span class="hljs-keyword">struct</span> Lnode));</code></pre></div><p>为了在编写代码时不用带上 struct 关键字，使用 typedef 关键字对 该数据类型 重命名。 typedef<数据类型><别名></别名></数据类型></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> &#123;</span>
    <span class="hljs-type">int</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> *<span class="hljs-title">next</span>;</span>
&#125;Lnode, *LinkList;

<span class="hljs-comment">//增加一个新结点</span>
Lnode *p = (Lnode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Lnode));
<span class="hljs-comment">//声明一个单链表</span>
LinkList L;</code></pre></div><p>通常用一个<strong>头指针</strong>来标识一个单链表，如单链表L。为了操作方便，在单链表的第一个结点之前附加一个结点，称为<strong>头结点</strong></p><p>二者区别：不管带不带头结点，<strong>头指针始终指向链表的第一个结点</strong>，而头结点是带头结点的链表中第一个结点，节点内通常不存储信息。头结点的指针域指向线性表的第一个元素结点。<strong>可以没有头结点，但不能没有头指针</strong>。</p><p>引入头结点带来的优点：</p><ul><li>让链表在第一个位置的操作和在表其他位置的操作保持一致。若不带头结点，每次插入或删除第一个元素时，需要改变头指针L的指向，要单独处理。</li><li>无论链表是否为空，头指针都指向头结点的非空指针（空表中头结点指针域为空），让空表和非空表的操作的到了统一。</li></ul><h3 id="单链表上基本操作的实现">3.2、单链表上基本操作的实现</h3><h4 id="头插法建立单链表">头插法建立单链表</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//带头结点</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createList_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span> </span>&#123;
    <span class="hljs-comment">//用头插法逆序建立带头结点的单链表</span>
    L = (LinkList) <span class="hljs-built_in">malloc</span> (<span class="hljs-built_in">sizeof</span>(LNode));
    <span class="hljs-keyword">if</span>(!L) <span class="hljs-built_in">exit</span>(<span class="hljs-string">&quot;OVERFLOW&quot;</span>); <span class="hljs-comment">//申请失败，返回内存溢出</span>
    L-&gt;next = null;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
        p = (LinkList) <span class="hljs-built_in">malloc</span> (<span class="hljs-built_in">sizeof</span>(LNode));
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;p-&gt;data);
        p-&gt;next = L-&gt;next;
        L-&gt;next = p;
    &#125;    
&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//不带头结点</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createList_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span> </span>&#123;
    L = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;
        p = (LinkList) <span class="hljs-built_in">malloc</span> (<span class="hljs-built_in">sizeof</span>(LNode));
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;p-&gt;data);
        p-&gt;next = L;
        L = p; <span class="hljs-comment">//头指针指向第一个元素结点</span>
    &#125;</code></pre></div><h4 id="尾插法建立单链表">尾插法建立单链表</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//带头结点</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(LinkList &amp;L)</span> </span>&#123;
    <span class="hljs-comment">//创建头结点</span>
    L = (LNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));
    LNode *r = L; <span class="hljs-comment">//尾指针</span>
    <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data);
    <span class="hljs-keyword">while</span> (data != <span class="hljs-number">9999</span>) &#123; <span class="hljs-comment">// 输入结点值为9999时停止创建</span>
        LNode *node = (LNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (LNode));
        node-&gt;data = data;
        r-&gt;next = node;
        r = node;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data);
    &#125;
    r-&gt;next = <span class="hljs-literal">NULL</span>;
&#125;

<span class="hljs-comment">//不带头结点</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(LinkList &amp;L)</span> </span>&#123;
    L = <span class="hljs-literal">NULL</span>;
    LNode *r = L;
    <span class="hljs-type">int</span> data;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data);

    <span class="hljs-keyword">while</span> (data != <span class="hljs-number">9999</span>) &#123; 
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data为 %d&quot;</span>,data);
        LNode *node = (LNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (LNode));
        node-&gt;data = data;
        node-&gt;next = <span class="hljs-literal">NULL</span>;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data);
        <span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//第一个结点单独创建，此时需要改变头指针的指向</span>
            L = node;
            r = L;
            <span class="hljs-keyword">continue</span>;
        &#125;
        r-&gt;next = node;
        r = node;
    &#125;

&#125;</code></pre></div><h4 id="在第i个位置插入元素">在第i个位置插入元素</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//带头节点</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">listInsert</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> data)</span> </span>&#123;
    <span class="hljs-comment">//找到第 index - 1个结点，插在其后</span>
    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">1</span> ) <span class="hljs-comment">//位序从1开始</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    LNode *p = L;
    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; index - <span class="hljs-number">1</span>) &#123;
        p = p-&gt;next;
        j++;
    &#125;
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//index不合法，超出当前链表最大长度+1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
    LNode * node = (LNode*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (LNode));
    node-&gt;data = data;
    node-&gt;next = p-&gt;next;
    p-&gt;next = node;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-comment">//不带头结点</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">listInsert</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> data)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (index == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//在头部插入，需要单独处理</span>
        LNode *node = (LNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (LNode));
        node-&gt;data = data;
        node-&gt;next = L;
        L = node;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125; 
    
    LNode *p = L;
    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; <span class="hljs-comment">// 此时j从1开始</span>
    <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; index - <span class="hljs-number">1</span>) &#123;
        p = p-&gt;next;
        j ++;
    &#125;
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    LNode *node = (LNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (LNode));
    node-&gt;data = data;
    node-&gt;next = p-&gt;next;
    p-&gt;next = node;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div><h4 id="指定结点的后插操作">指定结点的后插操作</h4><p>带头结点和不带头结点的单链表操作相同，在给定结点不为空的前提下，申请一个新的结点，将其插在当前结点之后</p><h4 id="指定结点的前插操作">指定结点的前插操作</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*</span>
<span class="hljs-comment">指定结点的前插操作 相当于 指定结点的前驱的后插操作</span>
<span class="hljs-comment">1、传入头指针</span>
<span class="hljs-comment">	从头遍历链表找到当前结点的前驱，在其后插入新结点。不带头结点的单链表在第一个结点前插入时要单独处理。</span>
<span class="hljs-comment">2、不传入头指针</span>
<span class="hljs-comment">	在当前结点后插入新结点，将新结点的数据和当前结点的数据交换，达到前插的 “效果”</span>
<span class="hljs-comment">*/</span>

<span class="hljs-comment">//不带头结点</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insertPriorNode</span><span class="hljs-params">(LinkList L, LNode *p, <span class="hljs-type">int</span> data)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span> || p == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    
    <span class="hljs-comment">/* 不带头结点的链表 多 一个判断是否在第一个结点执行前插操作的判断，单独处理该情况，其余操作均相同*/</span>
    LNode *q = L;
    <span class="hljs-keyword">while</span>(q-&gt;next != p) &#123; <span class="hljs-comment">//寻找p的前驱</span>
        q = q-&gt;next;
    &#125;

    LNode *node = (LNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (LNode));
    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    node-&gt;data = data;
    q-&gt;next = node;
    node-&gt;next = p;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div><h4 id="按位序删除">按位序删除</h4><p>主要是找到待删除结点的前驱和后继，将其后继作为前驱的后继，并将当前结点删除。若i值不合法找不到第i-1个结点或第i个结点已经为NULL，删除失败。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//带头节点	</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">listDelete</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> &amp;data)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">1</span> || L == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-comment">/*若是不带头结点的单链表，判断index是否等于1.单独处理*/</span>
    
    LNode *pre = L, *p = L-&gt;next;
    <span class="hljs-keyword">while</span> (-- index &amp;&amp; p) &#123; <span class="hljs-comment">//寻找第index-1个结点</span>
        pre = p;
        p = p -&gt; next;
    &#125;
    
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">//i值不合法</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (p-&gt;next == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">//p已经是最后一个结点</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    
    LNode *q = p-&gt;next;
    data = q-&gt;data;
    p-&gt;next = q-&gt;next;
    <span class="hljs-built_in">free</span>(q);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-comment">//不带头结点</span>
<span class="hljs-comment">/*</span>
<span class="hljs-comment">	若删除的是第一个结点 (index = 1)，需要改变头指针的指向，需要单独处理</span>
<span class="hljs-comment">	寻找第i-1个结点时， j从1开始，其余操作和不带头结点的相同</span>
<span class="hljs-comment">*/</span></code></pre></div><h4 id="指定结点p的删除">指定结点p的删除</h4><ul><li>若传入头指针，循环寻找p的前驱，将后继作为前驱的后继</li><li>若不传入头指针，将p和p的后继节点数据交换后，删除后继。&lt; 注：若p是最后一个结点时会出错&gt;</li></ul><h3 id="双链表">3.4、双链表</h3><p>​ 单链表中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。访问某个结点的前驱结点时只能从头开始遍历，其时间复杂度为<em>O(n)</em>，访问其后继节点的时间复杂度为<em>O(1)</em>。</p><p>​ 为了克服单链表的上述缺点，引入了双链表。双链表的插入和删除时间复杂度都为 <em>O(1)</em>，按值查找和按位查找都需要遍历链表，时间复杂度都为 <em>O(n)。</em></p><p>​ 双链表结点中含有两个指针prior 和 next，分别指向其前驱和后继结点。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221020091225136-2024-12-615:11:00.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20221020091225136" style="zoom:67%"></p><p>其结点结构类型如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DNode</span> &#123;
    ElemType data;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dnode</span> *prior, *next;
&#125;DNode, *DLinkList;</code></pre></div><h4 id="双链表的插入操作">双链表的插入操作</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221020091611880-2024-12-615:15:34.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20221020091611880" style="zoom:67%"></p><p>在p之后插入新结点，其中第 1、2步必须在第4步之前，否则就会丢失p的后继节点。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//先处理好插入节点和p结点后继结点的关系</span>
<span class="hljs-number">1.</span> p-&gt;next-&gt;prior = s;
<span class="hljs-number">2.</span> s-&gt;next = p-&gt;next;
<span class="hljs-comment">//再处理插入结点和p结点的关系</span>
<span class="hljs-number">3.</span> s-&gt;prior = p;
<span class="hljs-number">4.</span> p-&gt;next = s;

<span class="hljs-comment">//注意边界，当对最后一个结点进行后插操作时，需要特殊处理，直接使用上述代码会出错</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insertDNode</span><span class="hljs-params">(DNode *p, DNode *s)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span>(p-&gt;next != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//若p结点有后继结点</span>
        p-&gt;next-&gt;prior = s;
    &#125;
    s-&gt;next = p-&gt;next;
    s-&gt;prior = p;
    p-&gt;next = s;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div><p>实现了双链表的后插操作后，其他插入操作如 按位序i插入（找到第i-1个结点，执行后插操作）和 某结点的前插操作（其前驱结点的后插操作都可以转化为后插操作。</p><h4 id="双链表的删除操作">双链表的删除操作</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2022-10-20_09-25-23-2024-12-615:16:29.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:67%"></p><p>删除p的后继结点：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//当p或p的后继为最后后一个结点时，该做法会出错</span>
p-&gt;next = q-&gt;next;
q-&gt;next-&gt;prior = p;
<span class="hljs-built_in">free</span>(q);

<span class="hljs-comment">//注意边界，当被删除结点为最后一个结点时要特殊处理。</span>
<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">deleteDNode</span><span class="hljs-params">(DNode *p)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    DNode *q = p-&gt;next;
    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//p没有后继</span>
    p-&gt;next = q-&gt;next;
    <span class="hljs-keyword">if</span>(q-&gt;next != <span class="hljs-literal">NULL</span>) &#123;
        q-&gt;next-&gt;prior = p;
    &#125;
    <span class="hljs-built_in">free</span>(q);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div><h3 id="循环链表">3.5、循环链表</h3><h4 id="循环单链表">循环单链表</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221020095402713-2024-12-615:20:17.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20221020095402713" style="zoom:67%"></p><p>初始化： <code>L-&gt;next = L</code></p><p>判空：<code>L-&gt;next == L</code></p><p>判断是否为表尾结点 : <code>p-&gt;next == L</code></p><p>在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任一结点开始遍历整个链表。</p><p><strong>对于只设置头指针的循环单链表，其要找到表尾结点的时间复杂的仍为 <em>O(n)</em>，需要依次遍历整个链表。故通常为循环单链表不设头指针而仅设置尾指针</strong></p><h4 id="循环双链表">循环双链表</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221020100322600-2024-12-615:20:39.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20221020100322600" style="zoom:67%"></p><p>初始化： <code>L-&gt;next = L; L-&gt;prior = L;</code></p><p>判空： <code>L-&gt;next == L</code></p><p>判断是否为表尾结点： <code>p-&gt;next == L</code></p><p>对循环双链表的插入和删除操作和 普通双链表基本相同，且不用考虑边界情况。</p><h3 id="静态链表">3.6、静态链表</h3><h2 id="四链表相关的算法题目">四、链表相关的算法题目</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="category-chain-item">数据结构</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="print-no-link">#线性表</a> <a href="/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/" class="print-no-link">#单链表</a> <a href="/tags/%E5%8F%8C%E9%93%BE%E8%A1%A8/" class="print-no-link">#双链表</a> <a href="/tags/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/" class="print-no-link">#循环链表</a></div></div><div class="license-box my-3"><div class="license-title"><div>二、线性表</div><div>https://catpaws.top/7682ef9a/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年12月6日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/d403458d/" title="三、栈和队列"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">三、栈和队列</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/bfab103e/" title="一、绪论"><span class="hidden-mobile">一、绪论</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://catpaws.top/blog-resource/twikoo1.6.42/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本站由<img src="/img/upyun_logo.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="width:auto;height:auto">提供CDN加速/云存储服务</a></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备2025059828号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61032302000087" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="police-icon"> <span>陕公网安备61032302000087号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//catpaws.top/blog-resource/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="//catpaws.top/blog-resource/js/loader.js"></script><script src="//catpaws.top/blog-resource/js/blurpicload.js"></script><script src="//catpaws.top/blog-resource/js/axios.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://catpaws.top/blog-resource/live2d/index.min.js"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"https://catpaws.top/blog-resource/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"}}})</script></body></html>