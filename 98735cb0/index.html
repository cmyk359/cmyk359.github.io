<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://catpaws.top/blog-resource/imgs/webicon.png"><link rel="icon" href="https://catpaws.top/blog-resource/imgs/webicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="一、泛型概述 JAVA推出泛型以前，程序员可以构建一个元素类型为Object的集合，该集合能够存储任意的数据类型对象，而在使用该集合的过程中，需要程序员明确知道存储每个元素的数据类型，否则在使用时进行强制类型转换很容易引发ClassCastException异常。 泛型（Generics）是 Java5引入的特性，允许在定义类、接口或方法时使用类型参数，使得代码可以灵活处理多种数据类型，"><meta property="og:type" content="article"><meta property="og:title" content="泛型程序设计"><meta property="og:url" content="https://catpaws.top/98735cb0/index.html"><meta property="og:site_name" content="猫爪在上の书桌"><meta property="og:description" content="一、泛型概述 JAVA推出泛型以前，程序员可以构建一个元素类型为Object的集合，该集合能够存储任意的数据类型对象，而在使用该集合的过程中，需要程序员明确知道存储每个元素的数据类型，否则在使用时进行强制类型转换很容易引发ClassCastException异常。 泛型（Generics）是 Java5引入的特性，允许在定义类、接口或方法时使用类型参数，使得代码可以灵活处理多种数据类型，"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211234157155-2025-2-1123:42:16.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211234307024-2025-2-1123:43:08.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211235351391-2025-2-1123:53:52.png"><meta property="article:published_time" content="2025-02-10T15:10:32.000Z"><meta property="article:modified_time" content="2025-02-11T17:06:30.054Z"><meta property="article:author" content="猫爪在上"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211234157155-2025-2-1123:42:16.png"><title>泛型程序设计 - 猫爪在上の书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/font.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/poem.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/shubiao.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/loader.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/twikoo_beautify.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/indeximg-hover.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/wave.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/blurpicload.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"https://catpaws.top/img/transpare.svg",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://leancloud.catpaws.top",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loader-container"><div class="loader"><div class="wrapper"><div class="catContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 733 673" class="catbody"><path fill="#212121" d="M111.002 139.5C270.502 -24.5001 471.503 2.4997 621.002 139.5C770.501 276.5 768.504 627.5 621.002 649.5C473.5 671.5 246 687.5 111.002 649.5C-23.9964 611.5 -48.4982 303.5 111.002 139.5Z"></path><path fill="#212121" d="M184 9L270.603 159H97.3975L184 9Z"></path><path fill="#212121" d="M541 0L627.603 150H454.397L541 0Z"></path></svg> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 158 564" class="tail"><path fill="#191919" d="M5.97602 76.066C-11.1099 41.6747 12.9018 0 51.3036 0V0C71.5336 0 89.8636 12.2558 97.2565 31.0866C173.697 225.792 180.478 345.852 97.0691 536.666C89.7636 553.378 73.0672 564 54.8273 564V564C16.9427 564 -5.4224 521.149 13.0712 488.085C90.2225 350.15 87.9612 241.089 5.97602 76.066Z"></path></svg><div class="text"><span class="bigzzz">Z</span> <span class="zzz">Z</span></div></div><div class="wallContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 500 126" class="wall"><line stroke-width="6" stroke="#7C7C7C" y2="3" x2="450" y1="3" x1="50"></line><line stroke-width="6" stroke="#7C7C7C" y2="85" x2="400" y1="85" x1="100"></line><line stroke-width="6" stroke="#7C7C7C" y2="122" x2="375" y1="122" x1="125"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="500" y1="43"></line><line stroke-width="6" stroke="#7C7C7C" y2="1.99391" x2="115.5" y1="43.0061" x1="115.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00002" x2="189" y1="43.0122" x1="189"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00612" x2="262.5" y1="43.0183" x1="262.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01222" x2="336" y1="43.0244" x1="336"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01833" x2="409.5" y1="43.0305" x1="409.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="153" y1="84.0122" x1="153"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="228" y1="84.0122" x1="228"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="303" y1="84.0122" x1="303"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="378" y1="84.0122" x1="378"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="192" y1="125.012" x1="192"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="267" y1="125.012" x1="267"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="342" y1="125.012" x1="342"></line></svg></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上の书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>个人主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://catpaws.top/blog-resource/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="泛型程序设计"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-02-10 23:10" pubdate>2025年2月10日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.9k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 33 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">泛型程序设计</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年2月12日 凌晨</p><div class="markdown-body"><meta name="referrer" , content="no-referrer"><h2 id="一泛型概述">一、泛型概述</h2><p>JAVA推出泛型以前，程序员可以构建一个元素类型为Object的集合，该集合能够存储任意的数据类型对象，而在使用该集合的过程中，需要程序员明确知道存储每个元素的数据类型，否则在使用时进行强制类型转换很容易引发<code>ClassCastException</code>异常。</p><p><strong>泛型（Generics）</strong>是 Java5引入的特性，允许在定义类、接口或方法时使用<strong>类型参数</strong>，使得代码可以灵活处理多种数据类型，同时保证类型安全。</p><p>泛型的核心思想是<strong>参数化类型</strong>，将类型作为参数传递给类或方法。</p><p>为什么要使用泛型？</p><ul><li><p><strong>类型安全</strong></p><p>泛型提供了编译时类型安全监测机制，强制检查类型匹配，该机制可以在编译时检测到非法的类型数据结构。</p></li><li><p><strong>消除类型转换</strong></p><p>直接使用泛型类型，无需手动强制转换</p></li><li><p>代码复用</p><p>编写一次泛型类或方法，可处理多种数据类型。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//泛型方法：支持任何可比较的类型</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt; T <span class="hljs-title function_">max</span><span class="hljs-params">(T a, T b)</span> &#123;
    <span class="hljs-keyword">return</span> a.compareTo(b) &gt;<span class="hljs-number">0</span> ? a : b;
&#125;</code></pre></div></li></ul><h2 id="二泛型的基本使用">二、泛型的基本使用</h2><h3 id="泛型类">泛型类</h3><p>泛型类的定义语法：</p><div class="code-wrapper"><pre><code class="hljs java">class 类名称 &lt;泛型标识,泛型标识, …&gt; &#123;
	<span class="hljs-keyword">private</span> 泛型标识 变量名;
    ....
&#125;</code></pre></div><p>常用的泛型标识：T、E、K、V</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * 泛型类的定义</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; 创建对象时指定具体的数据类型。</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic</span>&lt;T&gt; &#123;
    <span class="hljs-keyword">private</span> T key;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Generic</span><span class="hljs-params">(T key)</span> &#123;
        <span class="hljs-built_in">this</span>.key = key;
    &#125;

    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> key;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setKey</span><span class="hljs-params">(T key)</span> &#123;
        <span class="hljs-built_in">this</span>.key = key;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Generic&#123;&quot;</span> +
                <span class="hljs-string">&quot;key=&quot;</span> + key +
                <span class="hljs-string">&#x27;&#125;&#x27;</span>;
    &#125;
&#125;</code></pre></div><p>使用语法：</p><div class="code-wrapper"><pre><code class="hljs java">类名&lt;具体的数据类型&gt; 对象名 = <span class="hljs-keyword">new</span> 类名&lt;具体的数据类型&gt;();</code></pre></div><p>Javal.7以后，后面的&lt;&gt;中的具体的数据类型可以省略不写:</p><div class="code-wrapper"><pre><code class="hljs java">类名&lt;具体的数据类型&gt; 对象名 = <span class="hljs-keyword">new</span> 类名&lt;&gt;();</code></pre></div><p>例如：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
    <span class="hljs-comment">//泛型类在创建对象的时，指定操作的具体数据类型。</span>
    Generic&lt;String&gt; strGeneric = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generic</span>&lt;&gt;(<span class="hljs-string">&quot;abc&quot;</span>);
    <span class="hljs-type">String</span> <span class="hljs-variable">strKey</span> <span class="hljs-operator">=</span> strGeneric.getKey();
    System.out.println(strKey);
    System.out.println(<span class="hljs-string">&quot;--------------------------&quot;</span>);
    Generic&lt;Integer&gt; intGeneric = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generic</span>&lt;&gt;(<span class="hljs-number">123</span>);
    <span class="hljs-type">Integer</span> <span class="hljs-variable">intKey</span> <span class="hljs-operator">=</span> intGeneric.getKey();
    System.out.println(intKey);
&#125;</code></pre></div><p><strong>注意事项：</strong></p><ol type="1"><li>泛型类在创建对象的时候，若没有指定类型，将按照Object类型来操作。</li><li>泛型的类型参数只能是类类型，不能是基本数据类型</li><li>泛型类型在逻辑上可以看成是多个不同的类型，但实际上都是相同类型</li></ol><p>Java的泛型是通过<strong>类型擦除</strong>来实现的，在编译期间，所有的泛型类型信息都会被擦除，替换为原始类型（通常是Object）或者它们的边界类型。</p><p>基本数据类型（如<code>int</code>）不是对象，无法隐式转换为<code>Object</code>，所以泛型的类型参数不能是基本数据类型，通过包装类和自动装箱/拆箱，可以间接在泛型中使用基本类型；</p><p>在代码中，泛型类型参数化后，<strong>逻辑上</strong>会被视为不同的类型。由于类型擦除，<strong>所有泛型类型在运行时都会被擦除为原始类型</strong>，它们共享同一个Class对象。例如：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//逻辑上List&lt;String&gt;和List&lt;Integer&gt;是不同的类型，但实际上它们在运行时是相同的类型。</span>
<span class="hljs-comment">//它们共享同一个Class对象，即List.class</span>
List&lt;String&gt; strList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
List&lt;Integer&gt; intList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

System.out.println(strList.getClass()); <span class="hljs-comment">//class java.util.ArrayList</span>
System.out.println(intList.getClass()); <span class="hljs-comment">//class java.util.ArrayList</span>
System.out.println(strList.getClass() == intList.getClass()); <span class="hljs-comment">// true</span></code></pre></div><h3 id="泛型接口">泛型接口</h3><p>泛型接口的定义:</p><div class="code-wrapper"><pre><code class="hljs java">interface 接口名称 &lt;泛型标识，泛型标识，…&gt; &#123;
	泛型标识 方法名();
&#125;</code></pre></div><p>泛型接口的使用：</p><ul><li>实现类不是泛型类，接口要明确数据类型</li><li>实现类是泛型类，实现类和接口的泛型类型要一致</li></ul><h3 id="泛型方法">泛型方法</h3><p>泛型方法的定义：</p><p>在返回类型前使用尖括号<code>&lt;&gt;</code>定义类型参数，正在的类型由方法调用者决定。</p><div class="code-wrapper"><pre><code class="hljs java">修饰符 &lt;T，E，...&gt; 返回值类型 方法名（ 形参列表 ）&#123;
    方法体...
&#125;</code></pre></div><p>注意点：</p><ul><li><p>类型参数仅在方法内部有效，与类的泛型参数无关。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Utils</span> &#123;
    <span class="hljs-comment">// 泛型方法：类型参数&lt;T&gt;由方法自身定义</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getFirst</span><span class="hljs-params">(List&lt;T&gt; list)</span> &#123;
        <span class="hljs-keyword">return</span> list.get(<span class="hljs-number">0</span>);
    &#125;
&#125;</code></pre></div></li><li><p>结合可变参数处理多个同类型参数</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAll</span><span class="hljs-params">(T... items)</span> &#123;
    <span class="hljs-keyword">for</span> (T item : items) &#123;
        System.out.println(item);
    &#125;
&#125;</code></pre></div></li><li><p>当要确保方法内部可以安全调用特定类型的方法时，可以限制类型参数的范围，使其必须继承某个类或实现某接口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 限定T必须是Number的子类</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; <span class="hljs-type">double</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(T a, T b)</span> &#123;
    <span class="hljs-keyword">return</span> a.doubleValue() + b.doubleValue();
&#125;</code></pre></div></li><li><p>可以使用扩展类型列表，处理多个类型的参数</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T,E,K&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printInput</span><span class="hljs-params">(T t, E e, K k)</span> &#123;
    System.out.println(t +<span class="hljs-string">&quot;\t &quot;</span> + t.getClass());
    System.out.println(e +<span class="hljs-string">&quot;\t &quot;</span> + e.getClass());
    System.out.println(k +<span class="hljs-string">&quot;\t &quot;</span> + k.getClass());
&#125;</code></pre></div></li><li><p><strong>泛型方法 vs 泛型类的成员方法</strong></p><table><thead><tr class="header"><th><strong>维度</strong></th><th><strong>泛型方法</strong></th><th><strong>泛型类的成员方法</strong></th></tr></thead><tbody><tr class="odd"><td><strong>定义位置</strong></td><td>方法签名前独立声明类型参数</td><td>直接使用类的泛型参数</td></tr><tr class="even"><td><strong>作用域</strong></td><td>仅在方法内有效</td><td>类及其所有成员方法中有效</td></tr><tr class="odd"><td><strong>静态方法</strong></td><td>支持（如<code>public static &lt;T&gt; T method()</code>）</td><td>不支持（静态方法无法访问类的泛型参数）</td></tr><tr class="even"><td><strong>类型推断</strong></td><td>由方法调用时的参数决定</td><td>由类实例化时的类型参数决定</td></tr></tbody></table></li></ul><h2 id="三泛型类型的继承规则">三、泛型类型的继承规则</h2><h3 id="泛型类的继承规则">泛型类的继承规则</h3><p>在Java中，泛型类的继承规则与普通类有所不同，尤其是在处理类型参数时需遵循特定的约束。</p><ol type="1"><li><p>若子类为泛型类，<strong>必须保持与父类泛型参数的兼容性</strong>。子类可以：</p><ul><li><strong>直接继承父类的泛型参数</strong>：保持类型参数名称一致。</li><li><strong>扩展父类的泛型参数</strong>：为父类类型参数添加边界约束。</li><li><strong>引入额外的泛型参数</strong>：在继承父类泛型参数的同时定义新的类型参数。</li></ul><p>例如：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&lt;T&gt; &#123;
 <span class="hljs-keyword">private</span> T value;
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(T value)</span> &#123; <span class="hljs-built_in">this</span>.value = value; &#125;
 <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> value; &#125;
&#125;
<span class="hljs-comment">//场景1：子类直接继承父类泛型参数</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Child1</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&lt;T&gt; &#123; <span class="hljs-comment">// Child1的泛型参数T与Parent的T一致</span>
&#125;

<span class="hljs-comment">//场景2：子类扩展父类泛型参数的边界</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Child2</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&lt;T&gt; &#123; <span class="hljs-comment">// Parent的T被约束为Number或其子类</span>
&#125;

<span class="hljs-comment">//场景3：子类引入新的泛型参数</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Child3</span>&lt;T, U&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&lt;T&gt; &#123; <span class="hljs-comment">//新增泛型参数U，Parent的T保持独立</span>
&#125;</code></pre></div></li><li><p>子类不是泛型类</p><p>泛型类型需要在编译时确定，如果子类不提供类型参数，父类会被视为原始类型，导致类型不安全，编译器会发出警告。</p><p>若子类不是泛型类，<strong>必须为父类的泛型参数指定具体类型</strong>。此时父类将失去泛型灵活性，但类型安全得到保证。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span>&lt;T&gt; &#123;
 <span class="hljs-keyword">private</span> T value;
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(T value)</span> &#123; <span class="hljs-built_in">this</span>.value = value; &#125;
 <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> value; &#125;
&#125;

<span class="hljs-comment">//子类指定父类的具体类型为</span>
Stringclass ConcreteChild <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span>&lt;String&gt; &#123; <span class="hljs-comment">//父类的T被固定为String</span>
&#125;</code></pre></div></li></ol><h3 id="泛型接口的继承规则">泛型接口的继承规则</h3><h2 id="四类型通配符">四、类型通配符</h2><p>Java 泛型中的<strong>类型通配符</strong>（<code>?</code>）用于增强泛型的灵活性，允许在参数化类型中表示未知的具体类型。其主要目的是解决<strong>泛型类型的不可变性</strong>问题（如<code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>无继承关系）。</p><p>三种类型通配符：</p><table><thead><tr class="header"><th style="text-align:center"><strong>类型</strong></th><th><strong>语法</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align:center"><strong>无界通配符</strong></td><td><code>&lt;?&gt;</code></td><td>表示任意类型，但使用时类型信息完全丢失（只能调用与类型无关的方法，如<code>size()</code>）。</td></tr><tr class="even"><td style="text-align:center"><strong>上界通配符</strong></td><td><code>&lt;? extends T&gt;</code></td><td>表示<code>T</code>或其子类，主要用于<strong>安全地读取数据</strong>（协变）。</td></tr><tr class="odd"><td style="text-align:center"><strong>下界通配符</strong></td><td><code>&lt;? super T&gt;</code></td><td>表示<code>T</code>或其父类，主要用于<strong>安全地写入数据</strong>（逆变）。</td></tr></tbody></table><p>具体分析如下：</p><ul><li><p>无界通配符 <code>&lt;?&gt;</code></p><p>可以接受任意类型的泛型参数，如<code>List&lt;?&gt;</code>能接受<code>List&lt;String&gt;</code>或<code>List&lt;Integer&gt;</code>；但无法向其中添加数据（除null外），只能进行读取操作，返回值视为Object。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(List&lt;?&gt; list)</span> &#123;
    <span class="hljs-keyword">for</span> (Object elem : list) &#123;  <span class="hljs-comment">// 元素类型视为Object</span>
        System.out.println(elem);
    &#125;
    <span class="hljs-comment">// list.add(&quot;abc&quot;);  // 编译错误：无法确定具体类型</span>
    list.add(<span class="hljs-literal">null</span>);      <span class="hljs-comment">// 允许（null无类型）</span>
&#125;</code></pre></div></li><li><p>上界通配符<code>&lt;? extends T&gt;</code></p><p>要求该泛型的类型，只能是<strong><code>T</code>，或<code>T</code>的子类类型</strong>。</p><p>此时，允许读取类型为<code>T</code>或其子类的数据，但<strong>无法添加数据</strong>，因为编译器无法确定具体子类型。</p><p>适用于只消费数据的场景，如遍历、计算。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(List&lt;? extends Number&gt; list)</span> &#123;
    <span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">for</span> (Number num : list) &#123;  <span class="hljs-comment">// 安全读取为Number类型</span>
        sum += num.doubleValue();
    &#125;
    <span class="hljs-comment">// list.add(123);  // 编译错误：实际类型可能是Double或Integer</span>
    <span class="hljs-keyword">return</span> sum;
&#125;

<span class="hljs-comment">// 调用示例</span>
List&lt;Integer&gt; intList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
sum(intList);  <span class="hljs-comment">// 允许传入List&lt;Integer&gt;（Integer是Number的子类）</span></code></pre></div></li><li><p>下界通配符 <code>&lt;? super T&gt;</code></p><p>要求该泛型的类型，只能是<strong><code>T</code>，或<code>T</code>的父类类型</strong>。</p><p>此时，允许写入类型为<code>T</code>或其父类的数据，但读取数据时类型不确定，只能视为<code>Object</code>。</p><p>适用于生产数据的场景，如向集合中添加元素。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNumbers</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> Integer&gt; list)</span> &#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;
        list.add(i);  <span class="hljs-comment">// 允许添加Integer及其父类（如Number、Object）</span>
    &#125;
    <span class="hljs-comment">// Integer num = list.get(0);  // 编译错误：实际类型可能是Object</span>
&#125;

<span class="hljs-comment">// 调用示例</span>
List&lt;Number&gt; numList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
addNumbers(numList);  <span class="hljs-comment">// 允许传入List&lt;Number&gt;</span></code></pre></div></li></ul><p>核心区别：</p><table><thead><tr class="header"><th><strong>维度</strong></th><th><code>&lt;?&gt;</code></th><th><code>&lt;? extends T&gt;</code></th><th><code>&lt;? super T&gt;</code></th></tr></thead><tbody><tr class="odd"><td><strong>读取数据</strong></td><td>视为<code>Object</code></td><td>视为<code>T</code>或其子类</td><td>只能视为<code>Object</code></td></tr><tr class="even"><td><strong>写入数据</strong></td><td>仅<code>null</code></td><td>❌ 不允许</td><td>✅ 允许添加<code>T</code>或其子类对象</td></tr><tr class="odd"><td><strong>典型应用场景</strong></td><td>不关心类型的通用操作</td><td>只读操作（Producer）</td><td>只写操作（Consumer）</td></tr><tr class="even"><td><strong>类型安全</strong></td><td>低</td><td>高（限定了上界）</td><td>高（限定了下界）</td></tr></tbody></table><p><strong>PECS原则（Producer-Extends, Consumer-Super）</strong></p><ul><li><strong>Producer（生产者）</strong>：若泛型对象负责<strong>提供数据</strong>，使用<code>&lt;? extends T&gt;</code>。</li><li><strong>Consumer（消费者）</strong>：若泛型对象负责<strong>接收数据</strong>，使用<code>&lt;? super T&gt;</code>。</li></ul><p>例如：实现一个通用的集合合并方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(</span>
<span class="hljs-params">    List&lt;? <span class="hljs-built_in">super</span> T&gt; dest,  // Consumer：接收T类型数据</span>
<span class="hljs-params">    List&lt;? extends T&gt; src  // Producer：提供T类型数据</span>
<span class="hljs-params">)</span> &#123;
    dest.addAll(src);
&#125;
</code></pre></div><blockquote><p><strong><code>List&lt;?&gt;</code>和<code>List&lt;Object&gt;</code>的区别？</strong></p><ul><li><code>List&lt;?&gt;</code>是未知类型的集合，只能读取为<code>Object</code>且无法写入（除<code>null</code>）。</li><li><code>List&lt;Object&gt;</code>是明确类型的集合，可以添加任意对象。</li></ul></blockquote><h2 id="五类型擦除">五、类型擦除</h2><p>泛型是Java 1.5版本才引进的概念，在这之前是没有泛型的，但是，泛型代码能够很好地和之前版本的代码兼容。那是因为，泛型信息只存在于代码编译阶段，在进入JVM之前，与泛型相关的信息会被擦除掉。</p><p>擦除机制：泛型类型在编译时替换为边界类型或<code>Object</code>，确保兼容性。</p><p><strong>核心思想</strong></p><ul><li><strong>编译时类型检查</strong>：编译器验证泛型类型的安全性，如禁止<code>List&lt;String&gt;</code>添加整数。</li><li><strong>运行时擦除</strong>：将所有泛型类型参数替换为它们的<strong>上界</strong>（默认为<code>Object</code>）或具体指定类型。</li></ul><h3 id="擦除规则">擦除规则</h3><p><strong>类型参数的替换规则</strong></p><ul><li><p>无界泛型（如<code>&lt;T&gt;</code>）→ 替换为<code>Object</code>。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211234157155-2025-2-1123:42:16.png" srcset="https://catpaws.top/img/transpare.svg" lazyload style="zoom:80%"></p></li><li><p>有界泛型（如<code>&lt;T extends Number&gt;</code>）→ 替换为上界<code>Number</code>。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211234307024-2025-2-1123:43:08.png" srcset="https://catpaws.top/img/transpare.svg" lazyload style="zoom:80%"></p></li><li><p>嵌套泛型，（如<code>List&lt;List&lt;String&gt;&gt;</code>）→ 外层保留，内层擦除为<code>List</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 源码</span>
List&lt;List&lt;String&gt;&gt; nestedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

<span class="hljs-comment">// 擦除过程</span>
List&lt;List&lt;String&gt;&gt; → List&lt;List&gt; → List  <span class="hljs-comment">// 逐层剥离类型参数，每层独立擦除。</span></code></pre></div></li></ul><p><strong>通配符的擦除规则</strong></p><ul><li><code>&lt;?&gt;</code> → 擦除为<code>Object</code>。</li><li><code>&lt;? extends Number&gt;</code> → 擦除为<code>Number</code>。</li><li><code>&lt;? super Integer&gt;</code> → 擦除为<code>Object</code>。</li></ul><h3 id="桥接方法">桥接方法</h3><p>桥接方法是 Java 编译器为了解决<strong>泛型类型擦除</strong>与<strong>多态性</strong>之间的冲突而自动生成的合成方法。</p><p>Java 的泛型在编译后会擦除类型信息，但子类重写父类泛型方法时，可能出现<strong>方法签名不一致</strong>的问题。桥接方法的作用是<strong>保持多态性</strong>，确保在类型擦除后，子类仍能正确重写父类的方法。</p><p>编译器会自动生成一个桥接方法，<strong>将父类的方法调用“桥接”到子类实际的方法实现</strong>。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211235351391-2025-2-1123:53:52.png" srcset="https://catpaws.top/img/transpare.svg" lazyload style="zoom:80%"></p><h2 id="六约束和限制">六、约束和限制</h2><p>1、不能用基本类型实例化参数类型</p><p>2、运行时类型查询只适用于原始类型</p><p>3、不能创建参数化类型的数组</p><p>4、待补充....</p><h2 id="七泛型与反射">七、泛型与反射</h2><p>反射允许你在运行时分析任意的对象。如果对象是泛型类的实例，关于泛型类型参数则得不到太多信息，因为它们会被擦除。但在某些特定场景下（例如泛型被具体化，如通过继承或字段声明），可以通过反射结合 <code>Type</code> 接口获取泛型信息。</p><p><strong><code>Type</code> 接口</strong>是Java 反射 API 中所有泛型类型信息的父接口，<code>ParameterizedType</code> 是 其子接口，用于表示<strong>参数化类型</strong>，其中包括三个方法</p><table><thead><tr class="header"><th><strong>方法</strong></th><th><strong>返回值</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr class="odd"><td><code>Type[] getActualTypeArguments()</code></td><td><code>Type[]</code></td><td>获取参数化类型的实际泛型参数（如 <code>List&lt;String&gt;</code> 中的 <code>String</code>）。</td></tr><tr class="even"><td><code>Type getRawType()</code></td><td><code>Type</code></td><td>获取参数化类型的原始类型（如 <code>List&lt;String&gt;</code> 的原始类型是 <code>List.class</code>）。</td></tr><tr class="odd"><td><code>Type getOwnerType()</code></td><td><code>Type</code></td><td>获取外层所有者类型（仅当参数化类型是成员类型时有效，否则返回 <code>null</code>）。</td></tr></tbody></table><p>获取泛型类型：</p><ul><li><p><code>Class.getGenericSuperclass()</code>：获取<strong>父类</strong>的泛型类型。</p></li><li><p><code>Field.getGenericType()</code>：获取<strong>字段</strong>的泛型类型。</p></li><li><p><code>Method.getGenericParameterTypes()</code>：获取方法参数的泛型类型。</p></li><li><p><code>Method.getGenericReturnType()</code>：获取<strong>方法返回值</strong>的泛型类型。</p></li></ul><blockquote><p>如果泛型未在类、字段或方法中具体化（如 <code>List&lt;T&gt;</code> 中的 <code>T</code> 未指定具体类型），则无法通过反射获取实际类型。</p></blockquote><p>示例</p><p><strong>场景1：获取类的泛型父类信息</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt; &#123; &#125;  <span class="hljs-comment">// 继承泛型父类</span>

<span class="hljs-comment">// 反射获取父类的泛型参数</span>
<span class="hljs-type">Type</span> <span class="hljs-variable">genericSuperclass</span> <span class="hljs-operator">=</span> StringList.class.getGenericSuperclass();

<span class="hljs-comment">// 必须是ParameterizedType类型才能做接下来的操作，所以需要先判断</span>
<span class="hljs-keyword">if</span> (genericSuperclass <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;
    <span class="hljs-comment">// 首先要强制转型成ParameterizedType类型，才能调用方法</span>
    <span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">parameterizedType</span> <span class="hljs-operator">=</span> (ParameterizedType) genericSuperclass;
    <span class="hljs-comment">//获取实际的参数化类型，即具体是什么泛型。可能有多个类型参数，返回一个数组</span>
    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
    <span class="hljs-type">Type</span> <span class="hljs-variable">firstTypeArgument</span> <span class="hljs-operator">=</span> actualTypeArguments[<span class="hljs-number">0</span>];  <span class="hljs-comment">// 实际类型参数：String.class</span>
    System.out.println(firstTypeArgument);  <span class="hljs-comment">// 输出：class java.lang.String</span>
&#125;</code></pre></div><p><strong>场景2：获取字段的泛型类型</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericExample</span> &#123;
    <span class="hljs-keyword">private</span> List&lt;Map&lt;String, Integer&gt;&gt; complexData;
&#125;

<span class="hljs-comment">// 反射获取字段的泛型类型</span>
<span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> GenericExample.class.getDeclaredField(<span class="hljs-string">&quot;complexData&quot;</span>);
<span class="hljs-type">Type</span> <span class="hljs-variable">genericType</span> <span class="hljs-operator">=</span> field.getGenericType();

<span class="hljs-keyword">if</span> (genericType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;
    <span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">parameterizedType</span> <span class="hljs-operator">=</span> (ParameterizedType) genericType;
    <span class="hljs-type">Type</span> <span class="hljs-variable">rawType</span> <span class="hljs-operator">=</span> parameterizedType.getRawType();  <span class="hljs-comment">// 原始类型：List.class</span>

    <span class="hljs-comment">// 获取嵌套泛型参数：Map&lt;String, Integer&gt;</span>
    <span class="hljs-type">Type</span> <span class="hljs-variable">firstArgType</span> <span class="hljs-operator">=</span> parameterizedType.getActualTypeArguments()[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">if</span> (firstArgType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;
        <span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">nestedType</span> <span class="hljs-operator">=</span> (ParameterizedType) firstArgType;
        <span class="hljs-type">Type</span> <span class="hljs-variable">nestedRawType</span> <span class="hljs-operator">=</span> nestedType.getRawType();  <span class="hljs-comment">// Map.class</span>
        Type[] nestedArgs = nestedType.getActualTypeArguments();  <span class="hljs-comment">// String.class, Integer.class</span>
    &#125;
&#125;</code></pre></div><p><strong>场景3：获取方法参数的泛型类型</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Service</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(List&lt;Map&lt;String, Object&gt;&gt; data)</span> &#123; &#125;
&#125;

<span class="hljs-comment">// 反射获取方法的泛型参数</span>
<span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> Service.class.getMethod(<span class="hljs-string">&quot;process&quot;</span>, List.class);
Type[] genericParamTypes = method.getGenericParameterTypes();
<span class="hljs-type">Type</span> <span class="hljs-variable">paramType</span> <span class="hljs-operator">=</span> genericParamTypes[<span class="hljs-number">0</span>];  <span class="hljs-comment">// List&lt;Map&lt;String, Object&gt;&gt;</span>

<span class="hljs-keyword">if</span> (paramType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;
    <span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">parameterizedType</span> <span class="hljs-operator">=</span> (ParameterizedType) paramType;
    Type[] actualArgs = parameterizedType.getActualTypeArguments();  <span class="hljs-comment">// Map&lt;String, Object&gt;</span>
&#125;</code></pre></div><p><strong>场景4：获取方法返回值的泛型类型</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataFactory</span> &#123;
    <span class="hljs-keyword">public</span> List&lt;Number&gt; <span class="hljs-title function_">createNumbers</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); &#125;
&#125;

<span class="hljs-comment">// 反射获取返回值的泛型类型</span>
<span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> DataFactory.class.getMethod(<span class="hljs-string">&quot;createNumbers&quot;</span>);
<span class="hljs-type">Type</span> <span class="hljs-variable">returnType</span> <span class="hljs-operator">=</span> method.getGenericReturnType();  <span class="hljs-comment">// List&lt;Number&gt;</span>

<span class="hljs-keyword">if</span> (returnType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;
    <span class="hljs-type">ParameterizedType</span> <span class="hljs-variable">parameterizedType</span> <span class="hljs-operator">=</span> (ParameterizedType) returnType;
    Type[] actualArgs = parameterizedType.getActualTypeArguments();  <span class="hljs-comment">// Number.class</span>
&#125;
</code></pre></div></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/JavaSE/" class="category-chain-item">JavaSE</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>泛型程序设计</div><div>https://catpaws.top/98735cb0/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年2月10日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/12dbc0cd/" title="并发编程模式"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">并发编程模式</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/d5381517/" title="java 集合"><span class="hidden-mobile">java 集合</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://cdn.smartcis.cn/npm/twikoo@1.6.40/dist/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本站由<img src="/img/upyun_logo.png" srcset="https://catpaws.top/img/transpare.svg" lazyload style="width:auto;height:auto">提供CDN加速/云存储服务</a></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备2025059828号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61032302000087" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="police-icon"> <span>陕公网安备61032302000087号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//catpaws.top/blog-resource/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="//catpaws.top/blog-resource/js/loader.js"></script><script src="//catpaws.top/blog-resource/js/blurpicload.js"></script><script src="//cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://registry.npmmirror.com/oh-my-live2d/latest/files"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"https://catpaws.top/blog-resource/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"},idleTips:{interval:15e3,message:function(){return axios.get("https://v1.hitokoto.cn?c=i").then((function(t){return t.data.hitokoto})).catch((function(t){console.error(t)}))}}}})</script></body></html>