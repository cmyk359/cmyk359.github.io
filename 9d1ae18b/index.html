<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://catpaws.top/blog-resource/imgs/webicon.png"><link rel="icon" href="https://catpaws.top/blog-resource/imgs/webicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="反转链表  思路：  双指针法 定义pre和cur指针，pre指向前一个结点，cur指向当前结点。初始时，pre指向null，cur指向头结点。再定义一个next指针保存cur的后继结点，方便进入下一轮循环。 public ListNode reverseList(ListNode head) &#123;     if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D;"><meta property="og:type" content="article"><meta property="og:title" content="二、链表"><meta property="og:url" content="https://catpaws.top/9d1ae18b/index.html"><meta property="og:site_name" content="猫爪在上の书桌"><meta property="og:description" content="反转链表  思路：  双指针法 定义pre和cur指针，pre指向前一个结点，cur指向当前结点。初始时，pre指向null，cur指向头结点。再定义一个next指针保存cur的后继结点，方便进入下一轮循环。 public ListNode reverseList(ListNode head) &#123;     if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D;"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250713111517546-2025-7-1311:15:18.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250713185550914-2025-7-1318:55:55.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250713231240813-2025-7-1323:12:41.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250702100216382-2025-7-1400:01:58.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250713235559285-2025-7-1323:56:00.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250713160412088-2025-7-1316:04:14.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250702102216000-2025-7-210:22:34.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250702110950398-2025-7-211:09:52.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250713105318434-2025-7-1310:53:19.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250713110215937-2025-7-1311:02:26.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240417181004501-2024-8-410:42:33.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250713113830648-2025-7-1311:38:31.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250713153028805-2025-7-1315:30:41.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250713172907881-2025-7-1317:29:12.png"><meta property="article:published_time" content="2025-07-01T01:42:44.000Z"><meta property="article:modified_time" content="2025-07-15T02:36:20.574Z"><meta property="article:author" content="猫爪在上"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250713111517546-2025-7-1311:15:18.png"><title>二、链表 - 猫爪在上の书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/font.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/poem.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/shubiao.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/loader.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/twikoo_beautify.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/indeximg-hover.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/wave.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/blurpicload.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"https://catpaws.top/blog-resource/imgs/transparent.svg",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://leancloud.catpaws.top",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loader-container"><div class="loader"><div class="wrapper"><div class="catContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 733 673" class="catbody"><path fill="#212121" d="M111.002 139.5C270.502 -24.5001 471.503 2.4997 621.002 139.5C770.501 276.5 768.504 627.5 621.002 649.5C473.5 671.5 246 687.5 111.002 649.5C-23.9964 611.5 -48.4982 303.5 111.002 139.5Z"></path><path fill="#212121" d="M184 9L270.603 159H97.3975L184 9Z"></path><path fill="#212121" d="M541 0L627.603 150H454.397L541 0Z"></path></svg> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 158 564" class="tail"><path fill="#191919" d="M5.97602 76.066C-11.1099 41.6747 12.9018 0 51.3036 0V0C71.5336 0 89.8636 12.2558 97.2565 31.0866C173.697 225.792 180.478 345.852 97.0691 536.666C89.7636 553.378 73.0672 564 54.8273 564V564C16.9427 564 -5.4224 521.149 13.0712 488.085C90.2225 350.15 87.9612 241.089 5.97602 76.066Z"></path></svg><div class="text"><span class="bigzzz">Z</span> <span class="zzz">Z</span></div></div><div class="wallContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 500 126" class="wall"><line stroke-width="6" stroke="#7C7C7C" y2="3" x2="450" y1="3" x1="50"></line><line stroke-width="6" stroke="#7C7C7C" y2="85" x2="400" y1="85" x1="100"></line><line stroke-width="6" stroke="#7C7C7C" y2="122" x2="375" y1="122" x1="125"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="500" y1="43"></line><line stroke-width="6" stroke="#7C7C7C" y2="1.99391" x2="115.5" y1="43.0061" x1="115.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00002" x2="189" y1="43.0122" x1="189"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00612" x2="262.5" y1="43.0183" x1="262.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01222" x2="336" y1="43.0244" x1="336"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01833" x2="409.5" y1="43.0305" x1="409.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="153" y1="84.0122" x1="153"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="228" y1="84.0122" x1="228"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="303" y1="84.0122" x1="303"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="378" y1="84.0122" x1="378"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="192" y1="125.012" x1="192"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="267" y1="125.012" x1="267"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="342" y1="125.012" x1="342"></line></svg></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上の书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>个人主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://catpaws.top/blog-resource/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="二、链表"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-07-01 09:42" pubdate>2025年7月1日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 38 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">二、链表</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年7月15日 上午</p><div class="markdown-body"><meta name="referrer" , content="no-referrer"><h2 id="反转链表"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713111517546-2025-7-1311:15:18.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：</p><ul><li><p>双指针法</p><p>定义pre和cur指针，pre指向前一个结点，cur指向当前结点。初始时，pre指向null，cur指向头结点。再定义一个next指针保存cur的后继结点，方便进入下一轮循环。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;
    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">return</span> head;
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, cur = head, next;
    <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;
        next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    &#125;
    <span class="hljs-keyword">return</span> pre;
&#125;
<span class="hljs-comment">//实际上pre指向反转后链表的头结点，cur指向剩余链表的头结点，每次用pre作为cur的后继就完成了反转</span></code></pre></div></li><li><p>头插法逆置</p><p>定义一个虚拟头结点，遍历链表，将每次遍历到的结点作为虚拟头结点的后继。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">headNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head, q;
    <span class="hljs-comment">//头插法翻转</span>
    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;
        q = p.next;
        p.next = headNode.next;
        headNode.next = p;
        p = q;
    &#125;
    <span class="hljs-keyword">return</span> headNode.next;
&#125;</code></pre></div></li></ul><h2 id="k-个一组翻转链表"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713185550914-2025-7-1318:55:55.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：分组检查 → 断链翻转 → 重新连接。创建虚拟头结点 <code>dummy</code> 统一处理头节点翻转，同时记录最终链表的头结点。</p><ul><li>每组向后遍历k个结点，检查当前组是否满足k个节点，若不足k个直接return</li><li>保存下组的首节点后，将当前组与下一组断开，使用辅助函数 reverseList 独立翻转当前组</li><li>翻转后的组连接到上一组的尾部，原组头节点（翻转后成为尾节点）连接下一组</li></ul><p><strong>关键：断链，断链操作使翻转逻辑更简单</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713231240813-2025-7-1323:12:41.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;
    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;

    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();
    dummy.next = head;
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy; <span class="hljs-comment">// 上一组的尾节点</span>
    <span class="hljs-keyword">while</span>(pre.next != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-comment">// 1. 检查剩余节点是否足够k个</span>
        <span class="hljs-type">ListNode</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> pre;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;
            end = end.next;
            <span class="hljs-keyword">if</span> (end == <span class="hljs-literal">null</span>) 
                <span class="hljs-keyword">return</span> dummy.next; 
        &#125;

        <span class="hljs-comment">//2.记录关键节点</span>
        <span class="hljs-type">ListNode</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> pre.next; <span class="hljs-comment">// 当前组头节点</span>
        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newGroup</span> <span class="hljs-operator">=</span> end.next; <span class="hljs-comment">//下一组头结点</span>
        end.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">//断开当前组与下一组的连接</span>

        <span class="hljs-comment">//3.翻转后重新连接</span>
        pre.next = reverseList(start); <span class="hljs-comment">//翻转后连接到前一组尾部</span>
        start.next = newGroup; <span class="hljs-comment">//当前组尾部连接到下一组头部</span>

        pre = start; <span class="hljs-comment">//移动指针到下一组</span>
    &#125;
    <span class="hljs-keyword">return</span> dummy.next;
&#125;

<span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, cur = head;
    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    &#125;
    <span class="hljs-keyword">return</span> pre;
&#125;</code></pre></div><h2 id="合并两个有序链表"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">合并两个有序链表</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250702100216382-2025-7-1400:01:58.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：从两个链表头部开始各自向后遍历，每次找出两者中的最小值，插入到新链表的尾部，并将该链表 的遍历指针向后移动。若有一个遍历完毕，则将另一个剩余部分拼接到新链表尾部即可。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;

        <span class="hljs-type">ListNode</span> <span class="hljs-variable">headNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();
        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> headNode; 
        <span class="hljs-keyword">while</span>(list1 != <span class="hljs-literal">null</span> &amp;&amp; list2 != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">if</span> (list1.val &lt; list2.val) &#123;
                p.next = list1;
                list1 = list1.next;
            &#125; <span class="hljs-keyword">else</span> &#123;
                p.next = list2;
                list2 = list2.next;
            &#125;
            p = p.next;
        &#125;
        <span class="hljs-comment">//if (list1 == null)</span>
        <span class="hljs-comment">//    list1 = list2;</span>
        <span class="hljs-comment">//p.next = list1;</span>
		p.next = list1 != <span class="hljs-literal">null</span> ? list1:list2;
        <span class="hljs-keyword">return</span> headNode.next;
    &#125;
&#125;</code></pre></div><h2 id="合并-k-个有序链表"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">合并 K 个有序链表</a></h2><p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>思路：<strong>利用分治的思想，将 K 个链表的合并问题分解为多个两两合并的子问题，通过递归实现自底向上的归并排序。</strong>参考归并排序，将给定的升序链表看做一个个数组元素，对这个数组进行排序，只不过最终归并两个数组元素时，使用的是合并两个两个升序链表的方法。（归并排序过程的某个切片就是将k个有序子数组合并成一个）</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713235559285-2025-7-1323:56:00.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:67%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;
    <span class="hljs-keyword">if</span> (lists.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (lists.length == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>];

    <span class="hljs-comment">//归并排序</span>
    <span class="hljs-keyword">return</span> mergeKLists(lists,<span class="hljs-number">0</span>, lists.length - <span class="hljs-number">1</span>);

&#125;

<span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists,<span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;
    <span class="hljs-comment">//low &lt; high，说明需要继续拆分：</span>
    <span class="hljs-keyword">if</span> (low &lt; high) &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (low + high) / <span class="hljs-number">2</span>;
        <span class="hljs-type">ListNode</span> <span class="hljs-variable">list1</span> <span class="hljs-operator">=</span>  mergeKLists(lists, low , mid);
        <span class="hljs-type">ListNode</span> <span class="hljs-variable">list2</span> <span class="hljs-operator">=</span>  mergeKLists(lists, mid + <span class="hljs-number">1</span>, high);
        <span class="hljs-keyword">return</span> merge2Lists(list1, list2);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">return</span> lists[low]; <span class="hljs-comment">//low和high指向同一个，返回即可</span>
    &#125;
&#125;

<span class="hljs-comment">//合并两个有序链表</span>
<span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge2Lists</span><span class="hljs-params">(ListNode head1, ListNode head2)</span> &#123;
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head1, q = head2, tail = dummy;
    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; q != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">if</span> (p.val &lt; q.val) &#123;
            tail.next = p;
            p = p.next;
        &#125; <span class="hljs-keyword">else</span> &#123;
            tail.next = q;
            q = q.next;
        &#125;
        tail = tail.next;
    &#125;

    tail.next = p != <span class="hljs-literal">null</span> ? p : q;
    <span class="hljs-keyword">return</span> dummy.next;
&#125;</code></pre></div><h2 id="排序链表"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/7WHec2/">排序链表</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713160412088-2025-7-1316:04:14.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：</p><ul><li><p>采用插入排序对链表进行排序，每次选择未排序部分的第一个结点，在已排序部分寻找插入位置并插入，直至处理完所有未排序结点。时间复杂度<span class="math inline">\(O(n^2)\)</span>，会超时</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;
    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">return</span> head;
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">headNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(); <span class="hljs-comment">//虚拟头结点</span>
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> head.next;
    <span class="hljs-comment">//先将第一个结点放入已排序部分，从第二个结点开始取</span>
    headNode.next = head;
    headNode.next.next = <span class="hljs-literal">null</span>;

    ListNode nextNode, pre, cur;
    <span class="hljs-keyword">while</span> (ptr != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-comment">//保存下一个待排序结点</span>
        nextNode = ptr.next;
        pre = headNode;
        cur = pre.next;
        <span class="hljs-comment">//在已排序部分寻找插入位置</span>
        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span> &amp;&amp; cur.val &lt; ptr.val) &#123;
            pre = cur;
            cur = cur.next;
        &#125;
        <span class="hljs-comment">//插入</span>
        ptr.next = pre.next;
        pre.next = ptr;
        ptr = nextNode;
    &#125;
    <span class="hljs-keyword">return</span> headNode.next;
&#125;</code></pre></div></li><li><p>思路二：采用自顶向下的归并排序，时间复杂度O(n<span class="math inline">\(log_2^n\)</span>)，空间复杂度为<span class="math inline">\(O(log_2^n)\)</span></p><p>归并三部曲：分割、各自递归排序、最后合并</p><ol type="1"><li>找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针。</li><li>对两个子链表分别排序。</li><li>将两个排序后的子链表合并，得到完整的排序后的链表。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;
    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">return</span> head;
    <span class="hljs-comment">//从中间切分链表</span>
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> division(head);
    <span class="hljs-comment">//对前后两条链表分别进行排序</span>
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">firstList</span> <span class="hljs-operator">=</span> sortList(head);
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">secondList</span> <span class="hljs-operator">=</span> sortList(newHead);
    <span class="hljs-comment">//合并</span>
    <span class="hljs-keyword">return</span> merge(firstList, secondList);
&#125;

<span class="hljs-comment">//分割链表</span>
<span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">division</span><span class="hljs-params">(ListNode head)</span> &#123;
    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) 
        <span class="hljs-keyword">return</span> head;

    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;
    <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>) &#123;
        slow = slow.next;
        fast = fast.next.next;
    &#125;
    <span class="hljs-comment">//此时slow指向前一个链表尾部，将其从slow处分成两个链表，并返回后一链表的第一个结点</span>
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> slow.next;
    slow.next = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> newHead;
&#125;

<span class="hljs-comment">//合并两个有序链表</span>
<span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode head1, ListNode head2)</span> &#123;
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">headNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(); <span class="hljs-comment">//虚拟头结点</span>
    <span class="hljs-comment">//p,q用于遍历，tail执行新链表的尾结点</span>
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head1, q= head2, tail = headNode;
    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; q != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">if</span> (p.val &lt;= q.val) &#123;
            tail.next = p;
            p = p.next;
        &#125; <span class="hljs-keyword">else</span> &#123;
            tail.next = q;
            q = q.next;
        &#125;
        tail = tail.next;
    &#125;
    <span class="hljs-comment">// if (q != null) </span>
    <span class="hljs-comment">//     p = q;</span>
    <span class="hljs-comment">// tail.next = p;</span>
    tail.next = (p != <span class="hljs-literal">null</span> ? p : q);
    <span class="hljs-keyword">return</span> headNode.next;
&#125;</code></pre></div></li></ul><h2 id="相交链表"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">相交链表</a></h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250702102216000-2025-7-210:22:34.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><p>思路：</p><ul><li><p>若给定的两个链表中有一个为空，则不可能相交。</p></li><li><p>首先分别遍历两个链表，记录它们的长度以及最后一个结点。若两者的最后一个结点不一致，则不可能相交。</p></li><li><p>之后，将两者<strong>对齐</strong>后同时向后移动。即让更长的链表先移动长度之差个单位后，同时向后移动。若两者相交，则会指向同一个结点，此时返回该结点。若不相交，则两者都会遍历到null。</p></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;
        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> headA, q = headB;
        <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        
        <span class="hljs-type">int</span> <span class="hljs-variable">lenA</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, lenB = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (p.next != <span class="hljs-literal">null</span>) &#123;
            lenA++;
            p = p.next;
        &#125;
        <span class="hljs-keyword">while</span> (q.next != <span class="hljs-literal">null</span>) &#123;
            lenB++;
            q = q.next;
        &#125;
        <span class="hljs-comment">// 两链表的最后一个结点不同，必定不相交</span>
        <span class="hljs-keyword">if</span> (p != q) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

        <span class="hljs-comment">//对齐</span>
        <span class="hljs-keyword">if</span> (lenA &gt; lenB) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lenA - lenB; i++) 
                headA = headA.next;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lenB - lenA; i++) 
                headB = headB.next;
        &#125;

        <span class="hljs-comment">//一起向后移动</span>
        <span class="hljs-keyword">while</span> (headA != headB) &#123;
            headA = headA.next;
            headB = headB.next;
        &#125;

        <span class="hljs-keyword">return</span> headA == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span>:headA;

    &#125;
&#125;</code></pre></div><hr><p>进阶：给定两个<strong>可能有环也可能无环</strong>的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null</p><p>【要求】如果两个链表长度之和为N，时间复杂度请达到O（N），额外空间复杂度 请达到0（1）。</p><p>思路：</p><ol type="1"><li><p>首先判断两链表是否有环，有环则返回入环的第一个节点，无环则返回 null。</p></li><li><p>对于各自返回的两个节点 n1 和 n2。</p><ol type="1"><li><p>若n1和n2都为空，则两链表无环。此时分别遍历两链表，记录两链表的长度差值和各自的最后一个结点。若各自的最后一个结点不同，则两链表不相交；若相同则两链表相交，此时让长链表先移动差值步，之后两者一起移动，当第一次相等时，所指结点为第一个相交结点。</p></li><li><p>若n1和n2都不为空，则两链表均有环。此时只有三种种情况</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240418110156214-2024-8-410:42:44.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><p>若n1和n2相同，则两链表相交，此时找第一个相交结点即可，和环无关，转换为两无环链表第一个相交结点的问题，即case3</p><p>若n1和n2不同，则从n1出发，遍历一遍环，若能在其过程中找到n2则为case2,两链表相交，此时n1和n2均可为第一个相交结点；若没找到n2则为case1，不相交</p></li><li><p>n1和n2有一个为空另一个不为空。<strong>有环和无环的链表不可能相交。</strong>若相交则共用这个环，另一个不可能为无环</p></li></ol></li></ol><h2 id="环形链表i"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">环形链表I</a></h2><p>判断链表是否存在环。如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250702110950398-2025-7-211:09:52.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：</p><ul><li><p>使用<strong>HashSet或HashMap</strong>来保存已遍历过的结点（节点地址，而非值），每遍历一个结点，就查set或map看是否已经保存过。若没有查到，则将其存入；若查到则表示有环，且第一个查到的是第一个入环节点。若遍历到null则说明无环</p></li><li><p>使用<strong>快慢指针</strong>，快指针每次向后跳两个节点，慢指针每次向后跳一个结点。若链表有环，则当快慢指针进入环后，肯定会再次相遇，此时判断出链表有环；若快指针移动到null说明没有环。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Definition for singly-linked list.</span>
<span class="hljs-comment"> * class ListNode &#123;</span>
<span class="hljs-comment"> *     int val;</span>
<span class="hljs-comment"> *     ListNode next;</span>
<span class="hljs-comment"> *     ListNode(int x) &#123;</span>
<span class="hljs-comment"> *         val = x;</span>
<span class="hljs-comment"> *         next = null;</span>
<span class="hljs-comment"> *     &#125;</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;
        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-comment">//使用快慢指针，慢指针每次走一步，快指针每次走两步</span>
        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast  = head;
        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;
            slow = slow.next;
            fast = fast.next.next;
            <span class="hljs-keyword">if</span> (slow == fast) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//fast为null，链表中无环</span>
    &#125;
&#125;</code></pre></div></li></ul><h2 id="环形链表-ii"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">环形链表 II</a></h2><p>链表存在环时，求第一个入环结点</p><p>思路：在使用快慢指针判断有环的基础上，快慢指针在环内相遇，此时，将快指针移到头部且每次只走一步，快慢指针同时出发，当两者再次相遇时共同指向的结点即为入环的第一个结点</p><p>细节：一开始让slow指针先走一步，fast指针先走两步 ，以便能进入下面的while循环，当再次相等时退出</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;
        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        <span class="hljs-comment">//快慢指针分别先走一步</span>
        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head.next;
        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next.next;

        <span class="hljs-keyword">while</span> (slow != fast) &#123;
            <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) 
                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//无环</span>
            slow = slow.next;
            fast = fast.next.next;
        &#125;
        
        fast = head;
        <span class="hljs-keyword">while</span> (fast != slow) &#123;
            fast = fast.next;
            slow = slow.next;
        &#125;
        <span class="hljs-keyword">return</span> slow;
    &#125;
&#125;</code></pre></div><h2 id="链表的中间结点"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/middle-of-the-linked-list/">链表的中间结点</a></h2><p>思路：使用快慢指针，慢指针一次走一步，快指针一次走两步，快指针到达链表尾部时，慢指针到达链表中部。当要删除中间结点时，让fast多走一步后slow再开始移动，最终slow会指向中间结点的前一个结点，方便删除。</p><p>补充：对于返回结点的不同，其slow和fast初始位置有所不同：</p><ul><li>输入链表头节点，奇数长度返回中点，偶数长度返回上中点</li><li>输入链表头节点，奇数长度返回中点，偶数长度返回下中点</li><li>输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个</li><li>输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</li></ul><p>思路：</p><ol type="1"><li>首先判断链表中，没有结点、有一个结点、有两个结点时，该返回什么</li><li>其次，画出最终返回时两指针的位置，再往前反推slow和fast该如何设置初始值才能满足条件</li><li>最后，最终结点都是由slow返回。由于fast每次走两步，while的终止条件都为：fast.next != null &amp;&amp; fast.next.next != null</li></ol><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713105318434-2025-7-1310:53:19.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1、输入链表头节点，奇数长度返回中点，偶数长度返回上中点</span>
<span class="hljs-keyword">if</span> ( head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span> || head.next.next == <span class="hljs-literal">null</span>)
    <span class="hljs-keyword">return</span> head;
slow = head;
fast = head;
<span class="hljs-keyword">while</span> (fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>) &#123;
      slow = slow.next;
      fast = fast.next.next;
&#125;
<span class="hljs-keyword">return</span> slow;

<span class="hljs-comment">//2、输入链表头节点，奇数长度返回中点，偶数长度返回下中点</span>
<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)
    <span class="hljs-keyword">return</span> head;
<span class="hljs-keyword">if</span> (head.next.next == <span class="hljs-literal">null</span>) 
    <span class="hljs-keyword">return</span> head.next;
<span class="hljs-comment">//相当于第一种方式中slow和fast最终位置都后移一位</span>
<span class="hljs-comment">//偶数：slow指向了下中点</span>
<span class="hljs-comment">//奇数：slow还是指向中点，只不过fast指向了null，终止条件不同</span>
slow = head.next;
fast = head.next;
....
    
    
    
    
    
<span class="hljs-comment">//3、输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个</span>
<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span> || head.next.next == <span class="hljs-literal">null</span>) 
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
slow = head;
fast = head.next.next;
...

<span class="hljs-comment">//4、输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个(上中点)</span>
<span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
<span class="hljs-keyword">if</span> (head.next.next == <span class="hljs-literal">null</span>)
    <span class="hljs-keyword">return</span> head;
slow = head;
fast = head.next;
...</code></pre></div><h2 id="回文链表"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">回文链表</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713110215937-2025-7-1311:02:26.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：</p><ul><li><p>1、由于回文是正序和逆序相同，故可以使用栈，先将所有元素入栈，再边遍历链表边出栈，判断所有元素是否相同即可</p></li><li><p>2、基于1的方法，先使用快满指针找到链表中点，将中点以后的元素都入栈，再从链表头开始和出栈的元素比较是否相等，当栈为空时仍相同则为回文，否则不为（空间复杂度降一半）</p></li><li><p>3、（不使用辅助栈）还是利用快慢指针找到链表中点（或上中点），将其next设为null，且将后半部分链表<strong>逆序</strong>。之后从两边向中间一次判断结点是否相同，若直到一个指针为空仍相同，则为回文，否则不是。</p></li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240417181004501-2024-8-410:42:33.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Definition for singly-linked list.</span>
<span class="hljs-comment"> * public class ListNode &#123;</span>
<span class="hljs-comment"> *     int val;</span>
<span class="hljs-comment"> *     ListNode next;</span>
<span class="hljs-comment"> *     ListNode() &#123;&#125;</span>
<span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span>
<span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span>
<span class="hljs-comment"> * &#125;</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;
        <span class="hljs-comment">//1、找到链表的中点</span>
        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span> )
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;
        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>) &#123;
            slow = slow.next;
            fast = fast.next.next;
        &#125;

        <span class="hljs-comment">//2、逆置后半段</span>
        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, cur = slow, next;
        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        &#125;

        <span class="hljs-comment">//3、从两端向中间逐个对比</span>
        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head, q = pre;
        cur = pre; <span class="hljs-comment">//保存后半段链表的头结点，用于后面恢复链表</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//由于后续还要恢复链表，先将结果保存不返回</span>
        <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> &amp;&amp; q != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-keyword">if</span> (p.val != q.val) &#123;
                result = <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">break</span>;
            &#125;    
            p = p.next;
            q = q.next;
        &#125;
        

        <span class="hljs-comment">//4、恢复链表</span>
        pre = <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
        &#125;
		
        <span class="hljs-keyword">return</span> result;
    &#125;
&#125;</code></pre></div><h2 id="复杂链表的复制"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复杂链表的复制</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713113830648-2025-7-1311:38:31.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：<strong>关键是保存原结点和新结点的映射关系</strong></p><ol type="1"><li><p>使用HashMap保存原结点和新结点的映射关系，一开始遍历原链表，将原结点作为map的key，新结点作为map的value保存起来。再次遍历原链表，根据原链表的next和random指针，连接新结点的各指针域。</p><div class="code-wrapper"><pre><code class="hljs java">      <span class="hljs-comment">//1、使用HashMap保存新旧结点</span>
....sssss
      <span class="hljs-comment">//2、连接新结点的指针域</span>
ptr = head;
      <span class="hljs-keyword">while</span> (ptr != <span class="hljs-literal">null</span>) &#123;
          <span class="hljs-comment">//连接新结点的next指针域</span>
          nodeMap.get(ptr).next = nodeMap.get(ptr.next); 
        <span class="hljs-comment">//连接新结点的random指针域</span>
          nodeMap.get(ptr).random = nodeMap.get(ptr.random);
        ptr = ptr.next;
      &#125;</code></pre></div></li><li><p>使用next指针域来保存新结点和原结点的映射关系。<strong>将新创建的结点插入到原结点之后，便可以通过访问原结点的next指针域轻松找到新结点</strong>（与HashMap的功能相同）。在连接好新结点的各指针域后，需将新链表和原链表拆分开，此时只涉及next指针域方向的拆分。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713153028805-2025-7-1315:30:41.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span>
<span class="hljs-comment">// Definition for a Node.</span>
<span class="hljs-comment">class Node &#123;</span>
<span class="hljs-comment">    int val;</span>
<span class="hljs-comment">    Node next;</span>
<span class="hljs-comment">    Node random;</span>
<span class="hljs-comment"></span>
<span class="hljs-comment">    public Node(int val) &#123;</span>
<span class="hljs-comment">        this.val = val;</span>
<span class="hljs-comment">        this.next = null;</span>
<span class="hljs-comment">        this.random = null;</span>
<span class="hljs-comment">    &#125;</span>
<span class="hljs-comment">&#125;</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(Node head)</span> &#123;
        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>)
            <span class="hljs-keyword">return</span> head;

        <span class="hljs-comment">//1、创建新节点，作为当前结点的后继</span>
        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;
        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(cur.val);
            node.next = cur.next;
            cur.next = node;
            cur = node.next;
        &#125;

        <span class="hljs-comment">//2、连接新链表中结点的random指针域</span>
        <span class="hljs-comment">//不能同时修改next指针域，可能会导致random设置出错</span>
        cur = head;
        Node newNode;
        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;
            newNode = cur.next;
            newNode.random = cur.random == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : cur.random.next;
            cur = newNode.next;
        &#125;

        <span class="hljs-comment">//3、分离链表，连接新链表的next指针域，同时恢复旧链表结构</span>
        cur = head;
        <span class="hljs-type">Node</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> cur.next; 
        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;
            newNode = cur.next;
            cur.next = newNode.next; <span class="hljs-comment">//恢复旧结点的next</span>
            newNode.next = newNode.next == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : newNode.next.next;<span class="hljs-comment">//连接新结点的next</span>
            cur = cur.next;
        &#125;
        <span class="hljs-keyword">return</span> newHead;
    &#125;
&#125;</code></pre></div></li></ol><h2 id="重排链表"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-list/">重排链表</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250713172907881-2025-7-1317:29:12.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：首先使用快满指针找到链表的中点，将其分成前后两个链表。再将后一个链表逆置。最后将前半段链表与逆置后的后半链表<strong>合并</strong>，其中时间复杂度0(n)，空间复杂度O(1)。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reorderList</span><span class="hljs-params">(ListNode head)</span> &#123;
    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">//分割链表，返回后半链表头结点</span>
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> division(head);

    <span class="hljs-comment">//后半链表逆置</span>
    newHead = reverse(newHead);

    <span class="hljs-comment">//两链表合并</span>
    merge(head, newHead);
&#125;

<span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">division</span><span class="hljs-params">(ListNode head)</span> &#123;
    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) 
        <span class="hljs-keyword">return</span> head;

    <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head, fast = head;
    <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-literal">null</span> &amp;&amp; fast.next.next != <span class="hljs-literal">null</span>) &#123;
        slow = slow.next;
        fast = fast.next.next;
    &#125;
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> slow.next;
    slow.next = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> newHead;
&#125;

<span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;
    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>)  <span class="hljs-keyword">return</span> head;
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, cur = head, nextNode;
    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;
        nextNode = cur.next;
        cur.next = pre;
        pre = cur;
        cur = nextNode;
    &#125;
    <span class="hljs-keyword">return</span> pre;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode head1, ListNode head2)</span> &#123;
    <span class="hljs-comment">//按照之前的分割方法，后半链表长度 &lt;= 前半链表长度</span>
    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head1, q = head2, next1, next2;
    <span class="hljs-keyword">while</span>(q != <span class="hljs-literal">null</span>) &#123;
        next1 = p.next;
        next2 = q.next;

        q.next = p.next;
        p.next = q;
        p = next1;
        q = next2;
    &#125;
&#125;</code></pre></div><h2 id="两两交换链表中的节点"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">两两交换链表中的节点</a></h2><h2 id="lru-缓存"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">LRU 缓存</a></h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/" class="category-chain-item">算法学习</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>二、链表</div><div>https://catpaws.top/9d1ae18b/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年7月1日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/f5f9fa9b/" title="Docker"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Docker</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/c82a5987/" title="一、数组"><span class="hidden-mobile">一、数组</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://catpaws.top/blog-resource/twikoo1.6.42/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本站由<img src="/img/upyun_logo.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="width:auto;height:auto">提供CDN加速/云存储服务</a></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备2025059828号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61032302000087" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="police-icon"> <span>陕公网安备61032302000087号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//catpaws.top/blog-resource/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="//catpaws.top/blog-resource/js/loader.js"></script><script src="//catpaws.top/blog-resource/js/blurpicload.js"></script><script src="//catpaws.top/blog-resource/js/axios.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://catpaws.top/blog-resource/live2d/index.min.js"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"https://catpaws.top/blog-resource/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"}}})</script></body></html>