<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkai/dist/LXGWWenKai-Regular/result.css"><link rel="apple-touch-icon" sizes="76x76" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><link rel="icon" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="一、初识MQ 在微服务项目中，服务一旦拆分，必然涉及到服务之间的相互调用。 可以采用SpringCloud中的OpenFeign进行调用或者通过Dubbo做RPC调用。这种调用中，调用者发起请求后需要等待服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此称这种调用方式为同步调用，也可以叫同步通讯。但在很多场景下，可能需要采用异步通讯的方式。"><meta property="og:type" content="article"><meta property="og:title" content="RabbitMQ"><meta property="og:url" content="https://catpaws.top/b543ced0/index.html"><meta property="og:site_name" content="猫爪在上の书桌"><meta property="og:description" content="一、初识MQ 在微服务项目中，服务一旦拆分，必然涉及到服务之间的相互调用。 可以采用SpringCloud中的OpenFeign进行调用或者通过Dubbo做RPC调用。这种调用中，调用者发起请求后需要等待服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此称这种调用方式为同步调用，也可以叫同步通讯。但在很多场景下，可能需要采用异步通讯的方式。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211094833670-2025-2-1110:40:16.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211095334972-2025-2-1109:53:36.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211095944590-2025-2-1109:59:45.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100207999-2025-2-1110:02:09.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100551228-2025-2-1110:05:52.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100738170-2025-2-1110:07:39.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100924951-2025-2-1110:09:26.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211101237979-2025-2-1110:12:39.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211101950426-2025-2-1110:19:51.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016154419172-2025-10-1615:44:20.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016154712721-2025-10-1615:47:13.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016154925405-2025-10-1615:49:45.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016155213456-2025-10-1615:52:45.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016155301978-2025-10-1615:53:45.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016155637591-2025-10-1615:56:45.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016155818359-2025-10-1615:58:45.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016160039458-2025-10-1616:00:45.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016160252564-2025-10-1616:03:20.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016160952842-2025-10-1616:10:10.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016161526519-2025-10-1616:15:45.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016161602998-2025-10-1616:16:26.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016161930902-2025-10-1616:19:31.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016162241816-2025-10-1616:22:42.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016162359797-2025-10-1616:24:00.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016170206246-2025-10-1617:02:20.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211124025590-2025-2-1112:40:44.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016184957383-2025-10-1618:50:06.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211124655817-2025-2-1112:46:56.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016194509163-2025-10-1619:45:12.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016201519284-2025-10-1620:15:20.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016201819022-2025-10-1620:18:19.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016202340366-2025-10-1620:23:42.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016205848508-2025-10-1620:58:49.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016210146674-2025-10-1621:01:47.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016210411912-2025-10-1621:04:12.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016211541696-2025-10-1621:15:44.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016212350063-2025-10-1621:23:51.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016213048082-2025-10-1621:30:49.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251016213235482-2025-10-1621:32:36.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251017113358350-2025-10-1711:34:10.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251017115356565-2025-10-1711:54:03.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251017143755607-2025-10-1714:37:58.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251017151909260-2025-10-1715:19:12.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251017163430344-2025-10-1716:34:31.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251017163813744-2025-10-1716:38:14.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251017191758774-2025-10-1719:18:23.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251017192536076-2025-10-1719:25:36.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251017194311877-2025-10-1719:43:14.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251017194541718-2025-10-1719:45:42.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251017210757951-2025-10-1721:07:59.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251017210928768-2025-10-1721:09:29.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20251017211830041-2025-10-1721:18:32.png"><meta property="article:published_time" content="2025-06-16T06:40:33.000Z"><meta property="article:modified_time" content="2025-10-17T13:32:33.992Z"><meta property="article:author" content="猫爪在上"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250211094833670-2025-2-1110:40:16.png"><title>RabbitMQ - 猫爪在上の书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/font.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/poem.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/cursor.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/loader.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/twikoo_beautify.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/indeximg-hover.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/wave-1.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/blurpicload.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/reward/iconfont.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/switch.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"https://catpaws.top/blog-resource/imgs/transparent.svg",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://leancloud.catpaws.top",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loader-container"><div class="loader"><div class="wrapper"><div class="catContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 733 673" class="catbody"><path fill="#212121" d="M111.002 139.5C270.502 -24.5001 471.503 2.4997 621.002 139.5C770.501 276.5 768.504 627.5 621.002 649.5C473.5 671.5 246 687.5 111.002 649.5C-23.9964 611.5 -48.4982 303.5 111.002 139.5Z"></path><path fill="#212121" d="M184 9L270.603 159H97.3975L184 9Z"></path><path fill="#212121" d="M541 0L627.603 150H454.397L541 0Z"></path></svg> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 158 564" class="tail"><path fill="#191919" d="M5.97602 76.066C-11.1099 41.6747 12.9018 0 51.3036 0V0C71.5336 0 89.8636 12.2558 97.2565 31.0866C173.697 225.792 180.478 345.852 97.0691 536.666C89.7636 553.378 73.0672 564 54.8273 564V564C16.9427 564 -5.4224 521.149 13.0712 488.085C90.2225 350.15 87.9612 241.089 5.97602 76.066Z"></path></svg><div class="text"><span class="bigzzz">Z</span> <span class="zzz">Z</span></div></div><div class="wallContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 500 126" class="wall"><line stroke-width="6" stroke="#7C7C7C" y2="3" x2="450" y1="3" x1="50"></line><line stroke-width="6" stroke="#7C7C7C" y2="85" x2="400" y1="85" x1="100"></line><line stroke-width="6" stroke="#7C7C7C" y2="122" x2="375" y1="122" x1="125"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="500" y1="43"></line><line stroke-width="6" stroke="#7C7C7C" y2="1.99391" x2="115.5" y1="43.0061" x1="115.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00002" x2="189" y1="43.0122" x1="189"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00612" x2="262.5" y1="43.0183" x1="262.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01222" x2="336" y1="43.0244" x1="336"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01833" x2="409.5" y1="43.0305" x1="409.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="153" y1="84.0122" x1="153"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="228" y1="84.0122" x1="228"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="303" y1="84.0122" x1="303"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="378" y1="84.0122" x1="378"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="192" y1="125.012" x1="192"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="267" y1="125.012" x1="267"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="342" y1="125.012" x1="342"></line></svg></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上の书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>个人主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://catpaws.top/blog-resource/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="RabbitMQ"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-06-16 14:40" pubdate>2025年6月16日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 12k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 102 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">RabbitMQ</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年10月17日 晚上</p><div class="markdown-body"><meta name="referrer" , content="no-referrer"><h2 id="一初识mq">一、初识MQ</h2><p>在微服务项目中，服务一旦拆分，必然涉及到服务之间的相互调用。</p><p>可以采用SpringCloud中的OpenFeign进行调用或者通过Dubbo做RPC调用。这种调用中，调用者发起请求后需要<strong>等待</strong>服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此称这种调用方式为<strong>同步调用</strong>，也可以叫<strong>同步通讯</strong>。但在很多场景下，可能需要采用<strong>异步通讯</strong>的方式。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211094833670-2025-2-1110:40:16.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><ul><li>同步通讯：就如同打视频电话，双方的交互都是实时的。因此同一时刻你只能跟一个人打视频电话。</li><li>异步通讯：就如同发微信聊天，双方的交互不是实时的，你不需要立刻给对方回应。因此你可以多线操作，同时跟多人聊天。</li></ul><p>两种方式各有优劣，打电话可以立即得到响应，但是你却不能跟多个人同时通话。发微信可以同时与多个人收发微信，但是往往响应会有延迟。</p><p>如果我们的业务需要实时得到服务提供方的响应，则应该选择同步通讯（同步调用）。而如果我们追求更高的效率，并且不需要实时响应，则应该选择异步通讯（异步调用）。</p><h3 id="同步调用">1.1 同步调用</h3><p>假设目前服务间的调用都是基于OpenFeign的同步调用，以<strong>余额支付功能</strong>为例来分析，整个服务的流程如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211095334972-2025-2-1109:53:36.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><ul><li>支付服务需要先调用用户服务完成余额扣减</li><li>然后支付服务自己要更新支付流水单的状态</li><li>然后支付服务调用交易服务，更新业务订单状态为已支付</li></ul><p>三个步骤依次执行，其中就存在3个问题：</p><ol type="1"><li><p>拓展性差</p><p>目前的业务相对简单，但是随着业务规模扩大，产品的功能也在不断完善。如果之后添加需求：</p><ul><li><p>用户支付成功后以短信或者其它方式通知用户，告知支付成功。</p></li><li><p>增加积分或金币的概念，用户支付成功后，给用户以积分奖励或者返还金币</p></li><li><p>.....</p></li></ul><p>如果按照以上的服务调用方法，每次有新的需求，现有支付逻辑都要跟着变化，代码经常变动。最终支付业务会越来越臃肿：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211095944590-2025-2-1109:59:45.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></li><li><p>性能下降</p><p>由于采用了同步调用，调用者需要等待服务提供者执行完返回结果后，才能继续向下执行，也就是说每次远程调用，调用者都是阻塞等待状态。最终整个业务的响应时长就是每次远程调用的执行时长之和：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100207999-2025-2-1110:02:09.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></li><li><p><strong>级联失败</strong></p><p>由于是基于OpenFeign调用交易服务、通知服务。耦合性太高，一个服务失败会影响其他服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。这就是同步调用的<strong>级联失败</strong>问题。</p></li></ol><p>而要解决这些问题，我们就必须用<strong>异步调用</strong>的方式来代替<strong>同步调用</strong>。</p><h3 id="异步调用">1.2 异步调用</h3><p>异步调用方式其实就是基于<strong>消息通知</strong>的方式，一般包含三个角色：</p><ul><li>消息发送者：投递消息的人，就是原来的调用方</li><li>消息代理：管理、暂存、转发消息，可以把它理解成微信服务器</li><li>消息接收者：接收和处理消息的人，就是原来的服务提供方</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100551228-2025-2-1110:05:52.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息代理。然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。</p><p>这样，发送消息的人和接收消息的人就完全解耦了。</p><p>还是以余额支付业务为例：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100738170-2025-2-1110:07:39.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>除了扣减余额、更新支付流水单状态以外，其它调用逻辑全部取消。而是改为发送一条消息到Broker。而相关的微服务都可以订阅消息通知，一旦消息到达Broker，则会分发给每一个订阅了的微服务，处理各自的业务。</p><p>假如后序增加了新的需求，比如要在支付成功后更新用户积分。支付代码完全不用变更，而仅仅是让积分服务也订阅消息即可：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211100924951-2025-2-1110:09:26.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>不管后期增加了多少消息订阅者，作为支付服务来讲，执行问扣减余额、更新支付流水状态后，发送消息即可。业务耗时仅仅是这三部分业务耗时，仅仅100ms，大大提高了业务性能。</p><p>另外，不管是交易服务、通知服务，还是积分服务，他们的业务与支付关联度低。现在采用了异步调用，解除了耦合，他们即便执行过程中出现了故障，也不会影响到支付服务。</p><p>综上，异步调用的优势包括：</p><ul><li>耦合度更低</li><li>性能更好</li><li>业务拓展性强</li><li>故障隔离，避免级联失败</li></ul><p>当然，异步通信也并非完美无缺，它存在下列缺点：</p><ul><li>完全依赖于Broker的可靠性、安全性和性能</li><li>架构复杂，后期维护和调试麻烦</li></ul><h3 id="技术选型">1.3 技术选型</h3><p>消息Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为MQ.</p><p>目比较常见的MQ实现：</p><ul><li>ActiveMQ</li><li>RabbitMQ</li><li>RocketMQ</li><li>Kafka</li></ul><p>几种MQ的对比：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211101237979-2025-2-1110:12:39.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><p>目前国内消息队列使用最多的还是RabbitMQ，再加上其各方面都比较均衡，稳定性也好，因此选择RabbitMQ来学习。</p><h2 id="二rabbitmq">二、RabbitMQ</h2><p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件，<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">官网地址</a></p><p>RabbitMQ的架构如图：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211101950426-2025-2-1110:19:51.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>其中包含几个概念：</p><ul><li><strong><code>publisher</code></strong>：生产者，也就是发送消息的一方</li><li><strong><code>consumer</code></strong>：消费者，也就是消费消息的一方</li><li><strong><code>queue</code></strong>：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li><strong><code>exchange</code></strong>：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。</li><li><strong><code>virtual host</code></strong>：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue</li></ul><h3 id="安装">2.1 安装</h3><p>创建<code>docker-compose.yml</code>，在yml文件所在目录，使用<code>docker compose up -d</code>上线RabbitMQ 容器。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span>

<span class="hljs-attr">services:</span>
  <span class="hljs-attr">mq:</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">rabbitmq:3.8-management</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mq</span>
    <span class="hljs-attr">hostname:</span> <span class="hljs-string">mq</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">RABBITMQ_DEFAULT_USER=admin</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">RABBITMQ_DEFAULT_PASS=123321</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;15672:15672&quot;</span>  <span class="hljs-comment"># RabbitMQ 管理界面端口</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5672:5672&quot;</span>    <span class="hljs-comment"># AMQP 协议端口</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">mq-plugins:/plugins</span>
    <span class="hljs-attr">networks:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">hm-net</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span>

<span class="hljs-attr">volumes:</span>
  <span class="hljs-attr">mq-plugins:</span>

<span class="hljs-attr">networks:</span>
  <span class="hljs-attr">hm-net:</span></code></pre></div><p>安装完成后，我们访问 <code>http://服务器ip:15672</code> 即可看到管理控制台。首次访问需要登录，默认的用户名和密码在配置文件中已经指定了。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016154419172-2025-10-1615:44:20.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h3 id="使用控制台测试收发消息">2.2 使用控制台测试收发消息</h3><h4 id="交换机">交换机</h4><p>打开Exchanges选项卡，可以看到已经存在很多交换机：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016154712721-2025-10-1615:47:13.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>点击任意交换机，利用控制台中的publish message 发送一条消息：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016154925405-2025-10-1615:49:45.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>这里是由控制台模拟了生产者发送的消息。由于没有消费者存在，最终消息丢失了，这样说明交换机没有存储消息的能力。</p><h4 id="队列">队列</h4><p>打开<code>Queues</code>选项卡，新建一个队列，命名为<code>hello.queue1</code>：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016155213456-2025-10-1615:52:45.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>再以相同的方式，创建一个队列，密码为<code>hello.queue2</code>，最终队列列表如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016155301978-2025-10-1615:53:45.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>此时，再次向<code>amq.fanout</code>交换机发送一条消息。会发现消息依然没有到达队列！！</p><p>怎么回事呢？</p><p>发送到交换机的消息，只会路由到与其绑定的队列，因此仅仅创建队列是不够的，我们还需要将其与交换机绑定。</p><h4 id="绑定关系">绑定关系</h4><p>在<code>amq.fanout</code>交换机详情页的<code>Bindings</code>菜单中，填写要绑定的队列名称：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016155637591-2025-10-1615:56:45.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>相同的方式，将hello.queue2也绑定到改交换机。最终，绑定结果如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016155818359-2025-10-1615:58:45.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="发送消息">发送消息</h4><p>回到exchange页面，找到刚刚绑定的<code>amq.fanout</code>，再次发送一条消息后，查看两个队列，可以看到已经有一条消息了。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016160039458-2025-10-1616:00:45.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>查看<code>hello.queueq</code>，点击get message，可以看到消息到达队列了：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016160252564-2025-10-1616:03:20.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>这个时候如果有消费者监听了MQ的<code>hello.queue1</code>或<code>hello.queue2</code>队列，自然就能接收到消息了。</p><h3 id="数据隔离">2.3 数据隔离</h3><p>点击<code>Admin</code>选项卡，会看到RabbitMQ控制台的用户管理界面，这里的用户都是RabbitMQ的管理或运维人员。目前只有安装RabbitMQ时添加的<code>admin</code>这个用户。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016160952842-2025-10-1616:10:10.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>用户表格中的字段，如下：</p><ul><li><code>Name</code>：<code>admin</code>，也就是用户名</li><li><code>Tags</code>：<code>administrator</code>，说明<code>admin</code>用户是超级管理员，拥有所有权限</li><li><code>Can access virtual host</code>： 可以访问的<code>virtual host</code>，<code>/</code>是默认的<code>virtual host</code></li></ul><p>当只搭建一套MQ集群，供多个不同项目同时使用时，为了避免互相干扰， 可以利用<code>virtual host</code>的隔离特性，将不同项目隔离。一般会做两件事情：</p><ul><li>给每个项目创建独立的运维账号，将管理权限分离。</li><li>给每个项目创建不同的<code>virtual host</code>，将每个项目的数据隔离。</li></ul><hr><p>为当前项目创建一个新的用户，命名为 catpaws</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016161526519-2025-10-1616:15:45.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>此时的用户没有任何 virtual host 的访问权限</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016161602998-2025-10-1616:16:26.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><hr><p>切换到刚刚创建的catpaws用户，为当前项目创建一个单独的<code>virtual host</code></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016161930902-2025-10-1616:19:31.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>由于我们是登录<code>catpaws</code>账户后创建的<code>virtual host</code>，因此回到<code>users</code>菜单，你会发现当前用户已经具备了对<code>/cat-project</code>这个<code>virtual host</code>的访问权限了：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016162241816-2025-10-1616:22:42.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>通过右上角的<code>virtual host</code>下拉菜单，切换<code>virtual host</code>为 <code>/cat-project</code>，然后再次查看queues选项卡，会发现之前的队列已经看不到了，这就是基于<code>virtual host</code>的隔离效果。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016162359797-2025-10-1616:24:00.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h2 id="三springamqp">三、SpringAMQP</h2><p>真正开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。</p><p>由于<code>RabbitMQ</code>采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与<code>RabbitMQ</code>交互，并且官方也提供了各种不同语言的客户端。</p><p>RabbitMQ官方提供的Java客户端编码相对复杂，一般生产环境下我们更多会结合Spring来使用。Spring基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP，还基于SpringBoot实现了自动装配，使用起来非常方便。</p><p>SpringAMQP的<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-amqp/">官方地址</a></p><p>SpringAMQP提供了三个功能：</p><ul><li>自动声明队列、交换机及其绑定关系</li><li>基于注解的监听器模式，异步接收消息</li><li>封装了RabbitTemplate工具，用于发送消息</li></ul><h3 id="快速入门">3.1 快速入门</h3><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016165332818-2025-10-1616:53:34.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="项目结构"><figcaption aria-hidden="true">项目结构</figcaption></figure><p>创建springboot项目，包括三部分：</p><ul><li>RabbitMQ-demo：父工程，管理项目依赖</li><li>publisher：消息的发送者</li><li>consumer：消息的消费者</li></ul><p>在父工程中已经添加了SpringAMQP的相关依赖，子工程中就可以直接使用了。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><hr><p>在入门案例中，为了测试方便，直接向队列发送消息，跳过交换机。</p><ul><li>publisher直接发送消息到队列</li><li>消费者监听并处理队列中的消息</li></ul><blockquote><p><strong>注意</strong>：这种模式一般测试使用，很少在生产中使用。</p></blockquote><p>为了方便测试，先在控制台新建一个队列：simple.queue。接下来，就可以利用Java代码收发消息了。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016170206246-2025-10-1617:02:20.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="消息发送">消息发送</h4><p>首先在<code>publisher</code>服务的<code>application.yml</code>中添加MQ相关配置：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.181</span><span class="hljs-number">.100</span> <span class="hljs-comment"># 你的虚拟机IP</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span>
    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/cat-project</span> <span class="hljs-comment"># 虚拟主机</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">catpaws</span> <span class="hljs-comment"># 用户名</span>
    <span class="hljs-attr">password:</span> <span class="hljs-number">123321</span> <span class="hljs-comment"># 密码</span></code></pre></div><p>在<code>publisher</code>服务中编写测试类<code>SpringAmqpTest</code>，利用<code>RabbitTemplate</code>实现消息发送：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAmqpTest</span> &#123;
    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessage</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-comment">//1.队列名</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.queue&quot;</span>;
        <span class="hljs-comment">//2.消息</span>
		<span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>
        <span class="hljs-comment">//3.发送</span>
        rabbitTemplate.convertAndSend(queueName,itemDoc);
    &#125;
&#125;</code></pre></div><p>打开控制台，可以看到消息已经发送到队列中：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211124025590-2025-2-1112:40:44.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="消息接收">消息接收</h4><p>首先在<code>consumer</code>服务的<code>application.yml</code>中添加MQ相关配置：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.181</span><span class="hljs-number">.100</span> <span class="hljs-comment"># 你的虚拟机IP</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span> <span class="hljs-comment"># 端口</span>
    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/cat-project</span> <span class="hljs-comment"># 虚拟主机</span>
    <span class="hljs-attr">username:</span> <span class="hljs-string">catpaws</span> <span class="hljs-comment"># 用户名</span>
    <span class="hljs-attr">password:</span> <span class="hljs-number">123321</span> <span class="hljs-comment"># 密码</span></code></pre></div><p>在<code>consumer</code>服务的<code>listener</code>包中新建一个类<code>SpringRabbitListener</code>，代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;
    <span class="hljs-comment">// 监听已存在的队列</span>
    <span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueueMessage</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;
        System.out.println(<span class="hljs-string">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);
    &#125;
&#125;</code></pre></div><hr><p><code>@RabbitListener</code> 是 Spring AMQP 项目中用于声明消息驱动 POJO 的注解。它可以将一个方法标记为 RabbitMQ 的消息监听器。当有消息到达指定的队列时，该方法会被自动调用。</p><h4 id="测试">测试</h4><p>启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息。最终consumer收到消息：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016184957383-2025-10-1618:50:06.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h3 id="work-queue">3.2 Work Queue</h3><p>Work queues，任务模型。简单来说就是让<strong>多个消费者</strong>绑定到一个队列，共同消费队列中的消息。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250211124655817-2025-2-1112:46:56.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用WorkQueues模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p><p>Work Queue模型特点：</p><ul><li><p>多个消费者绑定到一个队列</p></li><li><p>同一条消息只会被一个消费者处理</p></li></ul><p>默认情况下，RabbitMQ的会将消息依次轮询投递给绑定在队列上的每一个消费者。简单地说，消息是平均分配给每个消费者，并没有考虑到消费者的处理能力，可能出现消息堆积。</p><p>可以通过在消费者配置文件中设置参数<code>preFetch</code>为1，确保同一时刻最多投递给消费者一条消息，处理完了才能获取下一个消息，从而实现“能者多劳”的效果。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">listener:</span>
      <span class="hljs-attr">simple:</span>
        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1</span> <span class="hljs-comment">#每次只能获取一条消息，处理完成才能获取下一个消息</span></code></pre></div><hr><p>首先在控制台创建一个队列<code>work.queue</code></p><p>在消费者服务中，创建两个消费者，监听来自<code>work.queue</code>的消息。为了区分两消费者的处理能力，分别让其休眠25ms和500ms。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;work.queue&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenWorkQueue1</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;
    System.out.println(<span class="hljs-string">&quot;消费者1....接收到消息：&quot;</span> + message +<span class="hljs-string">&quot;, &quot;</span>+ LocalTime.now());
    Thread.sleep(<span class="hljs-number">25</span>);
&#125;
<span class="hljs-meta">@RabbitListener(queues = &quot;work.queue&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenWorkQueue2</span><span class="hljs-params">(String message)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;
    System.err.println(<span class="hljs-string">&quot;消费者2....接收到消息：&quot;</span> + message +<span class="hljs-string">&quot;, &quot;</span>+ LocalTime.now());
    Thread.sleep(<span class="hljs-number">500</span>);
&#125;</code></pre></div><p>在消息提供者处，发送10条消息到<code>work.queue</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWorkQueue</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">//1.队列名</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;work.queue&quot;</span>;
    <span class="hljs-comment">//2.消息</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello，message_&quot;</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span> ; i++) &#123;
        <span class="hljs-comment">//3.发送</span>
        rabbitTemplate.convertAndSend(queueName,message + i);
    &#125;
&#125;</code></pre></div><p>暂不配置<code>preFetch</code>参数，RabbitMQ默认消息投递效果如下：10条消息平均分配给每个消费者，每条消息只会被一个消费者处理，不区分处理能力。</p><div class="code-wrapper"><pre><code class="hljs bash">消费者1....接收到消息：<span class="hljs-string">&quot;hello，message_1&quot;</span>, 19:21:12.570108500
消费者1....接收到消息：<span class="hljs-string">&quot;hello，message_3&quot;</span>, 19:21:12.571105800
消费者1....接收到消息：<span class="hljs-string">&quot;hello，message_5&quot;</span>, 19:21:12.571105800
消费者1....接收到消息：<span class="hljs-string">&quot;hello，message_7&quot;</span>, 19:21:12.571105800
消费者1....接收到消息：<span class="hljs-string">&quot;hello，message_9&quot;</span>, 19:21:12.572103200
消费者2....接收到消息：<span class="hljs-string">&quot;hello，message_2&quot;</span>, 19:21:12.570108500
消费者2....接收到消息：<span class="hljs-string">&quot;hello，message_4&quot;</span>, 19:21:12.571105800
消费者2....接收到消息：<span class="hljs-string">&quot;hello，message_6&quot;</span>, 19:21:12.571105800
消费者2....接收到消息：<span class="hljs-string">&quot;hello，message_8&quot;</span>, 19:21:12.572103200
消费者2....接收到消息：<span class="hljs-string">&quot;hello，message_10&quot;</span>, 19:21:12.572103200</code></pre></div><p>配置<code>preFetch</code>为1后，消费者根据自己的处理速度从队列中接收消息，消息分配结果如下：</p><div class="code-wrapper"><pre><code class="hljs bash">消费者2....接收到消息：<span class="hljs-string">&quot;hello，message_1&quot;</span>, 19:32:17.402016200
消费者2....接收到消息：<span class="hljs-string">&quot;hello，message_6&quot;</span>, 19:32:18.106082900
消费者2....接收到消息：<span class="hljs-string">&quot;hello，message_10&quot;</span>, 19:32:18.636266700
消费者1....接收到消息：<span class="hljs-string">&quot;hello，message_2&quot;</span>, 19:32:17.402016200
消费者1....接收到消息：<span class="hljs-string">&quot;hello，message_3&quot;</span>, 19:32:17.697104500
消费者1....接收到消息：<span class="hljs-string">&quot;hello，message_4&quot;</span>, 19:32:17.751538
消费者1....接收到消息：<span class="hljs-string">&quot;hello，message_5&quot;</span>, 19:32:18.106082900
消费者1....接收到消息：<span class="hljs-string">&quot;hello，message_7&quot;</span>, 19:32:18.297221400
消费者1....接收到消息：<span class="hljs-string">&quot;hello，message_8&quot;</span>, 19:32:18.536224100
消费者1....接收到消息：<span class="hljs-string">&quot;hello，message_9&quot;</span>, 19:32:18.611123200</code></pre></div><h3 id="exchange">3.3 Exchange</h3><p>RabbitMQ中的交换机（Exchange）是消息路由的核心组件。生产者将消息发送到交换机，交换机根据类型和绑定规则将消息路由到一个或多个队列。交换机的类型决定了路由的行为。</p><p>RabbitMQ中常见的交换机类型：</p><ol type="1"><li><p><strong>扇形交换机（Fanout Exchange）</strong>：将消息路由到所有绑定到该交换机的队列，忽略路由键。它适用于<strong>广播</strong>消息。</p></li><li><p><strong>直连交换机（Direct Exchange）</strong>：根据消息的<strong>路由键</strong>（routing key）精确匹配队列。</p><ul><li><p>每一个Queue都与Exchange设置一个binding key(绑定键)</p></li><li><p>发布者发送消息时，指定消息的routing key</p></li><li><p>Exchange将消息路由到binding key与消息routing key一致的队列</p></li></ul></li><li><p><strong>主题交换机（Topic Exchange）</strong>：根据消息的路由键和绑定键的模式匹配进行路由。</p><p>绑定键通常是多个单词的组合，并且以<code>.</code>分割。</p><p>绑定键可以包含通配符：<code>*</code>（匹配一个单词）和<code>#</code>（匹配零个或多个单词）。</p></li><li><p><strong>头交换机（Headers Exchange）</strong>：不依赖路由键，而是根据消息的头信息（headers）进行匹配。绑定队列时可以指定一组头信息的匹配条件（全部匹配或部分匹配）。</p></li></ol><div class="note note-warning"><p>Exchange只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p></div><p>之前的两个例子中都没有使用交换机而是直接发送消息到队列，现在采用交换机后，消息发送的模式会有很大变化：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016194509163-2025-10-1619:45:12.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><ul><li><p>生产者，不再发送消息到队列中，而是发给交换机。</p></li><li><p>交换机一方面，接收生产者发送的消息。另一方面根据交换机的类型，将消息路由到与其绑定的队列。</p></li><li><p>消息队列需要与交换机绑定</p></li><li><p>消费者没有变化</p></li></ul><h4 id="扇形交换机">扇形交换机</h4><p>fanout交换机会将消息路由到所有绑定到该交换机的队列。</p><p>应用场景：以之前的支付业务为例，当支付成功后，需要将支付信息广播到多个服务进行处理，此时就可以使用fanout交换机。</p><p>在控制台创建一个<code>fanout</code>类型的交换机 <code>catpaws.fanout</code>，再创建两个队列<code>fanout.queue1</code>和<code>fanout.queue2</code>，最后手动在交换机中绑定两个队列。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016201519284-2025-10-1620:15:20.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>在消费者服务中添加两个消费者，分别监听这两个队列</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;fanout.queue1&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenFanoutQueue1</span><span class="hljs-params">(String message)</span>&#123;
    System.out.println(<span class="hljs-string">&quot;消费者1....接收到消息：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);
&#125;

<span class="hljs-meta">@RabbitListener(queues = &quot;fanout.queue2&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenFanoutQueue2</span><span class="hljs-params">(String message)</span>&#123;
    System.out.println(<span class="hljs-string">&quot;消费者2....接收到消息：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);
&#125;</code></pre></div><p>消息提供者将消息发送到<code>fanout</code>交换机</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFanoutQueue</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">//1.交换机名</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;catpaws.fanout&quot;</span>;
    <span class="hljs-comment">//2.消息</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello,everyone&quot;</span>;
    <span class="hljs-comment">//3.发送，三个参数：交换机名称，路由键routingKey，消息</span>
    rabbitTemplate.convertAndSend(exchangeName,<span class="hljs-literal">null</span>,message);
&#125;</code></pre></div><p>结果：两个消费者都收到了广播消息</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016201819022-2025-10-1620:18:19.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="直连交换机">直连交换机</h4><p>Direct交换机根据消息的<strong>路由键</strong>精确匹配队列，因此称为定向路由。</p><ul><li><p>每一个Queue都与Exchange设置一个binding key(绑定键)</p></li><li><p>发布者发送消息时，指定消息的routing key</p></li><li><p>Exchange将消息路由到binding key与消息routing key一致的队列</p></li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016202340366-2025-10-1620:23:42.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>当每个队列绑定的路由键都相同时，就可以实现与fanout交换机相同的广播效果。</p><p>应用场景：以之前的支付业务为例。当支付成功后，需要将支付信息广播到交易服务、通知服务、积分服务等进行异步处理。但是当用户取消支付时，只需要将消息发送到通知服务，通知用户支付取消即可，不用发送消息到交易服务和积分服务，此时就可以使用Direct交换机实现。</p><hr><ul><li><p>在控制台创建一个<code>direct</code>类型的交换机 <code>catpaws.direct</code></p></li><li><p>再创建两个队列<code>direct.queue1</code>和<code>direct.queue2</code></p></li><li><p>绑定队列到交换机，<code>queue1</code>的路由键为 success和failure，<code>queue2</code>的路由键为 success</p></li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016205848508-2025-10-1620:58:49.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>在消费者服务中创建两个个消费者，代表通知服务、交易服务</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue1</span><span class="hljs-params">(String message)</span>&#123;
    System.out.println(<span class="hljs-string">&quot;通知服务....接收到消息：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);
&#125;

<span class="hljs-meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue2</span><span class="hljs-params">(String message)</span>&#123;
    System.out.println(<span class="hljs-string">&quot;交易服务....接收到消息：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);
&#125;</code></pre></div><p>将支付信息发送到Direct交换机</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDirectQueue</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">//1.交换机名</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;catpaws.direct&quot;</span>;
    <span class="hljs-comment">//2.消息</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;支付成功&quot;</span>;
    <span class="hljs-comment">//3.发送到&quot;catpaws.direct&quot;交换机中binding key为 “success”的队列</span>
    rabbitTemplate.convertAndSend(exchangeName,<span class="hljs-string">&quot;success&quot;</span>,message);
&#125;</code></pre></div><p>支付成功，支付信息广播到两个服务中</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016210146674-2025-10-1621:01:47.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDirectQueue</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">//1.交换机名</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;catpaws.direct&quot;</span>;
    <span class="hljs-comment">//2.消息</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;支付取消&quot;</span>;
    <span class="hljs-comment">//3.发送到&quot;catpaws.direct&quot;交换机中binding key为 “failure”的队列</span>
    rabbitTemplate.convertAndSend(exchangeName,<span class="hljs-string">&quot;failure&quot;</span>,message);
&#125;</code></pre></div><p>支付失败，只有通知服务接收到消息</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016210411912-2025-10-1621:04:12.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="主题交换机">主题交换机</h4><p>Topic交换机根据消息的路由键和绑定键的模式匹配进行路由。</p><p>Topic交换机与Direct交换机相比：<code>BindingKey</code>一般都是由一个或多个单词组成，多个单词之间以.分割，例如：item.insert。并且<code>BindingKey</code>中可以使用通配符：</p><ul><li><code>*</code>：匹配一个单词</li><li><code>#</code>：匹配一个或多个单词</li></ul><p>举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.spu.insert</code>或者<code>item.spu</code></li><li><code>item.*</code>：只能匹配 <code>item.spu</code></li></ul><hr><p>假如此时publisher发送的消息使用的RoutingKey共有四种：</p><ul><li><code>china.news</code> 代表有中国的新闻消息；</li><li><code>china.weather</code>代表中国的天气消息；</li><li><code>japan.news</code> 代表日本新闻</li><li><code>japan.weather</code>代表日本的天气消息；</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016211541696-2025-10-1621:15:44.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><ul><li><code>topic.queue1</code>：绑定的是<code>china.#</code>，凡是以china.开头的routing key都会被匹配到。包括：<ul><li><code>china.news</code></li><li><code>china.weather</code></li></ul></li><li><code>topic.queue2</code>：绑定的是<code>#.news</code>，凡是以.news结尾的routing key都会被匹配。包括：<ul><li><code>china.news</code></li><li><code>japan.news</code></li></ul></li></ul><p>在控制台创建Topic类的交换机和队列</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016212350063-2025-10-1621:23:51.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>在消费者服务中编写两个消费者，分别监听两个队列</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;topic.queue1&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenTopicQueue1</span><span class="hljs-params">(String message)</span>&#123;
    System.out.println(<span class="hljs-string">&quot;消费者1....接收到消息：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);
&#125;

<span class="hljs-meta">@RabbitListener(queues = &quot;topic.queue2&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenTopicQueue2</span><span class="hljs-params">(String message)</span>&#123;
    System.out.println(<span class="hljs-string">&quot;消费者2....接收到消息：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);
&#125;</code></pre></div><p>在消息发布者中向Topic交换机发布消息</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTopicQueue</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">//1.交换机名</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;catpaws.topic&quot;</span>;
    <span class="hljs-comment">//2.消息</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;日本战败矣！！！&quot;</span>;
    <span class="hljs-comment">//3.发送</span>
    rabbitTemplate.convertAndSend(exchangeName,<span class="hljs-string">&quot;china.news&quot;</span>,message);
&#125;</code></pre></div><p>routing key是<code>china.news</code>，两个队列都会收到消息</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016213048082-2025-10-1621:30:49.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTopicQueue</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">//1.交换机名</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;catpaws.topic&quot;</span>;
    <span class="hljs-comment">//2.消息</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;蓝色：暴雨预警&quot;</span>;
    <span class="hljs-comment">//3.发送</span>
    rabbitTemplate.convertAndSend(exchangeName,<span class="hljs-string">&quot;china.weather&quot;</span>,message);
&#125;</code></pre></div><p>routing key是<code>china.weather</code>，只有队列1会收到消息</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251016213235482-2025-10-1621:32:36.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h3 id="声明队列交换机">3.4 声明队列交换机</h3><p>之前例子中的队列和交换机都是在控制台手动创建和绑定的，开发过程中用代码声明用的比较多。</p><p>Spring AMQP提供了几个类，用来声明队列、交换机及其绑定关系：</p><ul><li>Queue：用于声明队列，可以用工厂类QueueBuilder构建</li><li>Exchange（接口）：用于声明交换机，可以用工厂类ExchangeBuilder构建</li><li>Binding：用于声明队列和交换机的绑定关系，可以用工厂类BindingBuilder构建</li></ul><div class="note note-summary"><p>声明队列和交换机一般在消费者方进行。</p></div><h4 id="基于bean声明队列交换机">基于Bean声明队列交换机</h4><p>在consumer中创建一个配置类，声明队列和交换机。程序启动时会检查队列和交换机是否存在，如果不存在自动创建</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.amqp.core.*;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutConfig</span> &#123;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 声明交换机</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> Fanout交换机</span>
<span class="hljs-comment">     */</span>

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> FanoutExchange <span class="hljs-title function_">fanoutExchange</span><span class="hljs-params">()</span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanoutExchange</span>(<span class="hljs-string">&quot;catpaws.fanout&quot;</span>);
        <span class="hljs-comment">//或者通过工厂方法创建</span>
        <span class="hljs-comment">//return ExchangeBuilder.fanoutExchange(&quot;catpaws.fanout&quot;).build();</span>
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 创建队列</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 队列</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">fanoutQueue1</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.queue1&quot;</span>);
        <span class="hljs-comment">//或者通过工厂方法创建</span>
        <span class="hljs-comment">//return QueueBuilder.durable(&quot;fanout.queue1&quot;).build();</span>
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 绑定队列和交换机</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">bindingQueue1</span><span class="hljs-params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;
        <span class="hljs-comment">//绑定 队列 到 交换机</span>
        <span class="hljs-keyword">return</span>  BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">fanoutQueue2</span><span class="hljs-params">()</span>&#123;
        <span class="hljs-keyword">return</span> QueueBuilder.durable(<span class="hljs-string">&quot;fanout.queue2&quot;</span>).build();
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">bindingQueue2</span><span class="hljs-params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;
        <span class="hljs-keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);
    &#125;
&#125;</code></pre></div><h4 id="基于注解声明队列交换机">基于注解声明队列交换机</h4><p>可以通过<code>@RabbitListener</code>注解的<code>bindings</code>属性来声明交换机和队列，以及它们之间的绑定关系，同时为该队列绑定消息监听器。</p><p><code>bindings</code>的值是<code>@QueueBinding</code>注解: 表示将队列和交换机进行绑定，它有三个重要的属性：</p><ul><li>value: 定义队列，使用@Queue注解<ul><li><code>name</code>/<code>value</code>属性：队列名称</li><li><code>durable</code>属性：是否持久化，设置为"true"表示队列在RabbitMQ服务器重启后仍然存在。</li></ul></li><li>exchange: 定义交换机，使用@Exchange注解。<ul><li><code>name</code>/<code>value</code>属性：交换机名称</li><li><code>type</code>属性：交换机的类型，默认为<code>Direct</code>类型，可通过<code>ExchangeTypes</code>指定</li><li><code>durable</code>属性默认为true</li></ul></li><li>key: 定义路由键<ul><li>可以是一个数组，绑定多个key</li><li>对于Topic交换机，可以使用通配符</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span>
<span class="hljs-meta">    value = @Queue(name = &quot;direct.queue1&quot;, durable = &quot;true&quot;),</span>
<span class="hljs-meta">    exchange = @Exchange(name = &quot;catpaws.direct&quot;, type = ExchangeTypes.DIRECT, durable = &quot;true&quot;),</span>
<span class="hljs-meta">    key = &#123;&quot;success&quot;,&quot;failure&quot;&#125;</span>
<span class="hljs-meta">))</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDirectQueue1</span><span class="hljs-params">(String message)</span>&#123;
    System.out.println(<span class="hljs-string">&quot;通知服务....接收到消息：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);
&#125;</code></pre></div><p>当消费者启动时，Spring AMQP会检查RabbitMQ中是否存在指定的队列和交换机。如果不存在，则会根据这些注解的定义自动创建它们，并将队列按照指定的路由键绑定到交换机上。</p><p>这样，当生产者发送一条路由键为"success"的消息到"catpaws.direct"交换机时，该消息会被路由到"direct.queue1"队列，然后被这个监听器处理。</p><h3 id="消息转换器">3.5 消息转换器</h3><p>在使用<code>rabbitTemplate</code>的<code>convertAndSend</code>方法发送消息时，消息体是一个Object。在数据传输时，它会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251017113358350-2025-10-1711:34:10.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>Spring的对消息对象的处理默认是由SimpleMessageConverter完成，它基于JDK的ObjectOutputStream完成序列化。JDK序列化存在下列问题：</p><ul><li>JDK的序列化有安全风险</li><li>JDK序列化的消息太大</li><li>JDK序列化的消息可读性差</li></ul><p>建议采用JSON序列化代替默认的JDK序列化，要做两件事情：</p><ul><li><p>在<code>publisher</code>和<code>consumer</code>中都引入jackson依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>在publisher和consumer中都要配置MessageConverter</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
<span class="hljs-keyword">import</span> org.springframework.amqp.support.converter.MessageConverter;

<span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageConvertConfig</span> &#123;
	
    <span class="hljs-comment">//配置jackson消息转换器</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">messageConverter</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();
    &#125;
&#125;</code></pre></div></li></ul><hr><p>在消息消费者处创建listener，同时创建队列和交换机并绑定。listener的消息参数类型与发送方发送时的消息类型一致即可。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener( bindings = @QueueBinding(</span>
<span class="hljs-meta">    value = @Queue(value = &quot;object.queue&quot;),</span>
<span class="hljs-meta">    exchange = @Exchange(value = &quot;catpaws.object&quot;),</span>
<span class="hljs-meta">    key = &quot;object&quot;</span>
<span class="hljs-meta">))</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenObjectQueue</span><span class="hljs-params">(Map&lt;String,Object&gt; message)</span>&#123;
    System.out.println(<span class="hljs-string">&quot;消费者....接收到消息：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);
&#125;</code></pre></div><p>在消息发布者处向交换机发送消息：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testObjectQueue</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">//1.交换机名</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;catpaws.object&quot;</span>;
    <span class="hljs-comment">//2.消息</span>
    Map&lt;String,Object&gt;message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">2</span>);
    message.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;Jack&quot;</span>);
    message.put(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">20</span>);
    <span class="hljs-comment">//3.发送</span>
    rabbitTemplate.convertAndSend(exchangeName,<span class="hljs-string">&quot;object&quot;</span>,message);
&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251017115356565-2025-10-1711:54:03.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h2 id="四消息可靠性">四、消息可靠性</h2><p>一条消息要经历的过程：消息发送者将消息发送到MQ，MQ存储消息等待被消费，最终消费者处理消息。</p><p>这三个阶段都可能出现消息丢失的问题：</p><ul><li>生产者发送消息时，可能因为网络问题、RabbitMQ节点故障、交换机不存在等原因导致消息发送失败。</li><li>RabbitMQ宕机导致内存中的消息丢失。</li><li>消费者在处理消息时，可能因为各种原因（如业务逻辑异常、消费者宕机）导致消息消费失败。</li></ul><p>以之前的支付业务为例，在支付成功后利用RabbitMQ通知交易服务，更新业务订单状态为已支付。若在此过程中MQ通知失败，支付服务中支付流水显示支付成功，而交易服务中的订单状态却显示未支付，数据出现了不一致。 <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251017143755607-2025-10-1714:37:58.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>因此，需要从消息发送、消息存储、消息消费三个方面确保MQ消息的可靠性，即：消息应该<strong>至少</strong>被消费者处理一次（可能出现消息重复投递的情况，需要做业务幂等处理）。</p><h3 id="发送者可靠性">4.1 发送者可靠性</h3><h4 id="生产者重试机制">生产者重试机制</h4><p>生产者发送消息时，可能出现了网络故障，导致与MQ的连接中断。通过配置我们可以开启连接失败后的重连机制：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">connection-timeout:</span> <span class="hljs-string">1s</span> <span class="hljs-comment">#设置MQ的连接超时时间</span>
    <span class="hljs-attr">template:</span>
      <span class="hljs-attr">retry:</span> 
        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启超时重试机制</span>
        <span class="hljs-attr">initial-interval:</span> <span class="hljs-string">1000ms</span> <span class="hljs-comment"># 失败后的初始等待时间</span>
        <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1</span>  <span class="hljs-comment"># 失败后下次的等待时⻓倍数，下次等待时⻓ = initial-interval * multiplier</span>
        <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span>  <span class="hljs-comment"># 最⼤重试次数</span></code></pre></div><p>需要注意，当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的重试机制是<strong>阻塞式</strong>的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。</p><p>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。</p><h4 id="生产者确认机制">生产者确认机制</h4><p>生产者确认机制：当生产者发送消息到 RabbitMQ 后，RabbitMQ 会返回一个确认信号，告知生产者消息是否已经成功处理。</p><p>RabbitMQ提供的生产者消息确认机制，包括：<code>Publisher Confirm</code>和<code>Publisher Return</code></p><ul><li><code>Publisher Confirm</code> 用于确认消息是否已经到达 RabbitMQ 代理（Broker）。它只关注消息是否被 Broker 接收，但并不关心消息是否被路由到队列。</li><li><code>Publisher Return</code>：当消息被 Broker 接收，但无法通过交换器路由到任何队列的情况下，RabbitMQ 会发送一个返回消息（Basic.Return）给生产者。</li></ul><p>在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的回执。返回的结果有以下几种情况：</p><ul><li>消息投递到了MQ，但是路由失败。此时会通过<code>Publisher Return</code>返回路由异常原因，然后返回<code>ACK</code>，告知投递<strong>成功</strong></li><li>临时消息投递到了MQ，并且入队成功，返回<code>ACK</code>，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回<code>ACK</code>，告知投递成功</li><li>其它情况都会返回<code>NACK</code>，告知投递失败</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251017151909260-2025-10-1715:19:12.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>默认两种机制都是关闭状态，需要通过配置⽂件来开启。</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">correlated</span> <span class="hljs-comment"># 开启publisher confirm机制，并设置confirm类型</span>
    <span class="hljs-attr">publisher-returns:</span>  <span class="hljs-literal">true</span> <span class="hljs-comment">#开启publish return机制</span></code></pre></div><p>这里的publisher-confirm-type有三种模式可选：</p><ul><li>none：关闭confirm机制</li><li>simple：同步阻塞等待MQ的回执消息</li><li>correlated：MQ异步回调方式返回回执消息（<strong>推荐</strong>）</li></ul><hr><p>在Spring AMQP中</p><ul><li>Publisher Confirm 机制通过<code>ConfirmCallback</code>接口实现。</li><li>Publisher Return 机制通过<code>ReturnsCallback</code>接口实现。</li></ul><p>每个 <code>RabbitTemplate</code> 实例只需要配置一个 <code>ReturnCallback</code>，这个回调会处理<strong>所有</strong>通过该 模板 发送且无法路由的消息。因此可以在配置类中统⼀设置。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-meta">@Slf4j</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MqConfig</span> &#123;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span>  RabbitTemplate rabbitTemplate;

    <span class="hljs-meta">@PostConstruct</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;
        rabbitTemplate.setReturnsCallback(returned -&gt; &#123;
            log.error(<span class="hljs-string">&quot;触发 return callback&quot;</span>);
            log.debug(<span class="hljs-string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());
            log.debug(<span class="hljs-string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());
            log.debug(<span class="hljs-string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());
            log.debug(<span class="hljs-string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());
            log.debug(<span class="hljs-string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());

            <span class="hljs-comment">//编写方法处理无法路由的消息</span>
        &#125;);
    &#125;
&#125;</code></pre></div><p>由于每个消息发送时的处理逻辑不一定相同，因此<code>ConfirmCallback</code>需要在每次发消息时定义。具体来说，是在调用<code>RabbitTemplate</code>中的<code>convertAndSend</code>方法时，多传递一个<code>CorrelationData</code>类型的参数：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251017163430344-2025-10-1716:34:31.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="消息返回机制">消息返回机制</h4><p>这里的CorrelationData中包含两个核心的东西：</p><ul><li><p><code>id</code>：消息的唯一标示，MQ对不同的消息的回执以此做判断，避免混淆</p></li><li><p><code>SettableListenableFuture</code>：回执结果的<code>Future</code>对象。将来MQ的回执就会通过这个<code>Future</code>来返回，我们可以提前给<code>CorrelationData</code>中的<code>Future</code>添加回调函数来处理消息回执：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251017163813744-2025-10-1716:38:14.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testConfirmCallback</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;
    <span class="hljs-comment">//1.创建CorrelationData</span>
    <span class="hljs-type">CorrelationData</span> <span class="hljs-variable">cd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());
    <span class="hljs-comment">//2.给Future添加ConfirmCallback</span>
    cd.getFuture().addCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable ex)</span> &#123;
            <span class="hljs-comment">//2.1 Future发生异常时的处理逻辑，基本不会触发。（不是消息的发送或处理异常）</span>
            log.error(<span class="hljs-string">&quot;spring ampq处理确认结果异常：&#123;&#125;&quot;</span>,ex);
        &#125;

        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(CorrelationData.Confirm result)</span> &#123;
            <span class="hljs-comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span>
           	<span class="hljs-comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span>
            <span class="hljs-keyword">if</span> (result.isAck()) &#123;
                log.debug(<span class="hljs-string">&quot;收到ConfirmCallback  ack,消息发送成功！&quot;</span>);
            &#125;<span class="hljs-keyword">else</span> &#123;
                log.error(<span class="hljs-string">&quot;收到ConfirmCallback  nack，消息发送失败！reason：&#123;&#125;&quot;</span>,result.getReason());
                <span class="hljs-comment">// TODO 消息重发</span>
            &#125;
        &#125;
    &#125;);
    <span class="hljs-comment">//3.发送消息</span>
    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;hmall.direct&quot;</span>,<span class="hljs-string">&quot;blue&quot;</span>,<span class="hljs-string">&quot;蓝色：猫爪在上&quot;</span>,cd);

    Thread.sleep(<span class="hljs-number">2000</span>);
&#125;</code></pre></div><h3 id="mq可靠性">4.2 MQ可靠性</h3><p>在默认情况下，RabbitMQ会将接收到的信息保存在<strong>内存</strong>中以降低消息收发的延迟。这样会导致两个问题：</p><ul><li>一旦MQ宕机，内存中的消息会丢失</li><li>内存空间有限，当消费者故障或处理过慢时，会导致消息积压，引发MQ阻塞</li></ul><h4 id="数据持久化">数据持久化</h4><p>RabbitMQ实现数据持久化包括3个方面：</p><ul><li>交换机持久化</li><li>队列持久化</li><li>消息持久化</li></ul><p>在Spring AMQP中，创建的交换机、队列以及发送的消息都是<strong>持久化</strong>的，无需额外处理。</p><p>相比于内存模式，采用持久化模式时当收到消息后会立即写入磁盘，不受内存压力影响，可以保证高吞吐量和稳定的性能，但是相比内存模式性能会有所下降。</p><h4 id="lazy-queue">Lazy Queue</h4><p>RabbitMQ的内存模式在收到大量消息出现阻塞时，会进行page out，将内存的中的一些消息写入磁盘，此时MQ处于阻塞状态，阻塞或限制消息接收。</p><p>为了解决这个问题，从RabbitMQ的3.6.0版本开始，就增加了<code>Lazy Queues</code>的模式，也就是<strong>惰性队列</strong>。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘，不再存储到内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（可以提前缓存部分消息到内存，最多2048条）</li></ul><p>而在3.12版本之后，LazyQueue已经成为所有队列的默认格式。因此官方推荐升级MQ为3.12版本或者所有队列都设置为LazyQueue模式。</p><p>手动开启LazyQueue模式：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//Bean方式声明队列</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">fanoutQueue</span><span class="hljs-params">()</span>&#123;
    <span class="hljs-keyword">return</span> QueueBuilder
        .durable(<span class="hljs-string">&quot;fanout.queue2&quot;</span>)
        .lazy()  <span class="hljs-comment">//开启lazy模式</span>
        .build();
&#125;

<span class="hljs-comment">//注解方式， 通过arguments参数开启lazy模式</span>
<span class="hljs-meta">@RabbitListener( bindings = @QueueBinding(</span>
<span class="hljs-meta">    value = @Queue(value = &quot;object.queue&quot;,</span>
<span class="hljs-meta">                   durable = &quot;true&quot;, </span>
<span class="hljs-meta">                   arguments = @Argument(name = &quot;x-queue-mod&quot;,value = &quot;lazy&quot;)), </span>
<span class="hljs-meta">    exchange = @Exchange(value = &quot;catpaws.object&quot;),</span>
<span class="hljs-meta">    key = &quot;object&quot;</span>
<span class="hljs-meta">))</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenObjectQueue</span><span class="hljs-params">(Map&lt;String,Object&gt; message)</span>&#123;
    System.out.println(<span class="hljs-string">&quot;消费者....接收到消息：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);
&#125;</code></pre></div><h3 id="消费者可靠性">4.3 消费者可靠性</h3><h4 id="消费者确认机制">消费者确认机制</h4><p>消费者确认机制（Consumer Acknowledgement）是为了确认消费者是否成功处理消息。当消费者处理消息结束后应该向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态：</p><ul><li><code>ack</code>：成功处理消息，RabbitMQ从队列中删除该消息</li><li><code>nack</code>：消息处理失败，RabbitMQ需要再次投递消息</li><li><code>reject</code>：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p>reject⽅式⽤的较少，一般用于消息格式或校验异常。因此⼤多数情况下我们需要将消息处理的代码通过<code>try catch</code>机制捕获，消息处理成功时返回<code>ack</code>，处理失败时返回<code>nack</code>.</p><hr><p>SpringAMQP帮我们实现了消息确认，并允许我们通过配置文件设置ACK处理方式。</p><p>有三种模式：</p><ul><li><code>none</code>：不处理。即消息投递给消费者后⽴刻<code>ack</code>，消息会⽴刻从MQ删除。⾮常不安全，不建议 使⽤</li><li><code>manual</code>：⼿动模式。需要⾃⼰在业务代码中调⽤api，发送 <code>ack</code>或 <code>reject</code>，存在业务⼊侵， 但更灵活</li><li><code>auto</code>：⾃动模式。Spring AMQP利⽤AOP对我们的消息处理逻辑做了<strong>环绕增强</strong>，当业务正常执⾏时则⾃动返回 <code>ack</code>。当业务出现异常时，根据异常判断返回不同结果：<ul><li>如果是业务异常，会⾃动返回 <code>nack</code>；</li><li>如果是消息处理或校验异常，⾃动返回 <code>reject</code>;</li></ul></li></ul><p>在<strong>消费者</strong>配置文件中设置ACK处理方式</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">listener:</span>
      <span class="hljs-attr">simple:</span>
        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1</span>
        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">auto</span>  <span class="hljs-comment">#设置ACK处理方式：none、manual、auto</span></code></pre></div><p>返回 <code>reject</code>的常见异常有：</p><ul><li><code>MessageConversionException</code></li><li><code>MethodArgumentNotValidException</code></li><li><code>MethodArgumentTypeMismatchException</code></li><li><code>NoSuchMethodException</code></li><li><code>ClassCastException</code></li></ul><h4 id="失败重试机制">失败重试机制</h4><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力。</p><p>为了应对上述情况Spring又提供了消费者失败<strong>重试机制</strong>：在消费者出现异常时利用本地重试，而不是无限制的requeue消息到mq队列。</p><p>重试机制默认关闭，需要在消费者的配置文件中开启：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">rabbitmq:</span>
    <span class="hljs-attr">listener:</span>
      <span class="hljs-attr">simple:</span>
        <span class="hljs-attr">prefetch:</span> <span class="hljs-number">1</span> 
        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">auto</span>
        <span class="hljs-attr">retry:</span>
          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 开启消费者失败重试</span>
          <span class="hljs-comment">#下面都是默认值</span>
          <span class="hljs-attr">initial-interval:</span> <span class="hljs-string">1000ms</span> <span class="hljs-comment"># 初识的失败等待时⻓为1秒</span>
          <span class="hljs-attr">multiplier:</span> <span class="hljs-number">1</span>   <span class="hljs-comment"># 失败的等待时⻓倍数，下次等待时⻓ = multiplier * last-interval</span>
          <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">3</span>  <span class="hljs-comment"># 最⼤重试次数</span>
          <span class="hljs-attr">stateless:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># true⽆状态；false有状态。如果业务中包含事务，这⾥改为false</span></code></pre></div><p>此时若消费者在处理消息时出现异常：</p><ul><li>失败后消息没有重新回到MQ⽆限重新投递，⽽是在本地重试了3次</li><li>本地重试3次以后，抛出了 <code>AmqpRejectAndDontRequeueException</code>异常。查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是 reject</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251017191758774-2025-10-1719:18:23.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>总结：</p><ul><li><p>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，⽽是在消费者本地重试</p></li><li><p>重试达到最⼤次数后，Spring会返回reject，消息会被丢弃</p></li></ul><p>这种默认的重试次数耗尽后的处理方式，在某些对于消息可靠性要求较⾼的业务场景下，显然不太合适了。</p><p>因此Spring允许我们⾃定义重试次数耗尽后的消息处理策略，这个策略是由 <code>MessageRecoverer</code> 接 ⼝来定义的，它有3个不同实现：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251017192536076-2025-10-1719:25:36.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接 <code>reject</code>，丢弃消息。默认就是这种方式</li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回 <code>nack</code>，消息重新⼊队</li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li></ul><p>此处采用第三种策略，将错误消息republish到一个专门的交换机<code>error.direct</code>，可以为该交换机添加消息监听器进行处理，如邮件通知开发人员介入等。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorMessageConfiguration</span> &#123;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 定义接收错误消息的交换机</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">errorExchange</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;error.direct&quot;</span>);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 定义接受错误消息的队列</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">errorQueue</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;error.queue&quot;</span>);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 绑定交换机与队列</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> errorQueue</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@param</span> errorExchange</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding</span><span class="hljs-params">(Queue errorQueue, DirectExchange errorExchange)</span> &#123;
        <span class="hljs-keyword">return</span> BindingBuilder.bind(errorQueue).to(errorExchange).with(<span class="hljs-string">&quot;error&quot;</span>);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 重试次数耗尽后的处理策略:RepublishMessageRecoverer</span>
<span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span>
<span class="hljs-comment">     */</span>
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> MessageRecoverer <span class="hljs-title function_">messageRecoverer</span><span class="hljs-params">(RabbitTemplate rabbitTemplate)</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RepublishMessageRecoverer</span>(rabbitTemplate,<span class="hljs-string">&quot;error.direct&quot;</span>,<span class="hljs-string">&quot;error&quot;</span>);
    &#125;
&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251017194311877-2025-10-1719:43:14.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="业务幂等性">业务幂等性</h4><p>幂等是一个数学概念，用函数表达式来描述是这样的：f(x)= f( f(x) )。在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251017194541718-2025-10-1719:45:42.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>然而在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：</p><ul><li>服务间调用的重试</li><li>页面卡顿时频繁刷新导致表单重复提交</li><li>MQ消息的重复投递</li></ul><p>例如，在之前的支付业务中，用户支付成功后会发送MQ消息到交易服务，修改订单状态为已支付，就可能出现消息重复投递的情况。如果消费者不做判断，很有可能导致消息被消费多次，出现业务故障。可能的场景如下：</p><p>【1】用户刚刚支付完成，并且投递消息到交易服务，交易服务更改订单为<strong>已支付</strong>状态。<br>【2】由于某种原因，例如网络故障导致生产者没有得到确认，隔了一段时间后重新投递给交易服务。<br>【3】但是，在新投递的消息被消费之前，用户选择了退款，将订单状态改为了<strong>已退款</strong>。<br>【4】退款完成后，新投递的消息才被消费，订单状态会被再次改为<strong>已支付</strong>，业务异常。<br></p><p>保证消息处理的幂等性的两种常见⽅案：</p><ul><li>唯一消息ID</li><li>业务状态判断</li></ul><hr><p>唯一消息ID的思路：</p><ul><li>每一条消息都生成一个唯一的id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ul><p>在<strong>消息发送者</strong>的消息转换器中可以为每条消息添加唯一ID。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageConvertConfig</span> &#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> MessageConverter <span class="hljs-title function_">messageConverter</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-comment">// 1.定义消息转换器</span>
        <span class="hljs-type">Jackson2JsonMessageConverter</span> <span class="hljs-variable">jjmc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonMessageConverter</span>();
        <span class="hljs-comment">// 2.配置⾃动创建消息id，⽤于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span>
        jjmc.setCreateMessageIds(<span class="hljs-literal">true</span>);
        <span class="hljs-keyword">return</span> jjmc;
    &#125;
&#125;</code></pre></div><p>为了获取消息ID，此时消息监听器的参数必须为<code>Message</code>类型</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueue</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> Exception &#123;
    System.out.println(<span class="hljs-string">&quot;消息ID: &quot;</span>+ message.getMessageProperties().getMessageId());
    System.out.println(<span class="hljs-string">&quot;消息内容：&quot;</span> + <span class="hljs-keyword">new</span>  <span class="hljs-title class_">String</span>(message.getBody()));
&#125;

<span class="hljs-comment">//输出</span>
消息ID: e00b0b09-0c74-4d82-b664-3112449f5065
消息内容：<span class="hljs-string">&quot;hello. spring AMQP&quot;</span></code></pre></div><p>这种方法需要做额外的数据库操作，对原有的业务造成了入侵，还会影响主业务的性能。</p><hr><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样。</p><p>例如，在支付业务案例中，处理消息的业务逻辑是把订单状态从未支付修改为已支付。因此我们就可以在执行业务时判断订单状态是否是未支付，如果不是则证明订单已经被处理过，无需重复处理。</p><h3 id="延迟消息">4.4 延迟消息</h3><p>在电商的支付业务中，对于一些库存有限的商品，为了更好的用户体验，通常都会在用户下单时立刻扣减商品库存。例如电影院购票、高铁购票，下单后就会锁定座位资源，其他人无法重复购买。</p><p>但是这样就存在一个问题，假如用户下单后一直不付款，就会一直占有库存资源，导致其他客户无法正常交易，最终导致商户利益受损！</p><p>因此，电商中通常的做法就是：<strong>对于超过一定时间未支付的订单，应该立刻取消订单并释放占用的库存。</strong>例如，订单支付超时时间为30分钟，则我们应该在用户下单后的第30分钟检查订单支付状态，如果发现未支付，应该立刻取消订单，释放库存。</p><p>但问题来了：如何才能准确的实现在下单后第30分钟去检查支付状态呢？</p><p>像这种在一段时间以后才执行的任务，我们称之为<strong>延迟任务</strong>，而要实现延迟任务，最简单的方案就是利用MQ的<strong>延迟消息</strong>了。</p><p>在RabbitMQ中实现延迟消息有两种方案：</p><ul><li>死信交换机+TTL</li><li>延迟消息插件</li></ul><h4 id="死信交换机">死信交换机</h4><p>什么是死信？</p><p>当一个队列中的消息满足下列情况之一时，可以成为<strong>死信</strong>（dead letter）：</p><ul><li>消费者使⽤ <code>basic.reject</code>或 <code>basic.nack</code> 声明消费失败，并且消息的 requeue 参数设置 为false</li><li>消息是⼀个过期消息，超时无人消费（TTL）</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果队列通过<code>dead-letter-exchange</code>属性指定了一个交换机，那么该队列中的死信就会投递到这个交换机中。这个交换机称为<strong>死信交换机</strong>（Dead Letter Exchange，简称DLX）。</p><p>如何通过死信交换机实现延时任务呢？</p><ol type="1"><li>为普通队列<code>normal.queue</code>绑定一个死信交换机<code>dlx.redict</code>，并且不为它指定消息监听器，消费者从<code>dlx.queue</code>中获取消息</li><li>发送者向<code>normal.direct</code>发送消息时，需要指定消息的过期时间（TTL）</li><li>由于<code>normal.queue</code>没有消费者，消息过期后会投递到死信交换机，消费者就能从<code>dlx.queue</code>中得到消息</li><li>总体效果就是：发送者发送了一条消息，消费者等待了TTL时间后获取到了消息</li></ol><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251017210757951-2025-10-1721:07:59.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><hr><p>定义普通交换机和队列</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalConfiguration</span> &#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">normalExchange</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;normal.direct&quot;</span>);
    &#125;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">normalQueue</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> QueueBuilder
                .durable(<span class="hljs-string">&quot;normal.durable&quot;</span>)
                .deadLetterExchange(<span class="hljs-string">&quot;dlx.direct&quot;</span>) <span class="hljs-comment">//指定死信交换机</span>
                .build();
    &#125;
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">binding</span><span class="hljs-params">(Queue normalQueue, DirectExchange normalExchange)</span> &#123;
        <span class="hljs-keyword">return</span> BindingBuilder.bind(normalQueue).to(normalExchange).with(<span class="hljs-string">&quot;normal&quot;</span>);
    &#125;
&#125;</code></pre></div><p>添加死信交换机和队列，并绑定消息监听器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RabbitListener( bindings = @QueueBinding(</span>
<span class="hljs-meta">    value = @Queue(value = &quot;dlx.queue&quot;),</span>
<span class="hljs-meta">    exchange = @Exchange(value = &quot;dlx.direct&quot;),</span>
<span class="hljs-meta">    key = &quot;normal&quot;  //两个交换机和队列的routingKey要保持一致</span>
<span class="hljs-meta">))</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenQueue</span><span class="hljs-params">(Map&lt;String,Object&gt; message)</span>&#123;
    System.out.println(<span class="hljs-string">&quot;消费者....接收到消息：【&quot;</span> + message + <span class="hljs-string">&quot;】&quot;</span>);
&#125;</code></pre></div><p>测试，向<code>normal.direct</code>交换机发送消息时可以添加一个参数：消息后置处理器，用于将发送内容转换为<code>Message</code>类型后做进一步处理，我们可以在其中为消息设置过期时间</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendLazyMessage</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">//1.交换机名</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;normal.direct&quot;</span>;
    <span class="hljs-comment">//2.消息</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello,everyone&quot;</span>;
    <span class="hljs-comment">//3.发送</span>
    rabbitTemplate.convertAndSend(
        exchangeName, 
        <span class="hljs-string">&quot;normal&quot;</span>, 
        message, 
        message1 -&gt; &#123;
            message1.getMessageProperties().setExpiration(<span class="hljs-string">&quot;10000&quot;</span>); <span class="hljs-comment">//设置过期时间，单位毫秒</span>
            <span class="hljs-keyword">return</span> message1;
        &#125;);
&#125;</code></pre></div><h4 id="延迟消息插件">延迟消息插件</h4><p>这个插件可以将普通交换机改造为支持延迟消息功能的交换机，当消息投递到交换机后可以暂存一定时间，到期后再投递到队列。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251017210928768-2025-10-1721:09:29.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><hr><ol type="1"><li><p>安装插件：<a target="_blank" rel="noopener" href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">github地址</a>，下载与自己RabbitMQ版本一致的插件</p></li><li><p>查看RabbitMQ 插件容器卷挂载目录，将插件上传到该目录</p><div class="code-wrapper"><pre><code class="hljs bash">
[root@iZ2vc38fe5o8go8jgtau7gZ ~]# docker volume <span class="hljs-built_in">ls</span>
DRIVER    VOLUME NAME
<span class="hljs-built_in">local</span>     dfe5641f594bab715f0b816faca53c4271d2d7fd906a6f72dd4526384ffe4db6
<span class="hljs-built_in">local</span>     ec6fd97257574649a4edb01c58e4a4145a22fe632550dd8770ee7273b327dd69
<span class="hljs-built_in">local</span>     rabbitmq_mq-plugins
[root@iZ2vc38fe5o8go8jgtau7gZ ~]# docker volume inspect rabbitmq_mq-plugins
[
    &#123;
        <span class="hljs-string">&quot;CreatedAt&quot;</span>: <span class="hljs-string">&quot;2025-10-16T15:35:59+08:00&quot;</span>,
        <span class="hljs-string">&quot;Driver&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,
        <span class="hljs-string">&quot;Labels&quot;</span>: &#123;
            <span class="hljs-string">&quot;com.docker.compose.project&quot;</span>: <span class="hljs-string">&quot;rabbitmq&quot;</span>,
            <span class="hljs-string">&quot;com.docker.compose.version&quot;</span>: <span class="hljs-string">&quot;2.27.0&quot;</span>,
            <span class="hljs-string">&quot;com.docker.compose.volume&quot;</span>: <span class="hljs-string">&quot;mq-plugins&quot;</span>
        &#125;,
        <span class="hljs-string">&quot;Mountpoint&quot;</span>: <span class="hljs-string">&quot;/var/lib/docker/volumes/rabbitmq_mq-plugins/_data&quot;</span>,
        <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;rabbitmq_mq-plugins&quot;</span>,
        <span class="hljs-string">&quot;Options&quot;</span>: null,
        <span class="hljs-string">&quot;Scope&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>
    &#125;
]
[root@iZ2vc38fe5o8go8jgtau7gZ ~]# <span class="hljs-built_in">cd</span> /var/lib/docker/volumes/rabbitmq_mq-plugins/_data</code></pre></div></li><li><p>启用该插件</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it mq rabbitmq-plugins <span class="hljs-built_in">enable</span> rabbitmq_delayed_message_exchange</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20251017211830041-2025-10-1721:18:32.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></li></ol><hr><p>声明具有延时效果的<strong>交换机</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//注解方式</span>
<span class="hljs-meta">@RabbitListener( bindings = @QueueBinding(</span>
<span class="hljs-meta">    value = @Queue(value = &quot;delay.queue&quot;),</span>
<span class="hljs-meta">    exchange = @Exchange(value = &quot;delay.direct&quot;, delayed = &quot;true&quot;), //设置delay属性为true</span>
<span class="hljs-meta">    key = &quot;delay&quot;</span>
<span class="hljs-meta">))</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDelayExchange</span><span class="hljs-params">(String message)</span>&#123;
    log.info(<span class="hljs-string">&quot;接收delay.queue到消息：&#123;&#125;&quot;</span>, message);
&#125;

<span class="hljs-comment">//Bean方式</span>
<span class="hljs-meta">@Bean</span>
<span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">delayExchange</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">return</span> ExchangeBuilder
        .directExchange(<span class="hljs-string">&quot;delay.direct&quot;</span>)
        .delayed() <span class="hljs-comment">// 设置delay属性为true</span>
        .build();
&#125;
声明队列和绑定关系略.....</code></pre></div><p>发送延时消息，同样通过消息后置处理器完成，这时设置过期时间的方法是<code>setDelay</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendDelayMessage</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">//1.交换机名</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">exchangeName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delay.direct&quot;</span>;
    <span class="hljs-comment">//2.消息</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello,everyone&quot;</span>;
    <span class="hljs-comment">//3.发送</span>
    rabbitTemplate.convertAndSend(exchangeName, <span class="hljs-string">&quot;delay&quot;</span>, message, message1 -&gt; &#123;
        <span class="hljs-comment">//添加延迟消息属性</span>
        message1.getMessageProperties().setDelay(<span class="hljs-number">10000</span>);
        <span class="hljs-keyword">return</span> message1;
    &#125;);
&#125;</code></pre></div><div class="note note-warning"><p>延迟消息插件内部会维护一个本地数据库表，同时使用Elang Timers功能实现计时。如果消息的延迟时间设置较长，可能会导致堆积的延迟消息非常多，会带来较大的CPU开销，同时延迟消息的时间会存在误差。 因此，<strong>不建议设置延迟时间过长的延迟消息。</strong></p></div><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="category-chain-item">微服务</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>RabbitMQ</div><div>https://catpaws.top/b543ced0/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年6月16日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/c82a5987/" title="一、数组"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">一、数组</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/364ea8cc/" title="设计模式"><span class="hidden-mobile">设计模式</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://catpaws.top/blog-resource/twikoo1.6.42/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本站由<img src="/img/upyun_logo.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="width:auto;height:auto">提供CDN加速/云存储服务</a></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备2025059828号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61032302000087" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="police-icon"> <span>陕公网安备61032302000087号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//catpaws.top/blog-resource/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="//catpaws.top/blog-resource/js/loader.js"></script><script src="//catpaws.top/blog-resource/js/blurpicload.js"></script><script src="//catpaws.top/blog-resource/js/axios.min.js"></script><script src="/js/boot.js"></script><!DOCTYPE html><html><head><style>#matechat-iframe-container{position:fixed;top:0;left:0;width:100%;height:100%;z-index:10000;opacity:0;visibility:hidden;transition:opacity .3s ease,visibility .3s ease}#matechat-iframe-container.active{opacity:1;visibility:visible}.matechat-iframe{width:100%;height:100%;border:none;background:#fff}#matechat-iframe-container.active .matechat-close-btn{opacity:1}body.matechat-open{overflow:hidden}</style></head><body><div id="matechat-iframe-container"><iframe class="matechat-iframe" src="https://chat.catpaws.top" allow="microphone" title="芙芙来帮你"></iframe></div><script>document.addEventListener("DOMContentLoaded",(function(){const e=document.getElementById("oml2d-stage"),t=document.getElementById("matechat-iframe-container");function n(){t.classList.remove("active"),document.body.classList.remove("matechat-open")}e?t?(e.addEventListener("click",(function(){t.classList.add("active"),document.body.classList.add("matechat-open")})),document.addEventListener("keydown",(function(e){"Escape"===e.key&&n()})),window.addEventListener("message",(function(e){"closeMateChat"!==e.data&&"close"!==e.data.type||n()})),t.addEventListener("click",(function(e){e.target===this&&n()}))):console.error("matechat-iframe-container 元素未找到"):console.error("oml2d-stage 元素未找到")}))</script><script data-pjax src="https://catpaws.top/blog-resource/live2d/index.min.js"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"https://catpaws.top/blog-resource/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"}}})</script></body></html><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>