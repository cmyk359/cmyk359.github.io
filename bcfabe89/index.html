<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://cdn.jsdelivr.net/gh/cmyk359/MyCDN/Hexo/static/img/webicon.png"><link rel="icon" href="https://cdn.jsdelivr.net/gh/cmyk359/MyCDN/Hexo/static/img/webicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="一、初始Redis 1.1、认识NoSQL ​ NoSQL最常见的解释是“non-relational”， “Not Only SQL”也被很多人接受。NoSQL仅仅是一个概念，泛指非关系型的数据库，区别于关系数据库。 与关系型数据库对比，在以下几点存在差异： 1、数据结构组织  存入SQL的数据都是结构化（Structured）的数据，这些数据都有固定的格式和要求，通过表和表的"><meta property="og:type" content="article"><meta property="og:title" content="Redis - 基础篇"><meta property="og:url" content="https://catpaws.top/bcfabe89/index.html"><meta property="og:site_name" content="猫爪在上de书桌"><meta property="og:description" content="一、初始Redis 1.1、认识NoSQL ​ NoSQL最常见的解释是“non-relational”， “Not Only SQL”也被很多人接受。NoSQL仅仅是一个概念，泛指非关系型的数据库，区别于关系数据库。 与关系型数据库对比，在以下几点存在差异： 1、数据结构组织  存入SQL的数据都是结构化（Structured）的数据，这些数据都有固定的格式和要求，通过表和表的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/cmyk359/MyCDN/Hexo/static/img/art-post6.jpg"><meta property="article:published_time" content="2024-12-10T17:44:29.000Z"><meta property="article:modified_time" content="2025-01-10T09:50:30.457Z"><meta property="article:author" content="猫爪在上"><meta property="article:tag" content="Redis"><meta property="article:tag" content="Redis基本数据类型"><meta property="article:tag" content="Jedis"><meta property="article:tag" content="SpringDataRedis"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/cmyk359/MyCDN/Hexo/static/img/art-post6.jpg"><title>Redis - 基础篇 - 猫爪在上de书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/cmyk359/MyCDN/Hexo/source/css/font.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/cmyk359/MyCDN/Hexo/source/css/poem.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://tntpv22c.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上de书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://cdn.jsdelivr.net/gh/cmyk359/MyCDN/Hexo/static/img/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Redis - 基础篇"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-12-11 01:44" pubdate>2024年12月11日 凌晨</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 48 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Redis - 基础篇</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年1月10日 下午</p><div class="markdown-body"><meta name="referrer" , content="no-referrer"><h2 id="一初始redis">一、初始Redis</h2><h3 id="认识nosql">1.1、认识NoSQL</h3><p>​ NoSQL最常见的解释是“non-relational”， “Not Only SQL”也被很多人接受。NoSQL仅仅是一个概念，泛指<strong>非关系型的数据库</strong>，区别于关系数据库。</p><p>与关系型数据库对比，在以下几点存在差异：</p><p>1、数据结构组织</p><ul><li><p>存入SQL的数据都是结构化（Structured）的数据，这些数据都有固定的格式和要求，通过<strong>表和表的约束</strong>确定下来。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210105846784-2024-12-1010:59:01.png" srcset="/img/loading.gif" lazyload alt="image-20241210105846784"><figcaption aria-hidden="true">image-20241210105846784</figcaption></figure></li><li><p>NoSQL中的数据是非结构化的数据，对数据的格式没有严格的限制。NoSQL主要有四种数据组织方式：键值类型、文档类型、列类型、图（Graph）类型。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241211015432742-2024-12-1101:54:38.png" srcset="/img/loading.gif" lazyload alt="image-20241211015432742"><figcaption aria-hidden="true">image-20241211015432742</figcaption></figure></li></ul><p>2、数据关联</p><ul><li><p>关系型数据库的数据是可以直接关联（Relational）的，可以通过<strong>外键</strong>建立数据的联系，这种外键关系一旦建立，数据库就会自动维护表和表之间的关联。同时可以减少数据的冗余。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210111342983-2024-12-1011:13:44.png" srcset="/img/loading.gif" lazyload alt="image-20241210111342983"><figcaption aria-hidden="true">image-20241210111342983</figcaption></figure></li><li><p>非关系型数据库没有直接维护数据与数据的关联，如采用外键方式，而是使用<strong>JSON文档嵌套</strong>的形式。要想实现外键关系这种效果，需要程序员通过业务逻辑来维护。这种方式也会造成数据的重复，同一份数据可能存储在多个用户下。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210112239209-2024-12-1011:22:40.png" srcset="/img/loading.gif" lazyload alt="image-20241210112239209"><figcaption aria-hidden="true">image-20241210112239209</figcaption></figure></li></ul><p>3、数据查询方式</p><ul><li><p>关系型数据库采用SQL查询，有固定的语法，只要是关系型数据库都能采用相同的语句进行查询</p></li><li><p>非关系型数据库的查询没有固定的语法格式，不同的NoSQL数据库有自己的语法格式</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210112815212-2024-12-1011:28:16.png" srcset="/img/loading.gif" lazyload alt="image-20241210112815212" style="zoom:80%"></p></li></ul><p>4、事务特性</p><ul><li>关系型数据库能够保证事务的<code>ACID</code>特性。当系统中的事务需要满足ACID时，优先选择关系型数据库。</li><li>对于非关系型数据库，有的没有事务，有的无法满足事务的强一致性，只能做到基本一致。<a target="_blank" rel="noopener" href="https://blog.csdn.net/yuanmayuzhou/article/details/137498595">BASE理论</a></li></ul><p>5、存储方式</p><ul><li>关系型数据库基于<strong>磁盘</strong>进行存储，会有大量的磁盘IO，对性能有一定影响。</li><li>非关系型数据库，它操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些。</li></ul><p>6、扩展性</p><ul><li><p>关系型数据库：<strong>垂直扩展性</strong>‌。关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。SQL数据库通常通过增强单个服务器的性能（如增加CPU、内存、存储等）来实现垂直扩展。</p></li><li><p>非关系型数据库：<strong>水平扩展性</strong>。非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。 NoSQL数据库通常设计为分布式系统，天生支持水平扩展。通过添加更多的节点到集群中，NoSQL数据库可以轻松地扩展存储和计算能力，以处理海量数据和并发请求。</p></li></ul><p>7、使用场景</p><ul><li>当数据结构固定，相关业务对数据安全性一致性要求较高时，采用关系型数据库。</li><li>数据结构否固定，对一致性、安全性要求不高，对性能要求高时，采用非关系型数据库。</li></ul><h3 id="认识redis">1.2、认识Redis</h3><figure><img src="https://i-blog.csdnimg.cn/blog_migrate/85f82d1770ba79525dec9edff840861a.jpeg" srcset="/img/loading.gif" lazyload alt="redis-logo"><figcaption aria-hidden="true">redis-logo</figcaption></figure><p>​ Redis诞生于2009年全称是<strong>R</strong>emote <strong>Di</strong>ctionary <strong>S</strong>erver，远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p>特征：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个<strong>命令</strong>具备原子性</li><li>低延迟，速度快（基于<strong>内存</strong>、IO多路复用、良好的编码）。</li><li>支持数据持久化（保证内存中数据的安全）</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><h3 id="安装redis">1.3.安装Redis</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cr4y1671t?vd_source=51d78ede0a0127d1839d6abf9204d1ee&amp;spm_id_from=333.788.player.switch&amp;p=5">参考视频</a></p><h2 id="二redis常用数据结构">二、Redis常用数据结构</h2><h3 id="redis数据结构介绍">2.1、Redis数据结构介绍</h3><p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210154119504-2024-12-1015:41:58.png" srcset="/img/loading.gif" lazyload alt="image-20241210154119504"><figcaption aria-hidden="true">image-20241210154119504</figcaption></figure><p>除此之外，还有其他具有特殊功能的数据类型，可在Redis官网查看。</p><p>Redis将操作不同数据类型的命令做了分组，可以在<a target="_blank" rel="noopener" href="https://redis.io/commands">官网</a>查看相关命令</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210154408388-2024-12-1015:44:58.png" srcset="/img/loading.gif" lazyload alt="image-20241210154408388"><figcaption aria-hidden="true">image-20241210154408388</figcaption></figure><p>也可以也可以通过Help命令来查看对应数据结构类型的命令</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210154609868-2024-12-1015:46:47.png" srcset="/img/loading.gif" lazyload alt="image-20241210154609868"><figcaption aria-hidden="true">image-20241210154609868</figcaption></figure><h3 id="redis通用命令">2.2、Redis通用命令</h3><p>通用指令是所有数据类型都可以使用的指令。<a target="_blank" rel="noopener" href="https://redis.io/docs/latest/commands/?group=generic">查看所有通用命令</a></p><p>可以控制台查看命令的用法，如：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210155923897-2024-12-1015:59:24.png" srcset="/img/loading.gif" lazyload alt="image-20241210155923897"><figcaption aria-hidden="true">image-20241210155923897</figcaption></figure><p>常见的有：</p><ul><li><p><code>KEYS</code>：查看<strong>符合模板</strong>的所有key，即可以使用 <code>*,?,[],^</code>等通配符进行模糊匹配。</p><blockquote><p><strong>在生产环境下不推荐使用keys 命令，因为进行模糊查询效率不高，数据量过大时，花费时间过长，由于Redis命令是单线程的，会阻塞后面命令的执行。</strong></p></blockquote></li><li><p><code>DEL</code>：删除一个指定的key。</p></li><li><p><code>EXISTS</code>：判断key是否存在</p></li><li><p><code>EXPIRE</code>：给一个key设置有效期，有效期到期时该key会被自动删除</p></li><li><p><code>TTL</code>：查看一个KEY的剩余有效期 &gt; i. 当前key没有设置过期时间，返回-1. &gt; &gt; ii. 当前key有设置过期时间，而且key已经过期，返回-2. &gt; &gt; iii. 当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.</p></li><li><p><code>Type</code>: 查看一个key的数据类型</p></li></ul><h3 id="string类型">2.3、String类型</h3><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增.自减操作</li><li>float：浮点类型，可以做自增.自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210161609186-2024-12-1016:16:10.png" srcset="/img/loading.gif" lazyload alt="image-20241210161609186"><figcaption aria-hidden="true">image-20241210161609186</figcaption></figure><p>String类型常见命令：</p><ul><li><p>SET：<strong>添加</strong>或者<strong>修改</strong>已经存在的一个String类型的键值对</p></li><li><p>GET：根据key获取String类型的value</p></li><li><p>MSET：批量添加多个String类型的键值对</p></li><li><p>MGET：根据多个key获取多个String类型的value</p></li><li><p>INCR：让一个整型的key自增1。</p></li><li><p>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</p></li><li><p>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</p></li></ul><blockquote><p>以上三个数值增加的函数，如果所操作的key不存在，则<strong>在执行操作前将其设置为 0</strong>。</p></blockquote><ul><li><p>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行（真正的新增操作）</p></li><li><p>SETEX：添加一个String类型的键值对，并且指定有效期</p></li></ul><h3 id="key的层级结构">2.4、KEY的层级结构</h3><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用<code>:</code>隔开，格式如下：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210164117344-2024-12-1016:41:58.png" srcset="/img/loading.gif" lazyload alt="image-20241210164117344"><figcaption aria-hidden="true">image-20241210164117344</figcaption></figure><p>例如我们的项目名称叫 heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr class="header"><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr class="odd"><td>heima:user:1</td><td>{"id":1, "name": "Jack", "age": 21}</td></tr><tr class="even"><td>heima:product:1</td><td>{"id":1, "name": "小米11", "price": 4999}</td></tr></tbody></table><p>一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210164316431-2024-12-1016:43:58.png" srcset="/img/loading.gif" lazyload alt="image-20241210164316431"><figcaption aria-hidden="true">image-20241210164316431</figcaption></figure><h3 id="hash类型">2.5、Hash类型</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要<strong>修改其中某个字段</strong>时很不方便：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210164556205-2024-12-1016:45:58.png" srcset="/img/loading.gif" lazyload alt="image-20241210164556205"><figcaption aria-hidden="true">image-20241210164556205</figcaption></figure><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210164642490-2024-12-1016:46:58.png" srcset="/img/loading.gif" lazyload alt="image-20241210164642490"><figcaption aria-hidden="true">image-20241210164642490</figcaption></figure><p><strong>Hash类型的常见命令</strong></p><ul><li>HSET key field value：<strong>添加</strong>或者<strong>修改</strong>hash类型key的field的值</li><li>HGET key field：获取一个hash类型key的field的值</li><li>HMSET：批量添加多个hash类型key的field的值</li><li>HMGET：批量获取多个hash类型key的field的值</li></ul><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; HSET heima:user:2 name rose
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; HSET heima:user:2 age 21
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; HGET heima:user:2 name
<span class="hljs-string">&quot;rose&quot;</span>
127.0.0.1:6379&gt; HMSET heima:user:3 name Lucy age 22 sex female
OK
127.0.0.1:6379&gt; HMGET heima:user:3 name age sex
1) <span class="hljs-string">&quot;Lucy&quot;</span>
2) <span class="hljs-string">&quot;22&quot;</span>
3) <span class="hljs-string">&quot;female&quot;</span>
</code></pre></div><ul><li>HGETALL：获取一个hash类型的key中的所有的field和value</li><li>HKEYS：获取一个hash类型的key中的所有的field</li><li>HVALS：获取一个hash类型的key中的所有的value</li></ul><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; HGETALL heima:user:3
1) <span class="hljs-string">&quot;name&quot;</span>
2) <span class="hljs-string">&quot;Lucy&quot;</span>
3) <span class="hljs-string">&quot;age&quot;</span>
4) <span class="hljs-string">&quot;22&quot;</span>
5) <span class="hljs-string">&quot;sex&quot;</span>
6) <span class="hljs-string">&quot;female&quot;</span>
127.0.0.1:6379&gt; HKEYS heima:user:3
1) <span class="hljs-string">&quot;name&quot;</span>
2) <span class="hljs-string">&quot;age&quot;</span>
3) <span class="hljs-string">&quot;sex&quot;</span>
127.0.0.1:6379&gt; HVALS heima:user:3
1) <span class="hljs-string">&quot;Lucy&quot;</span>
2) <span class="hljs-string">&quot;22&quot;</span>
3) <span class="hljs-string">&quot;female&quot;</span>
</code></pre></div><ul><li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; HINCRBY heima:user:3 age 3
(<span class="hljs-built_in">integer</span>) 25
127.0.0.1:6379&gt; HGET heima:user:3 age
<span class="hljs-string">&quot;25&quot;</span>
127.0.0.1:6379&gt; HINCRBY heima:user:3 age -2  <span class="hljs-comment">#增量为负数，则为自减操作</span>
(<span class="hljs-built_in">integer</span>) 23
127.0.0.1:6379&gt; HGET heima:user:3 age
<span class="hljs-string">&quot;23&quot;</span>


127.0.0.1:6379&gt; HSETNX heima:user:3 sex male  <span class="hljs-comment"># user3已存在sex字段，设置无效</span>
(<span class="hljs-built_in">integer</span>) 0
127.0.0.1:6379&gt; HGET heima:user:3 sex
<span class="hljs-string">&quot;female&quot;</span>
127.0.0.1:6379&gt; HSETNX heima:user:2 sex male <span class="hljs-comment">#user2没有sex字段，设置成功</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; HGET heima:user:2 sex
<span class="hljs-string">&quot;male&quot;</span>
</code></pre></div><ul><li>HEXISTS key field：判断指定key中是否已存在field字段，存在返回1，不存在返回0.</li><li>HDEL key field [field ...]：删除指定key中的field字段，如果指定field不存在则忽略；如果该key的所有字段都被删除，则该key也被删除。如果 key 不存在，则将其视为空散列，此命令返回 0。</li><li>HLEN key：返回该Key所含有的field字段的数量</li></ul><h3 id="list类型">2.6、List类型</h3><p>Redis中的List类型与Java中的<strong>LinkedList</strong>类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p><strong>List的常见命令有：</strong></p><ul><li><p>LPUSH key element ... ：向列表左侧插入一个或多个元素</p></li><li><p>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</p></li><li><p>RPUSH key element ... ：向列表右侧插入一个或多个元素</p></li><li><p>RPOP key：移除并返回列表右侧的第一个元素</p></li><li><p>LRANGE key star end：返回一段角标范围内的所有元素</p></li><li><p>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil。</p><blockquote><p>使用BLPOP和BRPO时，若不存在该元素，会<strong>阻塞进程</strong>等待指定时间。若指定时间内等待元素出现，返回该元素值，否则返回nil。</p></blockquote></li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210170706103-2024-12-1017:07:58.png" srcset="/img/loading.gif" lazyload alt="image-20241210170706103"><figcaption aria-hidden="true">image-20241210170706103</figcaption></figure><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; LPUSH <span class="hljs-built_in">users</span> 1 2 3
(<span class="hljs-built_in">integer</span>) 3
127.0.0.1:6379&gt; RPUSH <span class="hljs-built_in">users</span> 4 5 6
(<span class="hljs-built_in">integer</span>) 6
127.0.0.1:6379&gt; LRANGE <span class="hljs-built_in">users</span> 0 5  <span class="hljs-comment">#注意此时队列中数字的顺序</span>
1) <span class="hljs-string">&quot;3&quot;</span>
2) <span class="hljs-string">&quot;2&quot;</span>
3) <span class="hljs-string">&quot;1&quot;</span>
4) <span class="hljs-string">&quot;4&quot;</span>
5) <span class="hljs-string">&quot;5&quot;</span>
6) <span class="hljs-string">&quot;6&quot;</span>
127.0.0.1:6379&gt; LPOP <span class="hljs-built_in">users</span>
<span class="hljs-string">&quot;3&quot;</span>
127.0.0.1:6379&gt; RPOP <span class="hljs-built_in">users</span> 2  <span class="hljs-comment">#出队多个元素</span>
1) <span class="hljs-string">&quot;6&quot;</span>
2) <span class="hljs-string">&quot;5&quot;</span>
127.0.0.1:6379&gt; LRange key 0 -1 <span class="hljs-comment">#不知道最后一个元素下标时，用-1代替</span>
(empty array)
127.0.0.1:6379&gt; LRange <span class="hljs-built_in">users</span>  0 -1
1) <span class="hljs-string">&quot;2&quot;</span>
2) <span class="hljs-string">&quot;1&quot;</span>
3) <span class="hljs-string">&quot;4&quot;</span></code></pre></div><ul><li><p>如何利用List结构模拟一个栈？</p><p>入口和出口在同一边。使用LPUSH/LPOP 或 RPUSH/RPOP进行元素操作。</p></li><li><p>如何利用List结构模拟一个队列？</p><p>入口和出口在不同边。使用LPUSH/RPOP 或 RPUSH/LPOP进行元素操作。</p></li><li><p>如何利用List结构模拟一个阻塞队列？</p><p>入口和出口在不同边，且出队时采用BLPOP或BRPOP</p></li></ul><h3 id="set类型">2.7、Set类型</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个<strong>value为null的HashMap</strong>。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><p><strong>Set类型的常见命令</strong></p><ul><li>SADD key member ... ：向set中添加一个或多个元素</li><li>SREM key member ... : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li></ul><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; SADD s1 a b c d <span class="hljs-comment">#向s1中添加四个元素 a b c d</span>
(<span class="hljs-built_in">integer</span>) 4
127.0.0.1:6379&gt; SMEMBERS s1 <span class="hljs-comment">#查看s1中的元素</span>
1) <span class="hljs-string">&quot;a&quot;</span>
2) <span class="hljs-string">&quot;c&quot;</span>
3) <span class="hljs-string">&quot;d&quot;</span>
4) <span class="hljs-string">&quot;b&quot;</span>
127.0.0.1:6379&gt; SREM s1 a 
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; SREM s1 b  <span class="hljs-comment">#删除s1中的a b</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; SISMEMBER s1 a <span class="hljs-comment">#判断a是否是s1的元素，返回值为0</span>
(<span class="hljs-built_in">integer</span>) 0
127.0.0.1:6379&gt; SCARD s1 <span class="hljs-comment">#查看此时s1中元素的个数</span>
(<span class="hljs-built_in">integer</span>) 2
</code></pre></div><ul><li>SINTER key1 key2 ... ：求key1与key2的交集</li><li>SDIFF key1 key2 ... ：求key1与key2的差集</li><li>SUNION key1 key2 ..：求key1和key2的并集</li></ul><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#将下列数据用Redis的Set集合来存储：</span>
	<span class="hljs-comment">#张三的好友有：李四、王五、赵六</span>
	<span class="hljs-comment">#李四的好友有：王五、麻子、二狗</span>

127.0.0.1:6379&gt; SADD zs lisi wangwu zhaoliu
(<span class="hljs-built_in">integer</span>) 3
127.0.0.1:6379&gt; SADD <span class="hljs-built_in">ls</span> wangwu mazi ergou
(<span class="hljs-built_in">integer</span>) 3
127.0.0.1:6379&gt; SINTER zs <span class="hljs-built_in">ls</span>	 <span class="hljs-comment"># 计算张三和李四有哪些共同好友</span>
1) <span class="hljs-string">&quot;wangwu&quot;</span>
127.0.0.1:6379&gt; SDIFF zs <span class="hljs-built_in">ls</span>		<span class="hljs-comment"># 查询哪些人是张三的好友却不是李四的好友</span>
1) <span class="hljs-string">&quot;lisi&quot;</span>
2) <span class="hljs-string">&quot;zhaoliu&quot;</span>
127.0.0.1:6379&gt; SUNION zs <span class="hljs-built_in">ls</span> 	<span class="hljs-comment"># 查询张三和李四的好友总共有哪些人</span>
1) <span class="hljs-string">&quot;lisi&quot;</span>
2) <span class="hljs-string">&quot;zhaoliu&quot;</span>
3) <span class="hljs-string">&quot;wangwu&quot;</span>
4) <span class="hljs-string">&quot;mazi&quot;</span>
5) <span class="hljs-string">&quot;ergou&quot;</span>
</code></pre></div><h3 id="sortedset类型">2.8、SortedSet类型</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。</p><p>SortedSet中的每一个元素都带有一个<code>score</code>属性，可以基于score属性对元素<code>排序</code>，底层的实现是一个跳表（SkipList）加 hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现<u>排行榜</u>这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li><p>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</p></li><li><p>ZREM key member：删除sorted set中的一个指定元素</p></li><li><p>ZSCORE key member : 获取sorted set中的指定元素的score值</p></li><li><p>ZRANK key member：获取sorted set 中的指定元素的排名（<strong><u>排名从0开始</u></strong>）</p></li><li><p>ZCARD key：获取sorted set中的元素<strong>个数</strong></p></li><li><p>ZCOUNT key min max：统计<code>score值</code>在给定范围内的所有元素的<strong>个数</strong></p></li><li><p>ZRANGE key min max：按照score排序后，获取指定排名范围内的<strong>元素</strong></p></li><li><p>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的<strong>元素</strong></p></li><li><p>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</p></li><li><p>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</p></li></ul><blockquote><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，如ZREVRANK</p></blockquote><p>练习案例</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210174728207-2024-12-1017:47:45.png" srcset="/img/loading.gif" lazyload alt="image-20241210174728207" style="zoom:70%"></p><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; ZADD scores 85 Jack 89 Lucy 82 Rose  95 Tom 78 Jerry 92 Amy 76 Miles <span class="hljs-comment">#导入学生分数到scores</span>
(<span class="hljs-built_in">integer</span>) 7
127.0.0.1:6379&gt; ZREM scores Tom  <span class="hljs-comment">#删除Tom同学</span>
(<span class="hljs-built_in">integer</span>) 1
127.0.0.1:6379&gt; ZSCORE scores Amy <span class="hljs-comment">#获取Amy的分数</span>
<span class="hljs-string">&quot;92&quot;</span>
127.0.0.1:6379&gt; ZREVRANK scores Rose <span class="hljs-comment">#score降序，获得Rose的排名</span>
(<span class="hljs-built_in">integer</span>) 3
127.0.0.1:6379&gt; ZCOUNT scores 0 80 <span class="hljs-comment">#查询80分以下的学生个数</span>
(<span class="hljs-built_in">integer</span>) 2
127.0.0.1:6379&gt; ZINCRBY scores  2 Amy  <span class="hljs-comment">#Amy的分数加2</span>
<span class="hljs-string">&quot;94&quot;</span>
127.0.0.1:6379&gt; ZREVRANGE scores 0 2  <span class="hljs-comment">#score降序排序，获取前三名</span>
1) <span class="hljs-string">&quot;Amy&quot;</span>
2) <span class="hljs-string">&quot;Lucy&quot;</span>
3) <span class="hljs-string">&quot;Jack&quot;</span>
127.0.0.1:6379&gt; ZRANGEBYSCORE scores 0 80  <span class="hljs-comment">#查出80分以下的同学</span>
1) <span class="hljs-string">&quot;Miles&quot;</span>
2) <span class="hljs-string">&quot;Jerry&quot;</span>
</code></pre></div><h2 id="三redis三种特殊数据结构">三、Redis三种特殊数据结构</h2><h3 id="geo地理位置">3.1、<a href="https://catpaws.top/e0606bbf/#六附近的商户">GEO地理位置</a></h3><h3 id="bitmap">3.2、<a href="https://catpaws.top/e0606bbf/#七用户签到">BitMap</a></h3><h3 id="hyperloglog">3.3、<a href="https://catpaws.top/e0606bbf/#八uv网页的访问量统计">Hyperloglog</a></h3><h2 id="四redis的java客户端">四、Redis的Java客户端</h2><p>在Redis官网中提供了各种语言的客户端，地址：https://redis.io/clients</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210215022257-2024-12-1021:50:26.png" srcset="/img/loading.gif" lazyload alt="image-20241210215022257"><figcaption aria-hidden="true">image-20241210215022257</figcaption></figure><ul><li>jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装（SpringBoot<strong>默认使用Lettuce</strong>），因此后期可以以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h3 id="jedis">4.1、Jedis</h3><h4 id="快速入门">快速入门</h4><ol type="1"><li><p>引入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jedis--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>建立连接</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Jedis jedis;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">// 1.建立连接</span>
    jedis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;主机ip&quot;</span>, <span class="hljs-number">6379</span>);
    <span class="hljs-comment">// 2.设置密码</span>
    jedis.auth(<span class="hljs-string">&quot;123321&quot;</span>);
    <span class="hljs-comment">// 3.选择库</span>
    jedis.select(<span class="hljs-number">0</span>);
&#125;</code></pre></div></li><li><p>测试</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">// 存入数据</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;虎哥&quot;</span>);
    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);
    <span class="hljs-comment">// 获取数据</span>
    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;name&quot;</span>);
    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);
&#125;

<span class="hljs-meta">@Test</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">// 插入hash数据</span>
    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);
    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>);

    <span class="hljs-comment">// 获取</span>
    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="hljs-string">&quot;user:1&quot;</span>);
    System.out.println(map);
&#125;</code></pre></div></li><li><p>释放资源</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@AfterEach</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;
        jedis.close();
    &#125;
&#125;</code></pre></div></li></ol><h4 id="jedis连接池">Jedis连接池</h4><p>Jedis本身是线程不安全的，并发模式下需要为每个线程创建Jedis连接，使用完再释放连接。频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池代替Jedis的直连方式</p><p>创建Jedis连接池，通过连接池获取Jedis连接</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectionFactory</span> &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool;

    <span class="hljs-keyword">static</span> &#123;
        <span class="hljs-comment">//配置连接池</span>
        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();
        <span class="hljs-comment">//最大连接</span>
        poolConfig.setMaxTotal(<span class="hljs-number">10</span>);
        <span class="hljs-comment">//最大空闲连接</span>
        poolConfig.setMaxIdle(<span class="hljs-number">8</span>);
        <span class="hljs-comment">//最小空闲连接</span>
        poolConfig.setMinIdle(<span class="hljs-number">0</span>);
        <span class="hljs-comment">//设置最长等待时间 ，单位ms</span>
        poolConfig.setMaxWaitMillis(<span class="hljs-number">200</span>);

        <span class="hljs-comment">//创建连接池对象</span>
        jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig,
                <span class="hljs-string">&quot;192.168.181.100&quot;</span>,<span class="hljs-number">6379</span>,<span class="hljs-number">1000</span>,<span class="hljs-string">&quot;liuhao123&quot;</span>);
    &#125;
    <span class="hljs-comment">//获取Jedis对象</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> jedisPool.getResource();
    &#125;
&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"> <span class="hljs-meta">@BeforeEach</span>
 <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span>&#123;
     <span class="hljs-comment">//建立连接</span>
     <span class="hljs-comment">/*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/</span>
     jedis = JedisConnectionFacotry.getJedis();
      <span class="hljs-comment">//选择库</span>
     jedis.select(<span class="hljs-number">0</span>);
 &#125;

<span class="hljs-meta">@AfterEach</span>
 <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;
     <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;
         jedis.close();
     &#125;
 &#125;</code></pre></div><ol type="1"><li><p>在完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。</p></li><li><p>当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis连接<strong>归还</strong>给连接池。</p></li></ol><h3 id="springdataredis">4.2、SpringDataRedis</h3><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-redis">官网地址</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了<strong>RedisTemplate</strong>统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化（方便数据的存储和读取）</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。像redis一样，对不同数据类型做了分组，将不同数据类型的操作API封装到了不同的类型中：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210221341487-2024-12-1022:13:58.png" srcset="/img/loading.gif" lazyload alt="image-20241210221341487"><figcaption aria-hidden="true">image-20241210221341487</figcaption></figure><h4 id="快速入门-1">快速入门</h4><p>SpringBoot已经提供了对SpringDataRedis的支持，创建一个SpringBoot项目进行测试，步骤如下：</p><ol type="1"><li><p>引入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--redis依赖--&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
     <span class="hljs-comment">&lt;!--common-pool--&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
     <span class="hljs-comment">&lt;!--Jackson依赖--&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>配置文件</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>
  <span class="hljs-attr">redis:</span>
    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.181</span><span class="hljs-number">.100</span>
    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>
    <span class="hljs-attr">password:</span> <span class="hljs-number">123321</span>
    <span class="hljs-attr">lettuce:</span>
      <span class="hljs-attr">pool:</span>
        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span>  <span class="hljs-comment">#最大连接</span>
        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span>   <span class="hljs-comment">#最大空闲连接</span>
        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span>   <span class="hljs-comment">#最小空闲连接</span>
        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">100ms</span> <span class="hljs-comment">#连接等待时间</span></code></pre></div></li><li><p>测试</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisDemoApplicationTests</span> &#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-comment">// 写入一条String数据</span>
        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;jack&quot;</span>);
        <span class="hljs-comment">// 获取string数据</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);
    &#125;
&#125;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241211003003488-2024-12-1100:30:05.png" srcset="/img/loading.gif" lazyload alt="image-20241211003003488"><figcaption aria-hidden="true">image-20241211003003488</figcaption></figure></li></ol><h4 id="redistemplate的两种序列化实践方案">RedisTemplate的两种序列化实践方案</h4><p>RedisTemplate可以接收任意Object作为值写入Redis，在写入前会把Object序列化为字节形式，默认是采用<strong>JDK序列化</strong></p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241211014252619-2024-12-1101:42:58.png" srcset="/img/loading.gif" lazyload alt="image-20241211014252619"><figcaption aria-hidden="true">image-20241211014252619</figcaption></figure><p>得到的结果如下，可读性差，内存占用较大。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241211005242136-2024-12-1100:52:52.png" srcset="/img/loading.gif" lazyload alt="image-20241211005242136" style="zoom:67%"></p><p>可以采用两种方案解决</p><p>方案一：</p><ol type="1"><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span>&#123;
        <span class="hljs-comment">// 创建RedisTemplate对象</span>
        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();
        <span class="hljs-comment">// 设置连接工厂</span>
        template.setConnectionFactory(connectionFactory);
        <span class="hljs-comment">// 创建JSON序列化工具</span>
        <span class="hljs-type">GenericJackson2JsonRedisSerializer</span> <span class="hljs-variable">jsonRedisSerializer</span> <span class="hljs-operator">=</span> 
            							<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericJackson2JsonRedisSerializer</span>();
        <span class="hljs-comment">// 设置Key的序列化</span>
        template.setKeySerializer(RedisSerializer.string());
        template.setHashKeySerializer(RedisSerializer.string());
        <span class="hljs-comment">// 设置Value的序列化</span>
        template.setValueSerializer(jsonRedisSerializer);
        template.setHashValueSerializer(jsonRedisSerializer);
        <span class="hljs-comment">// 返回</span>
        <span class="hljs-keyword">return</span> template;
    &#125;
&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//测试代码</span>
<span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">HmDianPingApplicationTests</span> &#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;

    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-comment">// 写入一条String数据</span>
        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;jack&quot;</span>);
        <span class="hljs-comment">// 获取string数据</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);
    &#125;
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUser</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-comment">//存入对象数据</span>
        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;user:100&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestUser</span>(<span class="hljs-string">&quot;Dylan&quot;</span>,<span class="hljs-number">20</span>));
        <span class="hljs-comment">//获取数据</span>
        <span class="hljs-type">TestUser</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (TestUser) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;user:100&quot;</span>);
        System.out.println(<span class="hljs-string">&quot;o = &quot;</span>+ o);
    &#125;
&#125;</code></pre></div><p>采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241211011952945-2024-12-1101:19:58.png" srcset="/img/loading.gif" lazyload alt="image-20241211011952945" style="zoom:80%"></p><p>同时可以将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241211012224081-2024-12-1101:22:49.png" srcset="/img/loading.gif" lazyload alt="image-20241211012224081" style="zoom:80%"></p><p>方案二：</p><ol type="1"><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ol><p>​ 为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。为了减少内存的消耗，我们可以采用手动序列化和反序列化。</p><p>​ 同时，只采用String的序列化器，这样，在存储value时，就不需要在内存中就不用多存储数据，从而节约内存空间。SpringDataRedis就提供了RedisTemplate的子类：<code>StringRedisTemplate</code>，它的key和value的序列化方式默认就是String方式。</p><p>省去了自定义RedisTemplate的序列化方式的步骤，而是直接使用：StringRedisTemplate</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">HmDianPingApplicationTests</span> &#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;
    <span class="hljs-comment">//进行序列化和反序列化的工具</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();
    
    <span class="hljs-meta">@Test</span>
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;
        <span class="hljs-comment">//创建对象</span>
        <span class="hljs-type">TestUser</span> <span class="hljs-variable">testUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestUser</span>(<span class="hljs-string">&quot;Lucy&quot;</span>, <span class="hljs-number">21</span>);
        <span class="hljs-comment">//手动序列化</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(testUser);
        <span class="hljs-comment">//写入数据</span>
        stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;user:200&quot;</span>,json);
        <span class="hljs-comment">//获取数据</span>
        <span class="hljs-type">String</span> <span class="hljs-variable">jsonUser</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;user:200&quot;</span>);
        <span class="hljs-comment">//反序列化</span>
        <span class="hljs-type">TestUser</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.readValue(jsonUser, TestUser.class);
        System.out.println(<span class="hljs-string">&quot;user =&quot;</span>+ user);
    &#125;
&#125;</code></pre></div><p>此时存储的内容没有之前的class信息，节约了存储空间</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241211013242601-2024-12-1101:32:44.png" srcset="/img/loading.gif" lazyload alt="image-20241211013242601" style="zoom:80%"></p><h2 id="补充">补充</h2><p>Windows的Redis图形化客户端连接不上虚拟机中的Redis问题</p><p><strong>1、修改redis.conf配置文件</strong></p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241212095439904-2024-12-1209:56:28.png" srcset="/img/loading.gif" lazyload alt="image-20241212095439904"><figcaption aria-hidden="true">image-20241212095439904</figcaption></figure><p><strong>2、在linux下的防火墙中开放6379端口</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> firewall-cmd --zone=public --add-port=6379/tcp --permanent</code></pre></div><p><strong>3、重新载入firewalld以应用更改</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> firewall-cmd --reload</code></pre></div><p><strong>4、检查端口是否已开放</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> firewall-cmd --zone=public --list-ports</code></pre></div></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="category-chain-item">数据库</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Redis/" class="print-no-link">#Redis</a> <a href="/tags/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="print-no-link">#Redis基本数据类型</a> <a href="/tags/Jedis/" class="print-no-link">#Jedis</a> <a href="/tags/SpringDataRedis/" class="print-no-link">#SpringDataRedis</a></div></div><div class="license-box my-3"><div class="license-title"><div>Redis - 基础篇</div><div>https://catpaws.top/bcfabe89/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年12月11日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/e0606bbf/" title="Redis - 实战篇"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Redis - 实战篇</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/1bff3c65/" title="MyBatis"><span class="hidden-mobile">MyBatis</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://cdn.smartcis.cn/npm/twikoo@1.6.40/dist/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><br>人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//cdn.jsdelivr.net/gh/cmyk359/MyCDN/Hexo/source/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://unpkg.com/oh-my-live2d"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"http://img.catpaws.top/blog-source/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"},idleTips:{interval:15e3,message:function(){return axios.get("https://v1.hitokoto.cn?c=i").then((function(t){return t.data.hitokoto})).catch((function(t){console.error(t)}))}}}})</script></body></html>