<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://catpaws.top/blog-resource/imgs/webicon.png"><link rel="icon" href="https://catpaws.top/blog-resource/imgs/webicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="一、事务 事务(transaction)，是用户定义的一个数据库操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销，这些操作要么同时成功，要么同时失败。 只有DML语句（insert、delete、update）才会有事务这一说，其它语句和事务无关！！！因为 只有以上的三个语句是数据库表中数据进行增、删、改的。 只要你的操作一旦涉及到数据的增、删"><meta property="og:type" content="article"><meta property="og:title" content="MySQL（二）"><meta property="og:url" content="https://catpaws.top/bd62c17f/index.html"><meta property="og:site_name" content="猫爪在上の书桌"><meta property="og:description" content="一、事务 事务(transaction)，是用户定义的一个数据库操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销，这些操作要么同时成功，要么同时失败。 只有DML语句（insert、delete、update）才会有事务这一说，其它语句和事务无关！！！因为 只有以上的三个语句是数据库表中数据进行增、删、改的。 只要你的操作一旦涉及到数据的增、删"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240711100432572-2024-7-1110:04:51.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240712095425856-2024-7-1209:54:46.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240721191411802-2024-7-2119:14:12.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250312111300584-2025-3-1211:13:01.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250312111516116-2025-3-1211:15:24.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250312113022121-2025-3-1211:30:23.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250312153240660-2025-3-1215:32:42.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250312153042354-2025-3-1215:30:55.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250312153544178-2025-3-1215:35:48.png"><meta property="article:published_time" content="2024-12-08T15:12:03.000Z"><meta property="article:modified_time" content="2025-03-12T09:38:27.497Z"><meta property="article:author" content="猫爪在上"><meta property="article:tag" content="事务"><meta property="article:tag" content="InnoDB存储引擎"><meta property="article:tag" content="索引"><meta property="article:tag" content="SQL优化"><meta property="article:tag" content="锁"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240711100432572-2024-7-1110:04:51.png"><title>MySQL（二） - 猫爪在上の书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/font.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/poem.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/shubiao.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/loader.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/twikoo_beautify.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/indeximg-hover.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/wave.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/blurpicload.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"https://catpaws.top/img/transpare.svg",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://leancloud.catpaws.top",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loader-container"><div class="loader"><div class="wrapper"><div class="catContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 733 673" class="catbody"><path fill="#212121" d="M111.002 139.5C270.502 -24.5001 471.503 2.4997 621.002 139.5C770.501 276.5 768.504 627.5 621.002 649.5C473.5 671.5 246 687.5 111.002 649.5C-23.9964 611.5 -48.4982 303.5 111.002 139.5Z"></path><path fill="#212121" d="M184 9L270.603 159H97.3975L184 9Z"></path><path fill="#212121" d="M541 0L627.603 150H454.397L541 0Z"></path></svg> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 158 564" class="tail"><path fill="#191919" d="M5.97602 76.066C-11.1099 41.6747 12.9018 0 51.3036 0V0C71.5336 0 89.8636 12.2558 97.2565 31.0866C173.697 225.792 180.478 345.852 97.0691 536.666C89.7636 553.378 73.0672 564 54.8273 564V564C16.9427 564 -5.4224 521.149 13.0712 488.085C90.2225 350.15 87.9612 241.089 5.97602 76.066Z"></path></svg><div class="text"><span class="bigzzz">Z</span> <span class="zzz">Z</span></div></div><div class="wallContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 500 126" class="wall"><line stroke-width="6" stroke="#7C7C7C" y2="3" x2="450" y1="3" x1="50"></line><line stroke-width="6" stroke="#7C7C7C" y2="85" x2="400" y1="85" x1="100"></line><line stroke-width="6" stroke="#7C7C7C" y2="122" x2="375" y1="122" x1="125"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="500" y1="43"></line><line stroke-width="6" stroke="#7C7C7C" y2="1.99391" x2="115.5" y1="43.0061" x1="115.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00002" x2="189" y1="43.0122" x1="189"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00612" x2="262.5" y1="43.0183" x1="262.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01222" x2="336" y1="43.0244" x1="336"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01833" x2="409.5" y1="43.0305" x1="409.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="153" y1="84.0122" x1="153"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="228" y1="84.0122" x1="228"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="303" y1="84.0122" x1="303"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="378" y1="84.0122" x1="378"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="192" y1="125.012" x1="192"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="267" y1="125.012" x1="267"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="342" y1="125.012" x1="342"></line></svg></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上の书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>个人主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://catpaws.top/blog-resource/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="MySQL（二）"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-12-08 23:12" pubdate>2024年12月8日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 18k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 148 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">MySQL（二）</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年3月12日 下午</p><div class="markdown-body"><meta name="referrer" , content="no-referrer"><h2 id="一事务">一、事务</h2><p><strong>事务(transaction)</strong>，是用户定义的一个数据库操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销，这些操作要么同时成功，要么同时失败。</p><p>只有<strong>DML</strong>语句（<code>insert、delete、update</code>）才会有事务这一说，其它语句和事务无关！！！因为 只有以上的三个语句是数据库表中数据进行增、删、改的。 只要你的操作一旦涉及到数据的增、删、改，那么就一定要考虑安全问题。</p><h3 id="事务的原理">1.1、事务的原理</h3><p>InnoDB存储引擎：提供一组用来记录<strong>事务性活动的日志文件</strong>（类似于缓存）</p><div class="code-wrapper"><pre><code class="hljs mysql">事务开启了：
insert
insert
insert
delete
update
update
update
事务结束了！</code></pre></div><p>在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中，此时不会真正修改磁盘上的数据。</p><p>在事务的执行过程中，我们可以提交事务，也可以回滚事务。（提交和回滚是事务的<strong>两个终结操作</strong>）</p><p>提交事务？ 清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。 提交事务标志着，事务的结束。并且是一种<strong>全部成功</strong>的结束。</p><p>回滚事务？ 将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件 回滚事务标志着，事务的结束。并且是一种<strong>全部失败</strong>的结束。</p><h3 id="提交事务回滚事务">1.2、提交事务、回滚事务</h3><p>事务通常以 <code>start transaction</code>开始，以<code>commit</code> 或<code>rollback</code>结束。</p><ul><li><code>COMMIT</code>表示提交，即提交事务的所有操作。将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束。</li><li><code>ROLLBACK</code>表示回滚，即在事务运行过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始的状态。</li></ul><p>​ 在MySQL默认情况下是支持自动提交事务的，即每执行一条DML语句，则提交一次。这种自动提交实际上是不符合我们的开发习惯，因为一个业务通常是需要多条DML语句共同执行才能完成的，为了保证数据的安全，必须要求同时成功之后再提交，所以不能执行一条就提交一条。执行<code>start transaction</code>关闭自动提交机制，开启真正的事务机制。</p><p><strong>代码演示</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">演示事务：
  ---------------------------------回滚事务----------------------------------------
  mysql&gt; use bjpowernode;
  Database changed
  mysql&gt; select * from dept_bak;
  Empty set (0.00 sec)

  mysql&gt; start transaction;
  Query OK, 0 rows affected (0.00 sec)

  mysql&gt; insert into dept_bak values(10,&#x27;abc&#x27;, &#x27;tj&#x27;);
  Query OK, 1 row affected (0.00 sec)

  mysql&gt; insert into dept_bak values(10,&#x27;abc&#x27;, &#x27;tj&#x27;);
  Query OK, 1 row affected (0.00 sec)

  mysql&gt; select * from dept_bak;
  +--------+-------+------+
  | DEPTNO | DNAME | LOC  |
  +--------+-------+------+
  |     10 | abc   | tj   |
  |     10 | abc   | tj   |
  +--------+-------+------+
  2 rows in set (0.00 sec)

  mysql&gt; rollback;
  Query OK, 0 rows affected (0.00 sec)

  mysql&gt; select * from dept_bak;
  Empty set (0.00 sec)


  ---------------------------------提交事务----------------------------------------
  mysql&gt; use bjpowernode;
  Database changed
  mysql&gt; select * from dept_bak;
  +--------+-------+------+
  | DEPTNO | DNAME | LOC  |
  +--------+-------+------+
  |     10 | abc   | bj   |
  +--------+-------+------+
  1 row in set (0.00 sec)

  mysql&gt; start transaction;
  Query OK, 0 rows affected (0.00 sec)

  mysql&gt; insert into dept_bak values(20,&#x27;abc&#x27;)
  Query OK, 1 row affected (0.00 sec)

  mysql&gt; insert into dept_bak values(20,&#x27;abc&#x27;)
  Query OK, 1 row affected (0.00 sec)

  mysql&gt; insert into dept_bak values(20,&#x27;abc&#x27;)
  Query OK, 1 row affected (0.00 sec)

  mysql&gt; commit;
  Query OK, 0 rows affected (0.01 sec)

  mysql&gt; select * from dept_bak;
  +--------+-------+------+
  | DEPTNO | DNAME | LOC  |
  +--------+-------+------+
  |     10 | abc   | bj   |
  |     20 | abc   | tj   |
  |     20 | abc   | tj   |
  |     20 | abc   | tj   |
  +--------+-------+------+
  4 rows in set (0.00 sec)

  mysql&gt; rollback;
  Query OK, 0 rows affected (0.00 sec)

  mysql&gt; select * from dept_bak;
  +--------+-------+------+
  | DEPTNO | DNAME | LOC  |
  +--------+-------+------+
  |     10 | abc   | bj   |
  |     20 | abc   | tj   |
  |     20 | abc   | tj   |
  |     20 | abc   | tj   |
  +--------+-------+------+
  4 rows in set (0.00 sec)</code></pre></div><h3 id="事务四个特性acid">1.3、事务四个特性（ACID）</h3><p>事务的特性是<strong>ACID</strong>，即原⼦性（Atomicity）、⼀致性（Consistency）、隔离性（Isolation）、持久性（Durability）。</p><ul><li>原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p>例如，A向B转账500元，这个操作要么都成功，要么都失败，体现了原⼦性。转账过程中数据要保持⼀致，A扣除了500元，B必须增加500元。隔离性体现在A向B转账时，不受其他事务⼲扰。持久性体现在事务提交后，数据要被持久化存储。</p><p><a href="https://catpaws.top/bd62c17f/#事务原理">事务四个特性的实现原理</a></p><h3 id="事务的隔离性等级">1.4、事务的隔离性等级</h3><p>有关多个事务的并发控制</p><p><strong>多事务并发执行的问题</strong></p><ul><li><p><strong>脏读</strong>：一个事务读取了另一个事务未提交的数据，这些数据可能会被回滚，从而导致读取到无效数据</p></li><li><p><strong>不可重复读</strong>：一个事务在两次读取同一数据时，因其他事务的提交导致数据发生了变化，两次读取的数据不同。</p></li><li><p><strong>幻读</strong>：一个事务读取多条记录后，因其他事务的插入或删除，导致再次读取时获得的<strong>记录集</strong>发生变化。</p></li></ul><hr><p>事务隔离性存在隔离级别，理论上隔离级别包括<code>4</code>个：</p><ol type="1"><li><p>读未提交： <code>read uncommitted</code> （最低的隔离级别，没有提交就读到了）</p><ul><li>含义： 指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li>存在问题：脏读现象！(Dirty Read)</li></ul></li><li><p>读已提交：<code>read committed</code> (提交之后才能读到)</p><ul><li>含义：指一个事务提交之后，它做的变更才能被其他事务看到；</li><li>解决的问题：解决了脏读的现象。</li><li>存在的问题： 不可重复读取数据。<ul><li>在这种隔离级别下，每一次读到的数据是绝对的真实。</li></ul></li></ul></li><li><p>可重复读：<code>repeatable read</code>(提交之后也读不到，永远读取的都是刚开启事务时的数据)</p><ul><li>含义：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的</li><li>解决的问题：解决了不可重复读取数据。</li><li>存在的问题：可以会出现幻读。</li></ul></li><li><p>序列化/串行化：<code>serializable</code>（最高的隔离级别）</p><ul><li><p>含义：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</p></li><li><p>这是最高隔离级别，效率最低。解决了所有的问题。</p></li><li><p>这种隔离级别表示事务需要排队，不能并发！</p></li></ul></li></ol><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240424102156449-2024-12-823:54:55.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p><blockquote><p>注意：事务隔离级别越高，数据越安全，但是性能越低。</p></blockquote><p>Oracle数据库默认的隔离级别是：读已提交。</p><p>MySQL数据库默认的隔离级别是：<strong>可重复读</strong>。</p><div class="code-wrapper"><pre><code class="hljs mysql">#测试隔离级别
设置全局事务隔离级别：mysql&gt; set global transaction isolation level read uncommitted;
					Query OK, 0 rows affected (0.00 sec)
查看隔离级别：SELECT @@tx_isolation
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
mysql默认的隔离级别</code></pre></div><h2 id="二存储引擎">二、存储引擎</h2><h3 id="存储引擎体系结构">2.1、存储引擎体系结构</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240711100432572-2024-7-1110:04:51.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240711100432572" style="zoom:80%"></p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240711100551721-2024-7-1110:05:52.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240711100551721"><figcaption aria-hidden="true">image-20240711100551721</figcaption></figure><h3 id="存储引擎简介">2.2、存储引擎简介</h3><blockquote><p>什么是存储引擎，有什么用呢？</p></blockquote><p>存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）</p><ul><li>存储引擎就是存储/组织数据、建立索引、更新/查询数据等技术的实现方式。</li><li>存储引擎是基于<code>表</code>的，而不是基于库的，所以存储引擎也可被称为表类型。</li><li>不同的存储引擎，表存储数据的方式不同。</li></ul><p>可以在建表的时候给表指定存储引擎。<code>ENGINE</code>来指定存储引擎，<code>CHARSET</code>来指定这张表的字符编码方式。</p><p>查看MySQL支持哪些存储引擎，命令： <code>show engines;</code></p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240711101623788-2024-7-1110:17:12.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240711101623788"><figcaption aria-hidden="true">image-20240711101623788</figcaption></figure><h3 id="myisam存储引擎">2.3、MyISAM存储引擎</h3><p>它管理的表具有以下特征：</p><p>特点</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li><li>可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。</li></ul><p>文件组织结构</p><ul><li>使用三个文件表示每个表：</li><li>格式文件 — 存储表结构的定（mytable.sdi）</li><li>数据文件 — 存储表行的内（mytable.MYD）</li><li>索引文件 — 存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。</li></ul><h3 id="innodb存储引擎">2.4、InnoDB存储引擎</h3><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。</p><ul><li>特点<ul><li>DML操作遵循ACID模型，支持<code>事务</code>；</li><li><code>行级锁</code>，提高并发访问性能；</li><li>支持<code>外键</code> FOREIGN KEY约束，保证数据的完整性和正确性，包括级联删除和更新；</li><li>支持数据库崩溃后自动恢复机制，非常安全。</li></ul></li></ul><p><a href="https://catpaws.top/bd62c17f/#InnoDB存储引擎详解">InnoDB存储引擎详解</a></p><h3 id="memory存储引擎">2.5、MEMORY存储引擎</h3><p>Memory引擎的表数据时存储在<code>内存</code>中的，，且行的长度固定。由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</p><ul><li><p>特点</p><ul><li>数据和索引存放在内存中</li><li>支持hash索引</li><li>支持表锁</li></ul></li><li><p>文件结构</p><p>每个表对应一个 xxxx.sdi 格式的文件，保存表结构信息</p></li></ul><p>MEMORY 存储引擎以前被称为HEAP 引擎。</p><p>MEMORY引擎优点：查询效率 是最高的。不需要和硬盘交互。</p><p>MEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。</p><h3 id="存储引擎的对比与选择">2.6、存储引擎的对比与选择</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712095425856-2024-7-1209:54:46.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712095425856" style="zoom:120%"></p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712100104224-2024-7-1210:01:29.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712100104224"><figcaption aria-hidden="true">image-20240712100104224</figcaption></figure><h2 id="三索引index">三、索引（index）</h2><h3 id="索引概述">3.1、索引概述</h3><p>​ 索引（index）是帮助MySQL<strong>高效获取数据</strong>的<strong>数据结构</strong>（有序）,是为了提高查询效率存在的一种机制。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><ul><li>MySQL在查询方面主要就是两种方式： 第一种方式：全表扫描 (性能低) 第二种方式：根据索引检索。</li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712104938469-2024-7-1210:49:55.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712104938469"><figcaption aria-hidden="true">image-20240712104938469</figcaption></figure><h3 id="索引的数据结构">3.2、索引的数据结构</h3><p>索引是在MySQL体系结构的存储引擎层实现的，不同的存储引擎可以对应不同的索引结构。主要包含以下几种：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712105833956-2024-7-1210:58:58.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712105833956"><figcaption aria-hidden="true">image-20240712105833956</figcaption></figure><p>Full-text索引是基于倒排索引实现的。<a target="_blank" rel="noopener" href="https://b11et3un53m.feishu.cn/wiki/LDLew5xnDiDv7Qk2uPwcoeNpngf">参考ES的倒排索引</a></p><p>各存储引擎对上述索引结构的支持情况：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712105941293-2024-7-1210:59:41.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712105941293"><figcaption aria-hidden="true">image-20240712105941293</figcaption></figure><blockquote><p>B+ tree</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712112351760-2024-7-1211:24:03.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712112351760"><figcaption aria-hidden="true">image-20240712112351760</figcaption></figure><p>B+树的每个结点都是存储在一个页中的，对应于InnoDB存储引擎逻辑结构中的page</p><p><strong>为什么InnoDB存储引擎使用B+tree作为索引结构：</strong></p><ul><li>在相同结点数量下，B+树比二叉树的层级更少，查询一个元素所需的次数更少，搜索效率高。并且当元素顺序插入时，二叉树高度为结点数量，查询效率低。</li><li>树的每个结点保存在一个磁盘块中，从根节点开始查询某关键字需要，将路径上的所有磁盘块读入内存，由于磁盘块大小固定，在B+树中，非叶节点不包含该关键字对应记录的存储地址，只起到索引作用。可以使每个磁盘块包含更多的关键字，使得B+树的阶更大，树高更小，读取磁盘次数更少，查找更快。相比于B树，每个结点中都包含了关键字对应记录的信息，使得每个磁盘块存储的关键字个数变少，树高增大，查找速度变慢。</li><li>相对于Hash索引，其只支持精确匹配，而B+树还支持范围匹配及排序操作</li></ul><blockquote><p>Hash索引</p></blockquote><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712113933352-2024-7-1211:39:55.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712113933352"><figcaption aria-hidden="true">image-20240712113933352</figcaption></figure><p>Hash索引的特点：</p><ul><li>Hash索引只能用于对等比较（=，in），不支持范围查询（between，&gt;，&lt;，...）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于B+tree索引</li></ul><p>在MySQL中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。</p><h3 id="索引分类">3.3、索引分类</h3><ul><li><p>按「数据结构」分类：B+tree索引、Hash索引、R-tree索引、Full-text索引。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712105833956-2024-7-1210:58:58.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p></li><li><p>按「字段特性」分类：主键索引、唯一索引、普通索引、全文索引。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250310210719745-2025-3-1021:07:25.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p></li><li><p>按「字段个数」分类：单列索引、联合索引。</p></li><li><p>按「物理存储存储形式」分类：聚簇索引（主键索引）、二级索引（辅助索引）。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250310211009999-2025-3-1021:10:11.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712151114687-2024-7-1215:11:15.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p><blockquote><p>注：二级索引中不仅仅有该字段对应的聚集索引id，还有索引字段本身的值。</p></blockquote></li></ul><hr><p>回表查询：指通过⼆级索引找到对应的主键值，然后再通过主键值查询聚簇索引中对应的整⾏数据的过程。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712151257432-2024-7-1215:13:03.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p><p>由此可知：当id为主键，且name字段设置了索引的情况下，第一条sql的执行效率更高</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;

<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> &quot;jack&quot;;</code></pre></div><h3 id="sql性能分析">3.4、SQL性能分析</h3><h4 id="sql执行频率">SQL执行频率</h4><p>MySQL客户端连接成功后，通过show[session|global]status命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</p><div class="code-wrapper"><pre><code class="hljs mysql">show global status like &quot;Com_______&quot;;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712154433897-2024-7-1215:45:03.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712154433897"><figcaption aria-hidden="true">image-20240712154433897</figcaption></figure><h4 id="慢查询日志">慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。通过慢查询日志定位执行较慢的sql语句，针对这些慢sql进行优化。</p><p>MySQL的慢查询日志默认没有开启</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712154859197-2024-7-1215:49:03.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712154859197"><figcaption aria-hidden="true">image-20240712154859197</figcaption></figure><p>需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712154916297-2024-7-1215:50:03.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712154916297"><figcaption aria-hidden="true">image-20240712154916297</figcaption></figure><p>当出现慢sql时会记录在localhost-slow.log中，其中对一条慢SQL的记录内容如下</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712160914148-2024-7-1216:09:35.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712160914148"><figcaption aria-hidden="true">image-20240712160914148</figcaption></figure><h4 id="profile详情">profile详情</h4><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了，查看各个sql语句的执行耗时</p><ul><li><p>查看是否支持profile操作</p><div class="code-wrapper"><pre><code class="hljs mysql">select @@have_profiling;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712165548802-2024-7-1216:56:01.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712165548802"><figcaption aria-hidden="true">image-20240712165548802</figcaption></figure></li><li><p>查看是否开启profile功能</p><div class="code-wrapper"><pre><code class="hljs mysql">select @@profiling;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712165651959-2024-7-1216:56:52.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712165651959"><figcaption aria-hidden="true">image-20240712165651959</figcaption></figure></li><li><p>开启profile功能</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> profiling <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712165738387-2024-7-1216:57:38.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712165738387"><figcaption aria-hidden="true">image-20240712165738387</figcaption></figure></li></ul><div class="code-wrapper"><pre><code class="hljs mysql"># 查看每条sql的耗时基本情况
show profiles;

#查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;

#查看指定query_id的SQL语句的cpu使用情况
show profile cpu for query query_id;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712171227231-2024-7-1217:12:27.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712171227231"><figcaption aria-hidden="true">image-20240712171227231</figcaption></figure><h4 id="explain执行计划">explain执行计划</h4><p>使用<code>explain</code>查看指定sql语句的执行计划，了解MySQL如何处理该SQL语句，表的加载顺序，表是如何连接，以及索引使用情况。是SQL优化的重要工具，主要用于分析查询语句或表结构的性能瓶颈。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712220857971-2024-7-1222:09:03.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712220857971"><figcaption aria-hidden="true">image-20240712220857971</figcaption></figure><p>explain 出来的信息有10列，分别是：</p><p>id:选择标识符 select_type:表示查询的类型。 table:输出结果集的表 partitions:匹配的分区 type:表示表的连接类型 possible_keys:表示查询时，可能使用的索引 key:表示实际使用的索引 key_len:索引字段的长度 ref:列与索引的比较 rows:扫描出的行数(估算的行数) filtered:按表条件过滤的行百分比 Extra:执行情况的描述和说明</p><ol type="1"><li><p><code>id</code></p><p>select查询的序列号，表示查询中<strong>执行select子句或者是操作表</strong>的<u>顺序</u></p><ul><li>id相同执行顺序由上到下</li><li>如果是子查询，id的序号会递增。在所有组中，id值越大，优先级越高，越先执行</li></ul><p>例如：查询没有选张三老师课的学生的学号和姓名（见最下SQL练习的第五题）</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 3、返回没有选张三老师课的学生的学号和姓名
SELECT st.s_id, st.s_name
FROM student st
WHERE st.s_id NOT IN (
	-- 2、返回选了张三老师课的学生id
	SELECT DISTINCT s.s_id
	FROM score s 
	WHERE s.c_id IN (
		-- 1、连接course表和teacher表，从中选出张三老师教的所有课的c_id
		SELECT c.c_id 
		FROM
			course c
			INNER JOIN teacher t ON ( c.t_id = t.t_id AND t.t_name = &quot;张三&quot; ) 
	)
);</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712223235874-2024-7-1222:32:46.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240712223235874"><figcaption aria-hidden="true">image-20240712223235874</figcaption></figure><p>从中可以看出内部的多个子查询的id都为2，外部的查询id为1。并且在多个子查询中，操作表的顺序是从内到外的，先是teacher表，再是course表，最后是score表。</p></li><li><p>select_type</p><p>表示查询的类型。</p><ol type="1"><li><p>SIMPLE(简单SELECT，不使用UNION或子查询等)</p></li><li><p>PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</p></li><li><p>SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)</p></li><li><p>DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</p></li><li><p>DERIVED(派生表的SELECT, FROM子句的子查询)</p></li><li><p>UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p></li><li><p>UNION(UNION中的第二个或后面的SELECT语句)</p></li><li><p>DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p></li><li><p>UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)</p></li></ol></li><li><p>table</p><p>显示数据来自于哪个表，有时不是真实的表的名字,可能是简称，例如上面的t，c，也可能是第几步执行的结果的简称。</p></li><li><p>partitions</p></li><li><p><code>type</code></p><p>表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all。</p><ul><li><p>all：Full Table Scan， MySQL将遍历全表以找到匹配的行</p></li><li><p>index: Full Index Scan，all和index都是读全表，但index是从索引中检索的，而all是从硬盘中检索的。index类型只遍历索引树</p></li><li><p>range:只检索给定范围的行，一般条件查询中出现了&gt;、&lt;、in、between等查询，使用一个索引来选择行</p></li><li><p>ref: 使用<u>非唯一行索引</u>进行查询</p></li><li><p>eq_ref: 类似ref，区别就在使用的索引是<u>唯一索引</u>。简单来说，就是多表连接中使用primary key或者 unique key作为关联条件</p></li><li><p>const: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量</p></li><li><p>system是const类型的特例，当查询的表只有一行的情况下，使用system</p></li><li><p>NULL: MySQL在优化过程中分解语句，<u>令其执行时甚至不用访问表或索引</u></p></li></ul></li><li><p><code>possible_keys</code></p><p>显示可能应用在这张表中的索引，但<strong>不一定被查询实际使用</strong></p></li><li><p><code>key</code></p><p>实际使用的索引，如果为NULL，则没有使用索引。</p></li><li><p><code>key_len</code></p><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。一般来说，索引长度越长表示精度越高，效率偏低；长度越短，效率高，但精度就偏低。并不是真正使用索引的长度，是个预估值。</p></li><li><p>ref</p><p>哪些列或常量被用于查找索引列上的值</p></li><li><p>rows</p><p>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</p></li><li><p>filtered</p><p>表示返回结果的行数占需读取行数的百分比，filtered 的值越大越好。</p></li><li><p><code>Extra</code></p><p>一些重要的额外信息</p><ul><li><strong>Using filesort</strong>：使用外部的索引排序，而不是按照表内的索引顺序进行读取。（一般需要优化）</li><li><strong>Using temporary</strong>：使用了临时表保存中间结果。常见于排序order by和分组查询group by（最好优化）</li><li><strong>Using index</strong>：表示select语句中使用了覆盖索引，直接从索引中取值，而不需要回表查询（从磁盘中取数据）</li><li>Using where：使用了where过滤</li><li>Using index condition：表示查询的列有非索引的列，需要进行回表查询</li><li>Using join buffer：使用了连接缓存</li><li>impossible where： where子句的值总是false</li></ul></li></ol><h3 id="索引使用规则">3.5、索引使用规则</h3><h4 id="验证索引的效率">验证索引的效率</h4><div class="code-wrapper"><pre><code class="hljs mysql">-- 在user表中插入100万数据，再查询其中一条数据，感受加不加索引的区别

CREATE TABLE `app_user` (
`id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,
`name` VARCHAR(50) DEFAULT &#x27;&#x27;,
`email` VARCHAR(50) NOT NULL,
`phone` VARCHAR(20) DEFAULT &#x27;&#x27;,
`gender` TINYINT(4) UNSIGNED DEFAULT &#x27;0&#x27;,
`password` VARCHAR(100) NOT NULL DEFAULT &#x27;&#x27;,
`age` TINYINT(4) DEFAULT NULL,
`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,
`update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
PRIMARY KEY (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8


-- SET GLOBAL log_bin_trust_function_creators = 1;-- 开启创建函数功能
/*
  第一个语句 delimiter 将 mysql 解释器命令行的结束符由”;” 改成了”$$”，
  让存储过程内的命令遇到”;” 不执行
*/
DELIMITER $$
CREATE FUNCTION mock_data()
RETURNS INT
BEGIN
	DECLARE num INT DEFAULT 1000000;
	DECLARE i INT DEFAULT 0;
	WHILE i&lt;num DO
		INSERT INTO `app_user`(`name`,`email`,`phone`,`gender`)VALUES(CONCAT(&#x27;用户&#x27;,i),&#x27;19224305@qq.com&#x27;,&#x27;123456789&#x27;,FLOOR(RAND()*2));
		SET i=i+1;
	END WHILE;
	RETURN i;
END;$$

SELECT mock_data()$$ -- 执行此函数 生成一百万条数据



-- 不加索引查询
SELECT * FROM `app_user` WHERE `name` = &#x27;用户99999&#x27;
&gt; OK
&gt; 时间: 0.332s
-- 添加索引后查询
CREATE INDEX index_app_user_name ON app_user ( `name` );

SELECT * FROM `app_user` WHERE `name` = &#x27;用户99999&#x27;
&gt; OK
&gt; 时间: 0.001s</code></pre></div><h4 id="最左前缀法则">最左前缀法则</h4><p>如果索引了多列（联合索引），要遵守最左前缀法则。</p><p><strong>最左前缀法则</strong>指的是在查询时，必须从联合索引的最左边开始，并且不能跳过索引中的列。</p><ul><li><p>如果查询条件中缺失最左侧的索引字段，则后面的字段查询都不会使用索引。</p></li><li><p>如果跳跃某一列，则该列后面的字段索引失效（部分失效）</p></li></ul><p>例如：在tb_user表中，已对 profession、age、status建立了联合索引，现验证最左前缀法则</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713171404644-2024-7-1317:14:16.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713171404644"><figcaption aria-hidden="true">image-20240713171404644</figcaption></figure><p><code>explain select * from tb_user where profession =·软件工程'and age = 31 and status = '0';</code>该sql语句符合最左前缀法则，索引已生效，联合索引字段长度为54</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713171720088-2024-7-1317:17:20.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713171720088"><figcaption aria-hidden="true">image-20240713171720088</figcaption></figure><p><code>explain select * from tb_user where age = 31 and status = '0';</code>此sql语句中最左侧索引字段缺失，该语句未使用索引</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713172401186-2024-7-1317:24:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713172401186"><figcaption aria-hidden="true">image-20240713172401186</figcaption></figure><p><code>explain select * from tb_user where profession = 软件工程'and age = 31；</code>此sql语 句中索引最左侧字段存在，且中间没有缺失其他索引字段，故索引也生效，此时索引长度为49</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713172135947-2024-7-1317:21:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713172135947"><figcaption aria-hidden="true">image-20240713172135947</figcaption></figure><p><code>explain select * from tb_user where profession =·软件工程'and status = '0';</code></p><p>该sql语句中，只提供了联合索引中的profession和status字段，中间的age字段缺失，此时索引部分生效，索引字段长度为47，只有profession的查询使用了索引，但status没有使用索引</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713172650355-2024-7-1317:27:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713172650355"><figcaption aria-hidden="true">image-20240713172650355</figcaption></figure><h4 id="索引失效情况">索引失效情况</h4><ol type="1"><li><p>索引列运算</p><p>不要在索引列上进行运算操作，<code>索引将失效</code>。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713174016271-2024-7-1317:40:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713174016271"><figcaption aria-hidden="true">image-20240713174016271</figcaption></figure></li><li><p>字符串不加引号</p><p>字符串类型字段使用时未加引号，会进行隐式类型转换造成<code>索引将失效</code>。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713174559698-2024-7-1317:46:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713174559698"><figcaption aria-hidden="true">image-20240713174559698</figcaption></figure></li><li><p>模糊查询</p><p>如何仅仅是尾部模糊匹配，索引仍会生效。但如果是头部模糊匹配，索引失效。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713175107252-2024-7-1317:51:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713175107252"><figcaption aria-hidden="true">image-20240713175107252</figcaption></figure></li><li><p>范围查询右边的列，不能使用索引。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250310220922166-2025-3-1022:09:23.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p></li><li><p>or连接的条件</p><p>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。（前边有索引但后边没有，则索引不会生效；两边都有索引时，索引才会生效）</p><p>例如：在tb_user表中，age字段没有建立索引。执行<code>select * from tb_user where id = 10 or age = 23;</code>时，由于id为主键，存在主键索引，但age没有索引，执行过程中索引不会生效。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713175731784-2024-7-1317:57:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713175731784"><figcaption aria-hidden="true">image-20240713175731784</figcaption></figure><p>为age字段建立索引后，再执行该语句</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713180018863-2024-7-1318:00:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713180018863"><figcaption aria-hidden="true">image-20240713180018863</figcaption></figure></li><li><p>数据分布</p><p>如果MySQL评估使用索引比全表扫描更慢，则不使用索引。</p><p>比如在一张表中已对某个字段建立了索引，但使用该索引字段查询到的结果<u>基本上是整张表的数据，或是整张表的大部分数据</u>，经过MySQL评估后，不会使用索引而是进行全表扫描（<code>避免进行回表查询</code>）。但若是主键索引，即使查询结果时整张表的数据，但还是一定会使用主键索引。</p><p>例：tb_user表中，已对phone字段建立了索引，且表中phone的最小值为 "17799990000"。执行</p><p><code>select * from tb_user where phone &gt;= '17799990000';</code>得到的结果为整张表的数据，查看该sql的执行计划可知，索引不会生效</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713181911044-2024-7-1318:19:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713181911044"><figcaption aria-hidden="true">image-20240713181911044</figcaption></figure><p>但若是主键索引一定会生效，如：dish表中id最小为46，执行<code>select * from dish where id &gt;= 46</code>得到的也是整张表的数据，但主键索引还是生效了</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713182126019-2024-7-1318:21:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713182126019"><figcaption aria-hidden="true">image-20240713182126019</figcaption></figure></li></ol><h4 id="sql提示">SQL提示</h4><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713183235664-2024-7-1318:32:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713183235664"><figcaption aria-hidden="true">image-20240713183235664</figcaption></figure><h4 id="覆盖索引">覆盖索引</h4><p>覆盖索引是指：指查询使用了索引，返回的列，必须在索引中全部能够找到</p><blockquote><p>如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select*</p></blockquote><p>例：在tb_user表中，已经对 profession，age，status建立了联合索引，分别执行以下sql，查看其执行计划。</p><p>1、<code>select id, profession,age,status from tb_user where profession = '软件工程' and age = 31 and status = '0';</code>其执行计划中Extra列的信息为：<u>Using where; Using index</u></p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713185911831-2024-7-1318:59:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713185911831"><figcaption aria-hidden="true">image-20240713185911831</figcaption></figure><p>2、<code>select id, profession,age,status, name from tb_user where profession = '软件工程' and age = 31 and status = '0';</code>相比于上一条sql，这条sql的查询结果中需要返回的列多了一个name字段。其执行计划的Extra列的信息为：<u>Using index condition</u></p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713185952078-2024-7-1319:00:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713185952078"><figcaption aria-hidden="true">image-20240713185952078</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713190303548-2024-7-1319:03:04.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240713190303548"><figcaption aria-hidden="true">image-20240713190303548</figcaption></figure><p>由于对profession、age、status建立的联合索引索引二级索引（辅助索引），在二级索引的叶子结点中不仅包含了对应索引字段的值，还包括该记录对应的聚集索引的id（一般是主键id）。</p><p>故对应第一条sql语句，其需要返回的字段在二级索引树上全部都能查到，直接返回结果，一次索引扫描即可，不需要回表查询。但对于第二条sql，其返回结果中多出了二级索引树上没有的name字段，此时需要根据当前的聚集索引id，在聚集索引中进行回表查询，得到完整的记录，从中得到name字段，整合后返回。</p><p>图示如下：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713190928026-2024-7-1319:09:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="是覆盖索引"><figcaption aria-hidden="true">是覆盖索引</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240713191033317-2024-7-1319:10:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="不是覆盖索引，需要回表查询"><figcaption aria-hidden="true">不是覆盖索引，需要回表查询</figcaption></figure><hr><p>思考：一张表，有四个字段（id，username，password，status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250310213250626-2025-3-1021:32:53.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p><p>答：对username 和 password建立联合索引，使用覆盖索引，避免回表查询</p><h4 id="前缀索引">前缀索引</h4><p>一、前缀索引 当字段类型为字符串（ varchar ， text ， longtext 等）时，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘 IO ， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><ol type="1"><li>语法</li></ol><p></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_xxxx <span class="hljs-keyword">on</span> table_name(<span class="hljs-keyword">column</span>(n)) ;</code></pre></div><p></p><p>示例:</p><p>为 tb_user 表的 email 字段，建立长度为 5 的前缀索引。</p><p></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index index_email <span class="hljs-keyword">on</span> tb_user(email(<span class="hljs-number">5</span>));</code></pre></div><p></p><figure><img src="https://img-blog.csdnimg.cn/direct/315660d9baf0456db40d15ffd11f4475.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="前缀索引-1"><figcaption aria-hidden="true">前缀索引-1</figcaption></figure><ol start="2" type="1"><li>如何选择前缀长度 可以根据索引的<code>选择性</code>来决定，而选择性是指<code>不重复的索引值（基数）</code>和<code>数据表的记录总数</code>的<strong>比值</strong>，索引选择性越高则查询效率越高， 唯一索引的选择性是1 ，这是最好的索引选择性，性能也是最好的。</li></ol><p>下面这里我们看一下案例：</p><p></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> email)<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user;</code></pre></div><p></p><figure><img src="https://img-blog.csdnimg.cn/direct/12ffdc72e70f42eeb16dc585ab7bb7aa.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="前缀索引-2"><figcaption aria-hidden="true">前缀索引-2</figcaption></figure><p>可以看到上面显示的是1，也就是说所有的email字段的数据都没有出现重复，下面我们去从email字段数据去截取前5个字符比较试试看：</p><p></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-built_in">substring</span>(email,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user ;</code></pre></div><p></p><figure><img src="https://img-blog.csdnimg.cn/direct/12ffdc72e70f42eeb16dc585ab7bb7aa.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="前缀索引-3"><figcaption aria-hidden="true">前缀索引-3</figcaption></figure><p>这里我们可以看出出现重复了，但是非重复率还是有0.9583的，如果我们截取前4个或者前6个字符再试试看重复率：</p><p></p><div class="code-wrapper"><pre><code class="hljs sql">#截取前四个
<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-built_in">substring</span>(email,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user ;</code></pre></div><p></p><figure><img src="https://img-blog.csdnimg.cn/direct/f673ce33855541d498f0e8c8d7e5ade5.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="前缀索引-4"><figcaption aria-hidden="true">前缀索引-4</figcaption></figure><p></p><div class="code-wrapper"><pre><code class="hljs sql">#截取前<span class="hljs-number">6</span>个
<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-built_in">substring</span>(email,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user ;</code></pre></div><p></p><figure><img src="https://img-blog.csdnimg.cn/direct/85b0f173fd704df1aab543ea750dfec3.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="前缀索引-5"><figcaption aria-hidden="true">前缀索引-5</figcaption></figure><p>上面这两个对比就知道，截取前4个的话重复率变大了，而截取前6个的话重复率不变 ，故最优解就是截取前面前5个即可。</p><ol start="3" type="1"><li>前缀索引的查询流程 前缀索引的查询流程基本上跟前面讲到过的是差不多的，这里会通过我们选择好的前缀去建立一个辅助索引，在辅助索引上面去找到相对应的索引目标，如果出现重复的话就会先找到第一个重复的索引数据，然后再去进行回表查询得到对应行完整的数据，如果完整数据中的对应字段与查询条件相同，则返回改行数据；反之继续遍历下一个重复的结果。</li></ol><figure><img src="https://img-blog.csdnimg.cn/direct/5914eaa0180445c6b12f2c8ebc41c2ee.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="前缀索引-6"><figcaption aria-hidden="true">前缀索引-6</figcaption></figure><h4 id="单列索引联合索引">单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列。</p><p>联合索引：即一个索引包含了多个列。</p><p>查看当前tb_user表中建立的索引情况：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240719100709418-2024-7-1910:07:44.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240719100709418"><figcaption aria-hidden="true">image-20240719100709418</figcaption></figure><p>在tb_user表中已经针对 phone和name分别建立了单列索引，此时执行一条sql，以phone和name为查询条件，查看其执行计划</p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,phone,name <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> phone<span class="hljs-operator">=</span><span class="hljs-string">&#x27;17799990000&#x27;</span> <span class="hljs-keyword">and</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;吕布&#x27;</span>;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240719101022564-2024-7-1910:10:22.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240719101022564"><figcaption aria-hidden="true">image-20240719101022564</figcaption></figure><p>可能用到的索引为index_phone和index_name，但实际上在执行这条sql时MySQL只用到了其中的一个索引index_phone。在针对phone建立的索引树中并没有name字段，故还要进行回表查询。</p><p>对phone和name建立联合索引后，执行该sql，再次查询执行计划</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index idx_user_phone_name <span class="hljs-keyword">on</span> tb_user(phone,name);
explain <span class="hljs-keyword">select</span> id,phone,name <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> phone<span class="hljs-operator">=</span><span class="hljs-string">&#x27;17799990000&#x27;</span> <span class="hljs-keyword">and</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;吕布&#x27;</span>;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240719101448693-2024-7-1910:14:52.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240719101448693"><figcaption aria-hidden="true">image-20240719101448693</figcaption></figure><p>发现此时，MySQL使用的还是index_phone。<u>在多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。</u></p><p>此时可以通过SQL提示，建议MySQL使用联合索引，而在联合索引中包含 phone、name的信息，在叶子节点下挂的是对应的主键id，所以查询是无需回表查询的。</p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,phone,name <span class="hljs-keyword">from</span> tb_user use index(idx_user_phone_name)<span class="hljs-keyword">where</span> phone<span class="hljs-operator">=</span><span class="hljs-string">&#x27;17799990010&#x27;</span> <span class="hljs-keyword">and</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;韩信&#x27;</span>;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240719101848501-2024-7-1910:18:52.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240719101848501"><figcaption aria-hidden="true">image-20240719101848501</figcaption></figure><blockquote><p><strong>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</strong></p></blockquote><p>如果查询使用的是联合索引，具体的结构示意图如下：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240719102106348-2024-7-1910:21:52.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240719102106348"><figcaption aria-hidden="true">image-20240719102106348</figcaption></figure><p>根据索引定义顺序，在B+树中先按照phone进行排序，phone相同再按照name进行排序。注意联合索引使用时要遵循<code>最左前缀法则</code>。</p><h3 id="索引设计原则">3.6、索引设计原则</h3><p>针对什么表建立索引？针对表中的那些字段建立索引？建立什么类型的索引？</p><ol type="1"><li>针对于数据量较大，且<strong>查询比较频繁</strong>的表建立索引。</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li>尽量选择区<strong>分度高的列</strong>作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li><strong>尽量使用联合索引，减少单列索引</strong>，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。注意联合索引使用时要遵循<code>最左前缀法则</code>。</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><h2 id="四sql优化">四、SQL优化</h2><h3 id="插入数据">4.1、插入数据</h3><p>平时我们插入数据的时候一般都是一个语句插一个数据，如下所示：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;tom&#x27;</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;cat&#x27;</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;jerry&#x27;</span>);
.....</code></pre></div><p>每条insert语执行时都需要和MySQL建立/释放连接，开启和提交事务，执行SQL语句，进行数据传输，当时数据量较大时效率很低。</p><p>如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p><ol type="1"><li><p>insert插入的优化方案</p><p>（1）优化方案一：<strong>批量插入</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">Insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);</code></pre></div><p>相较于一条语句插入一个数据，一次性插入批量数据效率必然是更高的，这就不需要多次开启和提交事务了，节约时间。</p><p>（2）优化方案二：<strong>手动提交事务</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">start</span> transaction;
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);
<span class="hljs-keyword">commit</span>;</code></pre></div><p>手动控制事务，其实这个语句的就是方法1的本质，也就是通过一次事务去提交，避免多次开启事务的情况。</p><p>（3）优化方案三：<strong>主键顺序插入</strong></p><p>主键顺序插入，性能要高于乱序插入。这个应该没什么好多说了，排序肯定是需要耗时间的。</p><div class="code-wrapper"><pre><code class="hljs bash">主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3
主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89</code></pre></div></li><li><p>大批量插入数据 如果一次性需要插入大批量数据 ( 比如 : 几百万的记录 ) ，使用 insert 语句插入性能较低，此时可以使用 MySQL 数据库提供的<code>load指令</code>进行插入(<strong>在load时，主键顺序插入性能高于乱序插入</strong>)。操作如下： <img src="https://img-blog.csdnimg.cn/direct/8cdd02cbdfb64c6c9d181e69ec7d6e9b.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="load指令"></p><p>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 客户端连接服务端时，加上参数 -–local-infile
mysql –-local-infile -u root -p
 
-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile = 1;
 
-- 执行load指令将准备好的数据，加载到表结构中
load data local infile &#x27;/root/sql1.log&#x27; into table tb_user fields
terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27; ;</code></pre></div><p>补充：对于load指令的语句中，fields terminated by意思是每一个字段之间间隔符号用什么</p><p>lines terminated by意思是每一行间距是用什么。</p></li></ol><h3 id="主键优化">4.2、主键优化</h3><p>在上面，我们提到，主键顺序插入的性能是要高于乱序插入的。 这一小节，就来介绍一下具体的原因，然后再分析一下主键又该如何设计。</p><ol type="1"><li><p><strong>数据组织方式</strong></p><p>在 InnoDB 存储引擎中，<strong>表数据都是根据主键顺序组织存放的</strong>，这种存储方式的表称为索引组织表(index organized table IOT)</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093108993-2024-7-2009:31:12.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720093108993"><figcaption aria-hidden="true">image-20240720093108993</figcaption></figure><p>行数据，都是存储在聚集索引的叶子节点上的。而根据 InnoDB 的逻辑结构图：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240711104512418-2024-7-1110:45:17.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240711104512418"><figcaption aria-hidden="true">image-20240711104512418</figcaption></figure><p>在 InnoDB 引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认 16K 。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row 在该页存储不下，将会存储到下一个页中，页与页之间会通过指针连接。</p></li><li><p><strong>页分裂</strong></p><p>页可以为空，也可以填充一半，也可以填充 100% 。每个页包含了 2-N 行数据 ( 如果一行数据过大，会行溢出) ，根据主键排列。</p><blockquote><p>主键顺序插入效果</p></blockquote><p>① . 从磁盘中申请页， 主键顺序插入</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093553745-2024-7-2009:35:54.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720093553745"><figcaption aria-hidden="true">image-20240720093553745</figcaption></figure><p>②. 第一个页没有满，继续往第一页插入</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093614767-2024-7-2009:36:23.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720093614767"><figcaption aria-hidden="true">image-20240720093614767</figcaption></figure><p>③ . 当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093649301-2024-7-2009:37:23.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720093649301"><figcaption aria-hidden="true">image-20240720093649301</figcaption></figure><p>④. 当第二页写满了，再往第三页写入</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093735297-2024-7-2009:38:24.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720093735297"><figcaption aria-hidden="true">image-20240720093735297</figcaption></figure><blockquote><p>主键乱序插入效果</p></blockquote><p>① . 当1#,2#页都已经写满了，存放了如图所示的数据</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093843413-2024-7-2009:39:23.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720093843413"><figcaption aria-hidden="true">image-20240720093843413</figcaption></figure><p>② . 此时再插入 id 为 50 的记录，我们来看看会发生什么现象</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093908409-2024-7-2009:40:23.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720093908409"><figcaption aria-hidden="true">image-20240720093908409</figcaption></figure><p>会再次开启一个页，写入新的页中吗？答案是不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在 47 之后。但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093956540-2024-7-2009:41:23.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720093956540"><figcaption aria-hidden="true">image-20240720093956540</figcaption></figure><p>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720094028985-2024-7-2009:42:16.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720094028985"><figcaption aria-hidden="true">image-20240720094028985</figcaption></figure><p>此时，这三个页之间的数据顺序是有问题的。 1# 的下一个页，应该是3# ， 3# 的下一个页是 2# 。 所以，此时，需要重新设置链表指针。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720094114446-2024-7-2009:42:19.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720094114446"><figcaption aria-hidden="true">image-20240720094114446</figcaption></figure><p>上述的这种现象，称之为 "<code>页分裂</code>"，是比较耗费性能的操作。</p></li><li><p>页合并</p><p>目前表中已有数据的索引结构 ( 叶子节点)如下：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720094212022-2024-7-2009:42:20.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720094212022"><figcaption aria-hidden="true">image-20240720094212022</figcaption></figure><p>当我们对已有数据进行删除时，具体的效果如下 :</p><p>当删除一行记录时<u>，实际上记录并没有被物理删除，只是记录被标记（ flaged ）为删除并且它的空间变得允许被其他记录声明使用。</u></p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720094328067-2024-7-2009:43:28.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720094328067"><figcaption aria-hidden="true">image-20240720094328067</figcaption></figure><p>继续删除2#的内容，当页中删除的记录达到 MERGE_THRESHOLD （默认为页的 50% ），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720094843818-2024-7-2009:49:18.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720094843818"><figcaption aria-hidden="true">image-20240720094843818</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720094915435-2024-7-2009:49:19.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720094915435"><figcaption aria-hidden="true">image-20240720094915435</figcaption></figure><p>这个里面所发生的合并页的这个现象，就称之为 "<code>页合并</code>"</p></li><li><p><strong>主键设计原则</strong></p><ul><li>满足业务需求的情况下，尽量降低主键的长度。（<u>在二级索引的叶子结点中保存着主键，如果主键过长，二级索引较多，会占用较大的磁盘空间，且在搜索时会进行大量的磁盘IO</u> ）</li><li>插入数据时，尽量选择顺序插入。（<u>乱序插入可能会导致页分裂，插入效率低</u>）</li><li>选择使用AUTO_INCREMENT自增主键，尽量不要使用UUID做主键或者是其他自然主键，如身份证号。（<u>这些是无序的，且长度较长</u>）</li><li>业务操作时，避免对主键的修改。（<u>还要修改二级索引的内容</u>）</li></ul></li></ol><h3 id="order-by优化">4.3、order by优化</h3><p>MySQL 的排序，有两种方式：</p><ul><li>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在<u>排序缓冲区sort buffer中完成排序操作</u>，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。（如果缓冲区满了，会进一步在磁盘中进行排序）</li><li>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要 额外排序，操作效率高。</li></ul><p><strong>对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为Using index。</strong></p><p>SQL排序使用了哪种方式，可以通过<code>explain</code>在SQL语句执行计划的 Extra字段查看</p><blockquote><p>测试索引对排序的效果</p></blockquote><p>1、在tb_user表中，删除age和phone的索引，再根据这两个字段进行排序，查看其执行计划.</p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id ,age ,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720101450542-2024-7-2010:14:50.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720101450542"><figcaption aria-hidden="true">image-20240720101450542</figcaption></figure><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age, phone ;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720101228160-2024-7-2010:12:33.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720101228160"><figcaption aria-hidden="true">image-20240720101228160</figcaption></figure><p>由于 age, phone 都没有索引，所以此时再排序时，出现Using filesort， 排序性能较低。</p><p>2、创建索引后，再次进行排序，查看执行计划</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建索引</span>
<span class="hljs-keyword">create</span> index idx_age_phone <span class="hljs-keyword">on</span> tb_user(age,phone);</code></pre></div><blockquote><p>默认age和phone都是升序建立的索引</p></blockquote><p>A. 根据age, phone进行<strong>升序排序</strong></p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720101717524-2024-7-2010:17:17.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720101717524"><figcaption aria-hidden="true">image-20240720101717524</figcaption></figure><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age , phone;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720101747424-2024-7-2010:18:10.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720101747424"><figcaption aria-hidden="true">image-20240720101747424</figcaption></figure><p>B. 根据age，phone进行<strong>降序排序</strong></p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">desc</span> , phone <span class="hljs-keyword">desc</span> ;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720102255101-2024-7-2010:22:55.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720102255101"><figcaption aria-hidden="true">image-20240720102255101</figcaption></figure><blockquote><p>注：由于age和phone都是升序建立的索引，当排序时两者都是升序，排序方式是Using index；当两者都是降序时，Extra中也是Using index，但多了 Backward index scan，这个代表反向扫描索引，因为在 MySQL 中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan 。</p></blockquote><ol start="3" type="A"><li><strong>对于排序使用联合索引的情况，排序时 , 也需要满足最左前缀法则 , 否则也会出现 filesort 。</strong>因为在创建索引的时候， age 是第一个字段， phone 是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using filesort。</li></ol><p>D. 排序时<strong>根据age升序排序，根据phone降序排序</strong></p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span> ,phone <span class="hljs-keyword">desc</span> ;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720102448603-2024-7-2010:25:15.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720102448603"><figcaption aria-hidden="true">image-20240720102448603</figcaption></figure><p>因为创建索引时，如果未指定顺序，默认都是按照升序排序的（A是表示升序asc，D的话是表示降序desc），而<strong>查询时，一个升序，一个降序，此时就会出现Using filesort</strong> 。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720102604013-2024-7-2010:26:04.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720102604013"><figcaption aria-hidden="true">image-20240720102604013</figcaption></figure><p>为了解决上述问题，为了解决上述的问题，我们可以创建一个索引，这个联合索引中 age 升序排序， phone 倒序排序。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_age_phone_ad <span class="hljs-keyword">on</span> tb_user(age <span class="hljs-keyword">asc</span> ,phone <span class="hljs-keyword">desc</span>);</code></pre></div><p>再次执行上述排序SQL,查看其执行计划，其中排序方法为Using index</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240720103026285-2024-7-2010:30:34.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240720103026285"><figcaption aria-hidden="true">image-20240720103026285</figcaption></figure><p><strong>由上述的测试,我们得出order by优化原则:</strong></p><p>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p><p>B. 尽量使用覆盖索引。（以上排序方法为Using index 的前提是使用覆盖索引，否则要进行回表查询，得到数据后在排序缓冲区中进行排序，效率低）</p><p>C. 多字段排序 , 一个升序一个降序，此时需要注意联合索引在创建时的规则（ ASC/DESC ）。</p><p>D. 如果不可避免的出现 filesort ，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认 256k) 。</p><h3 id="group-by优化">4.4、group by优化</h3><p>在分组操作时，可以通过索引来提高效率 （尽量建立联合索引）。</p><ol type="A"><li>在没有索引的情况下，执行如下 SQL ，查询执行计划：</li></ol><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> profession , <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> profession ;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721100347253-2024-7-2110:03:50.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721100347253"><figcaption aria-hidden="true">image-20240721100347253</figcaption></figure><p>B. 针对于 profession ， age ， status 创建一个联合索引后执行相同的SQL，查看执行计划</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建联合索引</span>
<span class="hljs-keyword">create</span> index idx_user_pro_age_sta <span class="hljs-keyword">on</span> tb_user(profession , age , status);

<span class="hljs-comment">--执行上述SQL</span>
explain <span class="hljs-keyword">select</span> profession , <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> profession ;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721100608323-2024-7-2110:06:09.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721100608323"><figcaption aria-hidden="true">image-20240721100608323</figcaption></figure><blockquote><p><strong>注：在Group By中使用联合索引也要遵循最左前缀法则</strong></p></blockquote><h3 id="limit优化">4.5、limit优化</h3><p><strong>对应limit分页操作，在大数据的情况下，分页内容越靠后效率越低</strong>。如：limit 2000000，10，此时需要MySQL排序前2000010 记录，仅仅返回2000000-2000010的记录，其他记录丢弃，查询排序的代价非常大。</p><p>优化策略：<strong>覆盖索引 + 子查询</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--在 tb_sku表中查询 2000000 ~ 2000010范围内的数据</span>

<span class="hljs-comment">-- 先查询到该范围内记录的id，此时使用了覆盖索引，再将查询到的id作为临时表与原表关联后做等价查询</span>
<span class="hljs-keyword">select</span> t.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_sku t, (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">2000000</span>,<span class="hljs-number">10</span>) a
<span class="hljs-keyword">where</span> t.id <span class="hljs-operator">=</span> a.id;</code></pre></div><h3 id="count优化">4.6、count优化</h3><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user ;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721102724886-2024-7-2110:27:49.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721102724886"><figcaption aria-hidden="true">image-20240721102724886</figcaption></figure><p>优化思路：<strong>自己计数</strong>，利用key-value内存级别的数据库，如Redis，在其中设置一个字段total保存表中记录数。当在表中新增一条记录时，total加1；当在表中删除一条记录时，total减一。</p><p><strong>常见count的几种用法和其效率的对比：</strong></p><blockquote><p><strong>count（）是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。</strong></p></blockquote><ul><li><p>count（主键）</p><p>InnoDB 引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加（主键不可能为null）。</p></li><li><p>count（字段）</p><p>没有not null约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。</p><p>有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</p></li><li><p>count（数字）</p><p>InnoDB 引擎遍历整张表，但<strong>不取值</strong>。服务层对于返回的每一行，放一个数字（如0,-1,1等）进去，直接按行进行累加。</p></li><li><p>count（*）</p><p>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，<strong>不取值</strong>，服务层直接按行进行累加。</p></li></ul><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721103622142-2024-7-2110:36:26.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721103622142"><figcaption aria-hidden="true">image-20240721103622142</figcaption></figure><h3 id="update优化">4.7、update优化</h3><blockquote><p><strong>InnoDB的行锁是针对<u>索引</u>加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</strong></p></blockquote><p>在执行update语句时要根据索引字段进行选择，否则行锁就会升级为表锁，降低并发性能。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721104513524-2024-7-2110:45:49.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721104513524"><figcaption aria-hidden="true">image-20240721104513524</figcaption></figure><h3 id="总结">总结</h3><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721105139164-2024-7-2110:51:49.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721105139164"><figcaption aria-hidden="true">image-20240721105139164</figcaption></figure><h2 id="五视图存储过程触发器">五、视图/存储过程/触发器</h2><h3 id="视图">5.1、视图</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=97&amp;vd_source=51d78ede0a0127d1839d6abf9204d1ee">参考视频</a></p><p>什么是视图？</p><p>视图：站在不同的角度去看待同一份数据。</p><h4 id="视图创建和删除">视图创建和删除</h4><p>创建视图对象：</p><p></p><div class="code-wrapper"><pre><code class="hljs mysql">create view dept2_view as select * from dept2;</code></pre></div><p></p><blockquote><p>注意：</p><p>只有DQL语句才能以view的形式创建。 <code>create view view_name as</code> 这里的语句必须是DQL语句;</p></blockquote><p>删除视图对象：</p><div class="code-wrapper"><pre><code class="hljs mysql">drop view dept2_view;</code></pre></div><h4 id="视图的用途">视图的用途</h4><p>方便，简化开发，利于维护。我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致 原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）</p><div class="code-wrapper"><pre><code class="hljs mysql">//面向视图查询
select * from dept2_view; 

// 面向视图插入
insert into dept2_view(deptno,dname,loc) values(60,&#x27;SALES&#x27;, &#x27;BEIJING&#x27;);

// 查询原表数据
mysql&gt; select * from dept2;
+--------+------------+----------+
| DEPTNO | DNAME      | LOC      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
|     60 | SALES      | BEIJING  |
+--------+------------+----------+

// 面向视图删除
mysql&gt; delete from dept2_view;

// 查询原表数据
mysql&gt; select * from dept2;
Empty set (0.00 sec)</code></pre></div><p>​ 假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？可以把这条复杂的SQL语句以视图对象的形式新建。在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要修改视图对象所映射的SQL语句。</p><p>​ 我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。可以对视图进行增删改查等操作。视图不是在内存当中，视图对象也是存储在硬盘上的，不会消失。</p><h3 id="存储过程">5.2、存储过程</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=102&amp;vd_source=51d78ede0a0127d1839d6abf9204d1ee">参考视频</a></p><h3 id="触发器">5.3、触发器</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=116&amp;vd_source=51d78ede0a0127d1839d6abf9204d1ee">参考视频</a></p><h2 id="六锁">六、锁</h2><h3 id="概述">6.1、概述</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM，I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>分类：MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ul><h3 id="全局锁">6.2、全局锁</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于<strong>只读状态</strong>，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 添加全局锁
flush tables with read lock;

-- 释放全局锁
unlock tables;</code></pre></div><p>其典型的使用场景是<strong>做全库的逻辑备份</strong>，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。其过程如下：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721111958996-2024-7-2111:20:02.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721111958996"><figcaption aria-hidden="true">image-20240721111958996</figcaption></figure><p>注：在终端命令行中运行 mysqldump命令，不要登录了MySQL再用。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721113057150-2024-7-2111:31:35.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721113057150"><figcaption aria-hidden="true">image-20240721113057150</figcaption></figure><h3 id="表级锁">6.3、表级锁</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM，InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为一下三类：</p><ul><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li></ul><h4 id="表锁">表锁</h4><p>​ <img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721183519013-2024-7-2118:35:49.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721183519013"></p><h4 id="元数据锁">元数据锁</h4><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721185606540-2024-7-2118:56:11.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721185606540"><figcaption aria-hidden="true">image-20240721185606540</figcaption></figure><h4 id="意向锁">意向锁</h4><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721191002372-2024-7-2119:10:25.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721191002372"><figcaption aria-hidden="true">image-20240721191002372</figcaption></figure><p><strong>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</strong>添加意向锁后，再添加表锁，直接根据意向锁以及意向锁的类型，判断当前表锁能否添加成功，不用再逐行检查。</p><blockquote><p><strong>意向锁分类以及和表锁的兼容情况</strong></p></blockquote><p><strong>意向锁的分类</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721191411802-2024-7-2119:14:12.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721191411802"></p><p><strong>与表锁的兼容情况</strong></p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721191539971-2024-7-2119:15:49.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721191539971"><figcaption aria-hidden="true">image-20240721191539971</figcaption></figure><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><div class="code-wrapper"><pre><code class="hljs mysql">select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks;</code></pre></div><h3 id="行级锁">6.4、行级锁</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p><strong>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的</strong>锁。对于行级锁，主要分为以下三类：</p><p>1.行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721192230333-2024-7-2119:22:49.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721192230333">2.间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721192259087-2024-7-2119:23:49.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721192259087">3.临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721192315885-2024-7-2119:24:49.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721192315885"><figcaption aria-hidden="true">image-20240721192315885</figcaption></figure><h4 id="行锁">行锁</h4><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721192932330-2024-7-2119:29:49.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721192932330"><figcaption aria-hidden="true">image-20240721192932330</figcaption></figure><p>常见数据库操作语句锁添加的锁的类型：</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721193132992-2024-7-2119:31:49.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="image-20240721193132992"><figcaption aria-hidden="true">image-20240721193132992</figcaption></figure><h2 id="七innodb存储引擎详解">七、InnoDB存储引擎详解</h2><h3 id="逻辑存储结构">7.1、逻辑存储结构</h3><p>InnoDB 是 MySQL 的默认存储引擎，其逻辑存储结构以 <strong>表空间（Tablespace）</strong> 为核心，通过分层设计实现高效的数据管理和事务支持。以下是其核心逻辑单元的层次关系：</p><div class="code-wrapper"><pre><code class="hljs bash">表空间（Tablespace）→ 段（Segment）→ 区（Extent）→ 页（Page）→ 行（Row）</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250312105005237-2025-3-1210:50:10.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p><ul><li><p>表空间，分为系统表空间和独立表空间（具体见磁盘架构）</p><ul><li>系统表空间：默认文件为 <code>ibdata1</code>，存储数据字典（表、列、索引的元数据）、变更缓冲区（Change Buffer）、双写缓冲区（Doublewrite Buffer）、Undo 日志（Undo Logs）的默认存储位置。</li><li>独立表空间：每个表单独存储为 <code>.ibd</code> 文件，需配置 <code>innodb_file_per_table=ON</code>，包含表的数据和索引以及表级的 Undo 日志。</li></ul></li><li><p>段，分为数据段、索引段、回滚段，InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</p></li><li><p>区，表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为<strong>16K</strong>，即一个区中一共有64个连续的页。</p></li><li><p>页，是InnoDB存储引擎磁盘管理的<strong>最小单元</strong>，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请 4-5 个区。</p></li><li><p>行，是<strong>实际存储用户数据的单元</strong>，InnoDB存储引擎数据是按行进行存放的。行记录由<u>隐藏字段</u>和<u>用户数据</u>组成。其中隐藏字段包括：<code>Trx_id</code>、<code>Roll_ptr</code>、<code>Row_id</code></p><ul><li><p><code>Trx_id</code>：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</p></li><li><p><code>Roll_ptr</code>：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p></li><li><p><code>Row_id</code>：隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250312110952600-2025-3-1211:09:54.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p></li></ul></li></ul><h3 id="架构">7.2、架构</h3><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250312111300584-2025-3-1211:13:01.png" srcset="https://catpaws.top/img/transpare.svg" lazyload style="zoom:80%"></p><h4 id="内存架构">内存架构</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250312111516116-2025-3-1211:15:24.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="InnoDB存储引擎的内存架构" style="zoom:80%"></p><hr><p>​ Buffer Pool：缓冲池是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p><ul><li>free page：空闲page，未被使用。</li><li>clean page：被使用page，数据没有被修改过。</li><li>dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。</li></ul><hr><p>​ Change Buffer：更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer 中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p>为什么要用Change Buffer？</p><p>​ 与聚集索引不同，二级索引通常是非唯一的，并且以相对<strong>随机</strong>的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了Change Buffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p><hr><p>Adaptive Hash Index：自适应hash索引，自动为高频访问的索引键值创建哈希索引，加速等值查询。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。<strong>自适应哈希索引，无需人工干预，是系统根据情况自动完成。</strong></p><hr><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（<strong>redo log</strong>、<strong>undo log</strong>），默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘IO。</p><p>参数：</p><ul><li>innodb_log_buffer_size：缓冲区大小</li><li>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机<ul><li>1：日志在每次事务提交时写入并刷新到磁盘</li><li>0：每秒将日志写入并刷新到磁盘一次。</li><li>2：日志在每次事务提交后写入，并每秒刷新到磁盘一次。</li></ul></li></ul><h4 id="磁盘架构">磁盘架构</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250312113022121-2025-3-1211:30:23.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="InnoDB的磁盘架构" style="zoom:80%"></p><hr><p>System Tablespace：<strong>系统表空间</strong>是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。（在MySQL5.x版本中还包含InnoDB数据字典、undolog等）</p><p>参数：<code>innodb_data_file_path</code></p><hr><p>File-Per-Table Tablespaces：每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中。</p><p>参数：<code>innodb_file_pr_table</code>，开启后每个表都会有一个独立的表空间，单独存储为 <code>.ibd</code> 文件</p><hr><p>General Tablespaces：通用表空间，需要通过<code>CREATE TABLESPACE</code>语法创建通用表空间，在创建表时，可以指定该表空间。</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 创建表空间
CREATE TABLESPACE xxxx ADD 
DATAFILE &#x27;file_name&#x27;
ENGINE = engine_name;
-- 创建表时指定要使用的表空间
CREATE TABLE xx... TABLESPACE ts_name;</code></pre></div><hr><p>Undo Tablespaces：撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。</p><hr><p>Temporary Tablespaces：InnoDB使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><hr><p>Doublewrite Buffer Files：双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p><hr><p>Redo Log：重做日志，是<strong>用来实现事务的持久性</strong>。</p><p>该日志文件由两部分组成：重做日志缓冲区（redo log buffer）以及重做日志文件（redo log），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息以<strong>循环方式</strong>写入两个重做日志文件，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复使用。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250312095419808-2025-3-1209:54:33.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p><h4 id="后台线程">后台线程</h4><p>InnoDB的后台线程主要负责各种维护任务，比如刷新脏页、合并插入缓冲区、清理Undo日志等等。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250312153240660-2025-3-1215:32:42.png" srcset="https://catpaws.top/img/transpare.svg" lazyload style="zoom:80%"></p><ol type="1"><li><p>Master Thread</p><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收。</p></li><li><p>IO Thread</p><p>在InnoDB存储引擎中大量使用了<strong>AIO</strong>(异步非阻塞IO)来处理IO请求，这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250312153042354-2025-3-1215:30:55.png" srcset="https://catpaws.top/img/transpare.svg" lazyload style="zoom:80%"></p></li><li><p>Purge Thread</p><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。</p></li><li><p>Page Cleaner Thread</p><p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p></li></ol><h3 id="事务原理">7.3、事务原理</h3><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>事务的特性：ACID，原子性、一致性、隔离性、持久性。</p><p>MySQL InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 和 锁 机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250312153544178-2025-3-1215:35:48.png" srcset="https://catpaws.top/img/transpare.svg" lazyload style="zoom:80%"></p><h4 id="redo-log">redo log</h4><p>Redo Log：重做日志，是<strong>用来实现事务的持久性</strong>，即已提交的事务对数据的修改即使在系统崩溃后也不会丢失。</p><p>该日志文件由两部分组成：重做日志缓冲区（redo log buffer）以及重做日志文件（redo log），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250312095419808-2025-3-1209:54:33.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p><p>Redo Log的工作流程：</p><ul><li><p>事务对数据进行修改时，InnoDB 先将修改写入 <strong>内存中的缓冲池（Buffer Pool）</strong>，生成对应的 <strong>脏页（Dirty Page）</strong>。同时，生成描述该修改的 Redo Log 记录，暂存到 Log Buffer（日志缓冲区）。</p></li><li><p>事务提交时，InnoDB 将 Log Buffer 中的 Redo Log 记录根据参数<code>innodb_flush_log_at_trx_commit</code>指定的策略刷入磁盘：</p><ul><li>1（默认）：立即将 Log Buffer 内容写入 <strong>Redo Log 文件</strong>，并调用 <code>fsync()</code> 确保数据落盘。<strong>严格保证持久性</strong>，但性能较低。</li><li>0：每秒将 Log Buffer 内容写入 Redo Log 文件并刷盘。<strong>可能丢失最近 1 秒的提交</strong>，性能高。</li><li>2：立即写入 Redo Log 文件，但每秒刷盘一次。<strong>仅丢失操作系统崩溃未刷盘的数据</strong>，性能介于前两者之间。</li></ul></li><li><p>后台线程，如 <strong>Page Cleaner Thread</strong>，将缓冲池中的脏页<strong>异步刷新</strong>到磁盘的数据文件，Redo Log 的存在使得脏页刷新无需实时完成，即使脏页未刷盘，崩溃后仍可通过 Redo Log 恢复数据。</p><blockquote><p>所有修改先记录日志，再异步刷脏页，即<strong>日志优先（Write-Ahead Logging, WAL）</strong></p></blockquote></li><li><p>Redo Log 文件以循环方式写入。当日志文件写满时，触发 Checkpoint（检查点）机制：将已持久化到数据文件的修改对应的 Redo Log 标记为可覆盖，确保恢复时只需处理 Checkpoint 之后的日志。</p></li></ul><p><strong>Redo Log 的核心作用</strong></p><ul><li>持久性保证：记录事务对数据的物理修改，确保提交后的修改能通过日志恢复。</li><li>高性能写入：通过 <strong>顺序 I/O</strong> 写入日志文件，避免直接修改数据文件的随机 I/O 开销。</li></ul><h4 id="undo-log">undo log</h4><p>回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和MVCC（多版本并发控制）。</p><p>undo log和 redo log记录物理日志不一样，它是<strong>逻辑日志</strong>。当事务对数据进行修改时，InnoDB 会生成对应的 <strong>Undo Log 记录</strong>，保存修改前的数据状态。</p><table><thead><tr class="header"><th><strong>操作类型</strong></th><th><strong>Undo Log 内容</strong></th><th><strong>回滚动作</strong></th></tr></thead><tbody><tr class="odd"><td>INSERT</td><td>新插入行的主键值</td><td>删除该行（逻辑标记为删除）</td></tr><tr class="even"><td>UPDATE/DELETE</td><td>修改前的完整数据行（旧版本）</td><td>恢复旧数据</td></tr></tbody></table><p>当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><hr><p>Undo Log 默认存储在 <strong>系统表空间</strong>（<code>ibdata1</code>）或独立的 <strong>Undo 表空间</strong>中，采用段的方式进行管理和记录，存放在前面介绍的rollback segment回滚段中，内部包含1024个undo log segment。</p><p>事务提交和回滚</p><ul><li>事务提交后，Undo Log 不会立即删除，而是标记为“可清理”，供其他事务的 MVCC 读操作使用，后台的 Purge Thread 异步清理不再需要的 Undo Log。</li><li>事务回滚时，根据 Undo Log 逆向执行操作，回滚完成后，相关 Undo Log 标记为可清理。</li></ul><h4 id="mvcc">MVCC</h4><h5 id="基本概念">基本概念</h5><ul><li><p>当前读</p><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p><p>如：select ...lock in share mode（共享锁），select...for update，update，insert，delete（排他锁)是一种当前读。</p></li><li><p>快照读</p><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。在不同的隔离级别下，快照读的情况不同：</p><ul><li>Read Committed（读已提交）：每次select，都生成一个快照读。</li><li>Repeatable Read（可重复读）：开启事务后第一个select语句才是快照读的地方。</li><li>Serializable（串行化）：快照读会退化为当前读。</li></ul></li></ul><p>MVCC，全称 Multi-Version Concurrency Control，<strong>多版本并发控制</strong>。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现l MVCC提供了一个<strong>非阻塞读</strong>功能。</p><p>MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><hr><p>三个隐藏字段：一个表结构中，除了创建表时定义的列外，InnoDB引擎还维护了三个隐藏列</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250312110952600-2025-3-1211:09:54.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p><ul><li><code>DB_TRX_ID</code>：最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</li><li><code>DB_ROLL_PTR</code>：<strong>回滚指针</strong>，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</li><li><code>DB_ROW_ID</code>：隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</li></ul><hr><p>undo log，回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p><ul><li>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</li><li>而update，delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</li></ul><p>undo log <strong>版本链</strong></p><p>​ 每行数据会保存多个历史版本，每个版本对应不同事务的修改，每个版本通过隐藏字段<code>DB_TRX_ID</code>记录创建该版本的事务ID，通过<code>DB_ROLL_PTR</code>指向上一个版本。</p><p>​ 不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，版本链通过 <code>DB_ROLL_PTR</code>连接成一个链表。链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250312164647046-2025-3-1216:46:51.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p><hr><p><strong>ReadView</strong>（读视图）是<strong>快照读</strong>SQL执行时MVCC提取数据的依据，其实就是一个保存事务ID的list列表。记录的是本事务执行时，MySQL还有哪些事务在执行，且还没有提交。</p><p>ReadView中包含了四个核心字段：</p><ul><li><code>m_ids</code>：当前活跃的事务ID集合</li><li><code>min_trx_id</code>：最小活跃事务 ID</li><li><code>max_trx_id</code>：下一个待分配事务 ID</li><li><code>creator_trx_id</code>：ReadView创建者的事务ID</li></ul><p>通过对比当前事务ID<code>DB_TRX_ID</code>和 Read View，判断某行数据的某个版本是否对当前事务可见，规则如下：</p><ol type="1"><li><code>DB_TRX_ID</code> &lt; <code>min_trx_id</code>：表明生成该版本的事务在生成ReadView前已经提交，所以该版本<strong>可以</strong>被当前事务访问。</li><li><code>DB_TRX_ID</code>&gt; <code>max_trx_id</code>：表明生成该版本的事务在生成ReadView 后才生成，所以该版本<strong>不可以</strong>被当前事务访问。</li><li><code>DB_TRX_ID</code>在<code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，且<u>不在</u> <code>m_ids</code>列表中：表明创建 ReadView 时生成该版本的事务已经被提交，该版本<strong>可以</strong>被访问。</li><li><code>DB_TRX_ID</code>在<code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，且<u>在</u> <code>m_ids</code> 列表中：表明创建 ReadView 时生成该版本的事务还是活跃的，该版本<strong>不可以</strong>被访问。</li></ol><p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本，如果最后一个版本也不可见的话，那么就意味着该条记录对该事务不可见，查询结果就不包含该记录。</p><p>不同的隔离级别，生成ReadView的时机不同：</p><ul><li><p>READ COMMITTED（读已提交）：在事务中每一次执行快照读时生成ReadView。</p></li><li><p>REPEATABLE READ（可重复读）：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</p></li></ul><h5 id="原理分析">原理分析</h5><p>目前活跃的四个事务如下，各个事务对同一行数据修改的undo log版本链如下，在RC隔离级别下，事务5的两次查询都会生成Read View，分析两次查询到的数据是什么：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250312172415625-2025-3-1217:24:22.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p><p>第一次查询时，数据库中该条记录隐藏字段<code>DB_TRX_ID</code>所指出最近修改该记录的事务id是4，根据ReadView判断数据版本可见性的规则，事务4在<code>min_trx_id</code> 和 <code>max_trx_id</code> 之间，且<u>在</u> <code>m_ids</code> 列表中，故该版本数据不可见；查看版本链中下一个数据版本，它的<code>DB_TRX_ID</code>是3，它也在<u>在</u> <code>m_ids</code> 列表中，对应的数据版本不可见；继续查看下一个数据版本，它的<code>DB_TRX_ID</code>是2，小于当前ReadView中的<code>min_trx_id</code> ，故该版本数据可见，当前查询返回该版本的数据。</p><p>第二次查询时，与第一次过程类型，该条记录在版本链中的第二个版本可见，返回该版本的数据。</p><hr><p>在RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView，这就保证两个查询时读取的数据相同，保证了可重复读。读取过程与上面类似。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250312173615808-2025-3-1217:36:22.png" srcset="https://catpaws.top/img/transpare.svg" lazyload></p><h2 id="八数据库设计三范式">八、数据库设计三范式</h2><p>​ 数据库设计范式是符合某一种级别的关系模式的集合。设计关系数据库时，遵从不同的规范要求，可以设计出合理的关系型数据库。这些规范要求被称为不同的范式，越高的范式数据库冗余越小。满足这些规范的数据库是简洁的、结构明晰的，同时不会发生插入、删除和更新操作异常。</p><p>数据结构范式的种类：</p><ol type="1"><li><p>‌<strong>第一范式（1NF）</strong>‌：要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。</p><p>第一范式，最核心，最重要的范式，所有表的设计都需要满足</p><div class="code-wrapper"><pre><code class="hljs mysql">学生编号 学生姓名 联系方式
------------------------------------------
1001		张三		zs@gmail.com,1359999999
1002		李四		ls@gmail.com,13699999999
1001		王五		ww@163.net,13488888888

以上是学生表，不满足第一范式，第一：没有主键。第二：联系方式可以分为邮箱地址和电话

学生编号(pk) 		学生姓名	邮箱地址		联系电话
----------------------------------------------------
1001				张三		zs@gmail.com	1359999999
1002				李四		ls@gmail.com	13699999999
1003				王五		ww@163.net		13488888888
</code></pre></div></li><li><p>‌<strong>第二范式（2NF）</strong>‌：在第一范式的基础上，要求表中的所有非主键字段完全依赖于主键。</p><div class="code-wrapper"><pre><code class="hljs mysql">学生编号 		学生姓名   教师编号 教师姓名
----------------------------------------------------
1001			张三		001		王老师
1002			李四		002		赵老师
1003			王五		001		王老师
1001			张三		002		赵老师

这张表描述了学生和老师的关系：（1个学生可能有多个老师，1个老师有多个学生),这是非常典型的：多对多关系！

以上的表不满足第一范式，应改为


学生编号+教师编号(pk)			学生姓名  		教师姓名
----------------------------------------------------
1001			001				张三			王老师
1002			002				李四			赵老师
1003			001				王五			王老师
1001			002				张三			赵老师

学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号），经过修改之后，以上的表满足了第一范式。
但是不满足第二范式，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。产生部分依赖会导致数据冗余，空间浪费。


为了让以上的表满足第二范式，需要这样设计
  学生表
  学生编号(pk)		学生名字
  ------------------------------------
  1001					张三
  1002					李四
  1003					王五
  
  教师表
  教师编号(pk)		教师姓名
  --------------------------------------
  001					王老师
  002					赵老师

  学生教师关系表
  id(pk)			学生编号(fk)			教师编号(fk)
  ------------------------------------------------------
  1						1001						001
  2						1002						002
  3						1003						001
  4						1001						002

口诀：多对多，三张表，关系表两个外键</code></pre></div></li><li><p>‌<strong>第三范式（3NF）</strong>‌：在第二范式的基础上，要求表中的每个非主键字段不依赖于其他非主键字段。</p><div class="code-wrapper"><pre><code class="hljs mysql">学生编号（PK） 学生姓名 班级编号  班级名称
---------------------------------------------------------
  1001				张三		01			一年一班
  1002				李四		02			一年二班
  1003				王五		03			一年三班
  1004				赵六		03			一年三班

以上表的设计是描述：班级和学生的关系。很显然是1对多关系，一个教室中有多个学生。
以上表满足第一范式，有主键。
以上表满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。

但是不满足第三范式，第三范式要求：不要产生传递依赖！一年一班依赖01，01依赖1001，产生了传递依赖。不符合第三范式的要求。产生了数据的冗余。

那么应该怎么设计一对多呢？

  班级表：一
  班级编号(pk)				班级名称
  ----------------------------------------
  01								一年一班
  02								一年二班
  03								一年三班

  学生表：多

  学生编号（PK） 学生姓名 班级编号(fk)
  -------------------------------------------
  1001				张三			01			
  1002				李四			02			
  1003				王五			03			
  1004				赵六			03		
  
口诀：一对多，两张表，多的表加外键
</code></pre></div></li><li><p>‌<strong>巴斯-科德范式（BCNF）</strong>‌：进一步减少数据冗余，确保每个决定因素只依赖于主键。</p></li><li><p>‌<strong>第四范式（4NF）</strong>‌：解决多值依赖问题，确保每个决定因素不依赖于其他非主键字段。</p></li><li><p>‌<strong>第五范式（5NF）</strong>‌：又称完美范式，进一步减少数据冗余，确保每个决定因素不依赖于其他非主键字段。</p></li></ol></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="category-chain-item">数据库</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E4%BA%8B%E5%8A%A1/" class="print-no-link">#事务</a> <a href="/tags/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="print-no-link">#InnoDB存储引擎</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" class="print-no-link">#索引</a> <a href="/tags/SQL%E4%BC%98%E5%8C%96/" class="print-no-link">#SQL优化</a> <a href="/tags/%E9%94%81/" class="print-no-link">#锁</a></div></div><div class="license-box my-3"><div class="license-title"><div>MySQL（二）</div><div>https://catpaws.top/bd62c17f/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年12月8日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/f07c622d/" title="MySQL（三）"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">MySQL（三）</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/8d742da7/" title="MySQL（一）"><span class="hidden-mobile">MySQL（一）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://cdn.smartcis.cn/npm/twikoo@1.6.40/dist/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本站由<img src="/img/upyun_logo.png" srcset="https://catpaws.top/img/transpare.svg" lazyload style="width:auto;height:auto">提供CDN加速/云存储服务</a></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备2025059828号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61032302000087" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="https://catpaws.top/img/transpare.svg" lazyload alt="police-icon"> <span>陕公网安备61032302000087号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//catpaws.top/blog-resource/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="//catpaws.top/blog-resource/js/loader.js"></script><script src="//catpaws.top/blog-resource/js/blurpicload.js"></script><script src="//cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://registry.npmmirror.com/oh-my-live2d/latest/files"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"https://catpaws.top/blog-resource/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"},idleTips:{interval:15e3,message:function(){return axios.get("https://v1.hitokoto.cn?c=i").then((function(t){return t.data.hitokoto})).catch((function(t){console.error(t)}))}}}})</script></body></html>