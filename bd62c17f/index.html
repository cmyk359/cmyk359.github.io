<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="http://img.catpaws.top/blog-source/imgs/webicon.png"><link rel="icon" href="http://img.catpaws.top/blog-source/imgs/webicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="一、事务 事务(transaction)，是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 只有DML语句（insert、delete、update）才会有事务这一说，其它语句和事务无关！！！因为 只有以上的三个语句是数据库表中数据进行增、删、改的。 只要你的操作一旦涉及到数据的增、删、改，那么就一定要考虑安全问题。 1.1、事务的原理 In"><meta property="og:type" content="article"><meta property="og:title" content="MySQL（二）"><meta property="og:url" content="https://catpaws.top/bd62c17f/index.html"><meta property="og:site_name" content="猫爪在上de书桌"><meta property="og:description" content="一、事务 事务(transaction)，是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 只有DML语句（insert、delete、update）才会有事务这一说，其它语句和事务无关！！！因为 只有以上的三个语句是数据库表中数据进行增、删、改的。 只要你的操作一旦涉及到数据的增、删、改，那么就一定要考虑安全问题。 1.1、事务的原理 In"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://img.catpaws.top/img/image-20240711100432572-2024-7-1110_04_51.png"><meta property="og:image" content="http://img.catpaws.top/img/image-20240712095425856-2024-7-1209_54_46.png"><meta property="og:image" content="http://img.catpaws.top/img/image-20240721191411802-2024-7-2119_14_12.png"><meta property="article:published_time" content="2024-12-08T15:12:03.000Z"><meta property="article:modified_time" content="2025-01-26T07:06:08.829Z"><meta property="article:author" content="猫爪在上"><meta property="article:tag" content="事务"><meta property="article:tag" content="InnoDB存储引擎"><meta property="article:tag" content="索引"><meta property="article:tag" content="SQL优化"><meta property="article:tag" content="锁"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://img.catpaws.top/img/image-20240711100432572-2024-7-1110_04_51.png"><title>MySQL（二） - 猫爪在上de书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/bynotes/texiao/source/css/shubiao.css"><link rel="stylesheet" href="//img.catpaws.top/blog-source/css/font.css"><link rel="stylesheet" href="//img.catpaws.top/blog-source/css/poem.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://tntpv22c.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上de书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(http://img.catpaws.top/blog-source/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="MySQL（二）"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-12-08 23:12" pubdate>2024年12月8日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 13k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 110 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">MySQL（二）</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年1月26日 下午</p><div class="markdown-body"><meta name="referrer" , content="no-referrer"><h2 id="一事务">一、事务</h2><p><strong>事务(transaction)</strong>，是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</p><p>只有<strong>DML</strong>语句（<code>insert、delete、update</code>）才会有事务这一说，其它语句和事务无关！！！因为 只有以上的三个语句是数据库表中数据进行增、删、改的。 只要你的操作一旦涉及到数据的增、删、改，那么就一定要考虑安全问题。</p><h3 id="事务的原理">1.1、事务的原理</h3><p>InnoDB 存储引擎：提供一组用来记录<strong>事务性活动的日志文件</strong>（类似于缓存）</p><div class="code-wrapper"><pre><code class="hljs mysql">事务开启了：
insert
insert
insert
delete
update
update
update
事务结束了！</code></pre></div><p>在事务的执行过程中，每一条 DML 的操作都会记录到“事务性活动的日志文件”中，此时不会真正修改磁盘上的数据。</p><p>在事务的执行过程中，我们可以提交事务，也可以回滚事务。（提交和回滚是事务的<strong>两个终结操作</strong>）</p><p>提交事务？ 清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。 提交事务标志着，事务的结束。并且是一种<strong>全部成功</strong>的结束。</p><p>回滚事务？ 将之前所有的 DML 操作全部撤销，并且清空事务性活动的日志文件 回滚事务标志着，事务的结束。并且是一种<strong>全部失败</strong>的结束。</p><h3 id="提交事务回滚事务">1.2、提交事务、回滚事务</h3><p>事务通常以 <code>start transaction</code>开始，以<code>commit</code> 或<code>rollback</code>结束。</p><ul><li><code>COMMIT</code>表示提交，即提交事务的所有操作。将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束。</li><li><code>ROLLBACK</code>表示回滚，即在事务运行过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始的状态。</li></ul><p>​ 在 MySQL 默认情况下是支持自动提交事务的，即每执行一条 DML 语句，则提交一次。这种自动提交实际上是不符合我们的开发习惯，因为一个业务通常是需要多条 DML 语句共同执行才能完成的，为了保证数据的安全，必须要求同时成功之后再提交，所以不能执行一条就提交一条。执行<code>start transaction</code>关闭自动提交机制，开启真正的事务机制。</p><p><strong>代码演示</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">演示事务：
  ---------------------------------回滚事务----------------------------------------
  mysql&gt; use bjpowernode;
  Database changed
  mysql&gt; select * from dept_bak;
  Empty set (0.00 sec)

  mysql&gt; start transaction;
  Query OK, 0 rows affected (0.00 sec)

  mysql&gt; insert into dept_bak values(10,&#x27;abc&#x27;, &#x27;tj&#x27;);
  Query OK, 1 row affected (0.00 sec)

  mysql&gt; insert into dept_bak values(10,&#x27;abc&#x27;, &#x27;tj&#x27;);
  Query OK, 1 row affected (0.00 sec)

  mysql&gt; select * from dept_bak;
  +--------+-------+------+
  | DEPTNO | DNAME | LOC  |
  +--------+-------+------+
  |     10 | abc   | tj   |
  |     10 | abc   | tj   |
  +--------+-------+------+
  2 rows in set (0.00 sec)

  mysql&gt; rollback;
  Query OK, 0 rows affected (0.00 sec)

  mysql&gt; select * from dept_bak;
  Empty set (0.00 sec)


  ---------------------------------提交事务----------------------------------------
  mysql&gt; use bjpowernode;
  Database changed
  mysql&gt; select * from dept_bak;
  +--------+-------+------+
  | DEPTNO | DNAME | LOC  |
  +--------+-------+------+
  |     10 | abc   | bj   |
  +--------+-------+------+
  1 row in set (0.00 sec)

  mysql&gt; start transaction;
  Query OK, 0 rows affected (0.00 sec)

  mysql&gt; insert into dept_bak values(20,&#x27;abc&#x27;)
  Query OK, 1 row affected (0.00 sec)

  mysql&gt; insert into dept_bak values(20,&#x27;abc&#x27;)
  Query OK, 1 row affected (0.00 sec)

  mysql&gt; insert into dept_bak values(20,&#x27;abc&#x27;)
  Query OK, 1 row affected (0.00 sec)

  mysql&gt; commit;
  Query OK, 0 rows affected (0.01 sec)

  mysql&gt; select * from dept_bak;
  +--------+-------+------+
  | DEPTNO | DNAME | LOC  |
  +--------+-------+------+
  |     10 | abc   | bj   |
  |     20 | abc   | tj   |
  |     20 | abc   | tj   |
  |     20 | abc   | tj   |
  +--------+-------+------+
  4 rows in set (0.00 sec)

  mysql&gt; rollback;
  Query OK, 0 rows affected (0.00 sec)

  mysql&gt; select * from dept_bak;
  +--------+-------+------+
  | DEPTNO | DNAME | LOC  |
  +--------+-------+------+
  |     10 | abc   | bj   |
  |     20 | abc   | tj   |
  |     20 | abc   | tj   |
  |     20 | abc   | tj   |
  +--------+-------+------+
  4 rows in set (0.00 sec)</code></pre></div><h3 id="事务四个特性acid">1.3、事务四个特性（ACID）</h3><p>A：原子性（Automicity） 说明事务是最小的工作单元。不可再分。</p><p>C：一致性（Consistency） 在同一个事务当中，所有操作必须同时成功，或者同时失败，以保证数据的一致性。事务的执行结果必须是使数据库从一个一致性状态边到另一个一致性状态。</p><p>I：隔离性（Isolation） 一个事务的执行不能被其他事务干扰。A 事务和 B 事务之间具有一定的隔离。</p><p>D：持久性（Durability） 事务一旦提交，相当于将没有保存到硬盘上的数据保存到硬盘上，它对数据库中数据的改变就是永久性的。</p><h3 id="事务的隔离性等级">1.4、事务的隔离性等级</h3><p>有关多个事务的并发控制</p><p><strong>多事务并发执行的问题</strong></p><ul><li><p><strong>脏读</strong>：一个事务读取了另一个事务未提交的数据，这些数据可能会被回滚，从而导致读取到无效数据</p></li><li><p><strong>不可重复读</strong>：一个事务在两次读取同一数据时，因其他事务的提交导致数据发生了变化，从而无法获得一致的结果。</p></li><li><p><strong>幻读</strong>：一个事务读取多条记录后，因其他事务的插入或删除，导致再次读取时获得的记录集发生变化。</p></li></ul><p>事务隔离性存在隔离级别，理论上隔离级别包括<code>4</code>个：</p><ol type="1"><li>读未提交： <code>read uncommitted</code> （最低的隔离级别，没有提交就读到了）<ul><li>含义： 事务 A 可以读取到事务 B 未提交的数据</li><li>存在问题：脏读现象！(Dirty Read)</li></ul></li><li>读已提交：<code>read committed</code> (提交之后才能读到)<ul><li>含义：事务 A 只能读取到事务 B 提交之后的数据。</li><li>解决的问题：解决了脏读的现象。</li><li>存在的问题： 不可重复读取数据。<ul><li>在事务开启之后，第一次读到的数据是 3 条，当前事务还没有 结束，可能第二次再读取的时候，读到的数据是 4 条，称为不可重复读取。（做不到事务从开始到结束查询到的数据是一样的）</li><li>这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。</li></ul></li></ul></li><li>可重复读：<code>repeatable read</code>(提交之后也读不到，永远读取的都是刚开启事务时的数据)<ul><li>含义：一个事务在执行期间读取到的数据始终保持一致，不受其他事务的影响</li><li>解决的问题：解决了不可重复读取数据。</li><li>存在的问题：可以会出现幻影读。每一次读取到的数据都是幻象。不够真实！</li></ul></li><li>序列化/串行化：<code>serializable</code>（最高的隔离级别）<ul><li>这是最高隔离级别，效率最低。解决了所有的问题。 这种隔离级别表示事务排队，不能并发！ 每一次读取到的数据都是最真实的，并且效率是最低的。</li></ul></li></ol><figure><img src="http://img.catpaws.top/img/image-20240424102156449-2024-12-823_54_55.png" srcset="/img/loading.gif" lazyload alt="image-20240424102156449"><figcaption aria-hidden="true">image-20240424102156449</figcaption></figure><p>oracle 数据库默认的隔离级别是：读已提交。 mysq1 数据库默认的隔离级别是：可重复读。</p><div class="code-wrapper"><pre><code class="hljs mysql">#测试隔离级别
设置全局事务隔离级别：mysql&gt; set global transaction isolation level read uncommitted;
					Query OK, 0 rows affected (0.00 sec)
查看隔离级别：SELECT @@tx_isolation
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
mysql默认的隔离级别</code></pre></div><h2 id="二存储引擎">二、存储引擎</h2><h3 id="存储引擎体系结构">2.1、存储引擎体系结构</h3><p><img src="http://img.catpaws.top/img/image-20240711100432572-2024-7-1110_04_51.png" srcset="/img/loading.gif" lazyload alt="image-20240711100432572" style="zoom:80%"></p><figure><img src="http://img.catpaws.top/img/image-20240711100551721-2024-7-1110_05_52.png" srcset="/img/loading.gif" lazyload alt="image-20240711100551721"><figcaption aria-hidden="true">image-20240711100551721</figcaption></figure><h3 id="存储引擎简介">2.2、存储引擎简介</h3><blockquote><p>什么是存储引擎，有什么用呢？</p></blockquote><p>存储引擎是 MySQL 中特有的一个术语，其它数据库中没有。（Oracle 中有，但是不叫这个名字）</p><ul><li>存储引擎就是存储/组织数据、建立索引、更新/查询数据等技术的实现方式。</li><li>存储引擎是基于<code>表</code>的，而不是基于库的，所以存储引擎也可被称为表类型。</li><li>不同的存储引擎，表存储数据的方式不同。</li></ul><p>可以在建表的时候给表指定存储引擎。<code>ENGINE</code>来指定存储引擎，<code>CHARSET</code>来指定这张表的字符编码方式。</p><p>查看 MySQL 支持哪些存储引擎，命令： <code>show engines;</code></p><figure><img src="http://img.catpaws.top/img/image-20240711101623788-2024-7-1110_17_12.png" srcset="/img/loading.gif" lazyload alt="image-20240711101623788"><figcaption aria-hidden="true">image-20240711101623788</figcaption></figure><h3 id="myisam-存储引擎">2.3、MyISAM 存储引擎</h3><p>它管理的表具有以下特征：</p><p>特点</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li><li>可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。</li></ul><p>文件组织结构</p><ul><li>使用三个文件表示每个表：</li><li>格式文件 — 存储表结构的定（mytable.sdi）</li><li>数据文件 — 存储表行的内（mytable.MYD）</li><li>索引文件 — 存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。</li></ul><h3 id="innodb-存储引擎">2.4、InnoDB 存储引擎</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 存储引擎。</p><ul><li><p>特点</p><ul><li>DML 操作遵循 ACID 模型，支持<code>事务</code>；</li><li><code>行级锁</code>，提高并发访问性能；</li><li>支持<code>外键</code> FOREIGN KEY 约束，保证数据的完整性和正确性，包括级联删除和更新；</li><li>支持数据库崩溃后自动恢复机制，非常安全。</li></ul></li><li><p>文件</p><p>xxx.ibd： xxx 代表的是表名，innoDB 引擎的每张表都会对应这样一个表空间文件。存储该表的<strong>表结构</strong>（frm、sdi）、<strong>数据</strong>和<strong>索引</strong>。 参数：innodb_file_per_table：是否每张 InnoDB 的表对应一个表空间文件，默认开启</p></li></ul><p>InnoDB 的逻辑存储结构</p><figure><img src="http://img.catpaws.top/img/image-20240711104512418-2024-7-1110_45_17.png" srcset="/img/loading.gif" lazyload alt="image-20240711104512418"><figcaption aria-hidden="true">image-20240711104512418</figcaption></figure><h3 id="memory-存储引擎">2.5、MEMORY 存储引擎</h3><p>Memory 引擎的表数据时存储在<code>内存</code>中的，，且行的长度固定。由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</p><ul><li><p>特点</p><ul><li>数据和索引存放在内存中</li><li>支持 hash 索引</li><li>支持表锁</li></ul></li><li><p>文件结构</p><p>每个表对应一个 xxxx.sdi 格式的文件，保存表结构信息</p></li></ul><p>MEMORY 存储引擎以前被称为 HEAP 引擎。</p><p>MEMORY 引擎优点：查询效率 是最高的。不需要和硬盘交互。</p><p>MEMORY 引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。</p><h3 id="存储引擎的对比与选择">2.6、存储引擎的对比与选择</h3><p><img src="http://img.catpaws.top/img/image-20240712095425856-2024-7-1209_54_46.png" srcset="/img/loading.gif" lazyload alt="image-20240712095425856" style="zoom:120%"></p><figure><img src="http://img.catpaws.top/img/image-20240712100104224-2024-7-1210_01_29.png" srcset="/img/loading.gif" lazyload alt="image-20240712100104224"><figcaption aria-hidden="true">image-20240712100104224</figcaption></figure><h2 id="三索引index">三、索引（index）</h2><h3 id="索引概述">3.1、索引概述</h3><p>​ 索引（index）是帮助 MySQL<strong>高效获取数据</strong>的<strong>数据结构</strong>（有序）,是为了提高查询效率存在的一种机制。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><ul><li>MySQL 在查询方面主要就是两种方式： 第一种方式：全表扫描 (性能低) 第二种方式：根据索引检索。</li></ul><figure><img src="http://img.catpaws.top/img/image-20240712104938469-2024-7-1210_49_55.png" srcset="/img/loading.gif" lazyload alt="image-20240712104938469"><figcaption aria-hidden="true">image-20240712104938469</figcaption></figure><h3 id="索引的数据结构">3.2、索引的数据结构</h3><p>索引是在 MySQL 体系结构的存储引擎层实现的，不同的存储引擎可以对应不同的索引结构。主要包含以下几种：</p><figure><img src="http://img.catpaws.top/img/image-20240712105833956-2024-7-1210_58_58.png" srcset="/img/loading.gif" lazyload alt="image-20240712105833956"><figcaption aria-hidden="true">image-20240712105833956</figcaption></figure><p>Full-text 索引是基于倒排索引实现的。<a target="_blank" rel="noopener" href="https://b11et3un53m.feishu.cn/wiki/LDLew5xnDiDv7Qk2uPwcoeNpngf">参考 ES 的倒排索引</a></p><p>各存储引擎对上述索引结构的支持情况：</p><figure><img src="http://img.catpaws.top/img/image-20240712105941293-2024-7-1210_59_41.png" srcset="/img/loading.gif" lazyload alt="image-20240712105941293"><figcaption aria-hidden="true">image-20240712105941293</figcaption></figure><blockquote><p>B+ tree</p></blockquote><figure><img src="http://img.catpaws.top/img/image-20240712112351760-2024-7-1211_24_03.png" srcset="/img/loading.gif" lazyload alt="image-20240712112351760"><figcaption aria-hidden="true">image-20240712112351760</figcaption></figure><p>B+树的每个结点都是存储在一个页中的，对应于 InnoDB 存储引擎逻辑结构中的 page</p><p><strong>为什么 InnoDB 存储引擎使用 B+tree 作为索引结构：</strong></p><ul><li>在相同结点数量下，B+树比二叉树的层级更少，查询一个元素所需的次数更少，搜索效率高。并且当元素顺序插入时，二叉树高度为结点数量，查询效率低。</li><li>树的每个结点保存在一个磁盘块中，从根节点开始查询某关键字需要，将路径上的所有磁盘块读入内存，由于磁盘块大小固定，在 B+树中，非叶节点不包含该关键字对应记录的存储地址，只起到索引作用。可以使每个磁盘块包含更多的关键字，使得 B+树的阶更大，树高更小，读取磁盘次数更少，查找更快。相比于 B 树，每个结点中都包含了关键字对应记录的信息，使得每个磁盘块存储的关键字个数变少，树高增大，查找速度变慢。</li><li>相对于 Hash 索引，其只支持精确匹配，而 B+树还支持范围匹配及排序操作</li></ul><blockquote><p>Hash 索引</p></blockquote><figure><img src="http://img.catpaws.top/img/image-20240712113933352-2024-7-1211_39_55.png" srcset="/img/loading.gif" lazyload alt="image-20240712113933352"><figcaption aria-hidden="true">image-20240712113933352</figcaption></figure><p>Hash 索引的特点：</p><ul><li>Hash 索引只能用于对等比较（=，in），不支持范围查询（between，&gt;，&lt;，...）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+tree 索引</li></ul><p>在 MySQL 中，支持 hash 索引的是 Memory 引擎，而 InnoDB 中具有自适应 hash 功能，hash 索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的。</p><h3 id="索引分类">3.3、索引分类</h3><figure><img src="http://img.catpaws.top/img/image-20240712150609091-2024-7-1215_06_27.png" srcset="/img/loading.gif" lazyload alt="image-20240712150609091"><figcaption aria-hidden="true">image-20240712150609091</figcaption></figure><blockquote><p>在 InnoDB 存储引擎中，根据<strong>索引存储形式</strong>，又可分为以下两种</p></blockquote><figure><img src="http://img.catpaws.top/img/image-20240712150912890-2024-7-1215_09_13.png" srcset="/img/loading.gif" lazyload alt="image-20240712150912890"><figcaption aria-hidden="true">image-20240712150912890</figcaption></figure><figure><img src="http://img.catpaws.top/img/image-20240712151114687-2024-7-1215_11_15.png" srcset="/img/loading.gif" lazyload alt="image-20240712151114687"><figcaption aria-hidden="true">image-20240712151114687</figcaption></figure><p>注：二级索引中不仅仅有该字段对应的聚集索引 id，还有索引字段本身的值。</p><figure><img src="http://img.catpaws.top/img/image-20240712151257432-2024-7-1215_13_03.png" srcset="/img/loading.gif" lazyload alt="image-20240712151257432"><figcaption aria-hidden="true">image-20240712151257432</figcaption></figure><p>由此可知：当 id 为主键，且 name 字段设置了索引的情况下，第一条 sql 的执行效率更高</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;

<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> &quot;jack&quot;;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240712151950425-2024-7-1215_20_03.png" srcset="/img/loading.gif" lazyload alt="image-20240712151950425"><figcaption aria-hidden="true">image-20240712151950425</figcaption></figure><p>由此可知，对应两千多万条记录的表，其聚集索引对应的 B+树的树高不会超过 3，查找效率很高</p><h3 id="sql-性能分析">3.4、SQL 性能分析</h3><h4 id="sql-执行频率">SQL 执行频率</h4><p>MySQL 客户端连接成功后，通过 show[session|global]status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的 INSERT、UPDATE、DELETE、SELECT 的访问频次：</p><div class="code-wrapper"><pre><code class="hljs mysql">show global status like &quot;Com_______&quot;;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240712154433897-2024-7-1215_45_03.png" srcset="/img/loading.gif" lazyload alt="image-20240712154433897"><figcaption aria-hidden="true">image-20240712154433897</figcaption></figure><h4 id="慢查询日志">慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认 10 秒）的所有 SQL 语句的日志。通过慢查询日志定位执行较慢的 sql 语句，针对这些慢 sql 进行优化。</p><p>MySQL 的慢查询日志默认没有开启</p><figure><img src="http://img.catpaws.top/img/image-20240712154859197-2024-7-1215_49_03.png" srcset="/img/loading.gif" lazyload alt="image-20240712154859197"><figcaption aria-hidden="true">image-20240712154859197</figcaption></figure><p>需要在 MySQL 的配置文件（/etc/my.cnf）中配置如下信息：</p><figure><img src="http://img.catpaws.top/img/image-20240712154916297-2024-7-1215_50_03.png" srcset="/img/loading.gif" lazyload alt="image-20240712154916297"><figcaption aria-hidden="true">image-20240712154916297</figcaption></figure><p>当出现慢 sql 时会记录在 localhost-slow.log 中，其中对一条慢 SQL 的记录内容如下</p><figure><img src="http://img.catpaws.top/img/image-20240712160914148-2024-7-1216_09_35.png" srcset="/img/loading.gif" lazyload alt="image-20240712160914148"><figcaption aria-hidden="true">image-20240712160914148</figcaption></figure><h4 id="profile-详情">profile 详情</h4><p>show profiles 能够在做 SQL 优化时帮助我们了解时间都耗费到哪里去了，查看各个 sql 语句的执行耗时</p><ul><li><p>查看是否支持 profile 操作</p><div class="code-wrapper"><pre><code class="hljs mysql">select @@have_profiling;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240712165548802-2024-7-1216_56_01.png" srcset="/img/loading.gif" lazyload alt="image-20240712165548802"><figcaption aria-hidden="true">image-20240712165548802</figcaption></figure></li><li><p>查看是否开启 profile 功能</p><div class="code-wrapper"><pre><code class="hljs mysql">select @@profiling;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240712165651959-2024-7-1216_56_52.png" srcset="/img/loading.gif" lazyload alt="image-20240712165651959"><figcaption aria-hidden="true">image-20240712165651959</figcaption></figure></li><li><p>开启 profile 功能</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> profiling <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240712165738387-2024-7-1216_57_38.png" srcset="/img/loading.gif" lazyload alt="image-20240712165738387"><figcaption aria-hidden="true">image-20240712165738387</figcaption></figure></li></ul><div class="code-wrapper"><pre><code class="hljs mysql"># 查看每条sql的耗时基本情况
show profiles;

#查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;

#查看指定query_id的SQL语句的cpu使用情况
show profile cpu for query query_id;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240712171227231-2024-7-1217_12_27.png" srcset="/img/loading.gif" lazyload alt="image-20240712171227231"><figcaption aria-hidden="true">image-20240712171227231</figcaption></figure><h4 id="explain-执行计划">explain 执行计划</h4><p>使用<code>explain</code>查看指定 sql 语句的执行计划，了解 MySQL 如何处理该 SQL 语句，表的加载顺序，表是如何连接，以及索引使用情况。是 SQL 优化的重要工具，主要用于分析查询语句或表结构的性能瓶颈。</p><figure><img src="http://img.catpaws.top/img/image-20240712220857971-2024-7-1222_09_03.png" srcset="/img/loading.gif" lazyload alt="image-20240712220857971"><figcaption aria-hidden="true">image-20240712220857971</figcaption></figure><p>explain 出来的信息有 10 列，分别是：</p><p>id:选择标识符 select_type:表示查询的类型。 table:输出结果集的表 partitions:匹配的分区 type:表示表的连接类型 possible_keys:表示查询时，可能使用的索引 key:表示实际使用的索引 key_len:索引字段的长度 ref:列与索引的比较 rows:扫描出的行数(估算的行数) filtered:按表条件过滤的行百分比 Extra:执行情况的描述和说明</p><ol type="1"><li><p><code>id</code></p><p>select 查询的序列号，表示查询中<strong>执行 select 子句或者是操作表</strong>的<u>顺序</u></p><ul><li>id 相同执行顺序由上到下</li><li>如果是子查询，id 的序号会递增。在所有组中，id 值越大，优先级越高，越先执行</li></ul><p>例如：查询没有选张三老师课的学生的学号和姓名（见最下 SQL 练习的第五题）</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 3、返回没有选张三老师课的学生的学号和姓名
SELECT st.s_id, st.s_name
FROM student st
WHERE st.s_id NOT IN (
	-- 2、返回选了张三老师课的学生id
	SELECT DISTINCT s.s_id
	FROM score s
	WHERE s.c_id IN (
		-- 1、连接course表和teacher表，从中选出张三老师教的所有课的c_id
		SELECT c.c_id
		FROM
			course c
			INNER JOIN teacher t ON ( c.t_id = t.t_id AND t.t_name = &quot;张三&quot; )
	)
);</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240712223235874-2024-7-1222_32_46.png" srcset="/img/loading.gif" lazyload alt="image-20240712223235874"><figcaption aria-hidden="true">image-20240712223235874</figcaption></figure><p>从中可以看出内部的多个子查询的 id 都为 2，外部的查询 id 为 1。并且在多个子查询中，操作表的顺序是从内到外的，先是 teacher 表，再是 course 表，最后是 score 表。</p></li><li><p>select_type</p><p>表示查询的类型。</p><ol type="1"><li><p>SIMPLE(简单 SELECT，不使用 UNION 或子查询等)</p></li><li><p>PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的 select 被标记为 PRIMARY)</p></li><li><p>SUBQUERY(子查询中的第一个 SELECT，结果不依赖于外部查询)</p></li><li><p>DEPENDENT SUBQUERY(子查询中的第一个 SELECT，依赖于外部查询)</p></li><li><p>DERIVED(派生表的 SELECT, FROM 子句的子查询)</p></li><li><p>UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p></li><li><p>UNION(UNION 中的第二个或后面的 SELECT 语句)</p></li><li><p>DEPENDENT UNION(UNION 中的第二个或后面的 SELECT 语句，取决于外面的查询)</p></li><li><p>UNION RESULT(UNION 的结果，union 语句中第二个 select 开始后面所有 select)</p></li></ol></li><li><p>table</p><p>显示数据来自于哪个表，有时不是真实的表的名字,可能是简称，例如上面的 t，c，也可能是第几步执行的结果的简称。</p></li><li><p>partitions</p></li><li><p><code>type</code></p><p>表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all。</p><ul><li><p>all：Full Table Scan， MySQL 将遍历全表以找到匹配的行</p></li><li><p>index: Full Index Scan，all 和 index 都是读全表，但 index 是从索引中检索的，而 all 是从硬盘中检索的。index 类型只遍历索引树</p></li><li><p>range:只检索给定范围的行，一般条件查询中出现了&gt;、&lt;、in、between 等查询，使用一个索引来选择行</p></li><li><p>ref: 使用<u>非唯一行索引</u>进行查询</p></li><li><p>eq_ref: 类似 ref，区别就在使用的索引是<u>唯一索引</u>。简单来说，就是多表连接中使用 primary key 或者 unique key 作为关联条件</p></li><li><p>const: 当 MySQL 对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量</p></li><li><p>system 是 const 类型的特例，当查询的表只有一行的情况下，使用 system</p></li><li><p>NULL: MySQL 在优化过程中分解语句，<u>令其执行时甚至不用访问表或索引</u></p></li></ul></li><li><p><code>possible_keys</code></p><p>显示可能应用在这张表中的索引，但<strong>不一定被查询实际使用</strong></p></li><li><p><code>key</code></p><p>实际使用的索引，如果为 NULL，则没有使用索引。</p></li><li><p><code>key_len</code></p><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。一般来说，索引长度越长表示精度越高，效率偏低；长度越短，效率高，但精度就偏低。并不是真正使用索引的长度，是个预估值。</p></li><li><p>ref</p><p>哪些列或常量被用于查找索引列上的值</p></li><li><p>rows</p><p>MySQL 认为必须要执行查询的行数，在 innodb 引擎的表中，是一个估计值，可能并不总是准确的。</p></li><li><p>filtered</p><p>表示返回结果的行数占需读取行数的百分比，filtered 的值越大越好。</p></li><li><p><code>Extra</code></p><p>一些重要的额外信息</p><ul><li><strong>Using filesort</strong>：使用外部的索引排序，而不是按照表内的索引顺序进行读取。（一般需要优化）</li><li><strong>Using temporary</strong>：使用了临时表保存中间结果。常见于排序 order by 和分组查询 group by（最好优化）</li><li><strong>Using index</strong>：表示 select 语句中使用了覆盖索引，直接从索引中取值，而不需要回表查询（从磁盘中取数据）</li><li>Using where：使用了 where 过滤</li><li>Using index condition：表示查询的列有非索引的列，需要进行回表查询</li><li>Using join buffer：使用了连接缓存</li><li>impossible where： where 子句的值总是 false</li></ul></li></ol><h3 id="索引使用规则">3.5、索引使用规则</h3><h4 id="验证索引的效率">验证索引的效率</h4><div class="code-wrapper"><pre><code class="hljs mysql">-- 在user表中插入100万数据，再查询其中一条数据，感受加不加索引的区别

CREATE TABLE `app_user` (
`id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,
`name` VARCHAR(50) DEFAULT &#x27;&#x27;,
`email` VARCHAR(50) NOT NULL,
`phone` VARCHAR(20) DEFAULT &#x27;&#x27;,
`gender` TINYINT(4) UNSIGNED DEFAULT &#x27;0&#x27;,
`password` VARCHAR(100) NOT NULL DEFAULT &#x27;&#x27;,
`age` TINYINT(4) DEFAULT NULL,
`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,
`update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
PRIMARY KEY (`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8


-- SET GLOBAL log_bin_trust_function_creators = 1;-- 开启创建函数功能
/*
  第一个语句 delimiter 将 mysql 解释器命令行的结束符由”;” 改成了”$$”，
  让存储过程内的命令遇到”;” 不执行
*/
DELIMITER $$
CREATE FUNCTION mock_data()
RETURNS INT
BEGIN
	DECLARE num INT DEFAULT 1000000;
	DECLARE i INT DEFAULT 0;
	WHILE i&lt;num DO
		INSERT INTO `app_user`(`name`,`email`,`phone`,`gender`)VALUES(CONCAT(&#x27;用户&#x27;,i),&#x27;19224305@qq.com&#x27;,&#x27;123456789&#x27;,FLOOR(RAND()*2));
		SET i=i+1;
	END WHILE;
	RETURN i;
END;$$

SELECT mock_data()$$ -- 执行此函数 生成一百万条数据



-- 不加索引查询
SELECT * FROM `app_user` WHERE `name` = &#x27;用户99999&#x27;
&gt; OK
&gt; 时间: 0.332s
-- 添加索引后查询
CREATE INDEX index_app_user_name ON app_user ( `name` );

SELECT * FROM `app_user` WHERE `name` = &#x27;用户99999&#x27;
&gt; OK
&gt; 时间: 0.001s</code></pre></div><h4 id="最左前缀法则">最左前缀法则</h4><p>如果索引了多列（联合索引），要遵守最左前缀法则。</p><p><strong>最左前缀法则</strong>指的是在查询时，必须从联合索引的最左边开始，并且不能跳过索引中的列。</p><ul><li><p>如果查询条件中缺失最左侧的索引字段，则后面的字段查询都不会使用索引。</p></li><li><p>如果跳跃某一列，则该列后面的字段索引失效（部分失效）</p></li></ul><p>例如：在 tb_user 表中，已对 profession、age、status 建立了联合索引，现验证最左前缀法则</p><figure><img src="http://img.catpaws.top/img/image-20240713171404644-2024-7-1317_14_16.png" srcset="/img/loading.gif" lazyload alt="image-20240713171404644"><figcaption aria-hidden="true">image-20240713171404644</figcaption></figure><p><code>explain select * from tb_user where profession =·软件工程'and age = 31 and status = '0';</code>该 sql 语句符合最左前缀法则，索引已生效，联合索引字段长度为 54</p><figure><img src="http://img.catpaws.top/img/image-20240713171720088-2024-7-1317_17_20.png" srcset="/img/loading.gif" lazyload alt="image-20240713171720088"><figcaption aria-hidden="true">image-20240713171720088</figcaption></figure><p><code>explain select * from tb_user where age = 31 and status = '0';</code>此 sql 语句中最左侧索引字段缺失，该语句未使用索引</p><figure><img src="http://img.catpaws.top/img/image-20240713172401186-2024-7-1317_24_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713172401186"><figcaption aria-hidden="true">image-20240713172401186</figcaption></figure><p><code>explain select * from tb_user where profession = 软件工程'and age = 31；</code>此 sql 语 句中索引最左侧字段存在，且中间没有缺失其他索引字段，故索引也生效，此时索引长度为 49</p><figure><img src="http://img.catpaws.top/img/image-20240713172135947-2024-7-1317_21_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713172135947"><figcaption aria-hidden="true">image-20240713172135947</figcaption></figure><p><code>explain select * from tb user where profession ='软件工程'；</code>此 sql 语 句中索引最左侧字段存在，且中间没有缺失其他索引字段，故索引也生效。此时索引长度为 47，即 profession 索引字段长度为 47</p><figure><img src="http://img.catpaws.top/img/image-20240713172320284-2024-7-1317_23_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713172320284"><figcaption aria-hidden="true">image-20240713172320284</figcaption></figure><p><code>explain select * from tb_user where profession =·软件工程'and status = '0';</code></p><p>该 sql 语句中，只提供了联合索引中的 profession 和 status 字段，中间的 age 字段缺失，此时索引部分生效，索引字段长度为 47，只有 profession 的查询使用了索引，但 status 没有使用索引</p><figure><img src="http://img.catpaws.top/img/image-20240713172650355-2024-7-1317_27_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713172650355"><figcaption aria-hidden="true">image-20240713172650355</figcaption></figure><h4 id="索引失效情况">索引失效情况</h4><ol type="1"><li><p>索引列运算</p><p>不要在索引列上进行运算操作，<code>索引将失效</code>。</p><figure><img src="http://img.catpaws.top/img/image-20240713174016271-2024-7-1317_40_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713174016271"><figcaption aria-hidden="true">image-20240713174016271</figcaption></figure></li><li><p>字符串不加引号</p><p>字符串类型字段使用时未加引号，会进行隐式类型转换造成<code>索引将失效</code>。</p><figure><img src="http://img.catpaws.top/img/image-20240713174559698-2024-7-1317_46_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713174559698"><figcaption aria-hidden="true">image-20240713174559698</figcaption></figure></li><li><p>模糊查询</p><p>如何仅仅是尾部模糊匹配，索引仍会生效。但如果是头部模糊匹配，索引失效。</p><figure><img src="http://img.catpaws.top/img/image-20240713175107252-2024-7-1317_51_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713175107252"><figcaption aria-hidden="true">image-20240713175107252</figcaption></figure></li><li><p>or 连接的条件</p><p>用 or 分割开的条件，如果 or 前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。（前边有索引但后边没有，则索引不会生效；两边都有索引时，索引才会生效）</p><p>例如：在 tb_user 表中，age 字段没有建立索引。执行<code>select * from tb_user where id = 10 or age = 23;</code>时，由于 id 为主键，存在主键索引，但 age 没有索引，执行过程中索引不会生效。</p><figure><img src="http://img.catpaws.top/img/image-20240713175731784-2024-7-1317_57_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713175731784"><figcaption aria-hidden="true">image-20240713175731784</figcaption></figure><p>为 age 字段建立索引后，再执行该语句</p><figure><img src="http://img.catpaws.top/img/image-20240713180018863-2024-7-1318_00_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713180018863"><figcaption aria-hidden="true">image-20240713180018863</figcaption></figure></li><li><p>数据分布</p><p>如果 MySQL 评估使用索引比全表扫描更慢，则不使用索引。</p><p>比如在一张表中已对某个字段建立了索引，但使用该索引字段查询到的结果<u>基本上是整张表的数据，或是整张表的大部分数据</u>，经过 MySQL 评估后，不会使用索引而是进行全表扫描（<code>避免进行回表查询</code>）。但若是主键索引，即使查询结果时整张表的数据，但还是一定会使用主键索引。</p><p>例：tb_user 表中，已对 phone 字段建立了索引，且表中 phone 的最小值为 "17799990000"。执行</p><p><code>select * from tb_user where phone &gt;= '17799990000';</code>得到的结果为整张表的数据，查看该 sql 的执行计划可知，索引不会生效</p><figure><img src="http://img.catpaws.top/img/image-20240713181911044-2024-7-1318_19_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713181911044"><figcaption aria-hidden="true">image-20240713181911044</figcaption></figure><p>但若是主键索引一定会生效，如：dish 表中 id 最小为 46，执行<code>select * from dish where id &gt;= 46</code>得到的也是整张表的数据，但主键索引还是生效了</p><figure><img src="http://img.catpaws.top/img/image-20240713182126019-2024-7-1318_21_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713182126019"><figcaption aria-hidden="true">image-20240713182126019</figcaption></figure></li></ol><h4 id="sql-提示">SQL 提示</h4><figure><img src="http://img.catpaws.top/img/image-20240713183235664-2024-7-1318_32_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713183235664"><figcaption aria-hidden="true">image-20240713183235664</figcaption></figure><h4 id="覆盖索引">覆盖索引</h4><p>覆盖索引是指：查询使用了索引，并且需要返回的列，在该索引中已经能全部找到。</p><blockquote><p>尽量使用覆盖索引，减少使用 select *</p></blockquote><p>例：在 tb_user 表中，已经对 profession，age，status 建立了联合索引，分别执行以下 sql，查看其执行计划。</p><p>1、<code>select id, profession,age,status from tb_user where profession = '软件工程' and age = 31 and status = '0';</code>其执行计划中 Extra 列的信息为：<u>Using where; Using index</u></p><figure><img src="http://img.catpaws.top/img/image-20240713185911831-2024-7-1318_59_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713185911831"><figcaption aria-hidden="true">image-20240713185911831</figcaption></figure><p>2、<code>select id, profession,age,status, name from tb_user where profession = '软件工程' and age = 31 and status = '0';</code>相比于上一条 sql，这条 sql 的查询结果中需要返回的列多了一个 name 字段。其执行计划的 Extra 列的信息为：<u>Using index condition</u></p><figure><img src="http://img.catpaws.top/img/image-20240713185952078-2024-7-1319_00_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713185952078"><figcaption aria-hidden="true">image-20240713185952078</figcaption></figure><figure><img src="http://img.catpaws.top/img/image-20240713190303548-2024-7-1319_03_04.png" srcset="/img/loading.gif" lazyload alt="image-20240713190303548"><figcaption aria-hidden="true">image-20240713190303548</figcaption></figure><p>由于对 profession、age、status 建立的联合索引索引二级索引（辅助索引），在二级索引的叶子结点中不仅包含了对应索引字段的值，还包括该记录对应的聚集索引的 id（一般是主键 id）。</p><p>故对应第一条 sql 语句，其需要返回的字段在二级索引树上全部都能查到，直接返回结果，一次索引扫描即可，不需要回表查询。但对于第二条 sql，其返回结果中多出了二级索引树上没有的 name 字段，此时需要根据当前的聚集索引 id，在聚集索引中进行回表查询，得到完整的记录，从中得到 name 字段，整合后返回。</p><p>图示如下：</p><figure><img src="http://img.catpaws.top/img/image-20240713190928026-2024-7-1319_09_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713190928026"><figcaption aria-hidden="true">image-20240713190928026</figcaption></figure><figure><img src="http://img.catpaws.top/img/image-20240713191033317-2024-7-1319_10_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713191033317"><figcaption aria-hidden="true">image-20240713191033317</figcaption></figure><figure><img src="http://img.catpaws.top/img/image-20240713191436663-2024-7-1319_14_42.png" srcset="/img/loading.gif" lazyload alt="image-20240713191436663"><figcaption aria-hidden="true">image-20240713191436663</figcaption></figure><h4 id="前缀索引">前缀索引</h4><p>一、前缀索引 当字段类型为字符串（ varchar ， text ， longtext 等）时，有时候需要索引很长的字符串，这会让 索引变得很大，查询时，浪费大量的磁盘 IO ， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><ol type="1"><li>语法</li></ol><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_xxxx <span class="hljs-keyword">on</span> table_name(<span class="hljs-keyword">column</span>(n)) ;</code></pre></div><p>示例:</p><p>为 tb_user 表的 email 字段，建立长度为 5 的前缀索引。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index index_email <span class="hljs-keyword">on</span> tb_user(email(<span class="hljs-number">5</span>));</code></pre></div><figure><img src="https://img-blog.csdnimg.cn/direct/315660d9baf0456db40d15ffd11f4475.png" srcset="/img/loading.gif" lazyload alt="前缀索引-1"><figcaption aria-hidden="true">前缀索引-1</figcaption></figure><ol start="2" type="1"><li>如何选择前缀长度 可以根据索引的<code>选择性</code>来决定，而选择性是指<code>不重复的索引值（基数）</code>和<code>数据表的记录总数</code>的<strong>比值</strong>，索引选择性越高则查询效率越高， 唯一索引的选择性是 1 ，这是最好的索引选择性，性能也是最好的。</li></ol><p>下面这里我们看一下案例：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> email)<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user;</code></pre></div><figure><img src="https://img-blog.csdnimg.cn/direct/12ffdc72e70f42eeb16dc585ab7bb7aa.png" srcset="/img/loading.gif" lazyload alt="前缀索引-2"><figcaption aria-hidden="true">前缀索引-2</figcaption></figure><p>可以看到上面显示的是 1，也就是说所有的 email 字段的数据都没有出现重复，下面我们去从 email 字段数据去截取前 5 个字符比较试试看：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-built_in">substring</span>(email,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user ;</code></pre></div><figure><img src="https://img-blog.csdnimg.cn/direct/12ffdc72e70f42eeb16dc585ab7bb7aa.png" srcset="/img/loading.gif" lazyload alt="前缀索引-3"><figcaption aria-hidden="true">前缀索引-3</figcaption></figure><p>这里我们可以看出出现重复了，但是非重复率还是有 0.9583 的，如果我们截取前 4 个或者前 6 个字符再试试看重复率：</p><div class="code-wrapper"><pre><code class="hljs sql">#截取前四个
<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-built_in">substring</span>(email,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user ;</code></pre></div><figure><img src="https://img-blog.csdnimg.cn/direct/f673ce33855541d498f0e8c8d7e5ade5.png" srcset="/img/loading.gif" lazyload alt="前缀索引-4"><figcaption aria-hidden="true">前缀索引-4</figcaption></figure><div class="code-wrapper"><pre><code class="hljs sql">#截取前<span class="hljs-number">6</span>个
<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-built_in">substring</span>(email,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user ;</code></pre></div><figure><img src="https://img-blog.csdnimg.cn/direct/85b0f173fd704df1aab543ea750dfec3.png" srcset="/img/loading.gif" lazyload alt="前缀索引-5"><figcaption aria-hidden="true">前缀索引-5</figcaption></figure><p>上面这两个对比就知道，截取前 4 个的话重复率变大了，而截取前 6 个的话重复率不变 ，故最优解就是截取前面前 5 个即可。</p><ol start="3" type="1"><li>前缀索引的查询流程 前缀索引的查询流程基本上跟前面讲到过的是差不多的，这里会通过我们选择好的前缀去建立一个辅助索引，在辅助索引上面去找到相对应的索引目标，如果出现重复的话就会先找到第一个重复的索引数据，然后再去进行回表查询得到对应行完整的数据，如果完整数据中的对应字段与查询条件相同，则返回改行数据；反之继续遍历下一个重复的结果。</li></ol><figure><img src="https://img-blog.csdnimg.cn/direct/5914eaa0180445c6b12f2c8ebc41c2ee.png" srcset="/img/loading.gif" lazyload alt="前缀索引-6"><figcaption aria-hidden="true">前缀索引-6</figcaption></figure><h4 id="单列索引联合索引">单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列。</p><p>联合索引：即一个索引包含了多个列。</p><p>查看当前 tb_user 表中建立的索引情况：</p><figure><img src="http://img.catpaws.top/img/image-20240719100709418-2024-7-1910_07_44.png" srcset="/img/loading.gif" lazyload alt="image-20240719100709418"><figcaption aria-hidden="true">image-20240719100709418</figcaption></figure><p>在 tb_user 表中已经针对 phone 和 name 分别建立了单列索引，此时执行一条 sql，以 phone 和 name 为查询条件，查看其执行计划</p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,phone,name <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> phone<span class="hljs-operator">=</span><span class="hljs-string">&#x27;17799990000&#x27;</span> <span class="hljs-keyword">and</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;吕布&#x27;</span>;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240719101022564-2024-7-1910_10_22.png" srcset="/img/loading.gif" lazyload alt="image-20240719101022564"><figcaption aria-hidden="true">image-20240719101022564</figcaption></figure><p>可能用到的索引为 index_phone 和 index_name，但实际上在执行这条 sql 时 MySQL 只用到了其中的一个索引 index_phone。在针对 phone 建立的索引树中并没有 name 字段，故还要进行回表查询。</p><p>对 phone 和 name 建立联合索引后，执行该 sql，再次查询执行计划</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index idx_user_phone_name <span class="hljs-keyword">on</span> tb_user(phone,name);
explain <span class="hljs-keyword">select</span> id,phone,name <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> phone<span class="hljs-operator">=</span><span class="hljs-string">&#x27;17799990000&#x27;</span> <span class="hljs-keyword">and</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;吕布&#x27;</span>;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240719101448693-2024-7-1910_14_52.png" srcset="/img/loading.gif" lazyload alt="image-20240719101448693"><figcaption aria-hidden="true">image-20240719101448693</figcaption></figure><p>发现此时，MySQL 使用的还是 index_phone。<u>在多条件联合查询时，MySQL 优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。</u></p><p>此时可以通过 SQL 提示，建议 MySQL 使用联合索引，而在联合索引中包含 phone、name 的信息，在叶子节点下挂的是对应的主键 id，所以查询是无需回表查询的。</p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,phone,name <span class="hljs-keyword">from</span> tb_user use index(idx_user_phone_name)<span class="hljs-keyword">where</span> phone<span class="hljs-operator">=</span><span class="hljs-string">&#x27;17799990010&#x27;</span> <span class="hljs-keyword">and</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;韩信&#x27;</span>;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240719101848501-2024-7-1910_18_52.png" srcset="/img/loading.gif" lazyload alt="image-20240719101848501"><figcaption aria-hidden="true">image-20240719101848501</figcaption></figure><blockquote><p><strong>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</strong></p></blockquote><p>如果查询使用的是联合索引，具体的结构示意图如下：</p><figure><img src="http://img.catpaws.top/img/image-20240719102106348-2024-7-1910_21_52.png" srcset="/img/loading.gif" lazyload alt="image-20240719102106348"><figcaption aria-hidden="true">image-20240719102106348</figcaption></figure><p>根据索引定义顺序，在 B+树中先按照 phone 进行排序，phone 相同再按照 name 进行排序。注意联合索引使用时要遵循<code>最左前缀法则</code>。</p><h3 id="索引设计原则">3.6、索引设计原则</h3><p>针对什么表建立索引？针对表中的那些字段建立索引？建立什么类型的索引？</p><blockquote><ol type="1"><li>针对于数据量较大，且<strong>查询比较频繁</strong>的表建立索引。</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索 引。</li><li>尽量选择区<strong>分度高的列</strong>作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li><strong>尽量使用联合索引，减少单列索引</strong>，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。注意联合索引使用时要遵循<code>最左前缀法则</code>。</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li><li>如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询</li></ol></blockquote><h2 id="四sql-优化">四、SQL 优化</h2><h3 id="插入数据">4.1、插入数据</h3><p>平时我们插入数据的时候一般都是一个语句插一个数据，如下所示：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;tom&#x27;</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;cat&#x27;</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;jerry&#x27;</span>);
.....</code></pre></div><p>每条 insert 语执行时都需要和 MySQL 建立/释放连接，开启和提交事务，执行 SQL 语句，进行数据传输，当时数据量较大时效率很低。</p><p>如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p><ol type="1"><li><p>insert 插入的优化方案</p><p>（1）优化方案一：<strong>批量插入</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">Insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);</code></pre></div><p>相较于一条语句插入一个数据，一次性插入批量数据效率必然是更高的，这就不需要多次开启和提交事务了，节约时间。</p><p>（2）优化方案二：<strong>手动提交事务</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">start</span> transaction;
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);
<span class="hljs-keyword">commit</span>;</code></pre></div><p>手动控制事务，其实这个语句的就是方法 1 的本质，也就是通过一次事务去提交，避免多次开启事务的情况。</p><p>（3）优化方案三：<strong>主键顺序插入</strong></p><p>主键顺序插入，性能要高于乱序插入。这个应该没什么好多说了，排序肯定是需要耗时间的。</p><div class="code-wrapper"><pre><code class="hljs bash">主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3
主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89</code></pre></div></li><li><p>大批量插入数据 如果一次性需要插入大批量数据 ( 比如 : 几百万的记录 ) ，使用 insert 语句插入性能较低，此时可以使用 MySQL 数据库提供的<code>load指令</code>进行插入(<strong>在 load 时，主键顺序插入性能高于乱序插入</strong>)。操作如下： <img src="https://img-blog.csdnimg.cn/direct/8cdd02cbdfb64c6c9d181e69ec7d6e9b.png" srcset="/img/loading.gif" lazyload alt="load指令"></p><p>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 客户端连接服务端时，加上参数 -–local-infile
mysql –-local-infile -u root -p

-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile = 1;

-- 执行load指令将准备好的数据，加载到表结构中
load data local infile &#x27;/root/sql1.log&#x27; into table tb_user fields
terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27; ;</code></pre></div><p>补充：对于 load 指令的语句中，fields terminated by 意思是每一个字段之间间隔符号用什么</p><p>lines terminated by 意思是每一行间距是用什么。</p></li></ol><h3 id="主键优化">4.2、主键优化</h3><p>在上面，我们提到，主键顺序插入的性能是要高于乱序插入的。 这一小节，就来介绍一下具体的原因，然后再分析一下主键又该如何设计。</p><ol type="1"><li><p><strong>数据组织方式</strong></p><p>在 InnoDB 存储引擎中，<strong>表数据都是根据主键顺序组织存放的</strong>，这种存储方式的表称为索引组织表(index organized table IOT)</p><figure><img src="http://img.catpaws.top/img/image-20240720093108993-2024-7-2009_31_12.png" srcset="/img/loading.gif" lazyload alt="image-20240720093108993"><figcaption aria-hidden="true">image-20240720093108993</figcaption></figure><p>行数据，都是存储在聚集索引的叶子节点上的。而根据 InnoDB 的逻辑结构图：</p><figure><img src="http://img.catpaws.top/img/image-20240711104512418-2024-7-1110_45_17.png" srcset="/img/loading.gif" lazyload alt="image-20240711104512418"><figcaption aria-hidden="true">image-20240711104512418</figcaption></figure><p>在 InnoDB 引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认 16K 。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行 row 在该页存储不下，将会存储到下一个页中，页与页之间会通过指针连接。</p></li><li><p><strong>页分裂</strong></p><p>页可以为空，也可以填充一半，也可以填充 100% 。每个页包含了 2-N 行数据 ( 如果一行数据过大，会行溢出) ，根据主键排列。</p><blockquote><p>主键顺序插入效果</p></blockquote><p>① . 从磁盘中申请页， 主键顺序插入</p><figure><img src="http://img.catpaws.top/img/image-20240720093553745-2024-7-2009_35_54.png" srcset="/img/loading.gif" lazyload alt="image-20240720093553745"><figcaption aria-hidden="true">image-20240720093553745</figcaption></figure><p>②. 第一个页没有满，继续往第一页插入</p><figure><img src="http://img.catpaws.top/img/image-20240720093614767-2024-7-2009_36_23.png" srcset="/img/loading.gif" lazyload alt="image-20240720093614767"><figcaption aria-hidden="true">image-20240720093614767</figcaption></figure><p>③ . 当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</p><figure><img src="http://img.catpaws.top/img/image-20240720093649301-2024-7-2009_37_23.png" srcset="/img/loading.gif" lazyload alt="image-20240720093649301"><figcaption aria-hidden="true">image-20240720093649301</figcaption></figure><p>④. 当第二页写满了，再往第三页写入</p><figure><img src="http://img.catpaws.top/img/image-20240720093735297-2024-7-2009_38_24.png" srcset="/img/loading.gif" lazyload alt="image-20240720093735297"><figcaption aria-hidden="true">image-20240720093735297</figcaption></figure><blockquote><p>主键乱序插入效果</p></blockquote><p>① . 当 1#,2#页都已经写满了，存放了如图所示的数据</p><figure><img src="http://img.catpaws.top/img/image-20240720093843413-2024-7-2009_39_23.png" srcset="/img/loading.gif" lazyload alt="image-20240720093843413"><figcaption aria-hidden="true">image-20240720093843413</figcaption></figure><p>② . 此时再插入 id 为 50 的记录，我们来看看会发生什么现象</p><figure><img src="http://img.catpaws.top/img/image-20240720093908409-2024-7-2009_40_23.png" srcset="/img/loading.gif" lazyload alt="image-20240720093908409"><figcaption aria-hidden="true">image-20240720093908409</figcaption></figure><p>会再次开启一个页，写入新的页中吗？答案是不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在 47 之后。但是 47 所在的 1#页，已经写满了，存储不了 50 对应的数据了。 那么此时会开辟一个新的页 3#</p><figure><img src="http://img.catpaws.top/img/image-20240720093956540-2024-7-2009_41_23.png" srcset="/img/loading.gif" lazyload alt="image-20240720093956540"><figcaption aria-hidden="true">image-20240720093956540</figcaption></figure><p>但是并不会直接将 50 存入 3#页，而是会将 1#页后一半的数据，移动到 3#页，然后在 3#页，插入 50。</p><figure><img src="http://img.catpaws.top/img/image-20240720094028985-2024-7-2009_42_16.png" srcset="/img/loading.gif" lazyload alt="image-20240720094028985"><figcaption aria-hidden="true">image-20240720094028985</figcaption></figure><p>此时，这三个页之间的数据顺序是有问题的。 1# 的下一个页，应该是 3# ， 3# 的下一个页是 2# 。 所以，此时，需要重新设置链表指针。</p><figure><img src="http://img.catpaws.top/img/image-20240720094114446-2024-7-2009_42_19.png" srcset="/img/loading.gif" lazyload alt="image-20240720094114446"><figcaption aria-hidden="true">image-20240720094114446</figcaption></figure><p>上述的这种现象，称之为 "<code>页分裂</code>"，是比较耗费性能的操作。</p></li><li><p>页合并</p><p>目前表中已有数据的索引结构 ( 叶子节点)如下：</p><figure><img src="http://img.catpaws.top/img/image-20240720094212022-2024-7-2009_42_20.png" srcset="/img/loading.gif" lazyload alt="image-20240720094212022"><figcaption aria-hidden="true">image-20240720094212022</figcaption></figure><p>当我们对已有数据进行删除时，具体的效果如下 :</p><p>当删除一行记录时<u>，实际上记录并没有被物理删除，只是记录被标记（ flaged ）为删除并且它的空间变得允许被其他记录声明使用。</u></p><figure><img src="http://img.catpaws.top/img/image-20240720094328067-2024-7-2009_43_28.png" srcset="/img/loading.gif" lazyload alt="image-20240720094328067"><figcaption aria-hidden="true">image-20240720094328067</figcaption></figure><p>继续删除 2#的内容，当页中删除的记录达到 MERGE_THRESHOLD （默认为页的 50% ），InnoDB 会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p><figure><img src="http://img.catpaws.top/img/image-20240720094843818-2024-7-2009_49_18.png" srcset="/img/loading.gif" lazyload alt="image-20240720094843818"><figcaption aria-hidden="true">image-20240720094843818</figcaption></figure><figure><img src="http://img.catpaws.top/img/image-20240720094915435-2024-7-2009_49_19.png" srcset="/img/loading.gif" lazyload alt="image-20240720094915435"><figcaption aria-hidden="true">image-20240720094915435</figcaption></figure><p>这个里面所发生的合并页的这个现象，就称之为 "<code>页合并</code>"</p></li><li><p><strong>主键设计原则</strong></p><ul><li>满足业务需求的情况下，尽量降低主键的长度。（<u>在二级索引的叶子结点中保存着主键，如果主键过长，二级索引较多，会占用较大的磁盘空间，且在搜索时会进行大量的磁盘 IO</u> ）</li><li>插入数据时，尽量选择顺序插入。（<u>乱序插入可能会导致页分裂，插入效率低</u>）</li><li>选择使用 AUTO_INCREMENT 自增主键，尽量不要使用 UUID 做主键或者是其他自然主键，如身份证号。（<u>这些是无序的，且长度较长</u>）</li><li>业务操作时，避免对主键的修改。（<u>还要修改二级索引的内容</u>）</li></ul></li></ol><h3 id="order-by-优化">4.3、order by 优化</h3><p>MySQL 的排序，有两种方式：</p><ul><li>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在<u>排序缓冲区 sort buffer 中完成排序操作</u>，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。（如果缓冲区满了，会进一步在磁盘中进行排序）</li><li>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要 额外排序，操作效率高。</li></ul><p><strong>对于以上的两种排序方式，Using index 的性能高，而 Using filesort 的性能低，我们在优化排序操作时，尽量要优化为 Using index。</strong></p><p>SQL 排序使用了哪种方式，可以通过<code>explain</code>在 SQL 语句执行计划的 Extra 字段查看</p><blockquote><p>测试索引对排序的效果</p></blockquote><p>1、在 tb_user 表中，删除 age 和 phone 的索引，再根据这两个字段进行排序，查看其执行计划.</p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id ,age ,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240720101450542-2024-7-2010_14_50.png" srcset="/img/loading.gif" lazyload alt="image-20240720101450542"><figcaption aria-hidden="true">image-20240720101450542</figcaption></figure><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age, phone ;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240720101228160-2024-7-2010_12_33.png" srcset="/img/loading.gif" lazyload alt="image-20240720101228160"><figcaption aria-hidden="true">image-20240720101228160</figcaption></figure><p>由于 age, phone 都没有索引，所以此时再排序时，出现 Using filesort， 排序性能较低。</p><p>2、创建索引后，再次进行排序，查看执行计划</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建索引</span>
<span class="hljs-keyword">create</span> index idx_age_phone <span class="hljs-keyword">on</span> tb_user(age,phone);</code></pre></div><blockquote><p>默认 age 和 phone 都是升序建立的索引</p></blockquote><p>A. 根据 age, phone 进行<strong>升序排序</strong></p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240720101717524-2024-7-2010_17_17.png" srcset="/img/loading.gif" lazyload alt="image-20240720101717524"><figcaption aria-hidden="true">image-20240720101717524</figcaption></figure><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age , phone;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240720101747424-2024-7-2010_18_10.png" srcset="/img/loading.gif" lazyload alt="image-20240720101747424"><figcaption aria-hidden="true">image-20240720101747424</figcaption></figure><p>B. 根据 age，phone 进行<strong>降序排序</strong></p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">desc</span> , phone <span class="hljs-keyword">desc</span> ;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240720102255101-2024-7-2010_22_55.png" srcset="/img/loading.gif" lazyload alt="image-20240720102255101"><figcaption aria-hidden="true">image-20240720102255101</figcaption></figure><blockquote><p>注：由于 age 和 phone 都是升序建立的索引，当排序时两者都是升序，排序方式是 Using index；当两者都是降序时，Extra 中也是 Using index，但多了 Backward index scan，这个代表反向扫描索引，因为在 MySQL 中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan 。</p></blockquote><p>C. <strong>对于排序使用联合索引的情况，排序时 , 也需要满足最左前缀法则 , 否则也会出现 filesort 。</strong>因为在创建索引的时候， age 是第一个字段， phone 是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using filesort。</p><p>D. 排序时<strong>根据 age 升序排序，根据 phone 降序排序</strong></p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span> ,phone <span class="hljs-keyword">desc</span> ;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240720102448603-2024-7-2010_25_15.png" srcset="/img/loading.gif" lazyload alt="image-20240720102448603"><figcaption aria-hidden="true">image-20240720102448603</figcaption></figure><p>因为创建索引时，如果未指定顺序，默认都是按照升序排序的（A 是表示升序 asc，D 的话是表示降序 desc），而<strong>查询时，一个升序，一个降序，此时就会出现 Using filesort</strong> 。</p><figure><img src="http://img.catpaws.top/img/image-20240720102604013-2024-7-2010_26_04.png" srcset="/img/loading.gif" lazyload alt="image-20240720102604013"><figcaption aria-hidden="true">image-20240720102604013</figcaption></figure><p>为了解决上述问题，为了解决上述的问题，我们可以创建一个索引，这个联合索引中 age 升序排序， phone 倒序排序。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_age_phone_ad <span class="hljs-keyword">on</span> tb_user(age <span class="hljs-keyword">asc</span> ,phone <span class="hljs-keyword">desc</span>);</code></pre></div><p>再次执行上述排序 SQL,查看其执行计划，其中排序方法为 Using index</p><figure><img src="http://img.catpaws.top/img/image-20240720103026285-2024-7-2010_30_34.png" srcset="/img/loading.gif" lazyload alt="image-20240720103026285"><figcaption aria-hidden="true">image-20240720103026285</figcaption></figure><p><strong>由上述的测试,我们得出 order by 优化原则:</strong></p><p>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p><p>B. 尽量使用覆盖索引。（以上排序方法为 Using index 的前提是使用覆盖索引，否则要进行回表查询，得到数据后在排序缓冲区中进行排序，效率低）</p><p>C. 多字段排序 , 一个升序一个降序，此时需要注意联合索引在创建时的规则（ ASC/DESC ）。</p><p>D. 如果不可避免的出现 filesort ，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认 256k) 。</p><h3 id="group-by-优化">4.4、group by 优化</h3><p>在分组操作时，可以通过索引来提高效率 （尽量建立联合索引）。</p><p>A. 在没有索引的情况下，执行如下 SQL ，查询执行计划：</p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> profession , <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> profession ;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240721100347253-2024-7-2110_03_50.png" srcset="/img/loading.gif" lazyload alt="image-20240721100347253"><figcaption aria-hidden="true">image-20240721100347253</figcaption></figure><p>B. 针对于 profession ， age ， status 创建一个联合索引后执行相同的 SQL，查看执行计划</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建联合索引</span>
<span class="hljs-keyword">create</span> index idx_user_pro_age_sta <span class="hljs-keyword">on</span> tb_user(profession , age , status);

<span class="hljs-comment">--执行上述SQL</span>
explain <span class="hljs-keyword">select</span> profession , <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> profession ;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240721100608323-2024-7-2110_06_09.png" srcset="/img/loading.gif" lazyload alt="image-20240721100608323"><figcaption aria-hidden="true">image-20240721100608323</figcaption></figure><blockquote><p><strong>注：在 Group By 中使用联合索引也要遵循最左前缀法则</strong></p></blockquote><h3 id="limit-优化">4.5、limit 优化</h3><p><strong>对应 limit 分页操作，在大数据的情况下，分页内容越靠后效率越低</strong>。如：limit 2000000，10，此时需要 MySQL 排序前 2000010 记录，仅仅返回 2000000-2000010 的记录，其他记录丢弃，查询排序的代价非常大。</p><p>优化策略：<strong>覆盖索引 + 子查询</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--在 tb_sku表中查询 2000000 ~ 2000010范围内的数据</span>

<span class="hljs-comment">-- 使用覆盖索引，先查询到该范围内记录的id，再将查询到的id作为临时表</span>
<span class="hljs-keyword">select</span> t.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_sku t, (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">2000000</span>,<span class="hljs-number">10</span>) a
<span class="hljs-keyword">where</span> t.id <span class="hljs-operator">=</span> a.id;</code></pre></div><h3 id="count-优化">4.6、count 优化</h3><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user ;</code></pre></div><figure><img src="http://img.catpaws.top/img/image-20240721102724886-2024-7-2110_27_49.png" srcset="/img/loading.gif" lazyload alt="image-20240721102724886"><figcaption aria-hidden="true">image-20240721102724886</figcaption></figure><p>优化思路：<strong>自己计数</strong>，利用 key-value 内存级别的数据库，如 Redis，在其中设置一个字段 total 保存表中记录数。当在表中新增一条记录时，total 加 1；当在表中删除一条记录时，total 减一。</p><p><strong>常见 count 的几种用法和其效率的对比：</strong></p><blockquote><p><strong>count（）是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。</strong></p></blockquote><ul><li><p>count（主键）</p><p>InnoDB 引擎会遍历整张表，把每一行的主键 id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加（主键不可能为 null）。</p></li><li><p>count（字段）</p><p>没有 not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为 null，不为 null，计数累加。</p><p>有 not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</p></li><li><p>count（数字）</p><p>InnoDB 引擎遍历整张表，但<strong>不取值</strong>。服务层对于返回的每一行，放一个数字（如 0,-1,1 等）进去，直接按行进行累加。</p></li><li><p>count（*）</p><p>InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，<strong>不取值</strong>，服务层直接按行进行累加。</p></li></ul><figure><img src="http://img.catpaws.top/img/image-20240721103622142-2024-7-2110_36_26.png" srcset="/img/loading.gif" lazyload alt="image-20240721103622142"><figcaption aria-hidden="true">image-20240721103622142</figcaption></figure><h3 id="update-优化">4.7、update 优化</h3><blockquote><p><strong>InnoDB 的行锁是针对<u>索引</u>加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</strong></p></blockquote><p>在执行 update 语句时要根据索引字段进行选择，否则行锁就会升级为表锁，降低并发性能。</p><figure><img src="http://img.catpaws.top/img/image-20240721104513524-2024-7-2110_45_49.png" srcset="/img/loading.gif" lazyload alt="image-20240721104513524"><figcaption aria-hidden="true">image-20240721104513524</figcaption></figure><h3 id="总结">总结</h3><figure><img src="http://img.catpaws.top/img/image-20240721105139164-2024-7-2110_51_49.png" srcset="/img/loading.gif" lazyload alt="image-20240721105139164"><figcaption aria-hidden="true">image-20240721105139164</figcaption></figure><h2 id="五视图存储过程触发器">五、视图/存储过程/触发器</h2><h3 id="视图">5.1、视图</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=97&amp;vd_source=51d78ede0a0127d1839d6abf9204d1ee">参考视频</a></p><p>什么是视图？</p><p>视图：站在不同的角度去看待同一份数据。</p><h4 id="视图创建和删除">视图创建和删除</h4><p>创建视图对象：</p><div class="code-wrapper"><pre><code class="hljs mysql">create view dept2_view as select * from dept2;</code></pre></div><blockquote><p>注意：</p><p>只有 DQL 语句才能以 view 的形式创建。 <code>create view view_name as</code> 这里的语句必须是 DQL 语句;</p></blockquote><p>删除视图对象：</p><div class="code-wrapper"><pre><code class="hljs mysql">drop view dept2_view;</code></pre></div><h4 id="视图的用途">视图的用途</h4><p>方便，简化开发，利于维护。我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致 原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）</p><div class="code-wrapper"><pre><code class="hljs mysql">//面向视图查询
select * from dept2_view;

// 面向视图插入
insert into dept2_view(deptno,dname,loc) values(60,&#x27;SALES&#x27;, &#x27;BEIJING&#x27;);

// 查询原表数据
mysql&gt; select * from dept2;
+--------+------------+----------+
| DEPTNO | DNAME      | LOC      |
+--------+------------+----------+
|     10 | ACCOUNTING | NEW YORK |
|     20 | RESEARCH   | DALLAS   |
|     30 | SALES      | CHICAGO  |
|     40 | OPERATIONS | BOSTON   |
|     60 | SALES      | BEIJING  |
+--------+------------+----------+

// 面向视图删除
mysql&gt; delete from dept2_view;

// 查询原表数据
mysql&gt; select * from dept2;
Empty set (0.00 sec)</code></pre></div><p>​ 假设有一条非常复杂的 SQL 语句，而这条 SQL 语句需要在不同的位置上反复使用。每一次使用这个 sql 语句的时候都需要重新编写，很长，很麻烦，怎么办？可以把这条复杂的 SQL 语句以视图对象的形式新建。在需要编写这条 SQL 语句的位置直接使用视图对象，可以大大简化开发。并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要修改视图对象所映射的 SQL 语句。</p><p>​ 我们以后面向视图开发的时候，使用视图的时候可以像使用 table 一样。可以对视图进行增删改查等操作。视图不是在内存当中，视图对象也是存储在硬盘上的，不会消失。</p><h3 id="存储过程">5.2、存储过程</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=102&amp;vd_source=51d78ede0a0127d1839d6abf9204d1ee">参考视频</a></p><h3 id="触发器">5.3、触发器</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=116&amp;vd_source=51d78ede0a0127d1839d6abf9204d1ee">参考视频</a></p><h2 id="六锁">六、锁</h2><h3 id="概述">6.1、概述</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM，I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>分类：MySQL 中的锁，按照锁的粒度分，分为以下三类：</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ul><h3 id="全局锁">6.2、全局锁</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于<strong>只读状态</strong>，后续的 DML 的写语句，DDL 语句，已经更新操作的事务提交语句都将被阻塞。</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 添加全局锁
flush tables with read lock;

-- 释放全局锁
unlock tables;</code></pre></div><p>其典型的使用场景是<strong>做全库的逻辑备份</strong>，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。其过程如下：</p><figure><img src="http://img.catpaws.top/img/image-20240721111958996-2024-7-2111_20_02.png" srcset="/img/loading.gif" lazyload alt="image-20240721111958996"><figcaption aria-hidden="true">image-20240721111958996</figcaption></figure><p>注：在终端命令行中运行 mysqldump 命令，不要登录了 MySQL 再用。</p><figure><img src="http://img.catpaws.top/img/image-20240721113057150-2024-7-2111_31_35.png" srcset="/img/loading.gif" lazyload alt="image-20240721113057150"><figcaption aria-hidden="true">image-20240721113057150</figcaption></figure><h3 id="表级锁">6.3、表级锁</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在 MyISAM，InnoDB、BDB 等存储引擎中。</p><p>对于表级锁，主要分为一下三类：</p><ul><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li></ul><h4 id="表锁">表锁</h4><p>​ <img src="http://img.catpaws.top/img/image-20240721183519013-2024-7-2118_35_49.png" srcset="/img/loading.gif" lazyload alt="image-20240721183519013"></p><h4 id="元数据锁">元数据锁</h4><figure><img src="http://img.catpaws.top/img/image-20240721185606540-2024-7-2118_56_11.png" srcset="/img/loading.gif" lazyload alt="image-20240721185606540"><figcaption aria-hidden="true">image-20240721185606540</figcaption></figure><h4 id="意向锁">意向锁</h4><figure><img src="http://img.catpaws.top/img/image-20240721191002372-2024-7-2119_10_25.png" srcset="/img/loading.gif" lazyload alt="image-20240721191002372"><figcaption aria-hidden="true">image-20240721191002372</figcaption></figure><p><strong>为了避免 DML 在执行时，加的行锁与表锁的冲突，在 InnoDB 中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</strong>添加意向锁后，再添加表锁，直接根据意向锁以及意向锁的类型，判断当前表锁能否添加成功，不用再逐行检查。</p><blockquote><p><strong>意向锁分类以及和表锁的兼容情况</strong></p></blockquote><p><strong>意向锁的分类</strong></p><p><img src="http://img.catpaws.top/img/image-20240721191411802-2024-7-2119_14_12.png" srcset="/img/loading.gif" lazyload alt="image-20240721191411802"></p><p><strong>与表锁的兼容情况</strong></p><figure><img src="http://img.catpaws.top/img/image-20240721191539971-2024-7-2119_15_49.png" srcset="/img/loading.gif" lazyload alt="image-20240721191539971"><figcaption aria-hidden="true">image-20240721191539971</figcaption></figure><p>可以通过以下 SQL，查看意向锁及行锁的加锁情况：</p><div class="code-wrapper"><pre><code class="hljs mysql">select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks;</code></pre></div><h3 id="行级锁">6.4、行级锁</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB 存储引擎中。</p><p><strong>InnoDB 的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的</strong>锁。对于行级锁，主要分为以下三类：</p><p>1.行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行 update 和 delete。在 RC、RR 隔离级别下都支持。</p><p><img src="http://img.catpaws.top/img/image-20240721192230333-2024-7-2119_22_49.png" srcset="/img/loading.gif" lazyload alt="image-20240721192230333">2.间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行 insert，产生幻读。在 RR 隔离级别下都支持。</p><p><img src="http://img.catpaws.top/img/image-20240721192259087-2024-7-2119_23_49.png" srcset="/img/loading.gif" lazyload alt="image-20240721192259087">3.临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙 Gap。在 RR 隔离级别下支持。</p><figure><img src="http://img.catpaws.top/img/image-20240721192315885-2024-7-2119_24_49.png" srcset="/img/loading.gif" lazyload alt="image-20240721192315885"><figcaption aria-hidden="true">image-20240721192315885</figcaption></figure><h4 id="行锁">行锁</h4><figure><img src="http://img.catpaws.top/img/image-20240721192932330-2024-7-2119_29_49.png" srcset="/img/loading.gif" lazyload alt="image-20240721192932330"><figcaption aria-hidden="true">image-20240721192932330</figcaption></figure><p>常见数据库操作语句锁添加的锁的类型：</p><figure><img src="http://img.catpaws.top/img/image-20240721193132992-2024-7-2119_31_49.png" srcset="/img/loading.gif" lazyload alt="image-20240721193132992"><figcaption aria-hidden="true">image-20240721193132992</figcaption></figure><h2 id="七数据库设计三范式">七、数据库设计三范式</h2><p>​ 数据库设计范式是符合某一种级别的关系模式的集合。设计关系数据库时，遵从不同的规范要求，可以设计出合理的关系型数据库。这些规范要求被称为不同的范式，越高的范式数据库冗余越小。满足这些规范的数据库是简洁的、结构明晰的，同时不会发生插入、删除和更新操作异常。</p><p>数据结构范式的种类：</p><ol type="1"><li><p>‌<strong>第一范式（1NF）</strong>‌：要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。</p><p>第一范式，最核心，最重要的范式，所有表的设计都需要满足</p><div class="code-wrapper"><pre><code class="hljs mysql">学生编号 学生姓名 联系方式
------------------------------------------
1001		张三		zs@gmail.com,1359999999
1002		李四		ls@gmail.com,13699999999
1001		王五		ww@163.net,13488888888

以上是学生表，不满足第一范式，第一：没有主键。第二：联系方式可以分为邮箱地址和电话

学生编号(pk) 		学生姓名	邮箱地址		联系电话
----------------------------------------------------
1001				张三		zs@gmail.com	1359999999
1002				李四		ls@gmail.com	13699999999
1003				王五		ww@163.net		13488888888
</code></pre></div></li><li><p>‌<strong>第二范式（2NF）</strong>‌：在第一范式的基础上，要求表中的所有非主键字段完全依赖于主键。</p><div class="code-wrapper"><pre><code class="hljs mysql">学生编号 		学生姓名   教师编号 教师姓名
----------------------------------------------------
1001			张三		001		王老师
1002			李四		002		赵老师
1003			王五		001		王老师
1001			张三		002		赵老师

这张表描述了学生和老师的关系：（1个学生可能有多个老师，1个老师有多个学生),这是非常典型的：多对多关系！

以上的表不满足第一范式，应改为


学生编号+教师编号(pk)			学生姓名  		教师姓名
----------------------------------------------------
1001			001				张三			王老师
1002			002				李四			赵老师
1003			001				王五			王老师
1001			002				张三			赵老师

学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号），经过修改之后，以上的表满足了第一范式。
但是不满足第二范式，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。产生部分依赖会导致数据冗余，空间浪费。


为了让以上的表满足第二范式，需要这样设计
  学生表
  学生编号(pk)		学生名字
  ------------------------------------
  1001					张三
  1002					李四
  1003					王五

  教师表
  教师编号(pk)		教师姓名
  --------------------------------------
  001					王老师
  002					赵老师

  学生教师关系表
  id(pk)			学生编号(fk)			教师编号(fk)
  ------------------------------------------------------
  1						1001						001
  2						1002						002
  3						1003						001
  4						1001						002

口诀：多对多，三张表，关系表两个外键</code></pre></div></li><li><p>‌<strong>第三范式（3NF）</strong>‌：在第二范式的基础上，要求表中的每个非主键字段不依赖于其他非主键字段。</p><div class="code-wrapper"><pre><code class="hljs mysql">学生编号（PK） 学生姓名 班级编号  班级名称
---------------------------------------------------------
  1001				张三		01			一年一班
  1002				李四		02			一年二班
  1003				王五		03			一年三班
  1004				赵六		03			一年三班

以上表的设计是描述：班级和学生的关系。很显然是1对多关系，一个教室中有多个学生。
以上表满足第一范式，有主键。
以上表满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。

但是不满足第三范式，第三范式要求：不要产生传递依赖！一年一班依赖01，01依赖1001，产生了传递依赖。不符合第三范式的要求。产生了数据的冗余。

那么应该怎么设计一对多呢？

  班级表：一
  班级编号(pk)				班级名称
  ----------------------------------------
  01								一年一班
  02								一年二班
  03								一年三班

  学生表：多

  学生编号（PK） 学生姓名 班级编号(fk)
  -------------------------------------------
  1001				张三			01
  1002				李四			02
  1003				王五			03
  1004				赵六			03

口诀：一对多，两张表，多的表加外键
</code></pre></div></li><li><p>‌<strong>巴斯-科德范式（BCNF）</strong>‌：进一步减少数据冗余，确保每个决定因素只依赖于主键。</p></li><li><p>‌<strong>第四范式（4NF）</strong>‌：解决多值依赖问题，确保每个决定因素不依赖于其他非主键字段。</p></li><li><p>‌<strong>第五范式（5NF）</strong>‌：又称完美范式，进一步减少数据冗余，确保每个决定因素不依赖于其他非主键字段。</p></li></ol></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="category-chain-item">数据库</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E4%BA%8B%E5%8A%A1/" class="print-no-link">#事务</a> <a href="/tags/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/" class="print-no-link">#InnoDB存储引擎</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" class="print-no-link">#索引</a> <a href="/tags/SQL%E4%BC%98%E5%8C%96/" class="print-no-link">#SQL优化</a> <a href="/tags/%E9%94%81/" class="print-no-link">#锁</a></div></div><div class="license-box my-3"><div class="license-title"><div>MySQL（二）</div><div>https://catpaws.top/bd62c17f/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年12月8日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/f07c622d/" title="MySQL（三）"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">MySQL（三）</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/8d742da7/" title="MySQL（一）"><span class="hidden-mobile">MySQL（一）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://cdn.smartcis.cn/npm/twikoo@1.6.40/dist/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a><br>人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//img.catpaws.top/blog-source/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://unpkg.com/oh-my-live2d"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"http://img.catpaws.top/blog-source/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"},idleTips:{interval:15e3,message:function(){return axios.get("https://v1.hitokoto.cn?c=i").then((function(t){return t.data.hitokoto})).catch((function(t){console.error(t)}))}}}})</script></body></html>