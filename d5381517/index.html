<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><link rel="icon" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="一、集合体系结构  Java集合是Java中用于存储和操作数据结构的核心库，其体系结构设计清晰，主要分为两大根接口：Collection和Map。  Collection代表单列集合，每个元素（数据）只包含一个值。 Map代表双列集合，每个元素包含两个值（键值对）。  1.1、Collection集合体系  Collection集合特点  List系列集合：添加的元素是有"><meta property="og:type" content="article"><meta property="og:title" content="java 集合"><meta property="og:url" content="https://catpaws.top/d5381517/index.html"><meta property="og:site_name" content="猫爪在上の书桌"><meta property="og:description" content="一、集合体系结构  Java集合是Java中用于存储和操作数据结构的核心库，其体系结构设计清晰，主要分为两大根接口：Collection和Map。  Collection代表单列集合，每个元素（数据）只包含一个值。 Map代表双列集合，每个元素包含两个值（键值对）。  1.1、Collection集合体系  Collection集合特点  List系列集合：添加的元素是有"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206232137786-2025-2-623:21:38.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/Collection.drawio-2025-9-717:22:19.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/map.drawio-2025-9-717:02:08.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206225828677-2025-2-622:58:29.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206231131946-2025-2-623:11:39.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206231910075-2025-2-623:19:17.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/list.drawio-2025-9-717:23:13.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250207094312800-2025-2-709:43:14.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250207153751245-2025-2-715:38:04.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/ArrayList%E6%89%A9%E5%AE%B9%E5%8E%9F%E7%90%86-2025-2-716:03:30.jpg"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-2025-2-716:29:04.jpg"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250207173805391-2025-2-717:38:11.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250207182132745-2025-2-718:21:39.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250207183326836-2025-2-718:33:36.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250207202158990-2025-2-720:22:03.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-2025-2-719:42:03.jpg"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250207202653978-2025-2-720:26:55.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-2025-2-720:44:57.jpg"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/set.drawio-2025-9-717:24:06.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-2025-2-800:58:50.jpg"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250208133657810-2025-2-813:37:19.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250208143217618-2025-2-814:32:35.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/queue.drawio-2025-9-717:25:10.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250912160332570-2025-9-1216:03:39.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250912171313904-2025-9-1217:13:36.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250912171950251-2025-9-1217:19:51.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250912225705206-2025-9-1222:57:10.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/map.drawio-2025-9-717:02:08.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250208222217866-2025-2-822:22:19.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250208222635363-2025-2-822:26:36.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250208223042986-2025-2-822:30:44.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-2025-2-822:42:36.jpg"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250208220230998-2025-2-822:02:36.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250208235237416-2025-2-823:52:40.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BE-2025-2-900:28:49.jpg"><meta property="article:published_time" content="2025-02-06T15:12:38.000Z"><meta property="article:modified_time" content="2025-09-12T15:03:04.488Z"><meta property="article:author" content="猫爪在上"><meta property="article:tag" content="JavaSE"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250206232137786-2025-2-623:21:38.png"><title>java 集合 - 猫爪在上の书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/font.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/poem.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/shubiao.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/loader.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/twikoo_beautify.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/indeximg-hover.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/wave.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/blurpicload.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/reward/iconfont.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"https://catpaws.top/blog-resource/imgs/transparent.svg",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://leancloud.catpaws.top",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loader-container"><div class="loader"><div class="wrapper"><div class="catContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 733 673" class="catbody"><path fill="#212121" d="M111.002 139.5C270.502 -24.5001 471.503 2.4997 621.002 139.5C770.501 276.5 768.504 627.5 621.002 649.5C473.5 671.5 246 687.5 111.002 649.5C-23.9964 611.5 -48.4982 303.5 111.002 139.5Z"></path><path fill="#212121" d="M184 9L270.603 159H97.3975L184 9Z"></path><path fill="#212121" d="M541 0L627.603 150H454.397L541 0Z"></path></svg> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 158 564" class="tail"><path fill="#191919" d="M5.97602 76.066C-11.1099 41.6747 12.9018 0 51.3036 0V0C71.5336 0 89.8636 12.2558 97.2565 31.0866C173.697 225.792 180.478 345.852 97.0691 536.666C89.7636 553.378 73.0672 564 54.8273 564V564C16.9427 564 -5.4224 521.149 13.0712 488.085C90.2225 350.15 87.9612 241.089 5.97602 76.066Z"></path></svg><div class="text"><span class="bigzzz">Z</span> <span class="zzz">Z</span></div></div><div class="wallContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 500 126" class="wall"><line stroke-width="6" stroke="#7C7C7C" y2="3" x2="450" y1="3" x1="50"></line><line stroke-width="6" stroke="#7C7C7C" y2="85" x2="400" y1="85" x1="100"></line><line stroke-width="6" stroke="#7C7C7C" y2="122" x2="375" y1="122" x1="125"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="500" y1="43"></line><line stroke-width="6" stroke="#7C7C7C" y2="1.99391" x2="115.5" y1="43.0061" x1="115.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00002" x2="189" y1="43.0122" x1="189"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00612" x2="262.5" y1="43.0183" x1="262.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01222" x2="336" y1="43.0244" x1="336"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01833" x2="409.5" y1="43.0305" x1="409.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="153" y1="84.0122" x1="153"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="228" y1="84.0122" x1="228"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="303" y1="84.0122" x1="303"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="378" y1="84.0122" x1="378"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="192" y1="125.012" x1="192"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="267" y1="125.012" x1="267"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="342" y1="125.012" x1="342"></line></svg></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上の书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>个人主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://catpaws.top/blog-resource/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="java 集合"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-02-06 23:12" pubdate>2025年2月6日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 20k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 166 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">java 集合</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年9月12日 晚上</p><div class="markdown-body"><meta name="referrer" , content="no-referrer"><h1 id="一集合体系结构">一、集合体系结构</h1><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206232137786-2025-2-623:21:38.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>Java集合是Java中用于存储和操作数据结构的核心库，其体系结构设计清晰，主要分为两大根接口：<strong>Collection</strong>和<strong>Map</strong>。</p><ul><li>Collection代表单列集合，每个元素（数据）只包含一个值。</li><li>Map代表双列集合，每个元素包含两个值（键值对）。</li></ul><h2 id="collection集合体系">1.1、Collection集合体系</h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/Collection.drawio-2025-9-717:22:19.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>Collection集合特点</p><ul><li>List系列集合：添加的元素是<span style="color:red">有序、可重复、有索引</span>。<ul><li>ArrayList、LinekdList：有序、可重复、有索引。</li></ul></li><li>Set系列集合：添加的元素是<span style="color:red">无序、不重复、无索引</span>。<ul><li>HashSet：无序、不重复、无索引；</li><li>LinkedHashSet：<strong>有序</strong>、不重复、无索引。</li><li>TreeSet：<strong>按照大小默认升序排序</strong>、不重复、无索引。</li></ul></li><li>Queue系列集合：<ul><li>添加的元素按照特定的规则排序（FIFO, LIFO, 或优先级）</li><li>访问元素通常被限制在队列的<strong>头部</strong>和<strong>尾部</strong>，不能随机访问中间元素。</li></ul></li></ul><blockquote><p>其中：<strong>有序和无序</strong>是指存和取的顺序是否一致，与元素值的大小无关；</p></blockquote><h2 id="map集合体系">1.2、Map集合体系</h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/map.drawio-2025-9-717:02:08.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h1 id="二collection集合">二、Collection集合</h1><p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Collection.html">Collection API参考文档</a></p><h2 id="collection集合的常用方法">2.1、Collection集合的常用方法</h2><p>Collection是单列集合的祖宗，它规定的方法（功能）是全部单列集合都会继承的</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206225828677-2025-2-622:58:29.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h2 id="collection的遍历方式">2.2、Collection的遍历方式</h2><h3 id="迭代器">迭代器</h3><p>迭代器是用来遍历集合的专用方式（数组没有迭代器），在Java中迭代器的代表是<strong>Iterator</strong>。</p><p>所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器。</p><p>Collection集合获取迭代器的方法：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206231131946-2025-2-623:11:39.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>Iterator迭代器中的常用方法：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206231910075-2025-2-623:19:17.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>示例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
     Collection&lt;String&gt; coll = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
     coll.add(<span class="hljs-string">&quot;aaa&quot;</span>);
     coll.add(<span class="hljs-string">&quot;bbb&quot;</span>);
     coll.add(<span class="hljs-string">&quot;ccc&quot;</span>);
     coll.add(<span class="hljs-string">&quot;ddd&quot;</span>);
     coll.add(<span class="hljs-string">&quot;eee&quot;</span>);

     <span class="hljs-comment">//获取迭代器对象</span>
     <span class="hljs-comment">//迭代器就好像一个箭头,默认指向集合的0索引处</span>
     Iterator&lt;String&gt; it = coll.iterator();
 	<span class="hljs-comment">//利用循环不断地去获取集合中的每一个元素</span>
     <span class="hljs-keyword">while</span> (it.hasNext())&#123;
         <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> it.next();
         System.out.println(str);
     &#125;
 &#125;
</code></pre></div><p>迭代器的注意点：</p><ol type="1"><li>越界会报错NoSuchElementException</li><li>迭代器遍历完毕，指针不会复位</li><li>循环中只能用一次next方法</li><li>迭代器遍历时，不能用集合的方法进行增加或者删除</li></ol><h3 id="增强for循环">增强for循环</h3><p>格式如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (元素的数据类型 变量名 : 数组或集合) &#123;
    ...
&#125;</code></pre></div><ul><li>增强for可以用来遍历集合或者数组。</li><li>增强for遍历集合，本质就是迭代器遍历集合的简化写法。</li></ul><h3 id="lambda表达式">lambda表达式</h3><p>Java Lambda 表达式是 Java 8 引入的核心特性之一，它提供了一种简洁的语法来表示<strong>函数式接口（Functional Interface）</strong>的实例，使得代码更加简洁、灵活，尤其在集合操作和函数式编程中广泛应用。</p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LHY537200/article/details/136889277">参考文章</a></p><p>Collection接口继承了Iterable接口，其中的<code>forEach</code>方法可以结合Lambda表达式来遍历集合。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250206233634331-2025-2-623:36:35.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaExample</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        Collection&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);
        <span class="hljs-comment">//使用匿名内部类</span>
        numbers.forEach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;Integer&gt;() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Integer number)</span> &#123;
                System.out.println(number + <span class="hljs-string">&quot; &quot;</span>);
            &#125;
        &#125;);
        
        <span class="hljs-comment">// Lambda表达式作为参数传递给forEach方法</span>
        numbers.forEach(number -&gt; System.out.print(number+<span class="hljs-string">&quot; &quot;</span>));
    &#125;
&#125;</code></pre></div><h3 id="案例">案例</h3><p>Movies类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Movies</span> &#123;
    <span class="hljs-keyword">private</span> String name;
    <span class="hljs-keyword">private</span> Double score;
    <span class="hljs-keyword">private</span> String actor;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Movies</span><span class="hljs-params">(String name, Double score, String actor)</span> &#123;
        <span class="hljs-built_in">this</span>.name = name;
        <span class="hljs-built_in">this</span>.score = score;
        <span class="hljs-built_in">this</span>.actor = actor;
    &#125;
    <span class="hljs-comment">// ... getter、 setter</span>
&#125;</code></pre></div><p>测试：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        Collection&lt;Movies&gt; movies = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        movies.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Movies</span>(<span class="hljs-string">&quot;《肖生克的救赎》&quot;</span>,<span class="hljs-number">9.7</span>,<span class="hljs-string">&quot;罗宾斯&quot;</span>));
        movies.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Movies</span>(<span class="hljs-string">&quot;《霸王别姬》&quot;</span>,<span class="hljs-number">9.6</span>,<span class="hljs-string">&quot;张国荣、张丰毅&quot;</span>));
        movies.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Movies</span>(<span class="hljs-string">&quot;《阿甘正传》&quot;</span>,<span class="hljs-number">9.5</span>,<span class="hljs-string">&quot;汤姆.汉克斯&quot;</span>));
        System.out.println(movies);
        <span class="hljs-comment">//输出的是对象的地址：[Movies@1e643faf, Movies@6e8dacdf, Movies@7a79be86]</span>

        <span class="hljs-keyword">for</span> (Movies movie : movies) &#123;
            System.out.println(<span class="hljs-string">&quot;片名: &quot;</span> + movie.getName());
            System.out.println(<span class="hljs-string">&quot;评分：&quot;</span> + movie.getScore());
            System.out.println(<span class="hljs-string">&quot;演员：&quot;</span> + movie.getActor());
            System.out.println(<span class="hljs-string">&quot;------------------------------------&quot;</span>);
        &#125;
    &#125;</code></pre></div><p>集合存储对象的原理：</p><p>集合中存储的是元素对象的地址。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250207093953123-2025-2-709:40:12.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><h2 id="list系列集合">2.3、List系列集合</h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/list.drawio-2025-9-717:23:13.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>List系列集合：添加的元素是<span style="color:red">有序、可重复、有索引</span>。</p><ul><li>ArrayList、LinekdList：有序、可重复、有索引。</li></ul><blockquote><p>其中：<strong>有序和无序</strong>是指存和取的顺序是否一致，与元素值的大小无关；</p></blockquote><h3 id="list集合的特有方法">List集合的特有方法</h3><p>List集合因为支持索引，所以多了很多与索引相关的方法，当然，Collection的功能List也都继承了。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250207094312800-2025-2-709:43:14.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>因为List集合有<strong>索引</strong>，所以List的遍历方式除了迭代器、增强for循环、Lambda表达式外，还支持<strong>一般的for循环</strong>。</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
list.add(<span class="hljs-string">&quot;糖宝宝&quot;</span>);
list.add(<span class="hljs-string">&quot;蜘蛛精&quot;</span>);
list.add(<span class="hljs-string">&quot;至尊宝&quot;</span>);

<span class="hljs-comment">//for循环</span>
<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++)&#123;
    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> list.get(i);
    System.out.println(s);
&#125;</code></pre></div><h3 id="arraylist的底层原理">ArrayList的底层原理</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/util/ArrayList.html">ArrayList API参考文档</a></p><p><strong><code>ArrayList</code></strong> 内部维护了一个 <strong><code>Object[] elementData</code></strong> 数组，用于存储元素。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250207141716465-2025-2-714:17:20.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><blockquote><p>补充：</p><p><code>transient</code> 是一个关键字，用于修饰类的成员变量。它的核心作用是<strong>标记某个字段不参与默认的序列化过程</strong>。</p><p><code>ArrayList</code> 的底层数组 <code>elementData</code> 被声明为 <code>transient</code>，但序列化时依然能保存所有元素。这是因为<code>ArrayList</code> <strong>自定义了序列化逻辑</strong>，覆盖了 <code>writeObject()</code> 和 <code>readObject()</code> 方法。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250207153751245-2025-2-715:38:04.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>优化目的：<code>elementData</code> 的容量可能大于实际元素数量（例如扩容后），直接序列化整个数组会浪费空间。通过自定义序列化，<strong>序列化时仅写入有效元素，而非整个数组，减少存储开销。</strong></p></blockquote><h4 id="动态扩容原理">动态扩容原理</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-comment">// 1、使用无参构造器</span>
        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-comment">//2、使用指定大小的构造器</span>
        <span class="hljs-comment">//List&lt;Integer&gt; list = new ArrayList&lt;&gt;(8);</span>
        <span class="hljs-comment">//添加1 - 10元素</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            list.add(i);
        &#125;
&#125;</code></pre></div><ul><li><p>当创建ArrayList对象时，如果使用的是<strong>无参构造器</strong>，则初始elementData容量为0。第一次添加元素时elementData扩容为10。如需要再次扩容，则扩容elementData为1.5倍。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/ArrayList扩容原理-2025-2-716:03:30.jpg" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:67%"></p></li><li><p>如果使用的是<strong>指定大小的构造器</strong>，则初始elementData容量为指定大小，如果需要扩容则直接扩容elementData为1.5倍。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/未命名绘图-2025-2-716:29:04.jpg" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:67%"></p></li></ul><p>从源码可以看出，ArrayList的操作方法上并没有添加<code>syncronized</code>关键字，所以是<strong>非线程安全的</strong>。在多线程环境下可以使用<code>Vector</code> ，它一个线程安全的类，它在每个方法上都使用了同步机制。</p><blockquote><p>补充：</p><p>ArrayList的<code>Fail-Fast</code> 机制：</p><p><code>ArrayList</code> 的 <code>Fail-Fast</code> 机制是一种设计模式，用于检测集合在迭代过程中是否被修改。如果检测到集合被修改，会立即抛出 <code>ConcurrentModificationException</code> 异常，以确保迭代的安全性和一致性，防止并发修改问题。</p><ol type="1"><li><strong><code>modCount</code> 计数器</strong>：<code>ArrayList</code> 中有一个名为 <code>modCount</code> 的内部计数器，用于记录集合结构的修改次数。每当集合的结构发生变化（如添加或删除元素），<code>modCount</code> 的值就会增加。</li><li><strong>迭代器的 <code>expectedModCount</code></strong>：当创建一个迭代器时，迭代器会保存一个 <code>expectedModCount</code> 值，该值是迭代器创建时 <code>modCount</code> 的值。在迭代过程中，迭代器会不断检查 <code>expectedModCount</code> 是否与当前的 <code>modCount</code> 匹配。</li><li><strong>检查和抛出异常</strong>：在每次调用 <code>next</code> 或 <code>remove</code> 方法时，迭代器会检查 <code>expectedModCount</code> 是否与当前的 <code>modCount</code> 匹配。如果不匹配，说明集合在迭代过程中被修改了，迭代器会抛出 <code>ConcurrentModificationException</code>异常。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FailFastExample</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        list.add(<span class="hljs-number">1</span>);
        list.add(<span class="hljs-number">2</span>);
        list.add(<span class="hljs-number">3</span>);

        Iterator&lt;Integer&gt; iterator = list.iterator();

        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
            <span class="hljs-type">Integer</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> iterator.next();
            System.out.println(element);

            <span class="hljs-comment">// 在迭代过程中修改集合</span>
            <span class="hljs-keyword">if</span> (element == <span class="hljs-number">2</span>) &#123;
                list.remove(element); <span class="hljs-comment">// 这里会抛出 ConcurrentModificationException</span>
                iterator.remove(); <span class="hljs-comment">// 使用迭代器的 remove 方法安全地删除元素</span>
            &#125;
        &#125;
    &#125;
&#125;
</code></pre></div></blockquote><h4 id="总结">总结</h4><p><code>ArrayList</code> 是一个灵活且功能强大的集合类，适用于大多数需要动态数组的场景。它的优点在于动态大小、快速随机访问和丰富的 API，而缺点主要体现在线程安全性、插入和删除的效率、内存占用和只能存储对象等方面。</p><p>优点</p><ol type="1"><li><p><strong>动态大小</strong>：</p><p><code>ArrayList</code> 可以根据需要自动调整其大小，用户无需手动管理数组的大小。</p></li><li><p><strong>快速随机访问</strong>：</p><p>由于内部实现基于数组，<code>ArrayList</code> 提供了 O(1) 的时间复杂度来通过索引访问元素，访问速度非常快。</p></li><li><p><strong>保持元素顺序</strong>：</p><p><code>ArrayList</code> 保持插入元素的顺序，允许用户按插入顺序访问和遍历元素。</p></li><li><p><strong>允许重复元素</strong>：</p><p><code>ArrayList</code> 允许存储重复的元素，这使得在某些情况下更灵活。</p></li></ol><p>缺点</p><ol type="1"><li><p><strong>非线程安全</strong>：</p><p><code>ArrayList</code> 在多线程环境下是非线程安全的，多个线程同时访问和修改时可能会导致数据不一致。</p></li><li><p><strong>低效的插入和删除</strong>：</p><p>在数组的中间插入或删除元素时，可能需要移动后续的元素，导致时间复杂度为 O(n)。在尾部添加元素时，虽然通常是 O(1)，但在扩展容量时也会变为 O(n)。</p></li><li><p><strong>内存占用</strong>：</p><p><code>ArrayList</code> 在扩展时可能会分配比实际需要更多的内存，导致内存的浪费。尤其是在大量元素删除后，内部数组的大小不会自动缩小。<code>trimToSize()</code> 方法可将数组容量调整为当前元素数量，释放多余空间。</p></li><li><p><strong>只能存储对象</strong>：</p><p><code>ArrayList</code> 只能存储对象，不能直接存储基本数据类型（如 <code>int</code>、<code>char</code> 等），需要使用包装类（如 <code>Integer</code>、<code>Character</code> 等）。</p></li></ol><h3 id="vector的底层原理">Vector的底层原理</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Vector.html">Vector API参考文档</a></p><p>Java中的<code>Vector</code>类是一个线程安全的动态数组实现，<code>Vector</code>内部使用一个Object数组<code>elementData</code>存储元素，与<code>ArrayList</code>类似。默认初始容量为<strong>10</strong>。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250207173805391-2025-2-717:38:11.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p><strong>扩容策略</strong></p><p>当元素数量超过当前数组长度时，Vector会进行扩容：</p><ul><li>若通过构造函数指定了<code>capacityIncrement</code>参数（增量值），则新容量为<code>旧容量 + capacityIncrement</code>。</li><li>若未指定<code>capacityIncrement</code>（默认为0），则新容量为<code>旧容量 *2</code>（即翻倍）。</li><li>扩容时调用<code>Arrays.copyOf()</code>复制数据到新数组。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VectorTest</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        Vector&lt;Integer&gt; vector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;
            vector.add(i);
        &#125;
    <span class="hljs-comment">//超出默认大小10，需要进行扩容</span>
        vector.add(<span class="hljs-number">10</span>);
    &#125;
&#125;</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250207174352997-2025-2-717:43:54.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="与ArraList一样，使用grow函数做真正扩容操作"><figcaption aria-hidden="true">与ArraList一样，使用grow函数做真正扩容操作</figcaption></figure><p>Vector的所有修改操作（如<code>add</code>、<code>remove</code>、<code>set</code>）均使用<code>synchronized</code>关键字修饰方法，确保多线程环境下的线程安全，但这也导致在单线程环境下性能不如ArrayList。</p><p>由于频繁的锁竞争导致性能低于<code>CopyOnWriteArrayList</code>（写时复制技术，适合读多写少场景）或<code>Collections.synchronizedList</code>（包装后的同步列表，通用同步），现在更推荐使用这两个来代替Vector。</p><p><strong>与 ArrayList对比：</strong></p><table><thead><tr class="header"><th><strong>特性</strong></th><th><strong>Vector</strong></th><th><strong>ArrayList</strong></th></tr></thead><tbody><tr class="odd"><td><strong>线程安全</strong></td><td>是（方法级同步）</td><td>否</td></tr><tr class="even"><td><strong>扩容策略</strong></td><td>默认翻倍或固定增量</td><td>默认增长50%（旧容量1.5倍）</td></tr><tr class="odd"><td><strong>性能</strong></td><td>低（同步开销）</td><td>高</td></tr><tr class="even"><td><strong>迭代器遍历</strong></td><td>需外部同步</td><td>非线程安全</td></tr></tbody></table><h3 id="stack">Stack</h3><p>首先，<strong><code>Stack</code> 未被纳入 Java 集合框架</strong>。<code>Stack</code>类是一个自Java 1.0以来就存在的古老类，而Java 1.2 引入了集合框架。</p><p><code>Stack</code>继承自<code>Vector</code>类，因此它也就继承了<code>Vector</code>的同步方法和一些不适用于栈操作的方法（如<code>insertElementAt</code>、<code>removeElementAt</code>等），这不仅破坏了栈应有的封装性，还造成了单线程下的性能问题。</p><p>从Java 1.6开始，Java引入了<code>Deque</code>接口（双端队列），并且提供了多种实现，如<code>ArrayDeque</code>和<code>LinkedList</code>。<code>Deque</code>接口支持在两端进行元素的插入和删除，因此完全可以作为栈来使用（栈只要求在一端进行操作）。</p><p>Java官方文档也建议使用<code>Deque</code>来实现栈的功能。在<code>Stack</code>类的文档中也有说明：“更完整和一致的LIFO栈操作由<code>Deque</code>接口及其实现提供，应该优先使用这类而不是<code>Stack</code>。</p><h3 id="linkedlist的底层原理">LinkedList的底层原理</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/util/LinkedList.html">LinkedList API参考文档</a></p><p>Java中的 <code>LinkedList</code>是基于 <strong>双向链表</strong>实现的线性表，它的内部结构由节点（Node）构成，每个节点包含数据以及指向前后节点的指针（prev和next）。</p><p>此外，LinkedList还实现了Deque接口，因此可以作为<u>普通队列</u>和<u>双端队列</u>使用。</p><h4 id="核心字段">核心字段</h4><p>这个简单的 <code>Node</code> 类是 <code>LinkedList</code> 的基石。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;
    E item;         <span class="hljs-comment">// 存储的元素数据</span>
    Node&lt;E&gt; next;   <span class="hljs-comment">// 指向下一个节点的引用</span>
    Node&lt;E&gt; prev;   <span class="hljs-comment">// 指向上一个节点的引用</span>

    <span class="hljs-comment">// 构造函数</span>
    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;
        <span class="hljs-built_in">this</span>.item = element;
        <span class="hljs-built_in">this</span>.next = next;
        <span class="hljs-built_in">this</span>.prev = prev;
    &#125;
&#125;</code></pre></div><p>size、first、last这三个属性维护了整个链表的状态。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt;
    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSequentialList</span>&lt;E&gt;
    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;
    
    <span class="hljs-comment">// 链表中元素的数量</span>
    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 指向第一个节点的指针</span>
<span class="hljs-comment">     * 如果链表为空，则为 null</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">transient</span> Node&lt;E&gt; first;
    
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">     * 指向最后一个节点的指针</span>
<span class="hljs-comment">     * 如果链表为空，则为 null</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;
    
    <span class="hljs-comment">// 其他方法和构造函数...</span>
&#125;</code></pre></div><h4 id="构造函数">构造函数</h4><p>默认构造函数只是初始化一个空链表，头节点和尾节点都为null。当添加第一个元素时，头节点和尾节点都指向这个新创建的节点。当添加更多元素时，新节点会被添加到链表的尾部或头部，具体取决于调用的方法。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250207182132745-2025-2-718:21:39.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>带参数的构造函数接受一个<code>Collection</code>类型的参数<code>c</code>，这个参数是一个包含元素的集合。这个构造函数首先调用无参构造函数创建一个空的<code>LinkedList</code>，然后使用<code>addAll</code>方法将参数<code>c</code>中的所有元素添加到这个<code>LinkedList</code>中。这样，新创建的<code>LinkedList</code>就包含了参数<code>c</code>中的所有元素。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250207183326836-2025-2-718:33:36.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="添加元素">添加元素</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250207202158990-2025-2-720:22:03.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListTest</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        <span class="hljs-comment">//添加一个结点，以add() 方法为例</span>
        list.add(<span class="hljs-number">1</span>);
        System.out.println(list);
    &#125;
&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/未命名绘图-2025-2-719:42:03.jpg" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="删除元素">删除元素</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250207202653978-2025-2-720:26:55.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedListTest</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        list.add(<span class="hljs-number">1</span>);
        <span class="hljs-comment">// 删除一个结点，以remove()方法为例</span>
        list.remove();
        System.out.println(list);
    &#125;
&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/未命名绘图-2025-2-720:44:57.jpg" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>其他操作类似，都是对双端链表进行操作</p><p>线程安全方面，LinkedList和ArrayList一样，不是线程安全的。如果多个线程同时修改链表，可能会导致数据不一致。因此，在多线程环境中，需要使用外部同步或使用并发集合类，比如CopyOnWriteArrayList，或者通过Collections.synchronizedList来包装LinkedList。</p><h3 id="list集合的选择">List集合的选择</h3><h4 id="list实现对比"><strong>List实现对比</strong>：</h4><table><thead><tr class="header"><th><strong>实现类</strong></th><th><strong>数据结构</strong></th><th><strong>线程安全</strong></th><th><strong>适用场景</strong></th><th><strong>性能特点</strong></th></tr></thead><tbody><tr class="odd"><td><strong><code>ArrayList</code></strong></td><td>动态数组</td><td>❌非线程安全</td><td>读多写少、频繁随机访问</td><td>快速随机访问（<code>O(1)</code>），尾部插入高效（<code>O(1)</code>）</td></tr><tr class="even"><td><strong><code>LinkedList</code></strong></td><td>双向链表</td><td>❌非线程安全</td><td>频繁头尾增删、需实现队列/栈</td><td>头尾增删高效（<code>O(1)</code>），随机访问慢（<code>O(n)</code>）</td></tr><tr class="odd"><td><strong><code>Vector</code></strong></td><td>动态数组</td><td>✅线程安全（方法级同步）</td><td>遗留代码兼容（不推荐新项目）</td><td>同步锁导致性能低，扩容默认翻倍</td></tr><tr class="even"><td><strong><code>CopyOnWriteArrayList</code></strong></td><td>动态数组</td><td>✅线程安全（写时复制）</td><td>高并发读、极少写</td><td>写操作昂贵（<code>O(n)</code>），读操作无锁（<code>O(1)</code>）</td></tr><tr class="odd"><td><strong><code>Collections.synchronizedList</code></strong></td><td>包装类</td><td>✅线程安全（外部锁）</td><td>需要同步的非线程安全 <code>List</code></td><td>性能优于 <code>Vector</code>，需手动控制锁范围</td></tr></tbody></table><hr><h4 id="选择策略"><strong>选择策略</strong></h4><p><strong>(1)单线程场景</strong></p><ul><li><strong>需求：快速随机访问</strong> → <strong><code>ArrayList</code></strong> （如：按索引频繁读取或修改元素）</li><li><strong>需求：频繁头尾增删</strong> → <strong><code>LinkedList</code></strong> （如：实现队列、栈或中间插入删除）</li><li><strong>需求：内存敏感</strong> → <strong><code>ArrayList</code></strong> （连续内存空间，无指针开销）</li></ul><p><strong>(2)多线程场景</strong></p><ul><li><strong>需求：读多写极少</strong> → <strong><code>CopyOnWriteArrayList</code></strong> （读无锁，写时复制数据）</li><li><strong>需求：通用同步</strong> → <strong><code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code></strong> （灵活控制同步范围）</li><li><strong>⚠️避免使用 <code>Vector</code></strong>：性能低且设计陈旧。</li></ul><p><strong>(3)特殊功能需求</strong></p><ul><li><strong>需求：双端队列（Deque）</strong> → <strong><code>LinkedList</code></strong>或 <strong><code>ArrayDeque</code></strong> （<code>LinkedList</code>实现 <code>Deque</code>，但 <code>ArrayDeque</code>内存更优）</li><li><strong>需求：栈（Stack）</strong> → <strong><code>ArrayDeque</code></strong> （替代遗留的 <code>Stack</code>类）</li></ul><p><strong>性能关键场景</strong>:</p><table><thead><tr class="header"><th><strong>场景</strong></th><th><strong>推荐实现</strong></th><th><strong>原因</strong></th></tr></thead><tbody><tr class="odd"><td>大规模数据遍历</td><td><code>ArrayList</code></td><td>CPU缓存友好，连续内存加速遍历</td></tr><tr class="even"><td>高频中间插入/删除</td><td><code>LinkedList</code></td><td>调整指针快于数组元素移动</td></tr><tr class="odd"><td>高并发读（如配置表）</td><td><code>CopyOnWriteArrayList</code></td><td>读无锁，保证最终一致性</td></tr><tr class="even"><td>高并发写（如实时日志）</td><td>外部同步 + <code>ArrayList</code></td><td>细粒度锁控制优于全方法同步</td></tr></tbody></table><h2 id="set系列集合">2.4、Set系列集合</h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/set.drawio-2025-9-717:24:06.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>Set系列集合：添加的元素是<span style="color:red">无序、不重复、无索引</span>。</p><ul><li>HashSet：无序、不重复、无索引；</li><li>LinkedHashSet：<strong>有序</strong>、不重复、无索引。</li><li>TreeSet：<strong>按照大小默认升序排序</strong>、不重复、无索引。</li></ul><blockquote><p>其中：<strong>有序和无序</strong>是指存和取的顺序是否一致，与元素值的大小无关；</p></blockquote><p>Set要用到的常用方法，基本上就是Collection提供的，自己几乎没有额外新增的功能。</p><p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Set.html">Set API文档</a></p><h3 id="hashset的底层原理">HashSet的底层原理</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/util/HashSet.html">HashSet API文档</a></p><p><code>HashSet</code>的底层是基于<code>HashMap</code>实现的。HashSet实际上使用HashMap的<strong>键</strong>来存储元素，而值则统一使用一个固定的 <code>PRESENT</code>静态对象占位。由于HashMap的键是唯一的，这样可以保证元素的唯一性。</p><p>HashMap底层是数组+链表/红黑树的结构。HashSet的元素被存储在HashMap的键数组中，每个数组位置可能是一个链表或红黑树，用来处理哈希冲突。当链表长度超过阈值（默认为8）并且整个table的大小超过64时，链表会转换为红黑树，以提高查询效率；当红黑树节点数小于6时，会退化为链表。</p><p>源码解析如下：</p><h4 id="构造函数-1">构造函数</h4><p>创建一个空的HashMap。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span>
<span class="hljs-comment"> * default initial capacity (16) and load factor (0.75).</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;
    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
&#125;</code></pre></div><h4 id="hashset扩容和转成红黑树的机制">HashSet扩容和转成红黑树的机制</h4><p>HashSet扩容机制：</p><ol type="1"><li><p><strong>触发条件</strong>：当HashMap中的元素数量超过 <strong>当前容量 * 负载因子</strong>时，会触发扩容。默认初始容量是16，负载因子0.75，所以当元素数超过12（16*0.75）时，会进行扩容。</p><p>新容量：当前容量的 2倍（如 16 →32）。</p><p>新阈值：新容量 ×负载因子（如 32 ×0.75 =24）。</p><div class="note note-info"><p>即：当存储的元素数量超过当前容量的3/4时触发扩容机制，新容量为当前容量的2倍</p></div></li><li><p>扩容过程</p><p>创建新数组，容量翻倍。然后遍历旧数组的所有桶，将每个元素重新计算哈希值，确定在新数组中的位置。这个过程将原链表拆分为高位和低位链表，以减少重新哈希后的冲突。</p></li></ol><p>HashMap底层是数组+链表/红黑树的结构。HashSet的元素被存储在HashMap的键数组中，每个数组位置可能是一个链表或红黑树，用来处理哈希冲突。</p><p>每将一个新元素结点插入到一个链表中，就需要根据当前链表的结点数和整个哈希表的长度进行判断，是否需要将当前的链表转化为红黑树存储。（<span style="color:red">树化条件：<strong>链表长度 ≥8</strong>且 <strong>数组长度 ≥64</strong></span>）</p><ul><li>若添加完新元素后，当前链表的<u>结点数</u><strong>达到</strong><code>TREEIFY_THRESHOLD</code> (8)，但整个哈希表的<u>长度</u><strong>未达到</strong> <code>MIN_TREEIFY_CAPACITY</code> (64)，则只将哈希表进行扩容</li><li>若添加完新元素后，当前链表的<u>结点数</u><strong>达到</strong><code>TREEIFY_THRESHOLD</code> (8)，且整个哈希表的<u>长度</u><strong>达到</strong> <code>MIN_TREEIFY_CAPACITY</code> (64)，则将当前链表转化为红黑树存储。</li></ul><h4 id="添加元素add方法">添加元素add方法</h4><p>案例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
    Set&lt;Object&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();
    <span class="hljs-comment">//添加字符串，重复条件：哈希值相同 且 （键地址相同 或 equals返回 true）</span>
    set.add(<span class="hljs-string">&quot;jack&quot;</span>); <span class="hljs-comment">// T：添加成功</span>
    set.add(<span class="hljs-string">&quot;dylan&quot;</span>); <span class="hljs-comment">// T</span>
    set.add(<span class="hljs-string">&quot;lucy&quot;</span>);<span class="hljs-comment">// T</span>
    set.add(<span class="hljs-string">&quot;jack&quot;</span>);<span class="hljs-comment">// F：添加失败</span>

    <span class="hljs-comment">//添加不同的对象</span>
    set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;Tom&quot;</span>)); <span class="hljs-comment">//T</span>
    set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;Tom&quot;</span>));<span class="hljs-comment">// T</span>


    <span class="hljs-comment">//添加字符串对象</span>
    set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;xiaomei&quot;</span>));<span class="hljs-comment">// T</span>
    set.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;xiaomei&quot;</span>));<span class="hljs-comment">// F</span>

    System.out.println(set);
&#125;</code></pre></div><p>步骤：</p><ul><li>先获取元素的哈希值（hashCode方法），再对哈希值进行运算，得出一个索引值即为要存放在哈希表中的位置号</li><li>如果该位置上没有其他元素，则直接存放。 如果该位置上已经有其他元素，则判断两者是否相等：<ul><li>若相等，则不再添加</li><li>如果不相等，则遍历该链表中的其他结点，判断是否有相等的，有则不再添加；否则，添加到链表尾部</li></ul></li><li>每次添加完元素，都要根据当前链表的结点数和整个哈希表的结点数进行判断，是否需要将当前的链表转化为红黑树存储。</li></ul><p>可以先看第一次执行add函数时相关操作的注释，先熟悉各个方法及其作用，再分析更复杂的情况。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/未命名绘图-2025-2-800:58:50.jpg" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="第一次add时相关操作的注释" style="zoom:80%"></p><ol type="1"><li><p>调用 <code>add(E e)</code>方法</p><p>当向 <code>HashSet</code>添加元素时，实际调用的是 <code>HashMap</code>的 <code>put</code>方法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/*</span>
<span class="hljs-comment">HashSet 底层使用HashMap的键存储，值为静态对象 PRESENT</span>
<span class="hljs-comment">    // Dummy value to associate with an Object in the backing Map</span>
<span class="hljs-comment">    private static final Object PRESENT = new Object();</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;
    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>; <span class="hljs-comment">//返回结果为null时，说明添加成功</span>
&#125;
---------------map.put()方法--------------------------------------------
<span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;
    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);
&#125;</code></pre></div></li><li><p>执行<code>put</code>方法，计算哈希值</p><p>首先获得key的hashCode，再通过位运算对哈希值高位进行扰动（spread），将高位的信息引入低位，使得哈希值的低位部分更加随机化，从而减少冲突。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;
        <span class="hljs-type">int</span> h;
        <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);
    &#125;</code></pre></div></li><li><p>执行<code>putVal</code>方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent, <span class="hljs-type">boolean</span> evict)</span> &#123;
    <span class="hljs-comment">//定义一些辅助变量</span>
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;
    <span class="hljs-comment">// table 是 HashMap的一个数组，类型是Node[]</span>
    <span class="hljs-comment">//初始table为null 或者 table的大小为0时，执行 resize() 方法对table扩容</span>
    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)
        n = (tab = resize()).length; <span class="hljs-comment">// 保存扩容后table的length，初始大小为 16</span>
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    *	索引定位：index = (n - 1) &amp; hash 等价于 用hash 和 n 做模运算，确定该元素在数组中的位置</span>
<span class="hljs-comment">    *	并将index位置的元素 tab[index] 保存在变量p中，判断是不是null，即判断这个位置有没有放元素</span>
<span class="hljs-comment">    *	若为null，说明该为为空，创建包含新元素的结点，将其放在index的位置</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)
        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);
    <span class="hljs-keyword">else</span> &#123; 
        <span class="hljs-comment">// 若 tab[index] 不为null，说明该位置已经存储了元素（同义词）</span>
        Node&lt;K,V&gt; e; K k;
        
        <span class="hljs-comment">/**</span>
<span class="hljs-comment">        * 此时p指向的可能是链表的第一个结点，也可能是红黑树的根节点</span>
<span class="hljs-comment">        * 去重判断：重复条件：哈希值相同 且 （键地址相同 或 equals返回 true），具体逻辑如下：</span>
<span class="hljs-comment">        * 判断：</span>
<span class="hljs-comment">        *	1、如果当前索引位置对应的结点 和准备添加的key的hash值一样 （不同hash值可能会散列到同一个位置）</span>
<span class="hljs-comment">        * 并且满足 下面两个条件之一</span>
<span class="hljs-comment">        *   2.1、准备加入的 key 和 p 指向结点的 key 是同一个对象</span>
<span class="hljs-comment">        *   2.2、p指向结点的 key，通过equals()方法 和准备加入的key比较后相同（对于自定义的对象，可以重写equals方法，自定义两个对象相等的逻辑）</span>
<span class="hljs-comment">        * 则说明准备添加的key 在HashSet中已经存在，直接跳过</span>
<span class="hljs-comment">        */</span>
        
        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))
            e = p;
        
        <span class="hljs-comment">// 再判断 p 指向的是不是一棵红黑树</span>
        <span class="hljs-comment">// 如果是一棵红黑树，就调用 putTreeVal() 方法进行判断/添加</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);
        
        <span class="hljs-comment">// 最后一种情况：当前p指向的是链表的第一个结点，但与待加入元素key不同</span>
        <span class="hljs-keyword">else</span> &#123;
            
            <span class="hljs-comment">/**</span>
<span class="hljs-comment">            * 循环遍历这个同义词链表中的所有结点，判断是否有和待加入元素key相同的。</span>
<span class="hljs-comment">            * 在for循环表达式中没有定义循环退出条件，是一个死循环，但在循环体内部有两种退出条件：</span>
<span class="hljs-comment">            */</span>
            
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123; 
                <span class="hljs-comment">//1、如果到达了链表尾部还没有提前退出，说明链表中没有与key相同的，则将key插入到链表末尾，并退出循环。</span>
                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// e = p.next，指针不断后移</span>
                    <span class="hljs-comment">//创建值为key的新结点，插入到链表末尾</span>
                    p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);
                    
                    <span class="hljs-comment">/**</span>
<span class="hljs-comment">                    * 每次插入新结点后都需进行判断，该链表是否已经达到8个结点，如果是，则调用treeifyBin 对当前这个链表进行树化，转成红黑树。</span>
<span class="hljs-comment">                    *  在 treeifyBin() 方法内部，首先判断 整个table的大小是否 超过了 MIN_TREEIFY_CAPACITY = 64</span>
<span class="hljs-comment">                    *  		如果没有超过，则先调用 resize() 对table进行扩容</span>
<span class="hljs-comment">                    *  		如果超过了，则进行树化（总结：树化的条件：当前链表节点个数 达到8 并且整个 table 的大小 达到64）</span>
<span class="hljs-comment">                    */</span>
                    
                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// TREEIFY_THRESHOLD = 8</span>
                        treeifyBin(tab, hash);
                    <span class="hljs-keyword">break</span>;
                &#125;
                <span class="hljs-comment">/**</span>
<span class="hljs-comment">                * 与上面判断key和第一个结点是否相同的逻辑一样</span>
<span class="hljs-comment">                * 判断链表中每一个结点是否和待插入的key相同，若发现有相同的，则直接break，退出循环</span>
<span class="hljs-comment">                */</span>
                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))
                    <span class="hljs-keyword">break</span>;
                p = e; <span class="hljs-comment">// 链表的循环指针后移，进行下一个结点的判断</span>
            &#125;
        &#125;
        
        
        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key 存在key相同的元素</span>
            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;
            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)
                e.value = value; <span class="hljs-comment">//用新的value *替换* 该结的value</span>
            afterNodeAccess(e);
            <span class="hljs-keyword">return</span> oldValue; <span class="hljs-comment">//不返回null，代表插入失败</span>
        &#125;
    &#125;
    <span class="hljs-comment">//对HashSet对象修改了一次，modCount++</span>
    ++modCount;
    <span class="hljs-comment">//添加了当前元素后，若数组的大小超过阈值threshold，则进行resize扩容</span>
    <span class="hljs-keyword">if</span> (++size &gt; threshold)
        resize();
    <span class="hljs-comment">//对当前HashMap来说，这是个空方法，主要是留给子类去实现，从而完成一下特定操作</span>
    afterNodeInsertion(evict);
    <span class="hljs-comment">//返回空代表成功</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
&#125;</code></pre></div></li><li><p><code>resize()</code>方法分析</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;
    <span class="hljs-comment">// 保存当前哈希表的引用到oldTab变量中</span>
    Node&lt;K,V&gt;[] oldTab = table;
     <span class="hljs-comment">// 获取当前哈希表的容量，如果表为空则容量为0</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;
    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;  <span class="hljs-comment">// 保存当前的扩容阈值（threshold）</span>
    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化新容量（newCap）和新阈值（newThr）</span>
    
    <span class="hljs-comment">//1、 如果当前哈希表的容量大于0</span>
    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-comment">// 如果当前容量已经达到最大允许容量</span>
        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
            threshold = Integer.MAX_VALUE; <span class="hljs-comment">//将扩容阈值设置为整型最大值（不再扩容）</span>
            <span class="hljs-keyword">return</span> oldTab; <span class="hljs-comment">// 返回当前表，不进行扩容。</span>
        &#125;
        <span class="hljs-comment">// 如果新容量（旧容量左移1位，即乘以2）小于最大容量 且 旧容量大于或等于默认初始容量</span>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 将新阈值设置为旧阈值的2倍</span>
    &#125;
    <span class="hljs-comment">//2、如果旧容量为0，但旧阈值大于0（表尚未初始化但已有阈值）</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>
        newCap = oldThr; <span class="hljs-comment">// 将新容量设置为旧阈值</span>
    
    <span class="hljs-comment">//3、 如果旧容量和旧阈值都为0（表示表完全未初始化）</span>
    <span class="hljs-keyword">else</span> &#123;               
        newCap = DEFAULT_INITIAL_CAPACITY; <span class="hljs-comment">// 设置新容量为默认初始容量（16）= 1 &lt;&lt; 4;</span>
        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="hljs-comment">// 根据默认加载因子（0.75）计算新阈值（16 *0.75 =12）</span>
    &#125;
    
    <span class="hljs-comment">//4、如果新阈值仍为0（可能在某些特殊情况下）</span>
    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;
        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<span class="hljs-comment">//计算新容量与加载因子的乘积</span>
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-type">float</span>)MAXIMUM_CAPACITY ?
                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE); <span class="hljs-comment">// 如果新容量和乘积都小于最大容量，则设置新阈值为乘积值，否则设置为整型最大值</span>
    &#125;
    
    
    threshold = newThr;<span class="hljs-comment">// 更新扩容阈值为新阈值</span>
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap]; <span class="hljs-comment">// 创建一个新的哈希表，大小为新容量</span>
    table = newTab; <span class="hljs-comment">// 将当前表指向新表</span>
    
    <span class="hljs-comment">// 如果旧表不为空</span>
    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123; <span class="hljs-comment">// 遍历旧表中的每个桶</span>
            Node&lt;K,V&gt; e;
            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 如果当前桶不为空</span>
                oldTab[j] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 清空旧表中的当前桶</span>
                <span class="hljs-comment">//1、如果当前桶中只有一个节点</span>
                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>) 
                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;  <span class="hljs-comment">// 根据新容量重新计算索引并放入新表中</span>
                <span class="hljs-comment">//2、如果当前节点是树形节点（红黑树结构）</span>
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap); <span class="hljs-comment">// 调用TreeNode的`split`方法，将红黑树重新分配到新表中</span>
                <span class="hljs-comment">//3、如果当前桶中是链表结构（多个节点）</span>
                <span class="hljs-keyword">else</span> &#123; 
                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 定义低位链表的头和尾</span>
                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 定义高位链表的头和尾</span>
                    Node&lt;K,V&gt; next;  <span class="hljs-comment">// 临时变量用于保存下一个节点</span>
                    <span class="hljs-keyword">do</span> &#123;
                        next = e.next;  <span class="hljs-comment">// 保存当前节点的下一个节点</span>
                        <span class="hljs-comment">// 如果当前节点的哈希值与旧容量按位与为0（低位）</span>
                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123; 
                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>) <span class="hljs-comment">// 如果低位链表为空，将当前节点设为头节点</span>
                                loHead = e;
                            <span class="hljs-keyword">else</span>			  <span class="hljs-comment">// 否则将当前节点链接到低位链表的尾部</span>
                                loTail.next = e;
                            loTail = e; <span class="hljs-comment">// 更新低位链表的尾节点。</span>
                        &#125;
                        <span class="hljs-comment">// 如果当前节点的哈希值与旧容量按位与不为0（高位）</span>
                        <span class="hljs-keyword">else</span> &#123;
                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)  <span class="hljs-comment">// 如果高位链表为空，将当前节点设为头节点</span>
                                hiHead = e;
                            <span class="hljs-keyword">else</span>				<span class="hljs-comment">// 否则将当前节点链接到高位链表的尾部</span>
                                hiTail.next = e;
                            hiTail = e; 	<span class="hljs-comment">// 更新高位链表的尾节点</span>
                        &#125;
                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<span class="hljs-comment">// 遍历当前桶的链表，直到链表末尾</span>
                    
                    <span class="hljs-comment">// 如果低位链表不为空</span>
                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;
                        loTail.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">//断开低位链表的尾节点</span>
                        newTab[j] = loHead; <span class="hljs-comment">// 将低位链表放入新表的对应索引位置</span>
                 &#125;
                    <span class="hljs-comment">// 如果高位链表不为空</span>
                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;
                        hiTail.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">//断开高位链表的尾节点</span>
                        newTab[j + oldCap] = hiHead; <span class="hljs-comment">// 将高位链表放入新表的对应索引位置（旧容量偏移）</span>
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-comment">// 返回扩容后的新哈希表</span>
    <span class="hljs-keyword">return</span> newTab;
&#125;
</code></pre></div></li></ol><h3 id="linkedhashset的底层原理">LinkedHashSet的底层原理</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/util/LinkedHashSet.html">LinkedHashMap API文档</a></p><p>LinkedHashSet 是 HashSet 的子类，基于LinkedHashMap实现，底层维护了一个 数组+ 双向链表。LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的。它同样不允许添重复元素。</p><h4 id="源码分析">源码分析</h4><p>由于LinkedHashSet继承了HashSet，它其中的许多方法都是通过多态机制使用父类的方法完成，包括添加元素、扩容等与HashSet一样。只是它底层用的双向链表，与父类中的单链表或红黑树的结点结构不同。</p><p>结点结构：</p><p>其中的table数组结构为<code>HashMap$Node[]</code>，而双向链表中的结点类型为<code>LinkedHashMap$Entry</code></p><div class="code-wrapper"><pre><code class="hljs java">   
<span class="hljs-comment">/**</span>
<span class="hljs-comment">*	LinkedHashMap的结点结构Entry，继承了HashMap中的静态内部类 Node</span>
<span class="hljs-comment">*   包括：</span>
<span class="hljs-comment">*		1、哈希值 hash</span>
<span class="hljs-comment">*		2、key、value 键值对</span>
<span class="hljs-comment">*		3、指向后继结点的next指针，此处用来连接同义词结点</span>
<span class="hljs-comment">*		4、before 和 after 用来记录结点的插入顺序 （新增）</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashMap</span>.Node&lt;K,V&gt; &#123;
       Entry&lt;K,V&gt; before, after;
       Entry(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;
           <span class="hljs-built_in">super</span>(hash, key, value, next);
       &#125;
   &#125;

<span class="hljs-comment">// HashMap 的Node类型，它又实现了Map接口中的Entry内部接口</span>
   <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;
       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;
       <span class="hljs-keyword">final</span> K key;
       V value;
       Node&lt;K,V&gt; next;

       Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;
           <span class="hljs-built_in">this</span>.hash = hash;
           <span class="hljs-built_in">this</span>.key = key;
           <span class="hljs-built_in">this</span>.value = value;
           <span class="hljs-built_in">this</span>.next = next;
       &#125;

	<span class="hljs-comment">// equals、hashCode、toString.....</span>
   &#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250208133657810-2025-2-813:37:19.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>构造函数</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250208143217618-2025-2-814:32:35.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>添加元素：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/未命名绘图-2025-2-814:44:13.jpg" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><h3 id="treeset的底层原理">TreeSet的底层原理</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/util/TreeSet.html">TreeSet API文档</a></p><p><code>TreeSet</code> 的底层完全依赖于 <code>TreeMap</code>，可以认为 <code>TreeSet</code> 是 <code>TreeMap</code> 的一个包装。具体来说：</p><ul><li><code>TreeSet</code> 内部维护了一个 <code>TreeMap</code> 实例。</li><li><code>TreeSet</code> 的元素存储在 <code>TreeMap</code> 的键（<code>key</code>）中，而 <code>TreeMap</code> 的值（<code>value</code>）是一个固定的常量对象。</li></ul><p>这一点和<code>HashSet</code>与<code>HashMap</code>的关系一样。</p><p><code>TreeSet</code> 的元素存储顺序由底层 <code>TreeMap</code> 决定，排序规则可以是：</p><ol type="1"><li><strong>自然顺序</strong>：元素实现了 <code>Comparable</code> 接口。</li><li><strong>自定义顺序</strong>：通过构造器传入自定义的比较器。</li></ol><p>总结：</p><table><thead><tr class="header"><th>特性</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><strong>底层实现</strong></td><td>基于 <code>TreeMap</code>，元素存储在 <code>TreeMap</code> 的键中。</td></tr><tr class="even"><td><strong>有序性</strong></td><td>元素按自然顺序或自定义比较器排序。</td></tr><tr class="odd"><td><strong>不允许重复</strong></td><td>通过 <code>TreeMap</code> 的键唯一性保证。</td></tr><tr class="even"><td><strong>线程安全性</strong></td><td><code>TreeSet</code> 是非线程安全的，可使用 <code>Collections.synchronizedSet</code> 包装。</td></tr><tr class="odd"><td><strong>时间复杂度</strong></td><td>插入、删除、查找的时间复杂度为 <code>O(log n)</code>（红黑树的特性）。</td></tr></tbody></table><h4 id="构造函数-2">构造函数</h4><p><code>TreeSet</code> 的构造器实际上是对 <code>TreeMap</code> 的构造器的封装。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeSet</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-built_in">this</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;E,Object&gt;());
&#125;</code></pre></div><p>TreeMap的构造器分析见下面TreeMap的内容。</p><h4 id="添加元素add">添加元素add</h4><p>实现原理：</p><ul><li>调用 <code>TreeMap.put(key, value)</code>，其中 <code>key</code> 是 <code>TreeSet</code> 的元素，<code>value</code> 是固定的 <code>PRESENT</code>。</li><li>如果 <code>TreeMap</code> 中已存在相同的键（即元素），<code>put</code> 方法会返回旧值，<code>TreeSet.add()</code> 返回 <code>false</code>。</li><li>如果键不存在，<code>put</code> 方法返回 <code>null</code>，<code>TreeSet.add()</code> 返回 <code>true</code>。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;
    <span class="hljs-keyword">return</span> m.put(e, PRESENT)==<span class="hljs-literal">null</span>; <span class="hljs-comment">// 调用 TreeMap 的 put 方法</span>
&#125;</code></pre></div><p>TreeMap的<code>put</code>方法分析见下面TreeMap的内容。</p><h4 id="删除元素remove">删除元素remove</h4><p>调用 TreeMap 的 remove 方法删除指定元素。由于TreeMap的remove方法删除节点后，会返回该结点value，而TreeSet的key存储在TreeMap结点的键中，而值都是一个固定的常量对象<code>PRESENT</code>。通过判断返回的结果是否是<code>PRESENT</code>，返回元素的删除结果。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;
    <span class="hljs-keyword">return</span> m.remove(o)==PRESENT; <span class="hljs-comment">// 调用 TreeMap 的 remove 方法</span>
&#125;

<span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();</code></pre></div><h2 id="queue系列集合">2.5、Queue系列集合</h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/queue.drawio-2025-9-717:25:10.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p><code>Queue</code>（队列）中添加的元素按照特定的规则排序（FIFO, LIFO, 或优先级）访问元素通常被限制在队列的<strong>头部</strong>和<strong>尾部</strong>，不能随机访问中间元素。</p><p>除了Collction接口中定义的方法外，Queue接口中还定义了操作队列的常用方法：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250912160332570-2025-9-1216:03:39.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h3 id="priorityqueue">PriorityQueue</h3><p>PriorityQueue（优先级队列）， 底层基于<strong>堆</strong> 实现（具体是一个<strong>小根堆</strong>），是一个<strong>无界</strong>队列。元素根据其<strong>自然顺序</strong>或构造时提供的 <strong><code>Comparator</code></strong> 进行排序，队头元素总是排序最小的。</p><p>源码分析如下：</p><h4 id="核心字段-1">核心字段</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;
    <span class="hljs-comment">// 存储元素的底层数组</span>
    <span class="hljs-keyword">transient</span> Object[] queue; <span class="hljs-comment">// non-private to simplify nested class access</span>
    <span class="hljs-comment">//默认容量为11</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;
    <span class="hljs-comment">// 最大数组容量，减去8是因为一些VM会在数组中保留一些头字，分配更大的数组可能会导致OutOfMemoryError</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;
    <span class="hljs-comment">// 元素数量</span>
    <span class="hljs-type">int</span> size;
    <span class="hljs-comment">// 比较器，如果为null则使用元素的自然排序</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; comparator;
    <span class="hljs-comment">// 修改次数</span>
    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;
&#125;</code></pre></div><h4 id="扩容机制">扩容机制</h4><p>优先级队列底层的数组默认大小为11。</p><p>向队尾添加元素时，若队中元素数量<code>size</code>达到数组<code>queue</code>的长度，触发扩容机制：</p><ul><li>计算新容量：如果旧容量 &lt; 64，则翻倍 + 2；否则扩容 50%。</li><li>若计算出的新容量超过了设置的最大容量<code>MAX_ARRAY_SIZE</code>，则按照所需的最小容量 minCapacity 扩容<ul><li>如果minCapacity &lt; 0，则溢出，已经超过<code>Integer.MAX_VALUE</code></li><li>如果所需的最小容量minCapacity已经大于<code>MAX_ARRAY_SIZE</code>，则直接分配最大的可能值<code>Integer.MAX_VALUE</code>；否则分配<code>MAX_ARRAY_SIZE</code>，这是一个相对安全的上限。</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> queue.length;
    <span class="hljs-comment">//计算新容量：如果旧容量 &lt; 64，则翻倍 + 2；否则扩容 50%</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + ((oldCapacity &lt; <span class="hljs-number">64</span>) ?
                                     (oldCapacity + <span class="hljs-number">2</span>) :
                                     (oldCapacity &gt;&gt; <span class="hljs-number">1</span>));
    <span class="hljs-comment">// 处理溢出等情况</span>
    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)
        newCapacity = hugeCapacity(minCapacity);
    queue = Arrays.copyOf(queue, newCapacity);
&#125;    
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;
    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();
    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
    MAX_ARRAY_SIZE;
&#125;</code></pre></div><h4 id="向队尾添加元素">向队尾添加元素</h4><p>add(e)、offer(e)</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;
    <span class="hljs-keyword">return</span> offer(e);
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;
    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(); <span class="hljs-comment">// 不允许null元素</span>
    modCount++;
    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size;
    <span class="hljs-keyword">if</span> (i &gt;= queue.length)
        grow(i + <span class="hljs-number">1</span>); <span class="hljs-comment">// 如果数组已满，则扩容</span>
    siftUp(i, e);   <span class="hljs-comment">// **核心：上浮操作，维护堆结构**</span>
    size = i + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div><p>在小根堆中插入元素 （新元素不断上升）：插入元素 <code>e</code> 时，先将其放在数组末尾（堆的最后一个叶子节点），然后不断与父节点比较。如果根据比较规则得出 <code>e</code> 比父节点“小”，就交换它们的位置，直到 <code>e</code> 找到一个比它“大”的父节点或到达根节点。<code>siftUp(int k, E x)</code> 上浮操作源码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUp</span><span class="hljs-params">(<span class="hljs-type">int</span> k, E x)</span> &#123;
    <span class="hljs-keyword">if</span> (comparator != <span class="hljs-literal">null</span>)
        siftUpUsingComparator(k, x, queue, comparator);
    <span class="hljs-keyword">else</span>
        siftUpComparable(k, x, queue);
&#125;
<span class="hljs-comment">// 以使用Comparator为例</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftUpUsingComparator</span><span class="hljs-params">(<span class="hljs-type">int</span> k, T x, Object[] es, Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; cmp)</span> &#123;
    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 找到父节点的索引</span>
        <span class="hljs-type">Object</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> es[parent];
        <span class="hljs-keyword">if</span> (cmp.compare(x, (T) e) &gt;= <span class="hljs-number">0</span>) <span class="hljs-comment">// **如果新元素 &gt;= 父节点，满足最小堆，停止上浮**</span>
            <span class="hljs-keyword">break</span>;
        es[k] = e; <span class="hljs-comment">// 否则，将父节点下沉</span>
        k = parent; <span class="hljs-comment">// 继续向上比较</span>
    &#125;
    es[k] = x; <span class="hljs-comment">// 找到最终位置，放入元素</span>
&#125;</code></pre></div><h4 id="移除队头元素">移除队头元素</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">final</span> Object[] es;
    <span class="hljs-keyword">final</span> E result;
    <span class="hljs-keyword">if</span> ((result = (E) ((es = queue)[<span class="hljs-number">0</span>])) != <span class="hljs-literal">null</span>) &#123;
        modCount++;
        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> n;
        <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (E) es[(n = --size)]; <span class="hljs-comment">// 获取最后一个元素</span>
        es[n] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 将最后一个位置置空</span>
        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; cmp;
            <span class="hljs-keyword">if</span> ((cmp = comparator) == <span class="hljs-literal">null</span>)
                siftDownComparable(<span class="hljs-number">0</span>, x, es, n); <span class="hljs-comment">// **核心：下沉操作**</span>
            <span class="hljs-keyword">else</span>
                siftDownUsingComparator(<span class="hljs-number">0</span>, x, es, n, cmp);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> result;
&#125;</code></pre></div><p>从小根堆中删除元素（替代元素不断下坠）：移除根节点（最小元素）后，将堆的最后一个元素 <code>x</code> 提到根节点。然后让 <code>x</code> 与其<strong>较小的子节点</strong>比较。</p><ul><li>如果 <code>x</code> 比它的两个子节点都“小”，则停止下沉。</li><li>否则，将 <code>x</code> 与那个“较小”的子节点交换，并在新的位置上重复这个过程，直到 <code>x</code> 找到合适的位置或成为叶子节点。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">siftDownUsingComparator</span><span class="hljs-params">(</span>
<span class="hljs-params">    <span class="hljs-type">int</span> k, T x, Object[] es, <span class="hljs-type">int</span> n, Comparator&lt;? <span class="hljs-built_in">super</span> T&gt; cmp)</span> &#123;
    <span class="hljs-comment">// assert n &gt; 0;</span>
    <span class="hljs-comment">// 计算堆的中间位置，即第一个叶子节点的索引</span>
    <span class="hljs-comment">//对于完全二叉树结构，叶子节点从索引n/2开始</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> n &gt;&gt;&gt; <span class="hljs-number">1</span>;
   
    <span class="hljs-keyword">while</span> (k &lt; half) &#123;  <span class="hljs-comment">//只需与非叶节点比较即可</span>
        
        <span class="hljs-comment">// 计算左孩子的索引：2*k + 1</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> (k &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>; 
        <span class="hljs-type">Object</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> es[child];
        
        <span class="hljs-comment">// 右孩子的索引：child + 1</span>
        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> child + <span class="hljs-number">1</span>;
        <span class="hljs-comment">//得到左右孩子中的较小的</span>
        <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; cmp.compare((T) c, (T) es[right]) &gt; <span class="hljs-number">0</span>)
            c = es[child = right];
        <span class="hljs-comment">// 如果当前元素x 小于或等于 左右孩子中的最小值，则满足最小堆，停止下沉</span>
        <span class="hljs-keyword">if</span> (cmp.compare(x, (T) c) &lt;= <span class="hljs-number">0</span>)
            <span class="hljs-keyword">break</span>;
        <span class="hljs-comment">//将较小孩子节点的值提升到当前位置 k，然后更新 k 为孩子节点的索引，继续向下比较。</span>
        es[k] = c;
        k = child;
    &#125;
    <span class="hljs-comment">// 将元素x放到最终位置k</span>
    es[k] = x;
&#125;</code></pre></div><h3 id="deque接口">Deque接口</h3><p><code>Deque</code>（Double Ended Queue，双端队列）是 <code>Queue</code> 接口的一个高级扩展。它不仅支持标准的队列操作（FIFO），还支持栈操作（LIFO）以及在队列两端进行操作。</p><hr><p><code>Deque</code>在继承<code>Queue</code>接口方法的基础上，极大地丰富了操作集合。几乎所有在 <code>Queue</code> 中只能操作队头的方法，在 <code>Deque</code> 中都有了对应的队尾操作版本。</p><p>例如，对于<code>add()</code>方法，新增了两个扩展方法<code>addFirst()</code>、<code>addLast()</code>。</p><hr><p>此外Deque还扩展了<code>remove()</code>方法。在普通队列<code>Queue</code>中只能从队头删除，现在可以从队尾删除、删除第一次出现的指定元素、删除最后一次出现的指定元素。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250912171313904-2025-9-1217:13:36.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><hr><p><code>Deque</code> 提供了从队尾向队头遍历的<strong>反向迭代器</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250912171950251-2025-9-1217:19:51.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java">Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();
deque.add(<span class="hljs-number">1</span>);
deque.add(<span class="hljs-number">2</span>);
deque.add(<span class="hljs-number">3</span>); <span class="hljs-comment">// 队列: [1, 2, 3]</span>

<span class="hljs-comment">// 正向迭代 (从 head 到 tail)</span>
Iterator&lt;Integer&gt; it = deque.iterator();
<span class="hljs-keyword">while</span> (it.hasNext()) &#123;
    System.out.print(it.next()); <span class="hljs-comment">// 输出 &quot;123&quot;</span>
&#125;

<span class="hljs-comment">// 反向迭代 (从 tail 到 head)</span>
Iterator&lt;Integer&gt; descIt = deque.descendingIterator();
<span class="hljs-keyword">while</span> (descIt.hasNext()) &#123;
    System.out.print(descIt.next()); <span class="hljs-comment">// 输出 &quot;321&quot;</span>
&#125;</code></pre></div><hr><p><code>Deque</code> 明确提供了模拟栈行为的方法，Java 官方文档明确建议使用 <code>Deque</code> 代替 <code>Stack</code>。因此在开发中，应优先选择 <code>Deque</code> 的实现类（如 <code>ArrayDeque</code>）来模拟栈行为。</p><ul><li><strong><code>push(E e)</code></strong>：将元素推入此双端队列表示的栈顶（即头部），内部调用<code>addFirst(e)</code></li><li><strong><code>pop()</code></strong>：从此双端队列所表示的栈中弹出栈顶元素，内部调用<code>removeFirst()</code>完成</li><li><code>peek()</code>：查看栈顶元素而不弹出，内部使用<code>peek()</code> 或 <code>peekFirst()</code>）。</li></ul><div class="code-wrapper"><pre><code class="hljs java">Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();
stack.push(<span class="hljs-number">1</span>); <span class="hljs-comment">// 栈顶: 1</span>
stack.push(<span class="hljs-number">2</span>); <span class="hljs-comment">// 栈顶: 2, 元素: [2, 1]</span>
stack.push(<span class="hljs-number">3</span>); <span class="hljs-comment">// 栈顶: 3, 元素: [3, 2, 1]</span>

<span class="hljs-type">int</span> <span class="hljs-variable">top</span> <span class="hljs-operator">=</span> stack.pop(); <span class="hljs-comment">// 返回 3, 栈顶变为 2</span>
top = stack.peek();    <span class="hljs-comment">// 返回 2, 栈不变</span></code></pre></div><h3 id="linkedlist">LinkedList</h3><p>LinkedList同时实现了 <code>List</code> 接口和 <code>Deque</code>接口。这种双重身份使其能够灵活地作为列表、栈、队列或双端队列使用。</p><p>LinkedList底层的<strong>双向链表</strong>天然地同时支持了列表和双端队列的所有操作。通过实现多个接口，无需编写多份代码，根据不同的场景需求，通过不同的接口视角来使用同一个对象，这是一种非常巧妙和强大的抽象。</p><p>使用LinkedList作为双端队列：</p><ul><li>没有容量限制，真正的动态大小；在头部和尾部操作非常高效</li><li>随机访问性能差，不能按索引访问；内存开销较大，每个元素需要额外空间存储前后节点的引用</li></ul><p>LinkedList底层的重要结构和字段，以及基本的插入删除操作可以看上面List系列集合中的介绍，下面主要介绍它对Deque接口中方法的实现细节。</p><h4 id="在头部操作的方法">在头部操作的方法</h4><p>队头插入元素：<code>addFirst(E e)</code> / <code>offerFirst(E e)</code> / <code>push(E e)</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 将元素添加到双端队列的开头</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(E e)</span> &#123;
    linkFirst(e);
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span> &#123;
    addFirst(e);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 由于LinkedList是无界的，总是返回true</span>
&#125;

<span class="hljs-comment">// Stack操作：将元素推入栈顶（即头部）</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E e)</span> &#123;
    addFirst(e);
&#125;

<span class="hljs-comment">// 实际的链接到首部的实现</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkFirst</span><span class="hljs-params">(E e)</span> &#123;
    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;      <span class="hljs-comment">// 保存当前首节点引用</span>
    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, e, f); <span class="hljs-comment">// 创建新节点，其next指向原首节点</span>
    first = newNode;              <span class="hljs-comment">// 更新首节点指针为新节点</span>
    
    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)                <span class="hljs-comment">// 如果原链表为空</span>
        last = newNode;           <span class="hljs-comment">// 那么新节点也是尾节点</span>
    <span class="hljs-keyword">else</span>
        f.prev = newNode;         <span class="hljs-comment">// 否则，原首节点的prev指向新节点</span>
    
    size++;                       <span class="hljs-comment">// 更新大小</span>
    modCount++;                   <span class="hljs-comment">// 修改计数器，用于迭代器的快速失败机制</span>
&#125;</code></pre></div><hr><p>查看队头元素：<code>getFirst()</code> / <code>peekFirst()</code> / <code>element()</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获取但不移除双端队列的第一个元素</span>
<span class="hljs-keyword">public</span> E <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;
    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();
    <span class="hljs-keyword">return</span> f.item;
&#125;

<span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekFirst</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;
    <span class="hljs-keyword">return</span> (f == <span class="hljs-literal">null</span>) ? <span class="hljs-literal">null</span> : f.item;
&#125;

<span class="hljs-comment">// 实现Queue的element操作（获取队首）</span>
<span class="hljs-keyword">public</span> E <span class="hljs-title function_">element</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">return</span> getFirst();
&#125;</code></pre></div><hr><p>队头删除元素：<code>removeFirst()</code> / <code>pollFirst()</code> / <code>pop()</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 移除并返回双端队列的第一个元素</span>
<span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;
    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>(); <span class="hljs-comment">//队列为空抛出异常</span>
    <span class="hljs-keyword">return</span> unlinkFirst(f);
&#125;

<span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollFirst</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;
    <span class="hljs-keyword">return</span> (f == <span class="hljs-literal">null</span>) ? <span class="hljs-literal">null</span> : unlinkFirst(f); <span class="hljs-comment">//队列为空抛出null</span>
&#125;

<span class="hljs-comment">// Stack操作：弹出栈顶元素（即头部）</span>
<span class="hljs-keyword">public</span> E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">return</span> removeFirst();
&#125;

<span class="hljs-comment">// 实际的从首部解除链接的实现</span>
<span class="hljs-keyword">private</span> E <span class="hljs-title function_">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> &#123;
    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> f.item;      <span class="hljs-comment">// 保存要返回的元素</span>
    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;   <span class="hljs-comment">// 保存首节点的下一个节点</span>
    
    <span class="hljs-comment">// 清理引用，帮助垃圾回收</span>
    f.item = <span class="hljs-literal">null</span>;
    f.next = <span class="hljs-literal">null</span>; 
    
    first = next;                  <span class="hljs-comment">// 更新首节点指针</span>

    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)              <span class="hljs-comment">// 如果链表只有一个元素，移除后为空，last指针也指向null</span>
        last = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">else</span>
        next.prev = <span class="hljs-literal">null</span>;          <span class="hljs-comment">// 新首节点的prev置为null</span>
    
    size--;                        <span class="hljs-comment">// 更新大小</span>
    modCount++;                    <span class="hljs-comment">// 更新修改计数器</span>
    <span class="hljs-keyword">return</span> element;                <span class="hljs-comment">// 返回被移除的元素</span>
&#125;</code></pre></div><h4 id="在队尾操作的方法">在队尾操作的方法</h4><p>队尾插入元素： <code>addLast(E e)</code> / <code>offerLast(E e)</code> / <code>add(E e)</code>/<code>offer(E e)</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 将元素添加到双端队列的末尾</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(E e)</span> &#123;
    linkLast(e);
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span> &#123;
    addLast(e);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 由于LinkedList是无界的，总是返回true</span>
&#125;

<span class="hljs-comment">// 实现Queue的add操作（在队尾添加）</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;
    linkLast(e);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-comment">//实现Queu的offer操作（在队尾添加）</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;
    <span class="hljs-keyword">return</span> add(e);
&#125;

<span class="hljs-comment">// 实际的链接到尾部的实现</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;
    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;           <span class="hljs-comment">// 保存当前尾节点引用</span>
    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 创建新节点，其prev指向原尾节点</span>
    last = newNode;                   <span class="hljs-comment">// 更新尾节点指针为新节点</span>

    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)                    <span class="hljs-comment">// 如果原链表为空</span>
        first = newNode;              <span class="hljs-comment">// 那么新节点也是首节点</span>
    <span class="hljs-keyword">else</span>
        l.next = newNode;             <span class="hljs-comment">// 否则，原尾节点的next指向新节点</span>

    size++;                           <span class="hljs-comment">// 更新大小</span>
    modCount++;                       <span class="hljs-comment">// 更新修改计数器</span>
&#125;</code></pre></div><hr><p>查看队尾元素：<code>getLast()</code> / <code>peekLast()</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 获取但不移除双端队列的最后一个元素</span>
<span class="hljs-keyword">public</span> E <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;
    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();
    <span class="hljs-keyword">return</span> l.item;
&#125;

<span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekLast</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;
    <span class="hljs-keyword">return</span> (l == <span class="hljs-literal">null</span>) ? <span class="hljs-literal">null</span> : l.item;
&#125;</code></pre></div><hr><p>尾部删除：<code>removeLast()</code> / <code>pollLast()</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 移除并返回双端队列的最后一个元素</span>
<span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;
    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();
    <span class="hljs-keyword">return</span> unlinkLast(l);
&#125;

<span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollLast</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;
    <span class="hljs-keyword">return</span> (l == <span class="hljs-literal">null</span>) ? <span class="hljs-literal">null</span> : unlinkLast(l);
&#125;

<span class="hljs-comment">// 实际的从尾部解除链接的实现</span>
<span class="hljs-keyword">private</span> E <span class="hljs-title function_">unlinkLast</span><span class="hljs-params">(Node&lt;E&gt; l)</span> &#123;
    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> l.item;      <span class="hljs-comment">// 保存要返回的元素</span>
    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = l.prev;   <span class="hljs-comment">// 保存尾节点的前一个节点</span>
    
    <span class="hljs-comment">// 清理引用，帮助垃圾回收</span>
    l.item = <span class="hljs-literal">null</span>;
    l.prev = <span class="hljs-literal">null</span>;
    
    last = prev;                   <span class="hljs-comment">// 更新尾节点指针</span>
    
    <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>)              <span class="hljs-comment">// 如果链表只有一个元素，移除后为空</span>
        first = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">else</span>
        prev.next = <span class="hljs-literal">null</span>;          <span class="hljs-comment">// 新尾节点的next置为null</span>
    
    size--;                        <span class="hljs-comment">// 更新大小</span>
    modCount++;                    <span class="hljs-comment">// 更新修改计数器</span>
    <span class="hljs-keyword">return</span> element;                <span class="hljs-comment">// 返回被移除的元素</span>
&#125;</code></pre></div><h4 id="删除特定元素的方法">删除特定元素的方法</h4><p><code>removeFirstOccurrence(Object o)</code> / <code>removeLastOccurrence(Object o)</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 从首部开始查找并删除第一次出现的指定元素</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeFirstOccurrence</span><span class="hljs-params">(Object o)</span> &#123;
    <span class="hljs-keyword">return</span> remove(o); <span class="hljs-comment">// 直接调用LinkedList的remove方法</span>
&#125;

<span class="hljs-comment">// 从尾部开始查找并删除第一次出现的指定元素</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeLastOccurrence</span><span class="hljs-params">(Object o)</span> &#123;
    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-comment">// 从尾部向前遍历查找null元素</span>
        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-literal">null</span>; x = x.prev) &#123;
            <span class="hljs-keyword">if</span> (x.item == <span class="hljs-literal">null</span>) &#123;
                unlink(x);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// 从尾部向前遍历查找非null元素</span>
        <span class="hljs-keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="hljs-literal">null</span>; x = x.prev) &#123;
            <span class="hljs-keyword">if</span> (o.equals(x.item)) &#123;
                unlink(x);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;

<span class="hljs-comment">// 删除指定节点</span>
E <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> &#123;
    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> x.item;
    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;
    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;

    <span class="hljs-comment">// 处理前驱节点</span>
    <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;
        first = next; <span class="hljs-comment">// 如果x是首节点，更新first</span>
    &#125; <span class="hljs-keyword">else</span> &#123;
        prev.next = next;
        x.prev = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 帮助GC</span>
    &#125;

    <span class="hljs-comment">// 处理后继节点</span>
    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) &#123;
        last = prev; <span class="hljs-comment">// 如果x是尾节点，更新last</span>
    &#125; <span class="hljs-keyword">else</span> &#123;
        next.prev = prev;
        x.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 帮助GC</span>
    &#125;

    x.item = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 帮助GC</span>
    size--;
    modCount++;
    <span class="hljs-keyword">return</span> element;
&#125;</code></pre></div><h3 id="arraydeque">ArrayDeque</h3><p><code>ArrayDeque</code> 是 一个基于<strong>循环数组</strong>实现的高性能双端队列。它既可以作为队列使用（FIFO），也可以作为栈使用（LIFO）。它不允许插入null元素，且不是线程安全的。</p><h4 id="核心字段-2">核心字段</h4><p>数组的大小始终是2的幂次，这样可以通过位运算代替模运算来提高效率。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayDeque</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCollection</span>&lt;E&gt;
    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Deque</span>&lt;E&gt;, Cloneable, Serializable &#123;

    <span class="hljs-comment">// 存储元素的数组。容量总是2的幂次，这样可以使用位运算代替模运算提高效率</span>
    <span class="hljs-keyword">transient</span> Object[] elements;

    <span class="hljs-comment">// 头部元素的索引，指向第一个元素的位置</span>
    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> head;

    <span class="hljs-comment">// 尾部元素的索引，指向下一个要添加元素的位置，即最后一个元素的下一个位置</span>
    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> tail;

    <span class="hljs-comment">// 最小初始容量（必须是2的幂次）</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;
    <span class="hljs-comment">// 其他方法和构造函数...</span>
&#125;</code></pre></div><div class="note note-primary"><p>在循环数组中，当指针到达数组末尾时，我们需要让它“循环”回到数组开头。通常采用模运算来完成这个操作，但模运算在底层需要执行<strong>除法</strong>操作来得到余数，而除法是 CPU 中最慢的基本算术运算之一。另一种高效的方法是<strong>按位与</strong>操作，它要求<strong>数组长度 <code>n</code> 是 2 的幂次</strong>，位运算通常在一个时钟周期内就能完成，速度极快。</p><p><strong>当 <code>n</code> 是 2 的幂次时，<code>x % n</code> 等价于 <code>x &amp; (n - 1)</code></strong>。</p><p>原理分析：任何一个 2 的幂次数，其二进制表示都有一个特点：只有一位是 1，其余位都是 0。当这个数减一后，会变成一个所有低位都是 1 的二进制数。任何数 <code>x</code> 与 <code>(n - 1)</code> 进行位与运算时，效果就是<strong>保留 <code>x</code> 的低位，高位清零</strong>。保留的低位所能表示的范围是[0, n - 1]，而这正是而余数的范围，这正好等同于 <code>x % n</code> 的效果。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250912212143057-2025-9-1221:21:44.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250912212143057"><figcaption aria-hidden="true">image-20250912212143057</figcaption></figure></div><h4 id="构造函数-3">构造函数</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 默认构造方法，初始容量为16</span>
<span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayDeque</span><span class="hljs-params">()</span> &#123;
    elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">16</span>];
&#125;

<span class="hljs-comment">// 指定初始容量的构造方法</span>
<span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayDeque</span><span class="hljs-params">(<span class="hljs-type">int</span> numElements)</span> &#123;
    elements = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[calculateSize(numElements)];
&#125;

<span class="hljs-comment">// 从其他集合初始化的构造方法</span>
<span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayDeque</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;
    <span class="hljs-built_in">this</span>(c.size());
    addAll(c);
&#125;</code></pre></div><p>其中，当传入了初始容量，使用<code>calculateSize</code> 将初始容量调整为2的幂次，具体地说是通过位运算将其调整为大于等于它的最小的2的幂次方。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateSize</span><span class="hljs-params">(<span class="hljs-type">int</span> numElements)</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">initialCapacity</span> <span class="hljs-operator">=</span> MIN_INITIAL_CAPACITY;
    <span class="hljs-comment">// 如果请求的容量大于最小初始容量，则找到大于等于numElements的最小2的幂次</span>
    <span class="hljs-keyword">if</span> (numElements &gt;= initialCapacity) &#123;
        initialCapacity = numElements;
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">1</span>);
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">2</span>);
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">4</span>);
        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="hljs-number">8</span>);
        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="hljs-number">16</span>);
        initialCapacity++;
        
        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)   <span class="hljs-comment">// 处理溢出</span>
            initialCapacity &gt;&gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 回退到2^30</span>
    &#125;
    <span class="hljs-keyword">return</span> initialCapacity;
&#125;</code></pre></div><h4 id="扩容机制-1">扩容机制</h4><p>当即 <code>head == tail</code>时，表示数组已满，需要进行扩容。 <code>doubleCapacity()</code> 是 扩容的核心方法.</p><p><strong>扩容过程解析：</strong></p><ol type="1"><li>计算新容量为原容量的<strong>两倍</strong></li><li>创建新数组</li><li>将原数组<strong>分两段拷贝</strong>到新数组：<ul><li>第一段：从 <code>head</code> 到数组末尾的元素拷贝到新数组的开头</li><li>第二段：从数组开头到 <code>head-1</code> 的元素拷贝到新数组的后续位置</li></ul></li><li>重置 <code>head</code> 为 0，<code>tail</code> 为原数组长度（即新数组的中间位置）</li></ol><p>这种分段拷贝的方式有效地将循环数组"拉直"，使其在新数组中从索引 0 开始连续存储。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250912225705206-2025-9-1222:57:10.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doubleCapacity</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">assert</span> head == tail; <span class="hljs-comment">// 只有在满的时候才调用此方法</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;
    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> elements.length;
    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> n - p; <span class="hljs-comment">// head右边元素个数（包括head）</span>

    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> n &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 新容量为原来的两倍</span>
    <span class="hljs-keyword">if</span> (newCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//溢出</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Sorry, deque too big&quot;</span>);

    Object[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[newCapacity];

    <span class="hljs-comment">// 分两段拷贝：</span>
    <span class="hljs-comment">// 1. 从head到数组末尾的元素拷贝到新数组的开头</span>
    System.arraycopy(elements, p, a, <span class="hljs-number">0</span>, r);
    <span class="hljs-comment">// 2. 从0到head-1的元素拷贝到新数组的后续位置</span>
    System.arraycopy(elements, <span class="hljs-number">0</span>, a, r, p);

    elements = a;
    head = <span class="hljs-number">0</span>;
    tail = n;
&#125;</code></pre></div><h4 id="在队头操作的方法">在队头操作的方法</h4><p>在头部添加元素<code>addFirst(E e)</code> / <code>offerFirst(E e)</code></p><p>操作过程：</p><ol type="1"><li>检查元素是否为 null，ArrayDeque 不允许插入 null 元素</li><li>计算新的 <code>head</code> 位置：<code>(head - 1) &amp; (elements.length - 1)</code><ul><li>使用位运算代替模运算，并处理 <code>head - 1</code> 可能为负数的情况</li><li>例如：当 <code>head</code> 为 0 时，<code>head - 1</code> 为 -1，与 <code>elements.length - 1</code> 进行与运算后会得到数组的最后一个位置</li></ul></li><li>将元素放入新的 <code>head</code> 位置</li><li>如果新的 <code>head</code> 等于 <code>tail</code>，说明数组已满，需要扩容</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFirst</span><span class="hljs-params">(E e)</span> &#123;
    <span class="hljs-comment">//ArrayDeque 不允许插入 null 元素</span>
    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();
    
    <span class="hljs-comment">// 计算新的head：(head - 1) &amp; (elements.length - 1)</span>
    <span class="hljs-comment">// 使用位运算代替模运算，处理负数情况</span>
    elements[head = (head - <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)] = e;
    
    <span class="hljs-keyword">if</span> (head == tail)
        doubleCapacity(); <span class="hljs-comment">// 如果head追上tail，说明数组已满，需要扩容</span>
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerFirst</span><span class="hljs-params">(E e)</span> &#123;
    addFirst(e);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div><hr><p>从头部移除元素：<code>removeFirst()</code> / <code>pollFirst()</code></p><p>操作过程：</p><ol type="1"><li>获取 <code>head</code> 位置的元素</li><li>如果元素为 null，返回 null（队列为空）</li><li>将 <code>head</code> 位置设为 null，帮助垃圾回收</li><li>更新 <code>head</code> 指针：<code>(head + 1) &amp; (elements.length - 1)</code></li><li>返回被移除的元素</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollFirst</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;
    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
    <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (E) elements[h];
    
    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) <span class="hljs-comment">// 队列为空</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    
    elements[h] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span>
    head = (h + <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>); <span class="hljs-comment">// 更新head指针</span>
    <span class="hljs-keyword">return</span> result;
&#125;

<span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> pollFirst();
    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();
    <span class="hljs-keyword">return</span> x;
&#125;
</code></pre></div><hr><p>查看队头元素：<code>getFirst()</code>/<code>peekFirst()</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
    <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (E) elements[head];
    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) <span class="hljs-comment">//队空，抛出异常</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();
    <span class="hljs-keyword">return</span> result;
&#125;
<span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekFirst</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">return</span> (E) elements[head]; <span class="hljs-comment">//直接通过数组下标获取队头元素</span>
&#125;</code></pre></div><h4 id="在队尾操作的方法-1">在队尾操作的方法</h4><p>在尾部添加元素：<code>addLast(E e)</code> / <code>offerLast(E e)</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addLast</span><span class="hljs-params">(E e)</span> &#123;
    <span class="hljs-comment">//ArrayDeque 不允许插入 null 元素</span>
    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();
    elements[tail] = e; <span class="hljs-comment">// 将元素放入tail位置</span>
    
    <span class="hljs-comment">// 计算新的tail：(tail + 1) &amp; (elements.length - 1)</span>
    <span class="hljs-keyword">if</span> ( (tail = (tail + <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)) == head )
        doubleCapacity(); <span class="hljs-comment">// 如果tail追上head，说明数组已满，需要扩容</span>
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offerLast</span><span class="hljs-params">(E e)</span> &#123;
    addLast(e);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div><hr><p>从尾部删除元素：<code>removeLast()</code> / <code>pollLast()</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">pollLast</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-comment">// 计算最后一个元素的位置：(tail - 1) &amp; (elements.length - 1)</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (tail - <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>);
    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
    <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (E) elements[t];
    
    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) <span class="hljs-comment">// 如果该位置为null，说明队列为空</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    
    elements[t] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span>
    tail = t; <span class="hljs-comment">// 更新tail指针</span>
    <span class="hljs-keyword">return</span> result;
&#125;

<span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeLast</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> pollLast(); 
    <span class="hljs-comment">//队空时抛出异常</span>
    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>(); 
    <span class="hljs-keyword">return</span> x;
&#125;</code></pre></div><hr><p>查看队尾元素：<code>peekLast()</code>/<code>getLast()</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> E <span class="hljs-title function_">peekLast</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">return</span> (E) elements[(tail - <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)];
&#125;

<span class="hljs-keyword">public</span> E <span class="hljs-title function_">getLast</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
    <span class="hljs-type">E</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (E) elements[(tail - <span class="hljs-number">1</span>) &amp; (elements.length - <span class="hljs-number">1</span>)];
    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();
    <span class="hljs-keyword">return</span> result;
&#125;</code></pre></div><h4 id="栈操作">栈操作</h4><p>通常使用<code>ArrayDeque</code>作为栈的实现，与 <code>LinkedList</code>相比，<code>ArrayDeque</code> 使用循环数组实现，内存连续访问，更适合现代 CPU 缓存机制，通常具有更好的性能。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E e)</span> &#123;
    addFirst(e);
&#125;

<span class="hljs-keyword">public</span> E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">return</span> removeFirst();
&#125;

<span class="hljs-keyword">public</span> E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;
    <span class="hljs-keyword">return</span> peekFirst();
&#125;</code></pre></div><h1 id="三map集合">三、Map集合</h1><p><img src="https://gitee.com/cmyk359/img/raw/master/img/map.drawio-2025-9-717:02:08.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h2 id="map接口和常用方法">3.1、Map接口和常用方法</h2><p>在<a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Map.html">Map接口 API</a> 中查看相关方法</p><p>特点：</p><ul><li>Map与Collection并列存在。用于保存具有映射关系的数据：Key-Value（双列元素）</li><li>Map 中的 key 和 value 可以是任何引用类型的数据，会封装到HashMap$Node对象中</li><li>Map 中的 key 不允许重复。若插入了key相同但value不同的新键值对，会<strong>替换</strong>掉原有的键值对</li><li>Map 中的value可以重复</li><li>Map 的key 可以为 null，value 也可以为null，注意 key 为null，只能有一个，value 为null，可以多个.</li><li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到对应的 value</li><li>常用String类作为Map的key</li></ul><blockquote><p>注：其中key是按哈希值散列到数组中的，存入的顺序和取出的顺序不一定相同（<strong>不保证有序</strong>）</p></blockquote><h2 id="map的遍历方式">3.2、Map的遍历方式</h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250208222007311-2025-2-822:20:54.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><ol type="1"><li><p>先获取Map集合全部的键，再通过遍历键来找值</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250208222217866-2025-2-822:22:19.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="主要方法" style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
    map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>);
    map.put(<span class="hljs-string">&quot;sex&quot;</span>,<span class="hljs-string">&quot;male&quot;</span>);
    Set&lt;String&gt; keys = map.keySet();
    <span class="hljs-keyword">for</span> (String key : keys) &#123;
        System.out.println(key + <span class="hljs-string">&quot;---&quot;</span> + map.get(key));
    &#125;
&#125;</code></pre></div></li><li><p>把“键值对“看成一个整体进行遍历</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250208222635363-2025-2-822:26:36.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="主要方法" style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
 map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>);
    map.put(<span class="hljs-string">&quot;sex&quot;</span>,<span class="hljs-string">&quot;male&quot;</span>);
    Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();

    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entries) &#123;
        System.out.println(entry.getKey()+<span class="hljs-string">&quot; -- &quot;</span>+entry.getValue());
    &#125;
&#125;</code></pre></div></li><li><p>使用<code>forEach</code>方法结合 Lambda表达式遍历Map</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250208223042986-2025-2-822:30:44.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="主要方法" style="zoom:80%"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
    map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>);
    map.put(<span class="hljs-string">&quot;sex&quot;</span>,<span class="hljs-string">&quot;male&quot;</span>);

    map.forEach((k, v) -&gt; System.out.println(k+<span class="hljs-string">&quot;---&quot;</span>+v));
&#125;</code></pre></div><p>forEach方法内部其实使用了第二种遍历方法，获得Map的entrySet，再获取各个Entry的key和value</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/未命名绘图-2025-2-822:42:36.jpg" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></li></ol><h2 id="hashmap底层原理分析">3.3、HashMap底层原理分析</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/util/HashMap.html">HashMap API文档</a></p><h3 id="table数组和entryset">table数组和EntrySet</h3><p>首先HashMap是基于哈希表实现的，它使用数组和链表（或红黑树）来处理冲突。数组中的每个元素是一个链表，当链表长度超过阈值时会转为红黑树。这个数组对应着HashMap源码中定义的table数组，里面存放的是<code>HashMap$Node</code>类型的对象。每个Node包含哈希值、键、值以及指向下一个节点的引用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;

<span class="hljs-comment">// HashMap 的Node，它又实现了Map接口中的Entry内部接口</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;
    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;
    <span class="hljs-keyword">final</span> K key;
    V value;
    Node&lt;K,V&gt; next;

    Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;
        <span class="hljs-built_in">this</span>.hash = hash;
        <span class="hljs-built_in">this</span>.key = key;
        <span class="hljs-built_in">this</span>.value = value;
        <span class="hljs-built_in">this</span>.next = next;
    &#125;

    <span class="hljs-comment">// equals、hashCode、toString.....</span>
&#125;</code></pre></div><p>为了方便程序员的遍历，HashMap还提供了entrySet视图（View），它存放的元素的类型是 <code>Map$Entry</code>，其中存储着key和value。</p><p><strong>entrySet视图并不独立存储数据，是通过<u>迭代器</u>动态访问底层 <code>table</code>数组中的键值对，<code>entrySet</code>中的所有键值对均来自 <code>table</code>数组中的 <code>Node</code>节点。</strong>因此，<code>entrySet</code>本质上是<code>table</code>数组的逻辑抽象，提供对键值对的统一访问接口。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250208220230998-2025-2-822:02:36.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><blockquote><p><code>Map</code>接口中的<code>Entry</code>接口包含了许多<strong>方便遍历键值对的方法</strong>，如<code>get</code>、<code>put</code>、<code>entrySet</code>、<code>keySet</code>和<code>values</code>等，HashMap的<code>Node</code>内部类就实现了<code>Entry</code>接口，因此本身就是一个键值对（Entry）。</p></blockquote><p><code>entrySet</code>中的每个entry对象直接对应<code>table</code>数组中的<code>Node</code>对象。无需额外封装，因为<code>Node</code>本身是<code>Map.Entry</code>的实现类。对<code>Node</code>的修改（如通过<code>Entry.setValue()</code>）会直接影响<code>EntrySet</code>的视图，<u>反之亦然</u>。两者共享同一数据源，保证了数据一致性。</p><p><code>entrySet</code>并非预先创建所有entry对象，而是在调用<code>entrySet()</code>方法时返回一个内部类对象（如<code>EntrySet</code>的实例）。该对象仅在需要时（如迭代时）访问<code>table</code>数组。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250208180636465-2025-2-818:06:41.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><p>那entrySet是如何通过迭代器获得键值对的映射集合的呢？</p><p>案例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapTest</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
        map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>);
        map.put(<span class="hljs-string">&quot;sex&quot;</span>,<span class="hljs-string">&quot;male&quot;</span>);
        <span class="hljs-comment">// 获得entrySet</span>
        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();
        <span class="hljs-comment">//使用增强for遍历</span>
        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entries) &#123;
            System.out.println(entry.getKey()+<span class="hljs-string">&quot; -- &quot;</span>+entry.getValue());
        &#125;
    &#125;

&#125;</code></pre></div><p>查看它的字节码文件可知，entrySet的元素是通过迭代器Iterator遍历得来的，所以entrySet()方法能有键值对的映射集合，是因为iterator()方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapTest</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMapTest</span><span class="hljs-params">()</span> &#123;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();
        map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;jack&quot;</span>);
        map.put(<span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;male&quot;</span>);
        Set&lt;Entry&lt;String, String&gt;&gt; entries = map.entrySet();
        <span class="hljs-type">Iterator</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> entries.iterator();

        <span class="hljs-keyword">while</span>(var3.hasNext()) &#123;
            Entry&lt;String, String&gt; entry = (Entry)var3.next();
            System.out.println((String)entry.getKey() + <span class="hljs-string">&quot; -- &quot;</span> + (String)entry.getValue());
        &#125;

    &#125;
&#125;</code></pre></div><p>那么entrySet的迭代器对象Iterator是怎样的呢？</p><p>当调用 <code>entrySet()</code>方法时，会返回一个 <code>EntrySet</code>视图对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;

<span class="hljs-keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;
    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;
    <span class="hljs-comment">//调用 entrySet方法时才会对entrySet属性进行初始化</span>
    <span class="hljs-comment">// 返回map中各个键值对映射关系的集合</span>
    <span class="hljs-keyword">return</span> (es = entrySet) == <span class="hljs-literal">null</span> ? (entrySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EntrySet</span>()) : es;
&#125;</code></pre></div><p>在EntrySet类内部，通过<code>iterator()</code>方法，返回一个<code>EntryIterator</code>对象。而<code>EntryIterator</code>继承自 <code>HashIterator</code>，使用父类 HashIterator 中的 next()方法 返回Entry对象。核心逻辑在 <code>HashIterator</code>中的next方法中：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EntrySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;
	<span class="hljs-comment">//.....</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EntryIterator</span>(); <span class="hljs-comment">//返回 EntryIterator迭代器</span>
    &#125;
    <span class="hljs-comment">//...</span>
&#125;

---------------EntryIterator&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
    
<span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EntryIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashIterator</span>  
    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Map.Entry&lt;K,V&gt; <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123; 
        <span class="hljs-keyword">return</span> nextNode(); <span class="hljs-comment">// 使用父类 HashIterator 中的 next()方法 返回Entry对象</span>
    &#125;
&#125;

---------------HashIterator&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashIterator</span> &#123;
    Node&lt;K,V&gt; next;        <span class="hljs-comment">// next entry to return</span>
    Node&lt;K,V&gt; current;     <span class="hljs-comment">// current entry</span>
    <span class="hljs-type">int</span> expectedModCount;  <span class="hljs-comment">// for fast-fail 记录迭代器创建时的修改次数（用于快速失败校验）</span>
    <span class="hljs-type">int</span> index;             <span class="hljs-comment">// current slot 当前遍历的哈希桶索引（从0开始遍历哈希表数组）</span>
    
    
    HashIterator() &#123;
        expectedModCount = modCount; <span class="hljs-comment">//保存当前HashMap的修改次数（用于并发修改检测）</span>
        Node&lt;K,V&gt;[] t = table; 		<span class="hljs-comment">//获取哈希表数组引用 </span>
        current = next = <span class="hljs-literal">null</span>;		<span class="hljs-comment">//初始化当前和下一个节点为null </span>
        index = <span class="hljs-number">0</span>;				  <span class="hljs-comment">//从哈希表的第一个桶开始遍历 </span>
        
        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//如果哈希表非空且存在元素</span>
            <span class="hljs-comment">//跳过所有空桶，找到第一个非空节点</span>
            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>);
        &#125;
    &#125;
    
    <span class="hljs-comment">//判断是否还有下一个节点</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-keyword">return</span> next != <span class="hljs-literal">null</span>;
    &#125;
    
    <span class="hljs-comment">//核心方法：获取下一个节点并更新状态 </span>
    <span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">nextNode</span><span class="hljs-params">()</span> &#123;
        Node&lt;K,V&gt;[] t;			<span class="hljs-comment">//临时变量保存哈希表数组 </span>
        Node&lt;K,V&gt; e = next;		<span class="hljs-comment">//临时保存当前要返回的节点 </span>
        
        <span class="hljs-comment">//如果发现外部修改了HashMap结构，抛出并发修改异常</span>
        <span class="hljs-keyword">if</span> (modCount != expectedModCount) 	
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();
        
        <span class="hljs-comment">//如果next为null，说明没有更多元素，抛出无元素异常</span>
        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();
        
         <span class="hljs-comment">//如果当前桶的链表/树遍历完毕，继续查找下一个非空桶</span>
        <span class="hljs-keyword">if</span> ((next = (current = e).next) == <span class="hljs-literal">null</span> &amp;&amp; (t = table) != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-comment">//循环查找下一个非空链表</span>
            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>);
        &#125;
        <span class="hljs-comment">// 返回下一个结点</span>
        <span class="hljs-keyword">return</span> e;
    &#125;
    
    <span class="hljs-comment">//删除当前遍历的节点 </span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;
        Node&lt;K,V&gt; p = current;	<span class="hljs-comment">//获取当前节点（由nextNode()设置的current）</span>
        <span class="hljs-comment">//如果未调用next()直接调用remove()，抛出非法状态异常 </span>
        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();
        <span class="hljs-comment">//校验并发修改 </span>
        <span class="hljs-keyword">if</span> (modCount != expectedModCount)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();
        current = <span class="hljs-literal">null</span>;	<span class="hljs-comment">//清除当前节点引用（避免重复删除）</span>
        <span class="hljs-type">K</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> p.key;	<span class="hljs-comment">//获取要删除节点的key </span>
        removeNode(hash(key), key, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);	<span class="hljs-comment">//调用HashMap的删除方法 </span>
        expectedModCount = modCount;	<span class="hljs-comment">//更新修改次数（因为removeNode修改了modCount）</span>
    &#125;
&#125;</code></pre></div><p>总结：</p><p><code>entrySet</code>通过迭代器（<code>HashIterator</code>）直接遍历 <code>table</code>数组中的每个桶。</p><ul><li>迭代器动态定位非空桶，并按链表或树结构遍历所有节点。</li><li>整个过程无需复制数据，保证了高效的内存使用和遍历性能。</li></ul><h3 id="添加元素和扩容机制">添加元素和扩容机制</h3><p>之前已经学习过HashSet的底层原理，它就是通过HashMap实现的，所以它们添加元素和扩容的机制完全相同。参考<a href="https://catpaws.top/#添加元素add方法">HashSet添加元素过程的源码分析</a>、<a href="https://catpaws.top/#hashset扩容和转成红黑树的机制">HashSet扩容和树化的机制</a></p><ul><li>HashMap底层维护了Node类型的数组table，默认为null</li><li>当创建对象时，将加载因子（loadfactor）初始化为0.75.</li><li>当添加key-val时，通过key的哈希值得到在table的索引。然后判断该索引处是否有元素如果没有元素直接添加。如果该索引处有元素，继续判断该元素的key和准备加入的key相是否等，如果相等，则直接替换val；如果不相等需要判断是树结构还是链表结构，做出相应处理。如果添加时发现容量不够，则需要扩容。</li><li>第1次添加，则需要扩容table容量为16，临界值（threshold）为12（16*0.75）</li><li>以后再扩容，则需要扩容table容量为原来的2倍（32），临界值为原来的2倍，即24，依次类推.</li><li>在Java8中，如果一条链表的元素个数超过TREEIFY THRESHOLD（默认是8），并且table的大小 &gt;= MIN_TREEIFY_CAPACITY（默认64），就会进行树化（红黑树）</li></ul><h3 id="线程安全问题">线程安全问题</h3><p>HashMap没有实现同步，它的操作方法上没有加<code>synchronized</code>关键字，因此是线程不安全的。在多线程环境下直接使用 <code>HashMap</code>可能导致数据不一致、死循环、甚至程序崩溃。</p><p>存在的线程安全问题：</p><ul><li><p><strong>数据丢失（覆盖）</strong></p><p>当多个线程同时调用 <code>put()</code>方法时，可能发生哈希冲突的键值对被覆盖。</p><p><strong>示例场景</strong>：</p><ul><li>线程 A和线程 B同时向同一个桶（哈希冲突）插入不同的键值对。</li><li>如果两个线程同时检测到该桶为空，并尝试插入数据，最终只有一个线程的修改会保留。</li></ul></li><li><p><strong>链表成环（JDK1.7的经典问题）</strong></p><p>在 JDK1.7中，<code>HashMap</code>使用<strong>头插法</strong>处理哈希冲突的链表。当多线程同时触发 <code>resize()</code>（扩容）时，在链表迁移过程中修改节点的 <code>next</code>指针，链表节点的 <code>next</code>指针被错误地指向其他节点，导致链表成环，后续的 <code>get()</code>操作陷入死循环。</p><p>举个例子，假设原数组的某个位置有一个链表A→B→null。</p><ul><li>当线程1开始扩容，遍历到节点A，计算它的哈希值，将其插入到新数组的某个位置。准备开始处理节点B，此时线程1被挂起，新数组中的链表为A→null</li><li>接着线程2开始扩容，同样处理这个链表，完成扩容操作，此时已经将链表转移为B→A→null。（<strong>关键的是它把节点B的next设置为了节点A。</strong>）</li><li>当线程1恢复执行时，继续处理节点B，并保存它的next节点A（下一个要处理的）。将B插入链表头部，结果为B→A→null；接着再处理节点A，将它插入链表头部，结果为<strong>A→B→A</strong>→null。此时就出现了链表成环（死链），后续的 <code>get()</code>操作陷入死循环。</li></ul><p>JDK1.8中，链表插入改为<strong>尾插法</strong>，避免了扩容时的链表成环问题，但并发 <code>put()</code>仍可能导致数据丢失或链表断裂。</p></li><li><p><strong>数据不一致（脏读）</strong></p><p>一个线程在遍历 <code>HashMap</code>时，另一个线程修改了结构（如添加或删除元素），导致遍历结果不可预测。</p></li></ul><p><strong>线程安全的替代方案</strong></p><table><thead><tr class="header"><th><strong>方案</strong></th><th><strong>原理</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr class="odd"><td><strong><code>ConcurrentHashMap</code></strong></td><td>分段锁（JDK1.7）或 CAS + synchronized（JDK1.8+）</td><td>高并发读写场景</td></tr><tr class="even"><td><strong><code>Collections.synchronizedMap()</code></strong></td><td>通过全局锁包装 <code>HashMap</code></td><td>低并发场景</td></tr><tr class="odd"><td><strong><code>Hashtable</code></strong></td><td>所有方法加 <code>synchronized</code>锁</td><td>遗留代码（不推荐）</td></tr></tbody></table><h2 id="hashtable的底层原理分析">3.4、Hashtable的底层原理分析</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Hashtable.html">Hashtable API文档</a></p><p>Hashtable是 Java早期提供的线程安全键值对存储结构，其设计与 HashMap类似，但实现细节和线程安全机制有显著差异。</p><p>Hashtable底层使用<strong>数组 +链表</strong>实现，与 HashMap类似，Hashtable使用 <code>Entry[] table</code>数组存储键值对，每个数组元素是一个链表头节点。Hashtable <strong>没有像 HashMap的链表转红黑树</strong>的优化（JDK1.8+），哈希冲突完全依赖链表解决。</p><p>Hashtable的键和值都不允许为null。</p><blockquote><p>Hashtable存储结点使用的Entry类型 和 HashMap存储结点使用的Node类型都是实现了Map.Entry接口</p></blockquote><p>Hashtable的所有公共方法（如 <code>put()</code>, <code>get()</code>）均用 <code>synchronized</code>修饰，保证单实例线程安全。（<strong>方法级同步</strong>）。由于所有操作竞争同一把锁，高并发下性能差（对比 ConcurrentHashMap的分段锁或 CAS机制）。</p><h3 id="扩容机制-2"><strong>扩容机制</strong></h3><ul><li><p><strong>初始容量</strong>：默认 <code>11</code>（HashMap默认 <code>16</code>），负载因子默认为0.75.</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250208235237416-2025-2-823:52:40.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></li><li><p><strong>扩容触发条件</strong>：当元素数量超过 <code>阈值（threshold = capacity * loadFactor）</code></p></li><li><p><strong>扩容规则</strong>：新容量为 <code>旧容量 * 2 +1</code>，而 HashMap直接翻倍。</p></li><li><p><strong>重新哈希</strong>：所有键值对需重新计算索引并迁移到新数组，过程与 HashMap类似。</p></li></ul><h3 id="源码分析-1">源码分析</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/未命名绘图-2025-2-900:28:49.jpg" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h2 id="properties">3.5、Properties</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Properties.html">Properties API文档</a></p><p>properties类继承自Hashtable类并且实现了Map接口，也是使用一种键值对的形式来保存属性集。</p><p>它是 Java中用于处理 <strong>键值对配置文件</strong>的专用类，主要面向 <code>.properties</code>文件的读写，键和值均为 <code>String</code>类型，非字符串操作会抛出 <code>ClassCastException</code>。</p><blockquote><p>通过覆写 <code>put()</code>、<code>get()</code>等方法限制键值类型为 <code>String</code>，直接调用 <code>Hashtable</code>的非字符串方法（如 <code>put(Object,Object)</code>）可能导致类型错误。</p></blockquote><p><strong>核心特性</strong>：</p><table><thead><tr class="header"><th><strong>特性</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr class="odd"><td><strong>键值类型</strong></td><td>键和值均为 <code>String</code>类型，非字符串操作会抛出 <code>ClassCastException</code>。</td></tr><tr class="even"><td><strong>线程安全</strong></td><td>继承自 <code>Hashtable</code>，方法使用 <code>synchronized</code>修饰，但并发性能较低。</td></tr><tr class="odd"><td><strong>默认值链</strong></td><td>支持通过 <code>defaults</code>属性链式查找未定义的键（类似继承机制）。</td></tr><tr class="even"><td><strong>文件读写</strong></td><td>提供 <code>load()</code>和 <code>store()</code>方法处理 <code>.properties</code>文件编码与转义。</td></tr><tr class="odd"><td><strong>无 <code>null</code>键值</strong></td><td>与 <code>Hashtable</code>一致，不允许 <code>null</code>键或值。</td></tr></tbody></table><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xudong-bupt/p/3758136.html">参考文章</a></p><h2 id="treemap底层原理分析">3.5、TreeMap底层原理分析</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/util/TreeMap.html">TreeMap API 文档</a></p><p><code>TreeMap</code>是 Java中基于红黑树（Red-Black Tree）实现的有序映射（SortedMap），其核心特性是<strong>按键的自然顺序或自定义比较器顺序存储键值对</strong>。</p><p><code>TreeMap</code> 的键通常是不可变的。这是因为 <code>TreeMap</code> 的内部结构（红黑树）依赖于键的比较结果来维护顺序。如果键在插入后被修改，那么可能会破坏树的结构，导致不正确的行为。</p><p>与大多数集合类一样，<code>TreeMap</code>是非线程安全的，需通过 <code>Collections.synchronizedSortedMap()</code>包装。</p><p>对比HashMap:</p><table><thead><tr class="header"><th>特性</th><th>TreeMap</th><th>HashMap</th></tr></thead><tbody><tr class="odd"><td>底层结构</td><td>红黑树</td><td>数组 +链表/红黑树</td></tr><tr class="even"><td>键顺序</td><td>有序</td><td>无序</td></tr><tr class="odd"><td>时间复杂度</td><td>O(log n)</td><td>O(1)（理想情况）</td></tr><tr class="even"><td>线程安全</td><td>否</td><td>否</td></tr><tr class="odd"><td>允许 null键</td><td>取决于比较器</td><td>允许</td></tr></tbody></table><ul><li><strong>时间复杂度</strong>：所有核心操作（插入、删除、查找）的时间复杂度为 <strong>O(log n)</strong>。</li><li><strong>空间复杂度</strong>：O(n)，每个节点需要存储额外信息（父节点、颜色）。</li></ul><p><strong>适用场景</strong></p><ul><li>需要有序键的场景（如范围查询）。</li><li>键的插入顺序不重要，但需要按特定顺序遍历。</li><li>对性能要求不高但需要稳定对数时间复杂度的场景。</li></ul><h3 id="数据结构">数据结构</h3><p><code>TreeMap</code>的底层数据结构是红黑树，一种自平衡的二叉搜索树（BST）。</p><p><a href="https://catpaws.top/24d4ba7c/#红黑树rbt">红黑树相关知识点</a></p><p><code>TreeMap</code>的节点通过内部类 <code>Entry&lt;K, V&gt;</code>表示，包含键、值、父节点、左子节点、右子节点以及颜色标志。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;
    K key;
    V value;
    Entry&lt;K,V&gt; left;
    Entry&lt;K,V&gt; right;
    Entry&lt;K,V&gt; parent;
    <span class="hljs-type">boolean</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> BLACK;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">      * Make a new cell with given key, value, and parent, and with</span>
<span class="hljs-comment">      * &#123;<span class="hljs-doctag">@code</span> null&#125; child links, and BLACK color.</span>
<span class="hljs-comment">       */</span>
    Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123;
        <span class="hljs-built_in">this</span>.key = key;
        <span class="hljs-built_in">this</span>.value = value;
        <span class="hljs-built_in">this</span>.parent = parent;
    &#125;
    <span class="hljs-comment">//其他方法........</span>
&#125;</code></pre></div><h3 id="构造方法">构造方法</h3><p><code>TreeMap</code> 提供了多个构造器：</p><ul><li><p><strong>默认的无参构造器</strong></p><p>使用默认的无参构造器创建TreeMap时，会使用键的自然顺序。也就是说，键必须实现 <code>Comparable</code> 接口，并且 <code>compareTo</code> 方法必须能够正确地比较两个键的大小。否则在插入时会抛出<code>ClassCastException</code>，不支持 <code>null</code>键（自然顺序无法比较<code>null</code>）。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">TreeMap</span><span class="hljs-params">()</span> &#123;
    comparator = <span class="hljs-literal">null</span>; <span class="hljs-comment">//使用键的自然顺序（键需实现Comparable接口）</span>
&#125;</code></pre></div></li><li><p><strong>指定比较器的构造器</strong></p><p>完全由用户定义的比较器决定键的排序，允许键不实现 <code>Comparable</code>接口。</p><div class="code-wrapper"><pre><code class="hljs java">TreeMap(Comparator&lt;? <span class="hljs-built_in">super</span> K&gt; comparator) &#123;
    <span class="hljs-built_in">this</span>.comparator = comparator; <span class="hljs-comment">// 显式指定比较器</span>
&#125;</code></pre></div><p>示例:</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-comment">// 自定义比较器：按键的长度进行排序</span>
        Comparator&lt;String&gt; lengthComparator = (s1, s2) -&gt; Integer.compare(s1.length(), s2.length());

        <span class="hljs-comment">// 创建 TreeMap 并传入自定义比较器</span>
        TreeMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;(lengthComparator);

        <span class="hljs-comment">// 插入元素</span>
        map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">1</span>);
        map.put(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>);
        map.put(<span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-number">3</span>);
        map.put(<span class="hljs-string">&quot;kiwi&quot;</span>, <span class="hljs-number">4</span>);

        <span class="hljs-comment">// 遍历 TreeMap</span>
        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;
            System.out.println(entry.getKey() + <span class="hljs-string">&quot; =&gt; &quot;</span> + entry.getValue());
        &#125;
    &#125;
&#125;</code></pre></div></li><li><p><strong>基于 <code>SortedMap</code>的构造器</strong></p><p>构造器接收一个<code>SortedMap</code>作为参数，并创建一个新的<code>TreeMap</code>实例。新创建的<code>TreeMap</code>将包含与传入的<code>SortedMap</code>相同的键值对，并且这些键值对将按照<code>SortedMap</code>的排序顺序进行排序。(从已有的 <code>SortedMap</code>中继承比较器和键值对。)</p><p>通过基于<code>SortedMap</code>的构造器创建<code>TreeMap</code>，可以方便地将一个已经排序的映射复制到新的<code>TreeMap</code>中，同时保持相同的排序顺序,无需重新排序。这可以提高性能，特别是当映射很大时。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;

    SortedMap&lt;Integer, String&gt; sortedMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();
    sortedMap.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;One&quot;</span>);
    sortedMap.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Two&quot;</span>);
    sortedMap.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Three&quot;</span>);
    <span class="hljs-comment">// treeMap 现在将包含与 sortedMap 相同的键值对，并且按照相同的顺序排序</span>
    TreeMap&lt;Integer, String&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;(sortedMap);
&#125;</code></pre></div><blockquote><p>SortedMap接口有一个子接口NavigableMap，它在SortedMap的基础上增加了一些额外的导航方法，使得对有序键值对的操作更加方便和灵活。NavigableMap接口提供了如<code>lowerKey</code>、<code>floorKey</code>、<code>ceilingKey</code>、<code>higherKey</code>等导航方法，以及<code>pollFirstEntry</code>、<code>pollLastEntry</code>等移除并返回最小/最大键值对的方法。</p></blockquote></li><li><p>基于普通 <code>Map</code>的构造器</p><p>当使用普通的<code>Map</code>构造器来创建<code>TreeMap</code>实例时，<code>TreeMap</code>会根据Map中键的值来构造红黑树，重新组织结点，它要求键必须是可以比较的。如果提供的<code>Map</code>中的键没有实现<code>Comparable</code>接口，那么必须在使用<code>TreeMap</code>的构造器时提供一个自定义的比较器，否则会抛出<code>ClassCastException</code>。</p></li></ul><h3 id="put方法分析">put()方法分析</h3><p>插入操作的核心是维护红黑树的平衡，步骤如下：</p><ol type="1"><li><strong>二叉搜索树插入</strong>：按 BST规则找到插入位置。</li><li><strong>颜色修正与旋转</strong>：通过调整颜色和旋转保持红黑树性质。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;
    Entry&lt;K,V&gt; t = root;
    
    <span class="hljs-comment">//判断根节点是否为空</span>
    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-comment">//调用 compare 方法，主要是为了检查 key 的类型是否正确以及是否为 null</span>
        compare(key, key); <span class="hljs-comment">// type (and possibly null) check</span>
		<span class="hljs-comment">// 创建一个新的 Entry 节点作为根节点，key 和 value 是传入的参数，父节点为 null</span>
        root = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(key, value, <span class="hljs-literal">null</span>); 
        size = <span class="hljs-number">1</span>;	<span class="hljs-comment">// 树的大小设置为1</span>
        modCount++;	<span class="hljs-comment">// 修改计数器加1，表示树结构发生了变化</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//添加成功，返回null </span>
    &#125;
    <span class="hljs-type">int</span> cmp;
    Entry&lt;K,V&gt; parent; <span class="hljs-comment">//用于存储待插入节点的父节点</span>
    
    <span class="hljs-comment">// 获取比较器，如果有自定义的比较器，则使用它；否则使用 key 的自然顺序比较</span>
    <span class="hljs-comment">// 根据比较结果寻找新结点的插入位置，最终插入在parent结点下</span>
    Comparator&lt;? <span class="hljs-built_in">super</span> K&gt; cpr = comparator;
    <span class="hljs-keyword">if</span> (cpr != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">do</span> &#123;
            parent = t; <span class="hljs-comment">// 将当前节点赋值给 parent，记录父节点</span>
            <span class="hljs-comment">// 使用比较器比较传入的 key 和当前节点的 key</span>
            cmp = cpr.compare(key, t.key); 
            
            <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)
                t = t.left;	<span class="hljs-comment">// 如果 key 小于当前节点的 key，移动到左子树</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>)
                t = t.right; <span class="hljs-comment">// 如果 key 大于当前节点的 key，移动到右子树	</span>
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> t.setValue(value);  <span class="hljs-comment">// 如果 key 等于当前节点的 key，更新 value 并返回旧值</span>
        
        &#125; <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">null</span>); <span class="hljs-comment">// 循环直到找到空位置插入新节点</span>
    &#125;
    <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) <span class="hljs-comment">// 如果 key 为 null，抛出空指针异常</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();
        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
        <span class="hljs-comment">// 将 key 转换为 Comparable 类型，用于自然顺序比较</span>
        Comparable&lt;? <span class="hljs-built_in">super</span> K&gt; k = (Comparable&lt;? <span class="hljs-built_in">super</span> K&gt;) key;
        <span class="hljs-keyword">do</span> &#123;
            parent = t; <span class="hljs-comment">// 将当前节点赋值给 parent，记录父节点</span>
            
             <span class="hljs-comment">// 使用自然顺序比较传入的 key 和当前节点的 key </span>
            cmp = k.compareTo(t.key); 
            <span class="hljs-comment">// 同上，根据比较结果寻找插入位置</span>
            <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)
                t = t.left;	
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>)
                t = t.right;
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> t.setValue(value);
        &#125; <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">null</span>);
    &#125;
    <span class="hljs-comment">// 创建一个新的 Entry 节点，父节点为 parent</span>
    Entry&lt;K,V&gt; e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(key, value, parent);
    
    <span class="hljs-comment">// 比较 key 和 parent的key的大小，上面循环中最后一轮已经计算出来了，决定将新结点插入到左孩子还是右孩子</span>
    
    <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)
        parent.left = e;
    <span class="hljs-keyword">else</span>
        parent.right = e;
    fixAfterInsertion(e); <span class="hljs-comment">// 调用修复方法，调整树的平衡性</span>
    size++; <span class="hljs-comment">// 树的大小加1</span>
    modCount++; <span class="hljs-comment">// 修改计数器加1，表示树结构发生了变化</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 当前是新结点，没有旧值，返回null</span>
&#125;</code></pre></div><h3 id="get-方法分析">get() 方法分析</h3><p>查找操作基于二叉搜索树的特性</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;
    <span class="hljs-comment">//调用getEntry()方法，根据key返回Entry对象</span>
    Entry&lt;K,V&gt; p = getEntry(key);
    <span class="hljs-comment">//判断：若Entry对象为空，则返回null；否则返回对应的value</span>
    <span class="hljs-keyword">return</span> (p==<span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : p.value);
&#125;
<span class="hljs-comment">/**</span>
<span class="hljs-comment">*查找指定键 key所对应节点的逻辑。</span>
<span class="hljs-comment">*	首先检查是否有自定义比较器，如果有，则使用比较器进行查找；否则，通过* 键的自然顺序遍历树来查找。</span>
<span class="hljs-comment">*	如果找到匹配的节点，返回该节点；如果未找到，返回 null。</span>
<span class="hljs-comment">*</span>
<span class="hljs-comment">*/</span>

<span class="hljs-keyword">final</span> Entry&lt;K,V&gt; <span class="hljs-title function_">getEntry</span><span class="hljs-params">(Object key)</span> &#123;
    <span class="hljs-comment">// 如果有自定义比较器，则调用 getEntryUsingComparator 方法进行查找。</span>
    <span class="hljs-comment">// getEntryUsingComparator 方法中寻找结点的逻辑与下面 完全一样</span>
    <span class="hljs-keyword">if</span> (comparator != <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">return</span> getEntryUsingComparator(key);
    
    <span class="hljs-comment">// 如果 key 为 null，抛出空指针异常，因为二叉搜索树不允许 null 键。</span>
    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();
     <span class="hljs-comment">// 将 key 转换为 Comparable 类型，用于自然顺序比较。</span>
    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span>
    Comparable&lt;? <span class="hljs-built_in">super</span> K&gt; k = (Comparable&lt;? <span class="hljs-built_in">super</span> K&gt;) key;
    
    Entry&lt;K,V&gt; p = root; <span class="hljs-comment">// 定义一个指针 p，初始化为根节点 root，用于遍历树。</span>
    
    <span class="hljs-comment">//遍历二叉搜索树</span>
    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-type">int</span> <span class="hljs-variable">cmp</span> <span class="hljs-operator">=</span> k.compareTo(p.key); <span class="hljs-comment">//比较 `key` 和当前节点的键 `p.key`的大小</span>
        <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>) 	<span class="hljs-comment">//key小于当前节点的键，则移动到左子树</span>
            p = p.left;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//key大于当前节点的键，则移动到右子树</span>
            p = p.right; 
        <span class="hljs-keyword">else</span>			<span class="hljs-comment">//等于当前节点的键，返回当前节点 p</span>
            <span class="hljs-keyword">return</span> p;
    &#125;
    <span class="hljs-comment">// 如果遍历完整棵树仍未找到匹配的节点，返回 null。</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
&#125;</code></pre></div><h3 id="remove方法分析">remove()方法分析</h3><p>红黑树中删除结点的逻辑：</p><ol type="1"><li><p>如果要删除的节点 <code>p</code> 有两个子节点：</p><ul><li>找到它的后继节点 <code>s</code>，用 <code>s</code> 的值覆盖 <code>p</code> 的值，然后将 <code>p</code> 指向 <code>s</code>。</li><li>后续操作会删除后继节点 <code>s</code>（后继节点最多只有一个子节点）。</li></ul></li><li><p>如果 <code>p</code>只有一个子节点：</p><ul><li>用它的子节点替代它，并修复树的结构。</li></ul></li><li><p>如果 <code>p</code> 没有子节点：</p><ul><li>如果 <code>p</code> 是黑色节点，修复树的平衡性。</li><li>从父节点中断开与 <code>p</code> 的连接。</li></ul></li><li><p>如果 <code>p</code> 是唯一的节点（即树中只有一个节点）：</p><ul><li>将树置为空树。</li></ul></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment">* Removes the mapping for this key from this TreeMap if present.</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;
    <span class="hljs-comment">//根据key 调用 getEnry()方法获取对应的Entry对象</span>
    Entry&lt;K,V&gt; p = getEntry(key);
    <span class="hljs-comment">//若树中没有对应的key，返回null</span>
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

    <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> p.value; <span class="hljs-comment">// 保存待删除节点的value</span>
    <span class="hljs-comment">//调用deleteEntry()方法删除指定节点，并将树重新设置平衡</span>
    deleteEntry(p);
    <span class="hljs-keyword">return</span> oldValue; <span class="hljs-comment">// 返回已删除结点的value</span>
&#125;


<span class="hljs-comment">/**</span>
<span class="hljs-comment">* Delete node p, and then rebalance the tree.</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteEntry</span><span class="hljs-params">(Entry&lt;K,V&gt; p)</span> &#123;
    modCount++; <span class="hljs-comment">// 修改计数器加1，表示树的结构发生了变化。</span>
    size--; <span class="hljs-comment">// 树的大小减1，表示删除了一个节点。</span>

    <span class="hljs-comment">// 如果节点 p 同时有左子节点和右子节点（即 p 是一个内部节点）， </span>
    <span class="hljs-comment">// 则找到它的后继节点 s，用后继节点的值覆盖当前节点的值，</span>
 	<span class="hljs-comment">// 然后将 p 指向后继节点（后继节点将在后续步骤中被删除）。</span>
    <span class="hljs-keyword">if</span> (p.left != <span class="hljs-literal">null</span> &amp;&amp; p.right != <span class="hljs-literal">null</span>) &#123;
        Entry&lt;K,V&gt; s = successor(p);
        p.key = s.key;
        p.value = s.value;
        p = s;
    &#125; <span class="hljs-comment">// p has 2 children</span>

    
    <span class="hljs-comment">// 定义替代节点 replacement，如果 p 有子节点，则选择非空的子节点作为替代节点。</span>
    Entry&lt;K,V&gt; replacement = (p.left != <span class="hljs-literal">null</span> ? p.left : p.right);
	
     <span class="hljs-comment">//1、 如果 p 有子节点</span>
    <span class="hljs-keyword">if</span> (replacement != <span class="hljs-literal">null</span>) &#123;
        replacement.parent = p.parent; <span class="hljs-comment">//将替代节点的父节点指向 p 的父节点。</span>
        
       
        <span class="hljs-keyword">if</span> (p.parent == <span class="hljs-literal">null</span>)  <span class="hljs-comment">// 如果 p 是根节点，则将替代节点设置为新的根节点。</span>
            root = replacement;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == p.parent.left) <span class="hljs-comment">// 如果 p 是父节点的左子节点，则将替代节点设置为父节点的左子节点。</span>
            p.parent.left  = replacement;
        <span class="hljs-keyword">else</span>						<span class="hljs-comment">// 如果 p 是父节点的右子节点，则将替代节点设置为父节点的右子节点。</span>
            p.parent.right = replacement; 

         <span class="hljs-comment">// 清除 p 的左右子节点和父节点的引用，释放资源。</span>
        p.left = p.right = p.parent = <span class="hljs-literal">null</span>;

        <span class="hljs-comment">// Fix replacement</span>
        <span class="hljs-keyword">if</span> (p.color == BLACK)  <span class="hljs-comment">// 如果删除的节点是黑色节点，则需要修复红黑树的平衡性。</span>
            fixAfterDeletion(replacement);
    &#125; 
    <span class="hljs-comment">//2、如果 p 是唯一的节点（即树中只有一个节点）</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.parent == <span class="hljs-literal">null</span>) &#123;
        root = <span class="hljs-literal">null</span>;	<span class="hljs-comment">// 将根节点设置为 null，树变为空树。</span>
    &#125;
    <span class="hljs-comment">//3、 如果 p 没有子节点（即 p 是叶子节点）</span>
    <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// 如果删除的节点是黑色节点，则需要修复红黑树的平衡性。</span>
        <span class="hljs-keyword">if</span> (p.color == BLACK)
            fixAfterDeletion(p);
		<span class="hljs-comment">// 如果 p 有父节点</span>
        <span class="hljs-keyword">if</span> (p.parent != <span class="hljs-literal">null</span>) &#123;
            <span class="hljs-comment">// 如果 p` 是父节点的左子节点，将父节点的左子节点置为 null。</span>
            <span class="hljs-keyword">if</span> (p == p.parent.left)
                p.parent.left = <span class="hljs-literal">null</span>;
            <span class="hljs-comment">// 如果 p 是父节点的右子节点，将父节点的右子节点置为 null。</span>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p == p.parent.right)
                p.parent.right = <span class="hljs-literal">null</span>;
            
            p.parent = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 清除 p 的父节点引用，释放资源。</span>
        &#125;
    &#125;
&#125;</code></pre></div><h2 id="concurrenthashmap">3.6、ConcurrentHashMap</h2><p>详见：<a href="https://catpaws.top/eb9166f8/#concurrenthashmap">ConcurrentHashMap</a></p><h1 id="四集合选型规则">四、集合选型规则</h1><p>在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类特性进行选择，分析如下：</p><ul><li><p>1）先判断存储的类型（一组对象[单列] 或 一组键值对[双列]）</p></li><li><p>2）一组对象[单列]：Collection接口</p><ul><li>允许重复：List<ul><li>增删多：LinkedList[底层维护了一个双向链表]</li><li>改查多：ArrayList[底层维护 Object类型的可变数组]</li></ul></li><li>不允许重复：Set<ul><li>无序：HashSet[底层是HashMap，维护了一个哈希表 即（数组+链表+红黑树）]</li><li>排序：TreeSet</li><li>插入和取出顺序一致：LinkedHashSet，维护数组+双向链表3）</li></ul></li></ul></li><li><p>3）一组键值对[双列]：Map</p><ul><li>键无序：HashMap[底层是：哈希表jdk7：数组+链表，jdk8：数组+链表+红黑树]</li><li>键排序：TreeMap</li><li>键插入和取出顺序一致：LinkedHashMap</li><li>读取文件 Properties</li></ul></li></ul><h1 id="五collections工具类">五、Collections工具类</h1><p><code>java.util.Collections</code>是 Java集合框架中提供的 <strong>静态工具类</strong>，封装了多种对集合（如 List、Set、Map）进行操作的实用方法。它不包含任何集合实例，而是通过静态方法增强集合功能。</p><p><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/util/Collections.html">Collections API文档</a></p><p><a target="_blank" rel="noopener" href="https://javabetter.cn/common-tool/collections.html">Collections工具类具体使用参考</a></p><h1 id="六stream流">六、Stream流</h1><p><a href="https://catpaws.top/146f67fb/">函数式编程-Stream流</a></p><h1 id="七线程安全集合">七、线程安全集合</h1><p><a href="https://catpaws.top/eb9166f8/#九并发工具之线程安全集合类">并发工具之线程安全集合类</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/JavaSE/" class="category-chain-item">JavaSE</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/JavaSE/" class="print-no-link">#JavaSE</a></div></div><div class="license-box my-3"><div class="license-title"><div>java 集合</div><div>https://catpaws.top/d5381517/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年2月6日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/98735cb0/" title="泛型程序设计"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">泛型程序设计</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/f0242a65/" title="JVM学习"><span class="hidden-mobile">JVM学习</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://catpaws.top/blog-resource/twikoo1.6.42/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本站由<img src="/img/upyun_logo.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="width:auto;height:auto">提供CDN加速/云存储服务</a></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备2025059828号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61032302000087" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="police-icon"> <span>陕公网安备61032302000087号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//catpaws.top/blog-resource/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="//catpaws.top/blog-resource/js/loader.js"></script><script src="//catpaws.top/blog-resource/js/blurpicload.js"></script><script src="//catpaws.top/blog-resource/js/axios.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://catpaws.top/blog-resource/live2d/index.min.js"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"https://catpaws.top/blog-resource/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"}}})</script></body></html>