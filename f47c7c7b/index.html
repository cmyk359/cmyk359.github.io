<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkai/dist/LXGWWenKai-Regular/result.css"><link rel="apple-touch-icon" sizes="76x76" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><link rel="icon" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="树和二叉树的相关知识点 链式存储的二叉树的结构： public class TreeNode&#123;     int val;     TreeNode left;     TreeNode right;     TreeNode(int val) &#123;         this.val &#x3D; val;         this.left &#x3D; null;         this"><meta property="og:type" content="article"><meta property="og:title" content="六、二叉树"><meta property="og:url" content="https://catpaws.top/f47c7c7b/index.html"><meta property="og:site_name" content="猫爪在上の书桌"><meta property="og:description" content="树和二叉树的相关知识点 链式存储的二叉树的结构： public class TreeNode&#123;     int val;     TreeNode left;     TreeNode right;     TreeNode(int val) &#123;         this.val &#x3D; val;         this.left &#x3D; null;         this"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240420174246041-2024-8-410:43:30.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250914174423547-2025-9-1417:44:53.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250914175431295-2025-9-1417:54:31.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250914182000841-2025-9-1418:20:01.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250914182339643-2025-9-1418:23:40.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250914182924491-2025-9-1418:29:27.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250914212843799-2025-9-1421:29:14.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250914214110999-2025-9-1421:41:11.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250914223242109-2025-9-1422:32:51.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250915091142047-2025-9-1509:11:51.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250915091256687-2025-9-1509:12:57.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250915095258189-2025-9-1509:53:07.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250920111734067-2025-9-2011:17:43.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250920182241500-2025-9-2018:22:43.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250920211136576-2025-9-2021:11:42.png"><meta property="article:published_time" content="2025-08-04T01:20:56.000Z"><meta property="article:modified_time" content="2025-10-15T10:06:38.645Z"><meta property="article:author" content="猫爪在上"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20240420174246041-2024-8-410:43:30.png"><title>六、二叉树 - 猫爪在上の书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/font.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/poem.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/cursor.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/loader.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/twikoo_beautify.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/indeximg-hover.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/wave-1.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/blurpicload.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/reward/iconfont.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/switch.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"https://catpaws.top/blog-resource/imgs/transparent.svg",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://leancloud.catpaws.top",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loader-container"><div class="loader"><div class="wrapper"><div class="catContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 733 673" class="catbody"><path fill="#212121" d="M111.002 139.5C270.502 -24.5001 471.503 2.4997 621.002 139.5C770.501 276.5 768.504 627.5 621.002 649.5C473.5 671.5 246 687.5 111.002 649.5C-23.9964 611.5 -48.4982 303.5 111.002 139.5Z"></path><path fill="#212121" d="M184 9L270.603 159H97.3975L184 9Z"></path><path fill="#212121" d="M541 0L627.603 150H454.397L541 0Z"></path></svg> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 158 564" class="tail"><path fill="#191919" d="M5.97602 76.066C-11.1099 41.6747 12.9018 0 51.3036 0V0C71.5336 0 89.8636 12.2558 97.2565 31.0866C173.697 225.792 180.478 345.852 97.0691 536.666C89.7636 553.378 73.0672 564 54.8273 564V564C16.9427 564 -5.4224 521.149 13.0712 488.085C90.2225 350.15 87.9612 241.089 5.97602 76.066Z"></path></svg><div class="text"><span class="bigzzz">Z</span> <span class="zzz">Z</span></div></div><div class="wallContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 500 126" class="wall"><line stroke-width="6" stroke="#7C7C7C" y2="3" x2="450" y1="3" x1="50"></line><line stroke-width="6" stroke="#7C7C7C" y2="85" x2="400" y1="85" x1="100"></line><line stroke-width="6" stroke="#7C7C7C" y2="122" x2="375" y1="122" x1="125"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="500" y1="43"></line><line stroke-width="6" stroke="#7C7C7C" y2="1.99391" x2="115.5" y1="43.0061" x1="115.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00002" x2="189" y1="43.0122" x1="189"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00612" x2="262.5" y1="43.0183" x1="262.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01222" x2="336" y1="43.0244" x1="336"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01833" x2="409.5" y1="43.0305" x1="409.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="153" y1="84.0122" x1="153"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="228" y1="84.0122" x1="228"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="303" y1="84.0122" x1="303"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="378" y1="84.0122" x1="378"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="192" y1="125.012" x1="192"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="267" y1="125.012" x1="267"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="342" y1="125.012" x1="342"></line></svg></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上の书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>个人主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://catpaws.top/blog-resource/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="六、二叉树"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-08-04 09:20" pubdate>2025年8月4日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 9k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 76 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">六、二叉树</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年10月15日 晚上</p><div class="markdown-body"><meta name="referrer" , content="no-referrer"><p><a href="https://catpaws.top/453281de/">树和二叉树的相关知识点</a></p><p>链式存储的二叉树的结构：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&#123;
    <span class="hljs-type">int</span> val;
    TreeNode left;
    TreeNode right;
    TreeNode(<span class="hljs-type">int</span> val) &#123;
        <span class="hljs-built_in">this</span>.val = val;
        <span class="hljs-built_in">this</span>.left = <span class="hljs-literal">null</span>;
        <span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span>;
    &#125;
    TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;
        <span class="hljs-built_in">this</span>.val = val;
        <span class="hljs-built_in">this</span>.left = left;
        <span class="hljs-built_in">this</span>.right = right;
    &#125;
&#125;</code></pre></div><p>递归三要素：</p><ul><li><strong>确定递归函数的参数和返回值</strong>：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件</strong>：写完了递归算法，运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑</strong>：确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ul><h2 id="先序遍历-nlr"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">先序遍历 NLR</a></h2><p>递归遍历</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;
    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    preOrder(root, res);
    <span class="hljs-keyword">return</span> res;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
    res.add(root.val); <span class="hljs-comment">//根</span>
    preOrder(root.left, res); <span class="hljs-comment">//左</span>
    preOrder(root.right, res); <span class="hljs-comment">//右</span>
&#125;</code></pre></div><hr><p>迭代遍历</p><p>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数。因此，可通过手动操作栈的方式代替递归。</p><p>思路：</p><ul><li>首先根节点入栈。此后，若栈不为空，则弹出栈顶元素访问。</li><li>若栈顶元素右孩子不为空，则先入栈右孩子；</li><li>若栈顶元素左孩子不为空，则再入栈左孩子。</li></ul><p>由于栈后进先出的特性，入栈时先右后左，出栈处理时先左后右</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;
    Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;

    stack.push(root);
    <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;
        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop(); <span class="hljs-comment">//访问根结点</span>
        res.add(node.val);
        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) stack.push(node.right);  <span class="hljs-comment">//先入栈右孩子</span>
        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) stack.push(node.left);  <span class="hljs-comment">//再入栈左孩子</span>
    &#125;
    stack = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h2 id="中序遍历-lnr"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">中序遍历 LNR</a></h2><p>递归遍历</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;
        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        inOrder(root, res);
        <span class="hljs-keyword">return</span> res;
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        inOrder(root.left, res); <span class="hljs-comment">//左</span>
        res.add(root.val);<span class="hljs-comment">//根</span>
        inOrder(root.right, res);<span class="hljs-comment">//右</span>
    &#125;
&#125;</code></pre></div><hr><p>迭代遍历</p><p>思路：</p><ol type="1"><li><p>沿着根的左孩子，依次入栈，直至左孩子为空。此时说明已经找到可以输出的结点</p></li><li><p>栈顶元素出栈并访问，转向处理右孩子</p></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;
    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();
    Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt; ();
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;

    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;
    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> || !stack.empty()) &#123;
        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//一路向左，不空就入栈</span>
            stack.push(p);
            p = p.left;
        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//左孩子为空，可以访问当前结点，出栈</span>
            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();
            list.add(node.val);
            p = node.right; <span class="hljs-comment">//转向右孩子</span>
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> list;
&#125;</code></pre></div><h2 id="后序遍历-lrn"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">后序遍历 LRN</a></h2><p>递归遍历</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;
        List&lt;Integer&gt;res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        postOrder(root,res);
        <span class="hljs-keyword">return</span> res;
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt;res)</span> &#123;
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
        postOrder(root.left,res); <span class="hljs-comment">//左</span>
        postOrder(root.right,res);<span class="hljs-comment">//右</span>
        res.add(root.val); <span class="hljs-comment">//根</span>
    &#125;
&#125;</code></pre></div><hr><p>迭代遍历</p><p>方法一：参考先序遍历的做法：先根节点入栈，再右孩子入栈，再左孩子入栈，最后得到的遍历序列是 <code>根 左 右</code>。</p><p>若颠倒其中左右孩子入栈顺序可到最终的遍历顺序为 <code>根 右 左</code> ，再将其逆序（不直接输出，而是存入另一个栈中）可得到后序遍历序列 <code>左 右 根</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;
    Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    Deque&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();

    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(res);

    stack.push(root);
    <span class="hljs-comment">//入栈时顺序为：根左右，出栈时顺序为：根右左，出栈收集时存入另一个栈中，就能得到逆序的结果 左右根</span>
    <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;
        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();
        res.push(node.val);
        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)  stack.push(node.left);
        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) stack.push(node.right);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(res);
&#125;</code></pre></div><p>方法二：用一个栈实现。使用c指向栈顶结点，h跟踪刚出栈访问的结点。</p><p><strong><code>h</code> 的作用</strong>：通过记录最近访问的节点，判断当前节点 <code>c</code> 的子树是否已被处理：</p><ul><li>若 <code>h == c.left</code>：说明左子树已处理完毕。</li><li>若 <code>h == c.right</code>：说明右子树已处理完毕。</li><li>若 <code>h</code> 既不是左也不是右孩子，说明左右子树均未处理。</li></ul><p>对于栈顶节点c：</p><ul><li>如果它的<u>左子树存在</u>且<u>尚未处理</u>（即h既不是左孩子也不是右孩子），则处理左子树</li><li>如果左子树已经处理或者左子树为空，而<u>右子树存</u>在且<u>尚未处理</u>（h不是右孩子），则处理右子树。</li><li>如果<u>左右子树都处理完了</u>，或<u>左右子树均为空</u>时，则处理当前节点。</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;
    Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;

    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> root; <span class="hljs-comment">//h跟踪最近出栈的结点，只要最开始不指向根节点的左右孩子即可</span>
    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//c指向栈顶结点</span>

    stack.push(root);
    <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;
        c = stack.peek();
        <span class="hljs-comment">//左子树不为空，最近出栈访问的既不是c左孩子也不是c的右孩子，则c的左子树还没处理完</span>
        <span class="hljs-keyword">if</span> (c.left != <span class="hljs-literal">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) &#123;
            stack.push(c.left);
        <span class="hljs-comment">//左子树已处理完毕，且右子树不为空，最近出栈访问的不是c的右孩子，则c的右子树还未处理完</span>
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( c.right != <span class="hljs-literal">null</span> &amp;&amp; h != c.right) &#123;
            stack.push(c.right);
        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//左右子树均处理完，或左右子树都为空时，处理当前结点</span>
            h = stack.pop();
            res.add(h.val);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h2 id="层序遍历"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">层序遍历</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240420174246041-2024-8-410:43:30.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:67%"></p><p>层序遍历一个二叉树，就是从左到右一层一层的去遍历二叉树，需要借用一个辅助<strong>队列</strong>来实现。</p><p>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</p><p>最终输出时，需要将每一层的结点放在一起。故需要知道当前层什么时候结束，可以使用一个变量<code>size</code>遍历记录当前层结点的个数。每次出队size个结点，此时当前层的结点均已出队，且当前队列中保存着下一层的所有结点。继续下去，直至队列为空。</p><div class="note note-warning"><p>关于队列的实现</p><p><code>LinkedList</code> 允许加入 <code>null</code> 元素，而 <code>ArrayDeque</code> 不允许。在二叉树遍历中，经常需要将 <code>null</code> 节点加入队列来表示空子树，因此 <code>LinkedList</code> 是更合适的选择。</p></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;
    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;

    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <span class="hljs-comment">//使用队列存储每层的节点</span>
    queue.offer(root);

    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
        size = queue.size(); <span class="hljs-comment">//记录当前层的结点个数</span>
        List&lt;Integer&gt; levelNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-keyword">while</span> (size-- != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();
            levelNodes.add(node.val);
            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);
            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);
        &#125;
        res.add(levelNodes);
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h2 id="层序遍历的扩展">层序遍历的扩展</h2><h3 id="二叉树的层序遍历-ii"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">二叉树的层序遍历 II</a></h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914174423547-2025-9-1417:44:53.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>收集每层的结果时，将其放在list首部即可；或者将层序遍历得到的最终数组反转一下也行。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrderBottom</span><span class="hljs-params">(TreeNode root)</span> &#123;
    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">return</span> res;

    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    queue.offer(root);

    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
        size = queue.size();
        List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
        <span class="hljs-keyword">while</span> (size-- != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();
            level.add(node.val);
            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)
                queue.offer(node.left);
            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)
                queue.offer(node.right);
        &#125;
        res.add(<span class="hljs-number">0</span>,level); <span class="hljs-comment">//每次都放入list首部，即可实现最终自底向上的遍历结果</span>
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h3 id="二叉树的锯齿形层序遍历"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">二叉树的锯齿形层序遍历</a></h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914175431295-2025-9-1417:54:31.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>只需在层序遍历的基础上，知道当前层是第几层，奇数层收集时，每次加入到列表尾部；偶数层收集时，加入到列表头部。注意，此时收集每层遍历结果时要使用<code>LinkedList</code>，方便在列表首尾进行操作。</p><p>或者奇数层保持不变，偶数层将收集的结点逆置后加入结果。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">zigzagLevelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;
    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;

    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, level = <span class="hljs-number">1</span>;
    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    queue.offer(root);
    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
        size = queue.size();
        LinkedList&lt;Integer&gt; levelNodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
        <span class="hljs-keyword">while</span>(size-- != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();
            <span class="hljs-keyword">if</span> (level % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//偶数层每次加入到列表头部</span>
                levelNodes.addFirst(node.val);
            &#125;<span class="hljs-keyword">else</span> &#123;
                levelNodes.addLast(node.val);
            &#125;

            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);
            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);
        &#125;
        res.add(levelNodes);
        level++; <span class="hljs-comment">//层数+1</span>
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h3 id="找树左下角的值"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">找树左下角的值</a></h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914182000841-2025-9-1418:20:01.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：</p><ol type="1"><li>利用层序遍历，当收集到最后一层的结果时，返回当前层第一个结点。</li><li>将层序遍历顺序改为==从右到左==遍历，最后一个出列的结点即为所求。</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findBottomLeftValue</span><span class="hljs-params">(TreeNode root)</span> &#123;
    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root.val;
    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> root;
    queue.offer(root);
    <span class="hljs-keyword">while</span>(!queue.isEmpty()) &#123;
        node = queue.poll();
        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) <span class="hljs-comment">//先右</span>
            queue.offer(node.right);
        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) <span class="hljs-comment">//后左</span>
            queue.offer(node.left);
    &#125;
    <span class="hljs-keyword">return</span> node.val;
&#125;</code></pre></div><h3 id="二叉树的右视图"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">二叉树的右视图</a></h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914182339643-2025-9-1418:23:40.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：利用层序遍历，每层遍历顺序为从左到右，记录并收集每层最后一个结点即可。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rightSideView</span><span class="hljs-params">(TreeNode root)</span> &#123;
    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">return</span> res;
    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    queue.offer(root);
    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
        size = queue.size();
        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">while</span> (size-- != <span class="hljs-number">0</span>) &#123;
            node = queue.poll();
            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);
            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);
        &#125;
        res.add(node.val); <span class="hljs-comment">//收集每层最后一个节点的值</span>
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h3 id="填充每个节点的下一个右侧节点指针-ii"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">填充每个节点的下一个右侧节点指针 II</a></h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914182924491-2025-9-1418:29:27.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：采用层序遍历，遍历每层的结点的同时连接结点的next指针域，可以像链表那样使用虚拟头结点便利结点的连接。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root;

    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    Queue&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    queue.offer(root);
    <span class="hljs-type">Node</span> <span class="hljs-variable">headNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(); <span class="hljs-comment">//头节点</span>
    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
        size = queue.size();
        <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> headNode; <span class="hljs-comment">//每层开始时，pre指向头节点</span>
        <span class="hljs-keyword">while</span> (size-- != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();
            pre.next = node;
            pre = node;
            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);
            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> root;
&#125;</code></pre></div><h3 id="二叉树的最大深度"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">二叉树的最大深度</a></h3><p><strong>最大深度</strong> 是从根节点到最远叶子节点的最长路径上的节点数量。</p><div class="note note-primary"><p>二叉树节点的<strong>深度</strong>：指<u>从根节点到该节点</u>的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）</p><p>二叉树节点的<strong>高度</strong>：指<u>从该节点到叶子节点</u>的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）</p><p><strong>用前序求的就是深度（从上往下累加），用后序求的是高度（从下往上累加）。</strong></p></div><p>思路：当前二叉树的最大深度即为这棵二叉树整体的高度，利用<u>层序遍历</u>或<u>后序遍历</u>求二叉树高度。</p><p>使用层序遍历时，每进入一层就深度加一，处理完所有层节点也就得到了树的高度。</p><p>使用后续遍历时，先求左子树深度，再求右子树深度，最后取左右深度中的最大值再加一，就是当前节点为根节点的树的高度。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//层序求树的高度</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    queue.offer(root);
    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, deepth = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
        size = queue.size();
        <span class="hljs-keyword">while</span> (size-- != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();
            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)
                queue.offer(node.left);
            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)
                queue.offer(node.right);
        &#125;
        deepth++; <span class="hljs-comment">//高度+1</span>
    &#125;
    <span class="hljs-keyword">return</span> deepth;
&#125;

<span class="hljs-comment">//后序求树的高度</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-type">int</span> <span class="hljs-variable">leftDepth</span> <span class="hljs-operator">=</span> maxDepth(root.left);
    <span class="hljs-type">int</span> <span class="hljs-variable">rightDepth</span> <span class="hljs-operator">=</span> maxDepth(root.right);
    <span class="hljs-comment">//当前树的高度等于左右子树的最大高度+1</span>
    <span class="hljs-keyword">return</span> Math.max(leftDepth, rightDepth) + <span class="hljs-number">1</span>;
&#125;</code></pre></div><h3 id="二叉树的最小深度"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a></h3><p><strong>最小深度</strong>是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>思路：利用<u>层序遍历</u>或<u>后序遍历</u>求二叉树最小深度。</p><p>使用层序遍历，记录每层的深度，当某层中有结点的左右孩子均为空时，找到了最近的叶子结点，返回此时的深度即可。</p><p>使用后序遍历时，当一个节点右子树为空，左子树不为空时，则以该节点为根的子树的最小深度为左子树的深度+1，右不为空而左为空的情况亦同（当前节点不是叶子节点，而是只有一个孩子的节点，最近的叶子节点在不为空的那棵子树中）；当左右子树都不为空，则返回左右子树深度的最小值+1.</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    queue.offer(root);
    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, deepth = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
        size = queue.size();
        deepth ++;
        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">while</span> (size-- != <span class="hljs-number">0</span>) &#123;
            node = queue.poll();
            <span class="hljs-comment">//如果当前节点的左右孩子都为空，直接返回最小深度</span>
            <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>) 
                <span class="hljs-keyword">return</span> deepth;
            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) queue.offer(node.left);
            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) queue.offer(node.right);
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> deepth;
&#125;

<span class="hljs-comment">//后序求最小深度：关键之处在于正确处理单子树为空的情况</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-type">int</span> <span class="hljs-variable">leftDepth</span> <span class="hljs-operator">=</span> minDepth(root.left);
    <span class="hljs-type">int</span> <span class="hljs-variable">rightDepth</span> <span class="hljs-operator">=</span> minDepth(root.right);
    <span class="hljs-comment">//如果左子树为空，最小深度等于右子树深度+1</span>
    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">return</span> rightDepth + <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-comment">//如果右子树为空，最小深度等于左子树深度+1</span>
    <span class="hljs-keyword">if</span> (root.right == <span class="hljs-literal">null</span>) &#123;
        <span class="hljs-keyword">return</span> leftDepth + <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-comment">// 如果左右子树都存在，最小深度等于左右子树深度的较小值+1</span>
    <span class="hljs-keyword">return</span> Math.min(leftDepth, rightDepth) + <span class="hljs-number">1</span>;
&#125;</code></pre></div><h2 id="翻转二叉树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">翻转二叉树</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914212843799-2025-9-1421:29:14.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：<strong>只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果</strong>。关键在于遍历顺序，遍历的过程中去翻转每一个节点的左右孩子就可以达到整体翻转的效果。</p><p>这道题目使用前序遍历、后序遍历、层序遍历都可以，唯独中序遍历不行。</p><div class="note note-info"><p>当使用中序遍历时：</p><ol type="1"><li>首先递归遍历左子树。</li><li>然后访问当前节点并交换其左右子树。</li><li>最后递归遍历右子树。</li></ol><p>但问题在于，交换左右子树后，当前节点的右子树实际上变成了原来的左子树（刚刚被遍历过的子树）。这意味着接下来要遍历的“右子树”其实是已经遍历过的左子树，从而导致原来的左子树被再次遍历。</p></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;
    preOrderInvert(root);
    <span class="hljs-keyword">return</span> root;
&#125;
<span class="hljs-comment">//先序遍历：先交换左右孩子结点，然后反转左子树、右子树</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrderInvert</span><span class="hljs-params">(TreeNode node)</span> &#123;
    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-comment">//交换当前结点的左右孩子</span>
    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> node.left;
    node.left = node.right;
    node.right = temp;
    
    preOrderInvert(node.left); <span class="hljs-comment">//左</span>
    preOrderInvert(node.right); <span class="hljs-comment">//右</span>
&#125;

<span class="hljs-comment">//迭代法略（使用先序遍历的迭代法或者层序遍历）</span></code></pre></div><h2 id="同时遍历两棵树">同时遍历两棵树</h2><p>同时遍历两棵二叉树是指同步地访问两棵树中的对应节点，通常用于比较两棵树的结构或值是否相同，解决二叉树比较、合并或同步操作的问题。</p><p>采用递归方式时与一棵树的遍历逻辑是一样的，只要在递归函数中传入两棵树的根节点即可实现同步遍历。</p><p>采用迭代遍历时，需要将要比较的节点成对地放入队列或栈中，再每次成对的取出来进行比较实现同步遍历。</p><p>由于两棵树的结构不同，可能会遇到在某位置一棵树的节点为空，一棵树的结点不为空的情况。此时就要根据题目要求处理，例如：</p><ul><li>在对称二叉树问题中，要同时遍历左右两棵子树。若遇到一个为空，一个不为空的情况，说明不是对称的，返回false。</li><li>在合并二叉树问题中，要同时遍历两棵树。若一个为空，一个不为空，就返回不为空的那个节点作为合并的结果，将它插入到新的树中。</li></ul><h3 id="对称二叉树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a></h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914214110999-2025-9-1421:41:11.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：判断二叉树是否对称，要比较的是根节点的左子树与右子树是不是可以<strong>相互翻转</strong>的。对于是否是可以相互翻转的，需要比较的是<strong>两个子树的里侧和外侧的元素是否相等</strong>。在这个问题中其实要比较的是两棵树（这两棵树是根结点的左右子树），在递归遍历过程中需要同时遍历这两棵树。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250914223242109-2025-9-1422:32:51.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>因为要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等，所以只能用<strong>后序遍历</strong>。</p><div class="note note-primary"><p>像这种需要根据左右子树的处理结果来判断根节点情况的时候，只能采用<strong>后序遍历</strong>。先处理左右子树再处理根节点，收集左右子树的信息向上一层返回进行处理。</p></div><p>递归三部曲：</p><ol type="1"><li><p>确定递归函数的参数和返回值</p><p>因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。</p><p>返回值是bool类型。</p><div class="code-wrapper"><pre><code class="hljs java">bool <span class="hljs-title function_">compare</span><span class="hljs-params">(TreeNode left, TreeNode right)</span></code></pre></div></li><li><p>确定返回条件</p><p>首先要排除两个结点可能为空的情况，防止比较结点的值时，出现空指针异常。</p><p>具体情况如下：</p><ul><li><p>左右结点都为空，对称，返回true</p></li><li><p>左节点为空，右节点不为空，不对称，返回false</p></li><li><p>左节点不为空，有节点为空，不对称，返回false</p></li><li><p>左右节点都不为空，但值不相等，不对称，返回false</p></li></ul><p>最后，当左右节点都不为空且值相等时，需要递归判断以这两个结点为根的子树是否能相互翻转</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left.val != right.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

<span class="hljs-comment">//等价的判断逻辑</span>
<span class="hljs-comment">//左节点为空，右节点为空，说明是对称的</span>
<span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
<span class="hljs-comment">//左右一个节点不为空，或者都不为空但数值不同，返回false</span>
<span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> || right == <span class="hljs-literal">null</span> || left.val != right.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</code></pre></div></li><li><p>单层处理逻辑</p><p>此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p><ul><li>判断二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子</li><li>判断二叉树内侧是否对称：传入的是左节点的右孩子，右节点的左孩子</li><li>如果内侧和外侧都对称，则返回true，否则返回false</li></ul></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;
    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) 
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">return</span> compare(root.left, root.right);
&#125;

<span class="hljs-comment">//判断左右子树是否可以翻转</span>
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;
    <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> || right == <span class="hljs-literal">null</span> || left.val != right.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
 	<span class="hljs-comment">//后序遍历，先收集左右孩子的信息，再向上返回进行处理</span>
    <span class="hljs-type">boolean</span> <span class="hljs-variable">outside</span> <span class="hljs-operator">=</span> compare(left.left, right.right);
    <span class="hljs-type">boolean</span> <span class="hljs-variable">inside</span> <span class="hljs-operator">=</span> compare(left.right, right.left);
    <span class="hljs-keyword">return</span> outside &amp;&amp; inside;
&#125;</code></pre></div><hr><p>迭代法</p><p>思路：<strong>同时遍历左右子树，把要比较的元素顺序放进一个容器，然后成对成对的取出来进行比较</strong>。</p><p>比如，使用队列进行处理，首先将根节点的左右孩子依次入队，再成对取出判断，若两节点都不为空且值相等时，再将左节点的左孩子和右节点的右孩子、左节点的右孩子和右节点的左孩子依次入队，下次循环时再次成对取出判断，以此类推。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/101.对称二叉树-2025-9-1422:54:24.gif" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	
    <span class="hljs-comment">//注意：此处的队列实现不能用ArrayDeque，它不能存储null值，而左右孩子可能为null</span>
    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    queue.offer(root.left);
    queue.offer(root.right);

    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">leftNode</span> <span class="hljs-operator">=</span> queue.poll();
        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">rightNode</span> <span class="hljs-operator">=</span> queue.poll();
        <span class="hljs-keyword">if</span> (leftNode == <span class="hljs-literal">null</span> &amp;&amp; rightNode == <span class="hljs-literal">null</span>) 
            <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">if</span> (leftNode == <span class="hljs-literal">null</span> || rightNode == <span class="hljs-literal">null</span> || leftNode.val != rightNode.val)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-comment">//外侧节点成对入队</span>
        queue.offer(leftNode.left);
        queue.offer(rightNode.right);
        <span class="hljs-comment">//内侧节点成对入队</span>
        queue.offer(leftNode.right);
        queue.offer(rightNode.left);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div><p>此外也可以使用层序遍历，再判断每层是否是回文（需要将null保存起来）</p><h3 id="相同的树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/">相同的树</a></h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250915091142047-2025-9-1509:11:51.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>判断s和t两个树是否<strong>相等</strong>的三个条件是<strong>与</strong>的关系，即：</p><ol type="1"><li>s和t的根节点值相等；</li><li>并且，s 的左子树和 t 的左子树相等；</li><li>并且，s 的右子树和 t 的右子树相等。</li></ol><p>思路：与上题思路完全相同，采用后序遍历方式，判断相同位置的节点是否都相同，返回结果</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSameTree</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span> || p.val != q.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	
    <span class="hljs-comment">//比较两棵树的左孩子是否相同</span>
    <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> isSameTree(p.left, q.left);
    <span class="hljs-comment">//比较两棵树的右孩子是否相同</span>
    <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> isSameTree(p.right, q.right);
    <span class="hljs-keyword">return</span> left &amp;&amp; right;
&#125;</code></pre></div><h3 id="另一棵树的子树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/">另一棵树的子树</a></h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250915091256687-2025-9-1509:12:57.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>判断 t 是否为 s 的<strong>子树</strong>的三个条件是<strong>或</strong>的关系，即：</p><ol type="1"><li>当前两棵树相等；</li><li>或者，t 是 s 的左子树；</li><li>或者，t 是 s 的右子树。</li></ol><p>本题采用先序遍历的方式，递归三部曲：</p><ol type="1"><li><p>确定参数和返回值</p><p>要比较的是两棵树，因此参数是两棵树的根节点；返回值为布尔类型。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubtree</span><span class="hljs-params">(TreeNode root, TreeNode subRoot)</span></code></pre></div></li><li><p>确定终止条件</p><p>如果给定的两棵树都是空树，也算作一棵是另一棵的子树，返回true；</p><p>如果一棵为空，另一棵不为空，则不是子树，返回false</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> &amp;&amp; subRoot == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || subRoot == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</code></pre></div></li><li><p>确定单层递归的逻辑</p><p>首先检查当前树<code>root</code>是否与 <code>subRoot</code> 相同；如果当前树不匹配，则递归检查 <code>root</code> 的左子树是否包含 <code>subRoot</code>；如果左子树也不包含，则递归检查 <code>root</code> 的右子树是否包含 <code>subRoot</code>。</p><p>最终若满足一条，则<code>subRoot</code>是<code>root</code>的子树。</p></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubtree</span><span class="hljs-params">(TreeNode root, TreeNode subRoot)</span> &#123;
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> &amp;&amp; subRoot == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> || subRoot == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> isSameTree(root, subRoot) <span class="hljs-comment">//判断两棵树是否相等</span>
            	|| isSubtree(root.left, subRoot) <span class="hljs-comment">//递归判断左子树是否包含</span>
            	|| isSubtree(root.right, subRoot); <span class="hljs-comment">//递归判断右子树是否包含</span>
    &#125;
	
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSameTree</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;
        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || q == <span class="hljs-literal">null</span> || p.val != q.val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> isSameTree(p.left, q.left) 
            	&amp;&amp; isSameTree(p.right, q.right);
    &#125;
&#125;</code></pre></div><h3 id="合并二叉树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">合并二叉树</a></h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250915095258189-2025-9-1509:53:07.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>思路：采用<strong>先序遍历</strong>方式同时遍历两颗树，当遍历到的两个节点：</p><ul><li>一个为空一个不为空时，它们合并的结果就是不为空的节点</li><li>两个都为空时，合并的结果就是空节点</li><li>两个都不为空时，新节点的值为这两个节点之和</li></ul><p>可以重复利用root1这棵树，将root2合并到root1；也可以不改变原来树的结构，在合并过程中创建新节点记录合并结果。</p><p>也可以采用<strong>迭代方式</strong>，参考之前对称二叉树的迭代法，将要合并的两个节点成对地存入栈或队列中，在下次迭代中再成对地取出进行合并。</p><hr><p>递归三部曲：</p><ol type="1"><li><p>确定参数和返回值</p><p>参数就是要合并的两棵树的根节点，最终返回合并后新树的根节点，返回类型是<code>TreeNode</code></p><div class="code-wrapper"><pre><code class="hljs java">TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span></code></pre></div></li><li><p>确定终止条件</p><p>当遍历到的两个节点一个为空，另一个不为空时，返回不为空的节点作为合并结果</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//其中包含了两个都为null时返回null的情况</span>
<span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> roo2;
<span class="hljs-keyword">if</span> (root2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root1;</code></pre></div></li><li><p>确定单层的处理逻辑</p><p>合并两个不为空的节点，再递归的合并左子树和右子树，最终返回当前的根节点。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建一棵新的树而不改变给定树的结构</span>
<span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(root1.val + root2.val); 
root.left = mergeTrees(root1.left, root2.left); <span class="hljs-comment">//合并左子树，将合并结果插入到原来位置</span>
root.right = mergeTrees(root1.right, root2.right);<span class="hljs-comment">//合并右子树，将合并结果插入到原来位置</span>
<span class="hljs-keyword">return</span> root;

<span class="hljs-comment">//或者，重复利用root1</span>
root1.val += root2.val; <span class="hljs-comment">//中</span>
root1.left = mergeTrees(root1.left, root2.left); <span class="hljs-comment">//左</span>
root2.left = mergeTrees(root1.right, root2.left); <span class="hljs-comment">//右</span>
<span class="hljs-keyword">return</span> root1;</code></pre></div></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">mergeTrees</span><span class="hljs-params">(TreeNode root1, TreeNode root2)</span> &#123;
    <span class="hljs-keyword">if</span> (root1 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root2;
    <span class="hljs-keyword">if</span> (root2 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> root1; <span class="hljs-comment">//其中包含了两个都为null时返回null的情况</span>

    <span class="hljs-comment">//创建一棵新的树而不改变给定树的结构</span>
    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(root1.val + root2.val); 
    root.left = mergeTrees(root1.left, root2.left);
    root.right = mergeTrees(root1.right, root2.right);

    <span class="hljs-keyword">return</span> root;
&#125;</code></pre></div><h2 id="完全二叉树的节点个数"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">完全二叉树的节点个数</a></h2><p>题目描述：给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p>对于普通的二叉树可以利用各种遍历方法，在遍历的过程中统计结点数量即可。对于完全二叉树，有其自己的特性，不必通过遍历全部的结点来得到总结点数。</p><p>完全二叉树只有两种情况：一是满二叉树，二是最后一层叶子结点没有满</p><p>对于情况一：利用公式： <span class="math inline">\(2^{树的深度} -1\)</span>计算，此时根节点深度为1</p><p>对于情况二，分别递归左孩子和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250920111734067-2025-9-2011:17:43.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>那么在<strong>完全二叉树中</strong>如何判断子树是满二叉树：只需记录从根节点开始一直沿左孩子到叶子结点的深度 <span class="math inline">\(leftDepth\)</span> 和从根节点开始一直沿右孩子到叶子结点的深度 <span class="math inline">\(rightDepth\)</span>。</p><ul><li>若 <span class="math inline">\(leftDepth == rightDepth\)</span>，则是满二叉树，利用公式得出此子树的结点数 <span class="math inline">\(2^{leftDepth} - 1\)</span>，如此<strong>只需遍历两侧的结点即可得到该子树的总结点数，而不用遍历无用的内侧节点。</strong></li><li>否则，继续递归判断以左右孩子为根的子树是否是满二叉树，得到左右子树的结点数再加1即是当前子树的总结点数。</li></ul><p>由于要先计算左右子树的节点数，最后得到当前树的总节点数，故采用后序遍历。</p><hr><p>递归三部曲：</p><ol type="1"><li><p>确定递归函数的参数和返回值</p><p>传入的参数是当前树的根节点，最终返回树中的节点总数</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span></code></pre></div></li><li><p>确定终止条件</p><p>若根节点为null，则为空树，总节点数为 0</p><p>若当前树是满二叉树，则总节点数为<span class="math inline">\(2^{树的深度} -1\)</span></p></li><li><p>单层递归逻辑</p><p>若当前子树不是满二叉树，则继续判断左右孩子的子树情况，总结点数为左右子树的结点之和再加一</p></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countNodes</span><span class="hljs-params">(TreeNode root)</span> &#123;
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-comment">//判断当前子树是否为满二叉树，若是则返回子树的总节点数</span>
    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">leftChild</span> <span class="hljs-operator">=</span> root.left;
    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">rightChild</span> <span class="hljs-operator">=</span> root.right;
    <span class="hljs-type">int</span> <span class="hljs-variable">leftDepth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, rightDepth = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (leftChild != <span class="hljs-literal">null</span>) &#123;
        leftDepth++;
        leftChild = leftChild.left;
    &#125;
    <span class="hljs-keyword">while</span> (rightChild != <span class="hljs-literal">null</span>) &#123;
        rightDepth++;
        rightChild = rightChild.right;
    &#125;

    <span class="hljs-keyword">if</span> (leftDepth == rightDepth)
        <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> &lt;&lt; leftDepth) - <span class="hljs-number">1</span>;
	
    <span class="hljs-comment">// 当前不是满二叉树，则递归处理统计左右子树的节点数，总结点数为左右子树的结点之和再加一</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">leftNums</span> <span class="hljs-operator">=</span> countNodes(root.left);
    <span class="hljs-type">int</span> <span class="hljs-variable">rightNums</span> <span class="hljs-operator">=</span> countNodes(root.right);
    <span class="hljs-keyword">return</span> leftNums + rightNums + <span class="hljs-number">1</span>;
&#125;</code></pre></div><h2 id="二叉树的所有路径"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">二叉树的所有路径</a></h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250920182241500-2025-9-2018:22:43.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>本题要求从根节点到叶子的路径，所以要用<strong>前序遍历</strong>，这样才方便从父节点指向孩子节点，找到对应的路径。</p><p>此外，由于要找全部路径所以涉及到回溯。当从一个节点进入它的左子树收集完路径后，要回溯到当前节点，再转向收集右子树中的路径，这样才能收集到全部路径。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250920211136576-2025-9-2021:11:42.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>在传统回溯中，path为记录路径的可变列表，每处理完一个节点就从path中收集删除记录进行回溯。</p><p>也可以在每个递归调用中创建新的字符串路径path来避免显式回溯。具体来说，在每次递归调用时，使用<code>StringBuilder</code>来构建新path的字符串，然后将这个新字符串传递给下一层递归，左右子树的递归调用接收的是这个新创建的路径副本。当递归返回时，当前层的<code>path</code>变量保持不变，不需要撤销操作。（<strong>通过值传递的方式避免显式回溯</strong>）这种方式下每次递归调用都创建新的字符串对象，字符串拼接操作可能较慢，特别是对于深度较大的树</p><p>递归三部曲：</p><ol type="1"><li><p>确定递归函数的参数和返回值</p><p>需要传入根节点、路径记录path和收集结果的res，不需要返回值。</p><p>采用传统回溯时，path为可变列表；采用值传递方式时，path为字符串</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">getPath</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; path, List&lt;String&gt; res)</span> <span class="hljs-comment">//传统回溯</span>
<span class="hljs-keyword">void</span> <span class="hljs-title function_">getPath</span><span class="hljs-params">(TreeNode root, List&lt;String&gt; res, String path)</span> <span class="hljs-comment">//值传递方式</span></code></pre></div></li><li><p>确定终止条件</p><p>当传入的节点为空时，是棵空树，直接返回。</p><p>当传入的节点是叶子节点时，收集路径。</p></li><li><p>确定单层递归逻辑</p><p>采用先序遍历，将当前根节点加入到path中，再递归地处理左子树和右子树。</p></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//值传递方式避免显式回溯</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getPath</span><span class="hljs-params">(TreeNode root, List&lt;String&gt; res, String path)</span> &#123;
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;
        res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(path).append(root.val).toString());
    &#125;

    path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(path).append(root.val).append(<span class="hljs-string">&quot;-&gt;&quot;</span>).toString();
    getPath(root.left, res, path);
    getPath(root.right, res, path);
&#125;
<span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;
    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> res;
    getPath(root, res, <span class="hljs-string">&quot;&quot;</span>);
    <span class="hljs-keyword">return</span> res;

&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//传统回溯方式</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getPath</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; path, List&lt;String&gt; res)</span> &#123;

    path.add(root.val); <span class="hljs-comment">//中，放在终止条件之前，确保叶子结点能加入到路径中</span>

    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//终止条件,遇到叶子结点</span>
        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; path.size() - <span class="hljs-number">1</span>; i++) &#123;
            sb.append(path.get(i)+<span class="hljs-string">&quot;-&gt;&quot;</span>);
        &#125;
        sb.append(path.get(path.size() - <span class="hljs-number">1</span>)); <span class="hljs-comment">//记录最后一个结点</span>
        res.add(sb.toString()); <span class="hljs-comment">//收集该条路径</span>
        <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;
        getPath(root.left, path, res);
        <span class="hljs-comment">//回溯</span>
        path.remove(path.size() - <span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;
        getPath(root.right, path, res);
        <span class="hljs-comment">//回溯</span>
        path.remove(path.size() - <span class="hljs-number">1</span>);
    &#125;
&#125;

<span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;
    List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();
    getPath(root,path, res);
    <span class="hljs-keyword">return</span> res;
&#125;</code></pre></div><h2 id="验证平衡二叉树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">验证平衡二叉树</a></h2><p>题目描述：给定一个二叉树，判断它是否是 平衡二叉树（AVL树）。</p><p>思路：对于给定的二叉树，若它的左子树是平衡二叉树，右子树也是平衡二叉树，且左右子树的高度差不超过1，则这棵树是平衡二叉树，有一个条件不成立，则不是AVL树。</p><p>采用<strong>后序遍历</strong>方式，先得到左右子树的高度，再判断是否满足平衡二叉数的定义。若是平衡二叉树，则返回当前树的高度，否则返回-1，表示不是平衡二叉树。</p><p>递归三部曲：</p><ol type="1"><li><p>确定递归函数的参数和返回值</p><p>参数是树的根节点，返回值是该树的高度，若不是平衡二叉树返回-1.</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// -1表示该树已经不是平衡二叉树了，否则返回值是以该节点为根节点的树的高度</span>
<span class="hljs-type">int</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">(TreeNode root)</span></code></pre></div></li><li><p>确定终止条件</p><p>当传入的节点指针为空时，说明是棵空树，返回高度0</p></li><li><p>确定单层处理逻辑</p><p>采用后序遍历方式，计算当前节点左子树和右子树的高度。</p><p>若左子树或右子树不是平衡二叉树，直接返回-1。</p><p>若左右子树都是AVL树，再判断二者高度相差是否超过1。若是，则返回-1；否则，返回当前树的高度：左右子树高度的最大值+1.</p></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;
    <span class="hljs-keyword">if</span> (getHeight(root) == -<span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getHeight</span><span class="hljs-params">(TreeNode root)</span> &#123;
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-type">int</span> <span class="hljs-variable">leftHeight</span> <span class="hljs-operator">=</span> getHeight(root.left);
    <span class="hljs-keyword">if</span> (leftHeight == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//左子树不是AVL树</span>

    <span class="hljs-type">int</span> <span class="hljs-variable">rightHeight</span> <span class="hljs-operator">=</span> getHeight(root.right);
    <span class="hljs-keyword">if</span> (rightHeight == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//右子树不是AVL树</span>

    <span class="hljs-keyword">if</span> (Math.abs(leftHeight - rightHeight) &gt; <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">//左右子树不平衡</span>
    <span class="hljs-comment">//当时树是AVL树，返回高度</span>
    <span class="hljs-keyword">return</span> Math.max(leftHeight, rightHeight) + <span class="hljs-number">1</span>; 
&#125;</code></pre></div><hr><p>进阶：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/k-th-largest-perfect-subtree-size-in-binary-tree/">第 K 大的完美二叉子树的大小</a></p><h2 id="验证二叉搜索树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a></h2><p>题目描述：给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树（BST树）。</p><p>思路：BST树一个重要的性质是它<strong>中序遍历的结果是递增的</strong>。在遍历过程中检查，上一个遍历到的结点的值 与当前结点的值是否逆序，若逆序则不是二叉搜索树。</p><p>递归三部曲：</p><ul><li><p>确定递归函数的参数及返回值</p><p>需要定义一个<strong>全局变量</strong><code>preVal</code>记录中序序列中当前节点的前一个节点的值。由于题目中节点的值可以取到int类型的最小值，所以<code>preVal</code>应该取更小的值以保证第一次比较的正确，此处取long的最小值。</p><p>递归函数传入的参数是根节点，返回值为布尔类型</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">preValue</span> <span class="hljs-operator">=</span> Long.MIN_VALUE; 
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span>&#123;&#125;</code></pre></div></li><li><p>确定终止条件</p><p>当传入的根节点为空时，说明为空树，空树也是BST树，返回true。</p></li><li><p>确定单层处理逻辑</p><p>采用中序遍历，比较中序序列中前驱节点的值与当前节点值的大小，若前者更大，则不是BST树；否则，更新<code>preVal</code>为当前节点的值。</p><p>若左子树和右子树中的节点都遵循这种关系，则整棵树是二叉排序树。</p></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">preValue</span> <span class="hljs-operator">=</span> Long.MIN_VALUE; 
<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLeft</span> <span class="hljs-operator">=</span> isValidBST(root.left);
	
    <span class="hljs-comment">//也可以在这先判断左子树是否是BST树，若不是则直接返回。函数最终只需要返回右子树的判断结果即可</span>
    <span class="hljs-comment">//判断节点关系</span>
    <span class="hljs-keyword">if</span> (root.val &lt;= preValue) 
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    preValue = root.val;

    <span class="hljs-type">boolean</span> <span class="hljs-variable">isRight</span> <span class="hljs-operator">=</span> isValidBST(root.right);
	
    <span class="hljs-keyword">return</span> isLeft &amp;&amp; isRight;
&#125;</code></pre></div><hr><p>使用迭代法，修改<u>非递归</u>中序遍历：使用一个变量preValue记录上一个遍历结点的值。将出栈结点的值和preValue比较，若不是升序，则返回false；否则修改preValue的值为当前出栈结点的值。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;
    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;TreeNode&gt;();
    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;
    <span class="hljs-type">long</span> <span class="hljs-variable">preValue</span> <span class="hljs-operator">=</span> Long.MIN_VALUE;
    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> || !stack.empty()) &#123;
        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>) &#123;
            stack.push(p);
            p = p.left;
        &#125; <span class="hljs-keyword">else</span> &#123;
            p = stack.pop();
            <span class="hljs-keyword">if</span>(preValue &gt;= p.val)
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">else</span>
                preValue = p.val;
            p = p.right;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div><h2 id="验证完全二叉树"><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">验证完全二叉树</a></h2><p>题目描述：给你一棵二叉树的根节点 <code>root</code> ，请你判断这棵树是否是一棵 <strong>完全二叉树</strong> 。</p><p>完全二叉树的重要性质：</p><ul><li>最多存在一个度为1 的结点，且该结点只有左孩子而无右孩子</li><li>只有最后两层可能有叶结点</li></ul><p>思路：在<strong>层序遍历</strong>过程中，若碰到一个结点有右无左，则不是完全二叉树。在遇到第一个不双全结点或叶结点后，之后的结点必须是叶结点，否则不是完全二叉树（两个否定条件）。使用一个布尔变量标记是否遇到不双全结点或叶结点。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCompleteTree</span><span class="hljs-params">(TreeNode root)</span> &#123;
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();
    queue.offer(root);
    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLeaf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//判断是否遇到不双全节点</span>

    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;
        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();
        <span class="hljs-comment">//如果有一个结点有右孩子而无左孩子，则不是完全二叉树</span>
        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right != <span class="hljs-literal">null</span>) 
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-comment">//如果已经遇到过不双全结点，且其后不全是是叶子节点，则不是完全二叉树</span>
        <span class="hljs-keyword">if</span> (isLeaf &amp;&amp; !(node.left == <span class="hljs-literal">null</span> &amp;&amp; node.right == <span class="hljs-literal">null</span>))
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-comment">//遇到不双全结点    </span>
        <span class="hljs-keyword">if</span> (node.left == <span class="hljs-literal">null</span> || node.right == <span class="hljs-literal">null</span>) 
            isLeaf = <span class="hljs-literal">true</span>;

        <span class="hljs-comment">//左右孩子入队</span>
        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>)
            queue.offer(node.left);
        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>)
            queue.offer(node.right);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;</code></pre></div><hr><p>进阶：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/water-and-jug-problem/">水壶问题</a></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/leetcode/" class="category-chain-item">leetcode</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>六、二叉树</div><div>https://catpaws.top/f47c7c7b/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年8月4日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/700d279/" title="五、栈与队列"><span class="hidden-mobile">五、栈与队列</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://catpaws.top/blog-resource/twikoo1.6.42/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本站由<img src="/img/upyun_logo.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="width:auto;height:auto">提供CDN加速/云存储服务</a></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备2025059828号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61032302000087" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="police-icon"> <span>陕公网安备61032302000087号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//catpaws.top/blog-resource/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="//catpaws.top/blog-resource/js/loader.js"></script><script src="//catpaws.top/blog-resource/js/blurpicload.js"></script><script src="//catpaws.top/blog-resource/js/axios.min.js"></script><script src="/js/boot.js"></script><!DOCTYPE html><html><head><style>#matechat-iframe-container{position:fixed;top:0;left:0;width:100%;height:100%;z-index:10000;opacity:0;visibility:hidden;transition:opacity .3s ease,visibility .3s ease}#matechat-iframe-container.active{opacity:1;visibility:visible}.matechat-iframe{width:100%;height:100%;border:none;background:#fff}#matechat-iframe-container.active .matechat-close-btn{opacity:1}body.matechat-open{overflow:hidden}</style></head><body><div id="matechat-iframe-container"><iframe class="matechat-iframe" src="https://chat.catpaws.top" allow="microphone" title="芙芙来帮你"></iframe></div><script>document.addEventListener("DOMContentLoaded",(function(){const e=document.getElementById("oml2d-stage"),t=document.getElementById("matechat-iframe-container");function n(){t.classList.remove("active"),document.body.classList.remove("matechat-open")}e?t?(e.addEventListener("click",(function(){t.classList.add("active"),document.body.classList.add("matechat-open")})),document.addEventListener("keydown",(function(e){"Escape"===e.key&&n()})),window.addEventListener("message",(function(e){"closeMateChat"!==e.data&&"close"!==e.data.type||n()})),t.addEventListener("click",(function(e){e.target===this&&n()}))):console.error("matechat-iframe-container 元素未找到"):console.error("oml2d-stage 元素未找到")}))</script><script data-pjax src="https://catpaws.top/blog-resource/live2d/index.min.js"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"https://catpaws.top/blog-resource/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"}}})</script></body></html><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>