<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="stylesheet" href="https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkai/dist/LXGWWenKai-Regular/result.css"><link rel="apple-touch-icon" sizes="76x76" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><link rel="icon" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="一、简介  什么是Docker Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口，更重要的是容器性能开销极低 为什么用Docker 1、 简化程"><meta property="og:type" content="article"><meta property="og:title" content="Docker"><meta property="og:url" content="https://catpaws.top/f5f9fa9b/index.html"><meta property="og:site_name" content="猫爪在上の书桌"><meta property="og:description" content="一、简介  什么是Docker Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口，更重要的是容器性能开销极低 为什么用Docker 1、 简化程"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cos.easydoc.net/46901064/files/kv7rlicu.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250702160442687-2025-7-216:04:52.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250702161202518-2025-7-216:12:03.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250702162453088-2025-7-216:24:54.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250702172922731-2025-7-217:29:24.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250702180123423-2025-7-218:02:41.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250703100606136-2025-7-310:06:19.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250703101328143-2025-7-310:13:28.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250703105403083-2025-7-310:54:04.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250706102348480-2025-7-610:23:59.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250703194021801-2025-7-319:41:01.png"><meta property="og:image" content="c:%5CUsers%5C86152%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250705173605638.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250705192021485-2025-7-519:20:41.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250705192118436-2025-7-519:21:20.png"><meta property="article:published_time" content="2025-07-02T07:11:52.000Z"><meta property="article:modified_time" content="2025-07-25T03:39:50.008Z"><meta property="article:author" content="猫爪在上"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://cos.easydoc.net/46901064/files/kv7rlicu.png"><title>Docker - 猫爪在上の书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/font.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/poem.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/cursor.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/loader.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/twikoo_beautify.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/indeximg-hover.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/wave-1.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/blurpicload.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/reward/iconfont.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/switch.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"https://catpaws.top/blog-resource/imgs/transparent.svg",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://leancloud.catpaws.top",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loader-container"><div class="loader"><div class="wrapper"><div class="catContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 733 673" class="catbody"><path fill="#212121" d="M111.002 139.5C270.502 -24.5001 471.503 2.4997 621.002 139.5C770.501 276.5 768.504 627.5 621.002 649.5C473.5 671.5 246 687.5 111.002 649.5C-23.9964 611.5 -48.4982 303.5 111.002 139.5Z"></path><path fill="#212121" d="M184 9L270.603 159H97.3975L184 9Z"></path><path fill="#212121" d="M541 0L627.603 150H454.397L541 0Z"></path></svg> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 158 564" class="tail"><path fill="#191919" d="M5.97602 76.066C-11.1099 41.6747 12.9018 0 51.3036 0V0C71.5336 0 89.8636 12.2558 97.2565 31.0866C173.697 225.792 180.478 345.852 97.0691 536.666C89.7636 553.378 73.0672 564 54.8273 564V564C16.9427 564 -5.4224 521.149 13.0712 488.085C90.2225 350.15 87.9612 241.089 5.97602 76.066Z"></path></svg><div class="text"><span class="bigzzz">Z</span> <span class="zzz">Z</span></div></div><div class="wallContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 500 126" class="wall"><line stroke-width="6" stroke="#7C7C7C" y2="3" x2="450" y1="3" x1="50"></line><line stroke-width="6" stroke="#7C7C7C" y2="85" x2="400" y1="85" x1="100"></line><line stroke-width="6" stroke="#7C7C7C" y2="122" x2="375" y1="122" x1="125"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="500" y1="43"></line><line stroke-width="6" stroke="#7C7C7C" y2="1.99391" x2="115.5" y1="43.0061" x1="115.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00002" x2="189" y1="43.0122" x1="189"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00612" x2="262.5" y1="43.0183" x1="262.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01222" x2="336" y1="43.0244" x1="336"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01833" x2="409.5" y1="43.0305" x1="409.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="153" y1="84.0122" x1="153"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="228" y1="84.0122" x1="228"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="303" y1="84.0122" x1="303"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="378" y1="84.0122" x1="378"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="192" y1="125.012" x1="192"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="267" y1="125.012" x1="267"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="342" y1="125.012" x1="342"></line></svg></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上の书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>个人主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://catpaws.top/blog-resource/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Docker"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-07-02 15:11" pubdate>2025年7月2日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 13k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 111 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Docker</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年7月25日 中午</p><div class="markdown-body"><meta name="referrer" , content="no-referrer"><h2 id="一简介">一、简介</h2><p><img src="https://cos.easydoc.net/46901064/files/kv7rlicu.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h3 id="什么是docker">什么是Docker</h3><p>Docker 是一个开源的<u>应用容器引擎</u>，基于 <strong>Go</strong> <strong>语言</strong> 并遵从Apache2.0协议开源。</p><p><strong>Docker</strong> <strong>可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的</strong> <strong>Linux机器上，也可以实现虚拟化。</strong></p><p>容器是完全使用沙箱机制，相互之间不会有任何接口，更重要的是容器性能开销极低</p><h3 id="为什么用docker">为什么用Docker</h3><p><strong>1、 简化程序</strong></p><p>Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。</p><p><strong>2、 快速部署</strong></p><p>Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。</p><p><strong>3、 节省开支</strong></p><p>一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</p><p><strong>4、 持续交付和部署</strong></p><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像</p><p><strong>5、 更轻松的迁移</strong></p><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况</p><h3 id="docker的应用场景">Docker的应用场景</h3><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li></ul><h3 id="docker和虚拟机对比">Docker和虚拟机对比</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250702160442687-2025-7-216:04:52.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>Docker 和虚拟机（VM）是两种不同的虚拟化技术，它们在架构、性能和使用场景上有显著差异。</p><ul><li>实现技术原理不同：虚拟机是⽤来进⾏硬件资源划分的完美解决⽅案，利⽤的是<strong>硬件虚拟化技术</strong>。而容器则是<strong>操作系统级别的虚拟化</strong>，利⽤的是内核的 Cgroup （资源限制）和 Namespace 特性，此功能通过软件来实现，仅仅是进程本身就可以实现互相隔离，不需要任何辅助。</li><li>使用资源方面不同： <strong>Docker 容器与主机共享操作系统内核</strong>，不同的容器之间可以共享部分系统资源，因此更加轻量级， 消耗的资源更少。 <strong>虚拟机会独占分配给⾃⼰的资源</strong>，不存在资源共享，各个虚拟机之间近乎完全隔离，更加重量级，也 会消耗更多的资源。</li><li>应用场景不同：若需要资源的完全隔离并且不考虑资源的消耗，可以使用虚拟机。 若是想隔离进程并且需要运行大量进程实例，应该选择 Docker 容器。</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250702161202518-2025-7-216:12:03.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h3 id="总结">总结</h3><ul><li><p>Docker使用Google公司推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及AUFS类的UnionFS等技术，对<strong>进程</strong>进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。Docke最初实现是基于LXC。</p></li><li><p>Docker能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：<strong>构建杰出的软件</strong>。</p></li><li><p>用户可以方便地<strong>创建和使用容器</strong>，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p></li><li><p>Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现“这段代码在我机器上没问题啊”这类问题；——<strong>一致的运行环境</strong></p></li><li><p>可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。更快速的启动时间避免公用的服务器，资源会容易受到其他用户的影响。——<strong>隔离性</strong></p></li><li><p>善于处理集中爆发的服务器使用压力；——<strong>弹性伸缩，快速扩展</strong></p></li><li><p>可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——<strong>迁移方便</strong></p></li><li><p>使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。——<strong>持续交付和部署</strong></p></li></ul><h2 id="二docker基础">二、Docker基础</h2><h3 id="docker架构">Docker架构</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250702162453088-2025-7-216:24:54.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。</p><h3 id="docker-的基本概念">Docker 的基本概念</h3><p>Docker包括三个基本概念，它们构成了 Docker 技术栈的基础：</p><ul><li><p><strong>镜像</strong>（ Image ）</p></li><li><p><strong>容器</strong>（ Container ）</p></li><li><p><strong>仓库</strong>（ Repository ）</p></li></ul><h4 id="镜像">镜像</h4><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>镜像是一个<strong>只读</strong>的模板，镜像构建后无法修改，只能通过重新构建生成新版本。</p><hr><p><strong>分层存储</strong></p><p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <strong>UnionFS</strong> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像</p><h4 id="容器">容器</h4><p>容器通过镜像来创建，镜像和容器的关系，就像是面向对象程序设计中的 类 和 实例 一样。镜<strong>像是静态的定义，容器是镜像运行时的实体</strong>。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是<strong>进程</strong>，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <strong>命名空间</strong>。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p><p>每一个容器运行时，会在镜像的只读层之上创建一个可写层，所有对容器的修改（如文件写入、配置变更）都发生在此层，可以称这个为容器运行时读写而准备的存储层为<strong>容器存储层</strong>。该层与容器生命周期绑定，容器删除时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <strong>数据卷（Volume</strong>） 、或者<strong>绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷是由 Docker 管理的持久化存储，独立于容器生命周期。容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h4 id="仓库">仓库</h4><p>Docker仓库是集中存储和分发<strong>镜像</strong>的服务，分为 公共仓库（如 Docker Hub）和 私有仓库（如 Harbor）。</p><hr><p><strong>公有</strong> <strong>Docker Registry</strong></p><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的官方镜像。</p><p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（ Registry Mirror ），这些镜像服务被称为<strong>加速器</strong>。常见的有 <strong>阿里云加速器</strong>、<strong>DaoCloud</strong> <strong>加速器</strong> 等。</p><hr><p><strong>私有</strong> <strong>Docker Registry</strong></p><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <strong>Docker Registry</strong> 镜像，可以直接使用做为私有 Registry 服务。</p><p>开源的 Docker Registry 镜像只提供了 <strong>Docker Registry API</strong> 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 <strong>Docker Trusted Registry</strong>中，提供了这些高级功能。</p><p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<strong>VMWare Harbor</strong> 和 <strong>Sonatype Nexus</strong>。</p><h3 id="docker安装与配置">Docker安装与配置</h3><p>目前，CentOS 仅发行版本中的内核支持 Docker。Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10以上。Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。</p><p>从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。</p><p>Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。此处介绍 Docker CE 的安装使用。</p><ol type="1"><li><p>校验版本</p><p>命令：<code>uname -r</code> 校验Linux内核版本（3.10以上版本）</p></li><li><p>移除旧版本</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum remove docker \
				docker-client \
				docker-client-latest \
				docker-common \
				docker-latest \
				docker-latest-logrotate \
				docker-logrotate \
				docker-selinux \
				docker-engine-selinux \
				docker-engine</code></pre></div></li><li><p>安装一些必要的系统工具</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre></div></li><li><p>添加软件源信息</p><p>源1：官方推荐</p><div class="code-wrapper"><pre><code class="hljs bash">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</code></pre></div><p>源2：阿里云源</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre></div></li><li><p>更新yum缓存</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum makecache</code></pre></div></li><li><p>安装Docker-CE</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum -y install docker-ce</code></pre></div></li><li><p>启动Docker后台服务</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl start docker</code></pre></div></li><li><p>查看Docker版本验证是否安装成功</p><div class="code-wrapper"><pre><code class="hljs bash">docker version</code></pre></div></li></ol><hr><p>执行以下命令来卸载Docker-CE</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> yum remove docker-ce
<span class="hljs-built_in">sudo</span> <span class="hljs-built_in">rm</span> -rf /var/lib/docker</code></pre></div><hr><p>Docker镜像加速器配置</p><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决</p><p>阿里云为每个用户都配备了一个加速器地址，登录账号-&gt;容器镜像服务-&gt;容器镜像工具-&gt;镜像加速器。</p><p>通过在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>

<span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-string">&quot;加速器地址&quot;</span><span class="hljs-punctuation">]</span>

<span class="hljs-punctuation">&#125;</span></code></pre></div><div class="spoiler collapsed"><div class="spoiler-title">其他镜像</div><div class="spoiler-content"><div class="code-wrapper"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>
    <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
                <span class="hljs-string">&quot;https://docker.1panelproxy.com&quot;</span><span class="hljs-punctuation">,</span>
                <span class="hljs-string">&quot;https://dockerproxy.1panel.live&quot;</span><span class="hljs-punctuation">,</span>
                <span class="hljs-string">&quot;https://docker.1panel.live&quot;</span><span class="hljs-punctuation">,</span>
                <span class="hljs-string">&quot;https://proxy.1panel.live&quot;</span><span class="hljs-punctuation">,</span>
                  <span class="hljs-string">&quot;https://docker.m.daocloud.io&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;https://noohub.ru&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;https://huecker.io&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;https://dockerhub.timeweb.cloud&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;https://0c105db5188026850f80c001def654a0.mirror.swr.myhuaweicloud.com&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;https://5tqw56kt.mirror.aliyuncs.com&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;https://docker.1panel.live&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;http://mirrors.ustc.edu.cn/&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;http://mirror.azure.cn/&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;https://hub.rat.dev/&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;https://docker.ckyl.me/&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;https://docker.chenby.cn&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;https://docker.hpcloud.cloud&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-string">&quot;https://docker.m.daocloud.io&quot;</span>
        <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">&#125;</span></code></pre></div></div></div><p>重启Docker</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl daemon-reload
<span class="hljs-built_in">sudo</span> systemctl restart docker</code></pre></div><p>执行 <code>docker info</code>命令查看配置是否生效</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250702172922731-2025-7-217:29:24.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h3 id="docker镜像操作">Docker镜像操作</h3><p>镜像是Docker的三大组件之一。</p><p>Docker运行容器前需要本地存在对应的镜像，如果本地不存，Docker会从镜像仓库下载。</p><p><strong>本节将介绍更多关于镜像的内容，包括：</strong></p><ul><li><p>从仓库获取镜像；</p></li><li><p>管理本地主机上的镜像；</p></li><li><p>介绍镜像实现的基本原理;</p></li></ul><h4 id="获取镜像">获取镜像</h4><p>Docker Hub 上有大量的高质量的镜像可以用，可以从 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub 网站</a>来搜索镜像。</p><p>也可以使用 <code>docker search</code> 命令来搜索镜像。比如需要一个tomcat的镜像来作为我们的web服务</p><div class="code-wrapper"><pre><code class="hljs bash">docker search tomcat</code></pre></div><hr><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code> 其命令格式为：</p><div class="code-wrapper"><pre><code class="hljs bash">docker pull [选项] [Docker Registey 地址[:端口号]/] 仓库名[:标签]</code></pre></div><ul><li>具体的选项可以通过 <code>docker pull --help</code> 命令看到</li><li>Docker 镜像仓库地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub，但由于之前配置了阿里云的地址，所以会从阿里云镜像仓库中下载。</li><li>仓库名：这里的仓库名是两段式名称， 即<用户名>/<软件名>。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</软件名></用户名></li><li>标签用于指明镜像的版本，省略时默认为latest版本。</li></ul><p>以拉取tomcat 8的镜像为例</p><div class="code-wrapper"><pre><code class="hljs bash">docker pull tomcat:8</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250702175019043-2025-7-217:50:25.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><div class="note note-info"><p>如上图所示。从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。</p></div><h4 id="列出镜像">列出镜像</h4><p>要想列出已经下载下来的镜像，可以使用 <code>docker images</code> 命令。</p><div class="code-wrapper"><pre><code class="hljs bash">docker images <span class="hljs-comment">#返回镜像列表</span></code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250702175442327-2025-7-217:54:43.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><p>列表包含了 <strong>仓库名、标签、镜像ID、创建时间 以及 所占用的空间</strong>。 其中<strong>镜像ID是镜像的唯一标识</strong>，一个镜像可以对应多个标签。因此，如果拥有相同的 ID，因为它们对应的是同一个镜像。</p><div class="note note-info"><p>关于镜像体积：</p><p>列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p><p>比如，此时再次拉取tomcat的最新版本镜像，它会复用之前镜像中的一些层</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250702180123423-2025-7-218:02:41.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></div><h4 id="删除本地镜像">删除本地镜像</h4><div class="code-wrapper"><pre><code class="hljs bash">docker rmi 镜像ID</code></pre></div><blockquote><p>要删除镜像必须确认此镜像⽬前没有被任何容器使⽤</p></blockquote><p>补充：虚悬镜像</p><p>虚悬镜像是 Docker 中一种特殊的镜像状态，通常指 <strong>没有标签（Tag）且未被任何容器引用的中间层镜像</strong>。</p><p>当镜像的 <code>&lt;TAG&gt;</code> 被覆盖或删除后，旧版本的镜像会变成 <strong><code>&lt;none&gt;:&lt;none&gt;</code></strong> 状态，称为虚悬镜像。虚悬镜像本质是磁盘垃圾，通常可安全清理。</p><div class="code-wrapper"><pre><code class="hljs bash">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
&lt;none&gt;        &lt;none&gt;    123abc456def   2 weeks ago     1.2GB  <span class="hljs-comment"># 虚悬镜像示例</span></code></pre></div><p>可能产生的原因：</p><ul><li>构建新镜像时覆盖了旧标签。新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为none的镜像。比如：<code>docker build -t my-image:latest</code> 重复执行</li><li>删除镜像标签</li></ul><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有虚悬镜像</span>
docker images -f <span class="hljs-string">&quot;dangling=true&quot;</span>

<span class="hljs-comment"># 删除所有虚悬镜像</span>
docker image prune</code></pre></div><h4 id="导入导出镜像">导入导出镜像</h4><p>备份本地仓库的镜像</p><ol type="1"><li><p><strong>⽤</strong> <strong>save</strong> <strong>⼦命令将本地仓库的镜像保存当前⽬录下</strong></p><div class="code-wrapper"><pre><code class="hljs bash">docker save -o xxxx.tar 镜像名称</code></pre></div></li><li><p><strong>将本地目录下的镜像备份文件导⼊到本地</strong> <strong>Docker</strong> <strong>仓库</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># ⽅式—(不输出详细信息）：</span>
docker load –i xxxx.tar
<span class="hljs-comment"># ⽅式⼆（输出详细信息）：</span>
docker load &lt; xxxx.tar</code></pre></div></li></ol><p>要将自己的镜像共享给团队其他成员，更常用的方式是：会先Docker私库，将自己的上传，其他成员使用docker pull 的方式拉取。</p><h3 id="docker容器操作">Docker容器操作</h3><p>容器是独立运行的一个或一组应用，以及它们的运行环境。</p><h4 id="查看容器状态">查看容器状态</h4><div class="code-wrapper"><pre><code class="hljs bash">docker ps <span class="hljs-comment">#查看*运行*的容器</span>
docker ps –a <span class="hljs-comment">#查看所有的容器（包含运行和退出）</span>
docker inspect 容器ID  <span class="hljs-comment">#查看容器内部详情，如挂载、网络设置等</span></code></pre></div><h4 id="启动容器">启动容器</h4><p>启动容器有二种方式，一种是基于镜像新建一个容器并启动，一种是将在终止状态（ stopped ）的容器重新启动</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#基于镜像启动</span>
docker run 参数 镜像名称:tage 

<span class="hljs-comment">#启动停止状态的容器</span>
docker start 容器名称/容器ID

<span class="hljs-comment">#重启容器</span>
docker restart 容器名称/容器ID</code></pre></div><p>常用基础参数</p><ul><li>-it : 交互式运行</li><li>-d: 后台运行</li><li>--name: 指定容器名称</li><li>--rm: 容器退出后销毁</li><li>-p: 宿主机：内部端口</li></ul><p>例：在后台运行一个tomcat容器，容器名称是tomcat-8081，并且将主机的 8081 端口 映射到容器的 8080 端口。容器启动后，Tomcat 服务会在容器内部的 8080 端口运行，可以通过主机的 8081 端口即可访问。</p><div class="code-wrapper"><pre><code class="hljs bash">docker run -d -name tomcat-8081 -p 8081:8080 tomcat:8</code></pre></div><p>默认情况下，每次重启虚拟机我们都需要⼿动启动Docker和Docker中的容器。通过命令可以实现开机⾃启：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Docker开机⾃启</span>
systemctl <span class="hljs-built_in">enable</span> docker

<span class="hljs-comment"># Docker容器开机⾃启</span>
docker update --restart=always [容器名/容器<span class="hljs-built_in">id</span>]</code></pre></div><h4 id="停止容器">停止容器</h4><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#停止运行的容器</span>
docker stop 容器名称/容器ID

<span class="hljs-comment">#停止所有的容器</span>
docker stop $(docker ps -a -q)</code></pre></div><h4 id="删除容器">删除容器</h4><p>处于运行状态的容器无法直接删除，需要先将其停止后再删</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#删除指定容器</span>
docker <span class="hljs-built_in">rm</span> 容器名称/容器ID

<span class="hljs-comment">#删除所有容器</span>
docker <span class="hljs-built_in">rm</span> $(docker ps -a -q)</code></pre></div><h4 id="进入容器内部">进入容器内部</h4><p>某些时候需要进入容器进行操作，使用 <code>docker exec</code> 命令。比如，进入mysql容器内部进行sql操作。</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</code></pre></div><ul><li>[OPTIONS] ：配置执行方式的参数，核心参数有：<ul><li>-i：保持标准输入打开，允许交互式输入</li><li>-t：分配伪终端，<strong>通常与 -i 联用 (<code>-it</code>)</strong></li><li>-d：在后台执行命令</li><li>-u：以指定的用户身份执行</li><li>-e：设置环境变量（临时生效）</li><li>-w：指定命令的工作目录</li></ul></li><li>CONTAINER：<u>已运行的容器</u>的名称或ID</li><li>COMMAND：要在容器内执行的命令，如 /bin/bash、ls、mysql、shell等</li><li>[ARG...]：传递给命令的参数</li></ul><p>例1：进入mysql内部进行sql查询</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it mysql mysql -uroot -p

<span class="hljs-comment">#或者</span>
docker <span class="hljs-built_in">exec</span> -it mysql bash
mysql -uroot -p</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250703100606136-2025-7-310:06:19.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>例2：进入tomcat容器内部，添加index.html</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it tomcat-8081 bash</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250703101328143-2025-7-310:13:28.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="在宿主机和容器之间交换文件">在宿主机和容器之间交换文件</h4><p>在宿主机和容器之间相互COPY⽂件 cp的⽤法如下</p><div class="code-wrapper"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span> [OPTIONS] CONTAINER:SRC_PATH DEST_PATH  <span class="hljs-comment"># 容器 → 本地</span>
docker <span class="hljs-built_in">cp</span> [OPTIONS] SRC_PATH CONTAINER:DEST_PATH  <span class="hljs-comment"># 本地 → 容器</span></code></pre></div><ul><li>CONTAINER 容器名称或 ID（如 my-container 或 abc123）</li><li>SRC_PATH 源文件/目录路径（容器内或本地）</li><li>DEST_PATH 目标路径（容器内或本地）</li></ul><h3 id="docker查看日志">Docker查看日志</h3><div class="code-wrapper"><pre><code class="hljs bash">docker logs [OPTIONS] 容器名称/ID</code></pre></div><p>核心参数：</p><ul><li><code>-f</code> : 实时跟踪日志输出</li><li><code>--tail N</code> : 仅显示最后N行，默认显示全部</li><li><code>-t</code>：显示日志的时间戳</li><li><code>--since time</code>：显示指定时间之后的日志，如2024-05-06或10m</li><li><code>--until time</code>：显示指定时间之前的日志</li><li><code>-n</code>：显示日志的额外元数据</li></ul><h3 id="docker数据卷">Docker数据卷</h3><p>问题：通过镜像创建一个容器。容器一旦被销毁，则容器内的数据将一并被删除。容器中的数据不是持久化状态的。那有没有一种独立于容器、提供持久化并能服务于多个容器的东西呢？有的兄弟，有的---数据卷。</p><hr><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250703105403083-2025-7-310:54:04.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>什么是数据卷？</p><p>数据卷是一个可供一个或多个容器使用的特殊目录。它是 Docker 中用于持久化存储和共享数据的核心机制，它独立于容器的生命周期，即使容器被删除，数据卷仍然存在。</p><p>特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响镜像</li><li>数据卷默认会一直存在，即使容器被删除</li></ul><hr><p>为什么需要数据卷？</p><p>这得从 docker 容器的文件系统说起。出于效率等一系列原因，docker 容器的文件系统在宿主机上存在的方式很复杂，这会带来下面几个问题：</p><ul><li><p>不能在宿主机上很方便地访问容器中的文件。</p></li><li><p>无法在多个容器之间共享数据。</p></li><li><p>当容器删除时，容器中产生的数据将丢失</p></li></ul><p>为了解决这些问题，docker 引入了数据卷(volume) 机制。<strong>数据卷是存在于一个或多个容器中的特定文件或文件夹，这个文件或文件夹以独立于 docker 文件系统的形式存在于宿主机中，将docker容器内的数据保存进宿主机的磁盘中。</strong></p><p>数据卷的最大特点是：其生存周期<strong>独立于容器的生存周期</strong>。</p><hr><p>使用数据卷的最佳场景</p><ul><li><p>在多个容器之间共享数据，多个容器可以同时以只读或者读写的方式挂载同一个数据卷，从而共享数据卷中的数据。</p></li><li><p>当宿主机不能保证一定存在某个目录或一些固定路径的文件时，使用数据卷可以规避这种限制带来的问题。</p></li><li><p>当你想把容器中的数据存储在宿主机之外的地方时，比如远程主机上或云存储上。</p></li><li><p>当你需要把容器数据在不同的宿主机之间备份、恢复或迁移时，数据卷是很好的选择。</p></li></ul><h4 id="数据卷类型">数据卷类型</h4><div class="note note-warning"><p>Docker挂载主机目录访问如果出现cannot open directory.：Permission denied 解决办法：在挂载目录后多加一个<code>--privileged=true</code>参数即可。扩大容器的权限解决挂载目录没有权限的问题，使container内的root拥有真正的root权限</p></div><p><strong>命名卷</strong>：由Docker管理的持久化存储，默认存储在 <code>/var/lib/docker/volumes/</code> 目录下，由 Docker 自动维护生命周期。</p><p>特点：</p><ul><li>容器删除后数据仍然保留</li><li>适合跨主机迁移（通过 <code>docker volume</code> 命令管理）</li><li>Docker 对存储驱动进行了性能优化</li><li>自动继承容器内目标路径的权限</li></ul><p>适用场景：</p><ul><li>数据库存储（MySQL、PostgreSQL等）</li><li>需要 Docker 管理生命周期的持久化数据</li><li>跨容器共享数据</li></ul><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建命名卷</span>
docker volume create myapp_data

<span class="hljs-comment"># 使用命名卷启动容器</span>
docker run -d -v myapp_data:/var/lib/mysql mysql:8.0

<span class="hljs-comment"># 查看卷详情</span>
docker volume inspect myapp_data

<span class="hljs-comment"># 删除卷（需先移除所有引用）</span>
docker volume <span class="hljs-built_in">rm</span> myapp_data
</code></pre></div><hr><p><strong>绑定挂载</strong>：<strong>直接映射主机文件系统路径</strong>到容器，完全绕过 Docker 的存储管理。</p><div class="code-wrapper"><pre><code class="hljs bash">docker run -d --privileged=<span class="hljs-literal">true</span> -v 宿主机绝对路径目录：容器内目录 镜像名</code></pre></div><p>特点：</p><ul><li>主机和容器文件实时双向同步</li><li>可使用任意主机目录</li><li>直接读写主机文件系统，性能最佳</li><li>路径必须存在，且与主机环境耦合度高</li></ul><p>适用场景：开发环境，代码热更新；使用主机特定配置文件；需要直接访问主机设备的场景</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 映射主机目录到容器</span>
docker run -d -v /host/path:/container/path nginx

<span class="hljs-comment"># 只读模式挂载（容器不能修改）；默认是权限rw，可读写</span>
docker run -d -v /host/config:/etc/nginx:ro nginx

<span class="hljs-comment"># 数据卷继承。容器2继承容器1的卷规则 --volumes-from</span>
docker run -d --privileged=<span class="hljs-literal">true</span> --volumes-from 父类  --name 容器名 镜像</code></pre></div><hr><p><strong>共享存储卷</strong>：支持第三方存储系统，如 NFS、AWS EBS、Ceph 等。</p><p>常见驱动类型：</p><table><thead><tr class="header"><th>驱动类型</th><th>描述</th><th>典型用例</th></tr></thead><tbody><tr class="odd"><td><code>local</code></td><td>默认本地存储（命名卷/绑定挂载）</td><td>单机部署</td></tr><tr class="even"><td><code>nfs</code></td><td>挂载网络文件系统</td><td>跨主机共享数据</td></tr><tr class="odd"><td><code>sshfs</code></td><td>通过 SSH 挂载远程目录</td><td>安全访问远程文件</td></tr><tr class="even"><td><code>azure_file</code></td><td>Azure 云存储</td><td>云环境持久化</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建NFS卷</span>
docker volume create --driver <span class="hljs-built_in">local</span> \
  --opt <span class="hljs-built_in">type</span>=nfs \
  --opt o=addr=192.168.1.100,rw \
  --opt device=:/path/on/nfs \
  nfs_volume

<span class="hljs-comment"># 使用云存储卷（AWS EBS示例）</span>
docker run -v ebs_volume:/data amazon/amazon-ecs-agent</code></pre></div><h3 id="docker网络">Docker网络</h3><h2 id="三镜像制作-dockerfile">三、镜像制作 Dockerfile</h2><p>当我们从docker镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改：</p><ol type="1"><li>从已经创建的容器中更新镜像，并且提交这个镜像</li><li>使用 Dockerfile 指令来创建一个新的镜像</li></ol><p>镜像的定制实际上就是定制每一层所添加的配置、文件。<strong>如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像</strong>，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的指令，每条指令都会创建一个新的镜像层并对镜像进行提交，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段：</p><ul><li>Dockerfile是软件的原材料</li><li>Docker镜像是软件的交付品</li><li>Docker容器则可以认为是软件镜像的运行态，也即依照镜像运行的容器实例</li></ul><p>Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250706102348480-2025-7-610:23:59.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><hr><p><strong>补充</strong>：<code>docker commit</code> ：用于将正在运行的容器保存为新的镜像。主要用于临时保存调试状态和紧急备份，生产环境通常要求通过 Dockerfile 构建标准化镜像。</p><div class="code-wrapper"><pre><code class="hljs bash">docker commit -m=“提交的描述信息” -a=<span class="hljs-string">&quot;作者信息&quot;</span> 容器ID  新镜像名:标签</code></pre></div><h3 id="常用命令">常用命令</h3><p>首先参考一下tomcat的Dockerfile文件</p><div class="spoiler collapsed"><div class="spoiler-title">Dockerfile</div><div class="spoiler-content"><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment">#</span>
<span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> THIS DOCKERFILE IS GENERATED VIA &quot;apply-templates.sh&quot;</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># PLEASE DO NOT EDIT IT DIRECTLY.</span>
<span class="hljs-comment">#</span>

<span class="hljs-keyword">FROM</span> eclipse-temurin:<span class="hljs-number">21</span>-jdk-noble

<span class="hljs-keyword">ENV</span> CATALINA_HOME /usr/local/tomcat
<span class="hljs-keyword">ENV</span> PATH $CATALINA_HOME/bin:$PATH
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> -p <span class="hljs-string">&quot;<span class="hljs-variable">$CATALINA_HOME</span>&quot;</span></span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$CATALINA_HOME</span></span>

<span class="hljs-comment"># let &quot;Tomcat Native&quot; live somewhere isolated</span>
<span class="hljs-keyword">ENV</span> TOMCAT_NATIVE_LIBDIR $CATALINA_HOME/native-jni-lib
<span class="hljs-keyword">ENV</span> LD_LIBRARY_PATH $&#123;LD_LIBRARY_PATH:+$LD_LIBRARY_PATH:&#125;$TOMCAT_NATIVE_LIBDIR

<span class="hljs-keyword">ENV</span> TOMCAT_MAJOR <span class="hljs-number">11</span>
<span class="hljs-keyword">ENV</span> TOMCAT_VERSION <span class="hljs-number">11.0</span>.<span class="hljs-number">8</span>
<span class="hljs-keyword">ENV</span> TOMCAT_SHA512 <span class="hljs-number">82</span>a7a2e686da1fbafdd76c863d0bd1435bcd7e58d507ad353c43e364522eb3284d2dc3552388a5ca389e48afed863885886572edc13ba40ff0a13e339fca251f

<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">set</span> -eux; \</span>
<span class="language-bash">	\</span>
<span class="language-bash">	savedAptMark=<span class="hljs-string">&quot;<span class="hljs-subst">$(apt-mark showmanual)</span>&quot;</span>; \</span>
<span class="language-bash">	apt-get update; \</span>
<span class="language-bash">	apt-get install -y --no-install-recommends \</span>
<span class="language-bash">		ca-certificates \</span>
<span class="language-bash">		curl \</span>
<span class="language-bash">		gnupg \</span>
<span class="language-bash">	; \</span>
<span class="language-bash">	\</span>
<span class="language-bash">	<span class="hljs-function"><span class="hljs-title">ddist</span></span>() &#123; \</span>
<span class="language-bash">		<span class="hljs-built_in">local</span> f=<span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>; <span class="hljs-built_in">shift</span>; \</span>
<span class="language-bash">		<span class="hljs-built_in">local</span> distFile=<span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span>; <span class="hljs-built_in">shift</span>; \</span>
<span class="language-bash">		<span class="hljs-built_in">local</span> mvnFile=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;1:-&#125;</span>&quot;</span>; \</span>
<span class="language-bash">		<span class="hljs-built_in">local</span> success=; \</span>
<span class="language-bash">		<span class="hljs-built_in">local</span> distUrl=; \</span>
<span class="language-bash">		<span class="hljs-keyword">for</span> distUrl <span class="hljs-keyword">in</span> \</span>
<span class="language-bash"><span class="hljs-comment"># https://apache.org/history/mirror-history.html</span></span>
			<span class="hljs-string">&quot;https://dlcdn.apache.org/$distFile&quot;</span> \
<span class="hljs-comment"># if the version is outdated, we have to pull from the archive</span>
			<span class="hljs-string">&quot;https://archive.apache.org/dist/$distFile&quot;</span> \
<span class="hljs-comment"># if all else fails, let&#x27;s try Maven (https://www.mail-archive.com/users@tomcat.apache.org/msg134940.html; https://mvnrepository.com/artifact/org.apache.tomcat/tomcat; https://repo1.maven.org/maven2/org/apache/tomcat/tomcat/)</span>
			$&#123;mvnFile:+<span class="hljs-string">&quot;https://repo1.maven.org/maven2/org/apache/tomcat/tomcat/$mvnFile&quot;</span>&#125; \
		; do \
			if curl -fL -o <span class="hljs-string">&quot;$f&quot;</span> <span class="hljs-string">&quot;$distUrl&quot;</span> &amp;&amp; [ -s <span class="hljs-string">&quot;$f&quot;</span> ]; then \
				success=<span class="hljs-number">1</span>; \
				break; \
			fi; \
		done; \
		[ -n <span class="hljs-string">&quot;$success&quot;</span> ]; \
	&#125;; \
	\
	ddist <span class="hljs-string">&#x27;tomcat.tar.gz&#x27;</span> <span class="hljs-string">&quot;tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz&quot;</span> <span class="hljs-string">&quot;$TOMCAT_VERSION/tomcat-$TOMCAT_VERSION.tar.gz&quot;</span>; \
	echo <span class="hljs-string">&quot;$TOMCAT_SHA512 *tomcat.tar.gz&quot;</span> | sha512sum --strict --check -; \
	ddist <span class="hljs-string">&#x27;tomcat.tar.gz.asc&#x27;</span> <span class="hljs-string">&quot;tomcat/tomcat-$TOMCAT_MAJOR/v$TOMCAT_VERSION/bin/apache-tomcat-$TOMCAT_VERSION.tar.gz.asc&quot;</span> <span class="hljs-string">&quot;$TOMCAT_VERSION/tomcat-$TOMCAT_VERSION.tar.gz.asc&quot;</span>; \
	GNUPGHOME=<span class="hljs-string">&quot;$(mktemp -d)&quot;</span>; export GNUPGHOME; \
	curl -fL -o upstream-KEYS <span class="hljs-string">&#x27;https://www.apache.org/dist/tomcat/tomcat-11/KEYS&#x27;</span>; \
	gpg --batch --import upstream-KEYS; \
<span class="hljs-comment"># filter upstream KEYS file to *just* known/precomputed fingerprints</span>
	printf <span class="hljs-string">&#x27;&#x27;</span> &gt; filtered-KEYS; \
<span class="hljs-comment"># see https://www.apache.org/dist/tomcat/tomcat-11/KEYS</span>
	for key in \
		<span class="hljs-string">&#x27;A9C5DF4D22E99998D9875A5110C01C5A2F6059E7&#x27;</span> \
		<span class="hljs-string">&#x27;48F8E69F6390C9F25CFEDCD268248959359E722B&#x27;</span> \
	; do \
		gpg --batch --fingerprint <span class="hljs-string">&quot;$key&quot;</span>; \
		gpg --batch --export --armor <span class="hljs-string">&quot;$key&quot;</span> &gt;&gt; filtered-KEYS; \
	done; \
	gpgconf --kill all; \
	rm -rf <span class="hljs-string">&quot;$GNUPGHOME&quot;</span>; \
	GNUPGHOME=<span class="hljs-string">&quot;$(mktemp -d)&quot;</span>; export GNUPGHOME; \
	gpg --batch --import filtered-KEYS; \
	gpg --batch --verify tomcat.tar.gz.asc tomcat.tar.gz; \
	tar -xf tomcat.tar.gz --strip-components=<span class="hljs-number">1</span>; \
	rm bin/*.bat; \
	rm tomcat.tar.gz*; \
	gpgconf --kill all; \
	rm -rf <span class="hljs-string">&quot;$GNUPGHOME&quot;</span>; \
	\
<span class="hljs-comment"># https://tomcat.apache.org/tomcat-9.0-doc/security-howto.html#Default_web_applications</span>
	mv webapps webapps.dist; \
	mkdir webapps; \
<span class="hljs-comment"># we don&#x27;t delete them completely because they&#x27;re frankly a pain to get back for users who do want them, and they&#x27;re generally tiny (~7MB)</span>
	\
	nativeBuildDir=<span class="hljs-string">&quot;$(mktemp -d)&quot;</span>; \
	tar -xf bin/tomcat-native.tar.gz -C <span class="hljs-string">&quot;$nativeBuildDir&quot;</span> --strip-components=<span class="hljs-number">1</span>; \
	apt-get install -y --no-install-recommends \
		dpkg-dev \
		gcc \
		libapr1-dev \
		libssl-dev \
		make \
	; \
	( \
		export CATALINA_HOME=<span class="hljs-string">&quot;$PWD&quot;</span>; \
		cd <span class="hljs-string">&quot;$nativeBuildDir/native&quot;</span>; \
		gnuArch=<span class="hljs-string">&quot;$(dpkg-architecture --query DEB_BUILD_GNU_TYPE)&quot;</span>; \
		aprConfig=<span class="hljs-string">&quot;$(command -v apr-1-config)&quot;</span>; \
		./configure \
			--build=<span class="hljs-string">&quot;$gnuArch&quot;</span> \
			--libdir=<span class="hljs-string">&quot;$TOMCAT_NATIVE_LIBDIR&quot;</span> \
			--prefix=<span class="hljs-string">&quot;$CATALINA_HOME&quot;</span> \
			--with-apr=<span class="hljs-string">&quot;$aprConfig&quot;</span> \
			--with-java-home=<span class="hljs-string">&quot;$JAVA_HOME&quot;</span> \
		; \
		nproc=<span class="hljs-string">&quot;$(nproc)&quot;</span>; \
		make -j <span class="hljs-string">&quot;$nproc&quot;</span>; \
		make install; \
	); \
	rm -rf <span class="hljs-string">&quot;$nativeBuildDir&quot;</span>; \
	rm bin/tomcat-native.tar.gz; \
	\
<span class="hljs-comment"># reset apt-mark&#x27;s &quot;manual&quot; list so that &quot;purge --auto-remove&quot; will remove all build dependencies</span>
	apt-mark auto <span class="hljs-string">&#x27;.*&#x27;</span> &gt; /dev/null; \
	[ -z <span class="hljs-string">&quot;$savedAptMark&quot;</span> ] || apt-mark manual $savedAptMark &gt; /dev/null; \
	find <span class="hljs-string">&quot;$TOMCAT_NATIVE_LIBDIR&quot;</span> -type f -executable -exec ldd <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> <span class="hljs-string">&#x27;;&#x27;</span> \
		| awk <span class="hljs-string">&#x27;/=&gt;/ &#123; print $(NF-1) &#125;&#x27;</span> \
		| xargs -rt readlink -e \
		| sort -u \
		| xargs -rt dpkg-query --search \
		| cut -d: -f1 \
		| sort -u \
		| tee <span class="hljs-string">&quot;$TOMCAT_NATIVE_LIBDIR/.dependencies.txt&quot;</span> \
		| xargs -r apt-mark manual \
	; \
	\
	apt-get purge -y --auto-remove -o APT::AutoRemove::RecommendsImportant=false; \
	rm -rf /var/lib/apt/lists/*; \
	\
<span class="hljs-comment"># sh removes env vars it doesn&#x27;t support (ones with periods)</span>
<span class="hljs-comment"># https://github.com/docker-library/tomcat/issues/77</span>
	find ./bin/ -name <span class="hljs-string">&#x27;*.sh&#x27;</span> -exec sed -ri <span class="hljs-string">&#x27;s|^#!/bin/sh$|#!/usr/bin/env bash|&#x27;</span> <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span> +; \
	\
<span class="hljs-comment"># fix permissions (especially for running as non-root)</span>
<span class="hljs-comment"># https://github.com/docker-library/tomcat/issues/35</span>
	chmod -R +rX .; \
	chmod <span class="hljs-number">1777</span> logs temp work; \
	\
<span class="hljs-comment"># smoke test</span>
	catalina.sh version

<span class="hljs-comment"># verify Tomcat Native is working properly</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">set</span> -eux; \</span>
<span class="language-bash">	nativeLines=<span class="hljs-string">&quot;<span class="hljs-subst">$(catalina.sh configtest 2&gt;&amp;1)</span>&quot;</span>; \</span>
<span class="language-bash">	nativeLines=<span class="hljs-string">&quot;<span class="hljs-subst">$(echo <span class="hljs-string">&quot;<span class="hljs-variable">$nativeLines</span>&quot;</span> | grep &#x27;Apache Tomcat Native&#x27;)</span>&quot;</span>; \</span>
<span class="language-bash">	nativeLines=<span class="hljs-string">&quot;<span class="hljs-subst">$(echo <span class="hljs-string">&quot;<span class="hljs-variable">$nativeLines</span>&quot;</span> | sort -u)</span>&quot;</span>; \</span>
<span class="language-bash">	<span class="hljs-keyword">if</span> ! <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$nativeLines</span>&quot;</span> | grep -E <span class="hljs-string">&#x27;INFO: Loaded( APR based)? Apache Tomcat Native library&#x27;</span> &gt;&amp;2; <span class="hljs-keyword">then</span> \</span>
<span class="language-bash">		<span class="hljs-built_in">echo</span> &gt;&amp;2 <span class="hljs-string">&quot;<span class="hljs-variable">$nativeLines</span>&quot;</span>; \</span>
<span class="language-bash">		<span class="hljs-built_in">exit</span> 1; \</span>
<span class="language-bash">	<span class="hljs-keyword">fi</span></span>

<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>

<span class="hljs-comment"># upstream eclipse-temurin-provided entrypoint script caused https://github.com/docker-library/tomcat/issues/77 to come back as https://github.com/docker-library/tomcat/issues/302; use &quot;/entrypoint.sh&quot; at your own risk</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> []</span>

<span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;catalina.sh&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]</span></code></pre></div></div></div><h4 id="from">FROM</h4><p><strong>指定基础镜像</strong></p><p>基础镜像不存在会在Docker Hub上拉去(必须为第一条指令)</p><p>使用格式：</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> &lt;镜像&gt;:[tag]

<span class="hljs-keyword">FROM</span> &lt;镜像&gt;@digest[校验码]</code></pre></div><h4 id="maintainer">MAINTAINER</h4><p><strong>提供Dockerfile制作者提供本人信息</strong></p><blockquote><p>[逐渐废弃] LABLE替代了MAINTANIER</p></blockquote><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment">#使用格式</span>
MAINTANIER <span class="hljs-string">&quot;xxxx &lt;作者邮箱&gt;&quot;</span></code></pre></div><h4 id="label">LABEL</h4><p><strong>添加元数据（如作者、版本）</strong></p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;your@email.com&quot;</span></span>
<span class="hljs-keyword">LABEL</span><span class="language-bash"> version=<span class="hljs-string">&quot;1.0&quot;</span></span></code></pre></div><h4 id="env">ENV</h4><p><strong>用于为docker容器设置环境变量</strong></p><p>ENV设置的环境变量，可以使用 <code>docker inspect</code>命令来查看。同时还可以使用<code>docker run --env =</code>来修改环境变量。</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment">#示例</span>
<span class="hljs-keyword">ENV</span> JAVA_HOME /usr/local/jdk
<span class="hljs-keyword">ENV</span> JRE_HOME $JAVA_HOME/jre
<span class="hljs-keyword">ENV</span> CLASSPATH $JAVA_HOME/lib/:$JRE_HOME/lib/
<span class="hljs-keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin/</code></pre></div><h4 id="user">USER</h4><p><strong>切换运行用户，提升安全性。</strong></p><p>Docker 默认是使用 root，但若不需要，建议切换使用者身分，毕竟 root 权限太大了，使用上有安全的风险。</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">USER</span> xxx</code></pre></div><h4 id="workdir">WORKDIR</h4><p><strong>切换/设置工作目录</strong></p><p>Docker 默认的工作目录是<code>/</code>，如果想让其他指令在指定的目录下执行，就得靠 WORKDIR。WORKDIR 动作的目录改变是持久的，不用每个指令前都使用一次 WORKDIR。</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash">  xxxx  <span class="hljs-comment">#类似于 cd xxx</span></span></code></pre></div><h4 id="volume">VOLUME</h4><p><strong>定义匿名卷</strong></p><p>只能定义docker管理的卷，用来存放数据库和需要保持的数据等。</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /var/lib/mysql</span></code></pre></div><h4 id="copy">COPY</h4><p><strong>把宿主机中的文件复制到镜像中去</strong></p><p>仅执行本地文件的直接复制，不能直接处理远程 URL 或自动解压压缩包，行为透明且可预测。</p><p>源文件要在Dockerfile工作目录下（不能超出上下文目录）</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 复制单个文件</span>
<span class="hljs-keyword">COPY</span><span class="language-bash"> app.py /usr/src/app/</span>

<span class="hljs-comment"># 复制目录（保留目录结构）</span>
<span class="hljs-keyword">COPY</span><span class="language-bash"> static/ /var/www/html/static/</span>

<span class="hljs-comment"># 带权限设置</span>
<span class="hljs-keyword">COPY</span><span class="language-bash"> --<span class="hljs-built_in">chown</span>=1000:1000 config.yml /etc/app/</span></code></pre></div><h4 id="add">ADD</h4><p>在 <code>COPY</code> 基础上扩展了<strong>自动解压</strong>和<strong>远程 URL 下载</strong>功能。</p><p>可直接从 HTTP/HTTPS 链接下载文件，支持自动解压 tar, gzip, bzip2, xz 等格式文件</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment">#命令格式</span>
<span class="hljs-keyword">ADD</span><span class="language-bash"> [--<span class="hljs-built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;源路径或URL&gt;... &lt;目标路径&gt;</span>

<span class="hljs-comment"># 自动解压本地压缩包到目标目录</span>
<span class="hljs-keyword">ADD</span><span class="language-bash"> app.tar.gz /opt/</span>

<span class="hljs-comment"># 从URL下载文件（不会自动解压）</span>
<span class="hljs-keyword">ADD</span><span class="language-bash"> https://example.com/data.zip /tmp/</span></code></pre></div><p>对比</p><ul><li>COPY：简单、安全、可预测，适用于绝大多数场景</li><li>ADD：功能强大但需谨慎，仅在解压/下载时使用</li></ul><h4 id="expose">EXPOSE</h4><p><strong>声明容器运行时监听的端口，以实现与外部通信</strong></p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span></code></pre></div><h4 id="run">RUN</h4><p><strong>执行命令并创建新的镜像层</strong></p><p>由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li>shell格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。</li><li>exec格式：<code>RUN ["可执行文件", "参数1", "参数2"]</code>，这更像是函数调用中的格式。</li></ul><p>RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-comment">#编译安装redis</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y gcc libc6-dev make</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> wget http://download.redis.io/releases/redis-4.0.1.tar.gz</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> tar xzf redis-4.0.1.tar.gz</span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> redis-4.0.1</span></code></pre></div><p>Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，都是新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。 而上面的这种写法，创建了多层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。</p><p>而且，Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p><p>正确的写法如下：</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> centos
<span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update \</span>
<span class="language-bash">	&amp;&amp; apt-get install -y gcc libc6-dev make \</span>
<span class="language-bash">	&amp;&amp; wget http://download.redis.io/releases/redis-4.0.1.tar.gz \</span>
<span class="language-bash">	&amp;&amp; tar xzf redis-4.0.1.tar.gz \</span>
<span class="language-bash">	&amp;&amp; <span class="hljs-built_in">cd</span> redis-4.0.1</span></code></pre></div><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell脚本，而是在定义每一层该如何构建。 并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加  的命令换行方式，以及行首 # 进行注释的格式。</p><h4 id="cmd">CMD</h4><p>指定容器启动后要执行的操作。CMD指令的格式与RUN相似，也是两种格式。</p><div class="code-wrapper"><pre><code class="hljs bash">CMD [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;param2&quot;</span>]  <span class="hljs-comment"># exec 形式（推荐）</span>
CMD <span class="hljs-built_in">command</span> param1 param2               <span class="hljs-comment"># shell 形式</span></code></pre></div><p>与RUN的区别：</p><ul><li>CMD是在docker run时运行。</li><li>RUN是在 docker build时运行。</li></ul><p>特点：</p><ul><li><p>Dockerfile中可以有多个 CMD指令，但只有最后一个生效。</p></li><li><p>CMD 会被docker run 之后的参数覆盖</p><div class="code-wrapper"><pre><code class="hljs bash">Tomcat的Dockerfile最后CMD指令为
CMD [<span class="hljs-string">&quot;catalina.sh&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]

<span class="hljs-comment">#启动Tomcat时添加了参数 /bin/bash，</span>
docker run -it - p 8080:8080 57800e5b1cbf /bin/bash

该命令参数类似于 CMD[<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>],会将Dockerfile中的CMD命令覆盖</code></pre></div></li><li><p>与 ENTRYPOINT 一起使用时，不再是直接运行其命令而是将CMD的内容作为参数传递给ENTRYPOINT指令，即为ENTRYPOINT 指定默认参数。</p></li></ul><h4 id="entrypoint">ENTRYPOINT</h4><p>也是用来指定一个容器启动时要运行的命令。</p><p>类似于CMD指令，但是<strong>ENTRYPOINT不会被docker run直接覆盖，需添加用 <code>--entrypoint</code> 参数进行覆盖，而且这些命令行参数会被当作参数送给ENTRYPOINT指令指定的程序</strong></p><div class="code-wrapper"><pre><code class="hljs bash">ENTRYPOINT [<span class="hljs-string">&quot;executable&quot;</span>, <span class="hljs-string">&quot;param1&quot;</span>]  <span class="hljs-comment"># exec 形式（推荐）</span>
ENTRYPOINT <span class="hljs-built_in">command</span> param1            <span class="hljs-comment"># shell 形式</span></code></pre></div><p>最佳实践：与CMD配合使用，由它为ENTRYPOINT命令执行指定默认参数，同时可以被docker run 的参数替换。</p><div class="code-wrapper"><pre><code class="hljs bash">ENTRYPOINT [<span class="hljs-string">&quot;固定主命令&quot;</span>]  
CMD [<span class="hljs-string">&quot;默认参数&quot;</span>]</code></pre></div><table><thead><tr class="header"><th>Dockerfile 配置</th><th><code>docker run</code> 命令</th><th>最终执行的命令</th></tr></thead><tbody><tr class="odd"><td><code>ENTRYPOINT ["echo"]</code> + <code>CMD ["A"]</code></td><td><code>docker run demo</code></td><td><code>echo "A"</code></td></tr><tr class="even"><td><code>ENTRYPOINT ["echo"]</code> + <code>CMD ["A"]</code></td><td><code>docker run demo B</code></td><td><code>echo "B"</code></td></tr><tr class="odd"><td><code>ENTRYPOINT ["echo"]</code> + <code>CMD ["A"]</code></td><td><code>docker run demo --entrypoint=ls</code></td><td><code>ls "A"</code> (异常情况)</td></tr></tbody></table><h3 id="根据dockerfile构建镜像">根据Dockerfile构建镜像</h3><p><code>docker build</code> 是 Docker 中最常用的命令之一，用于<strong>根据 Dockerfile 构建镜像</strong>。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#命令格式</span>
docker build [OPTIONS] PATH | URL | -</code></pre></div><ul><li>PATH：Dockerfile 所在的目录路径（构建上下文）。</li><li>URL：远程 Git 仓库或 TAR 包（支持 git://, https://）。</li><li>-：从标准输入（stdin）读取 Dockerfile（需配合 -f 指定文件）。</li></ul><p>核心参数 OPTIONS：</p><ul><li><strong><code>-f</code></strong>：指定 Dockerfile 文件名（非默认 <code>Dockerfile</code> 时使用）</li><li><strong><code>-t</code></strong>：指定镜像名称和标签（格式：<code>name:tag</code>）</li><li><strong><code>--build-arg</code></strong>：传递构建参数，该参数在 Dockerfile 中用 ARG 定义</li><li><strong><code>--no-cache</code></strong>：禁用缓存，强制重新构建</li><li><strong><code>--pull</code></strong>：总是拉取最新基础镜像（避免使用本地旧版本）</li><li><strong><code>--target</code></strong>：多阶段构建时指定目标阶段</li></ul><p>示例：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#1、构建基础镜像</span>
<span class="hljs-comment"># . 表示当前目录是构建上下文，Dockerfile 需在此目录下</span>
docker build -t myapp:1.0 .

<span class="hljs-comment">#2、指定不同的 Dockerfile</span>
<span class="hljs-comment"># 使用 Dockerfile.prod 而非默认的 Dockerfile</span>
docker build -f Dockerfile.prod -t myapp:prod 

<span class="hljs-comment">#3、传递构建参数.</span>
<span class="hljs-comment"># Dockerfile的内容</span>
ARG APP_VERSION=1.0
RUN <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Building version <span class="hljs-variable">$&#123;APP_VERSION&#125;</span>&quot;</span>

<span class="hljs-comment">#--build-arg 会覆盖 Dockerfile 中的默认值。</span>
docker build --build-arg APP_VERSION=2.0 -t myapp:2.0 .

</code></pre></div><h3 id="案例1">案例1</h3><p>创建一个镜像（基于tomcat）里面要有一个index.html，并添加 hello tomcat。此外复制一个文件(图片)，并复制到容器中并能访问。</p><p>在宿主机中创建一个目录，在其中创建一个Dockerfile文件</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /usr/local/docker/demo1
vim Dockerfile</code></pre></div><p>Dockerfile文件内容如下：</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> tomcat:<span class="hljs-number">9</span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /usr/local/tomcat/webapps/ROOT  <span class="hljs-comment">#在tomcat的webapps目录下创建ROOT文件夹</span></span>
<span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;&lt;h1&gt;hello tomcat&lt;/h1&gt;&quot;</span>&gt;/usr/local/tomcat/webapps/ROOT/index.html </span>
<span class="hljs-keyword">COPY</span><span class="language-bash"> 1.jpg /usr/local/tomcat/webapps/ROOT <span class="hljs-comment">#从当前目录下拷贝1.jpg到ROOT目录下</span></span>
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr/local/tomcat/webapps/ROOT  <span class="hljs-comment">#切换工作目录到ROOT目录</span></span></code></pre></div><p>由该Dockerfile文件构建镜像</p><div class="code-wrapper"><pre><code class="hljs bash">docker build -t domo:0.1 . <span class="hljs-comment">#从Dockerfile文件所在目录构建镜像</span></code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250703194021801-2025-7-319:41:01.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>在该镜像的基础上创建容器，进入容器内部查看ROOT目录下的内容</p><div class="code-wrapper"><pre><code class="hljs bash">docker run -d --name demo-8081 -p 8081:8080 domo:0.1</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250703194449000-2025-7-319:44:51.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><p>访问该容器，查看效果</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250703194849761-2025-7-319:48:52.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p><h3 id="案例2">案例2</h3><p>要求：Docker部署SpringBoot微服务项目，微服务镜像制作</p><p>思路：以项目中的某一个微服务为例，首先使用maven工具打包生成jar文件，之后将其上传到linux服务器中，通过制定镜像完成微服务构建，最后运行多个容器来完成高可用、高并发等部署要求。</p><p>示例项目中存在两个微服务，准备将微服务1打包部署，该服务中只有一个Controller接口，返回一个字符串。</p><p><img src="C:%5CUsers%5C86152%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250705173605638.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>部署流程：</p><ol type="1"><li><p>在linux服务中创建目录，保存jar文件</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /usr/local/docker/demo2</code></pre></div></li><li><p>编写Dockerfile文件</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">17</span>
<span class="hljs-keyword">VOLUME</span><span class="language-bash"> /tmp</span>
<span class="hljs-keyword">ADD</span><span class="language-bash"> ch-1-0.0.1-SNAPSHOT.jar ch1-boot.jar</span>
<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;/ch1-boot.jar&quot;</span>]</span></code></pre></div><ul><li>FROM：表示基础镜像，即运行环境。该项目java版本为17</li><li>VOLUME /tmp：创建/tmp目录并持久化到Docker数据文件夹，因为Spring Boot使用的内嵌Tomcat容器默认使用/tmp作为工作目录</li><li>ADD：拷贝文件并且重命名，将jar文件拷贝到容器内部</li><li>EXPOSE：建立image的人员告诉容器布署人员容器应该映射哪个端口给外界</li><li>ENTRYPOINT：容器启动时运行的命令，相当于我们在命令行中输入java -jar xxxx.jar，为了缩短 Tomcat 的启动时间，添加java.security.egd的系统属性指向/dev/urandom作为 ENTRYPOINT</li></ul></li><li><p>制作镜像</p><div class="code-wrapper"><pre><code class="hljs bash">docker build -t ch1-boot:1.0 .</code></pre></div></li><li><p>启动容器</p><div class="code-wrapper"><pre><code class="hljs bash">docker run --<span class="hljs-built_in">rm</span> -d --name ch1-boot -p 8081:8080 ch1-boot:1.0</code></pre></div></li><li><p>查看日志</p><div class="code-wrapper"><pre><code class="hljs bash">docker logs ch1-boot</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250705192021485-2025-7-519:20:41.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></li><li><p>访问接口查看效果</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250705192118436-2025-7-519:21:20.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></li></ol><h2 id="四docker实战高级">四、Docker实战高级</h2><h3 id="idea整合docker">IDEA整合Docker</h3><ol type="1"><li><p>Docker开启远程访问</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#修改该Docker服务文件</span>
vi /lib/systemd/system/docker.service
<span class="hljs-comment">#修改ExecStart这行</span>
ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock

<span class="hljs-comment">#重新加载配置文件</span>
systemctl daemon-reload
<span class="hljs-comment">#重启服务</span>
systemctl restart docker.service
<span class="hljs-comment">#查看端口是否开启</span>
netstat -nlpt</code></pre></div></li><li><p>IDEA安装docker插件后，配置Docker连接，连接成功后可在IDEA中操作Docker</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250705193427761-2025-7-519:34:53.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="配置Docker连接"><figcaption aria-hidden="true">配置Docker连接</figcaption></figure><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250705193747431-2025-7-519:37:49.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="查看Docker镜像、容器等信息"><figcaption aria-hidden="true">查看Docker镜像、容器等信息</figcaption></figure><figure><img src="C:%5CUsers%5C86152%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20250705194647382.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="根据镜像创建容器"><figcaption aria-hidden="true">根据镜像创建容器</figcaption></figure></li><li><p>传统项目的打包，上传，生成镜像，部署等操作都可以再IDEA中使用插件:<strong>docker-maven-plugin</strong>自动完成，大大提高了开发效率。在项目的POM文件中添加插件配置：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-comment">&lt;!--设置镜像前缀--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">docker.image.prefix</span>&gt;</span>com.hfut<span class="hljs-tag">&lt;/<span class="hljs-name">docker.image.prefix</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>docker-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.activation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 镜像名称 xxx/yyy--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span>
        <span class="hljs-comment">&lt;!--指定标签 为项目版本--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">imageTags</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">imageTag</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageTag</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">imageTags</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 基础镜像jdk--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">baseImage</span>&gt;</span>openjdk:17<span class="hljs-tag">&lt;/<span class="hljs-name">baseImage</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 制作者提供本人信息 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">maintainer</span>&gt;</span>lh cmyk359@163.com<span class="hljs-tag">&lt;/<span class="hljs-name">maintainer</span>&gt;</span>
        <span class="hljs-comment">&lt;!--切换到/ROOT目录 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">workdir</span>&gt;</span>/ROOT<span class="hljs-tag">&lt;/<span class="hljs-name">workdir</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">cmd</span>&gt;</span>[&quot;java&quot;, &quot;-version&quot;]<span class="hljs-tag">&lt;/<span class="hljs-name">cmd</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">entryPoint</span>&gt;</span>[&quot;java&quot;, &quot;-jar&quot;, &quot;$&#123;project.build.finalName&#125;.jar&quot;]<span class="hljs-tag">&lt;/<span class="hljs-name">entryPoint</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 指定 Dockerfile 路径</span>
<span class="hljs-comment">                    &lt;dockerDirectory&gt;$&#123;project.basedir&#125;/src/main/docker&lt;/dockerDirectory&gt;</span>
<span class="hljs-comment">                    --&gt;</span>
        <span class="hljs-comment">&lt;!--指定远程 docker api地址--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dockerHost</span>&gt;</span>http://192.168.181.100:2375<span class="hljs-tag">&lt;/<span class="hljs-name">dockerHost</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 这里是复制 jar 包到 docker 容器指定目录配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>/ROOT<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span>
                <span class="hljs-comment">&lt;!--用于指定需要复制的根目录，$&#123;project.build.directory&#125;表示target目录--&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>
                <span class="hljs-comment">&lt;!--用于指定需要复制的文件。$&#123;project.build.finalName&#125;.jar指的是打包后的jar</span>
<span class="hljs-comment">                            包文件。--&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre></div><p>该插件最终会生成如下内容的Dockerfile</p><div class="code-wrapper"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">17</span>
<span class="hljs-keyword">MAINTAINER</span> lh cmyk359@<span class="hljs-number">163</span>.com
<span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /ROOT</span>
<span class="hljs-keyword">ADD</span><span class="language-bash"> /ROOT/xxx.jar /ROOT</span>
<span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;xxx.jar&quot;</span>]</span>
<span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-version&quot;</span>]</span></code></pre></div></li><li><p>对项目打包，并制作镜像上传到Docker</p><div class="code-wrapper"><pre><code class="hljs bash">mvn clean package docker:build</code></pre></div><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250705213949252-2025-7-521:39:52.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250705213949252"><figcaption aria-hidden="true">image-20250705213949252</figcaption></figure></li><li><p>扩展配置：绑定Docker 命令到 Maven 各个阶段。</p><p>把 Docker 分为 build、tag、push，然后分别绑定 Maven 的 package、deploy 阶段。只用执行maven的package阶段，就能自动完成上述所有操作</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>
    <span class="hljs-comment">&lt;!--当执行mvn package 时，执行： mvn clean package docker:build --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>build-image<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
    <span class="hljs-comment">&lt;!--当执行mvn package 时，会对镜像进行 标签设定--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>tag-image<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>tag<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">image</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;:latest<span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">newName</span>&gt;</span>docker.io/$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;:$&#123;project.version&#125;
            <span class="hljs-tag">&lt;/<span class="hljs-name">newName</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>push-image<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>deploy<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>push<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>docker.io/$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;:$&#123;project.version&#125;
            <span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span></code></pre></div><p>完整POM文件</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>
    <span class="hljs-comment">&lt;!--设置镜像名称前缀--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">docker.image.prefix</span>&gt;</span>com.hfut<span class="hljs-tag">&lt;/<span class="hljs-name">docker.image.prefix</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.spotify<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>docker-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.activation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 镜像名称 xxx/yyy--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">imageName</span>&gt;</span>$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageName</span>&gt;</span>
        <span class="hljs-comment">&lt;!--指定标签 为项目版本--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">imageTags</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">imageTag</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">imageTag</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">imageTags</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 基础镜像jdk--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">baseImage</span>&gt;</span>openjdk:17<span class="hljs-tag">&lt;/<span class="hljs-name">baseImage</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 制作者提供本人信息 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">maintainer</span>&gt;</span>lh cmyk359@163.com<span class="hljs-tag">&lt;/<span class="hljs-name">maintainer</span>&gt;</span>
        <span class="hljs-comment">&lt;!--切换到/ROOT目录 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">workdir</span>&gt;</span>/ROOT<span class="hljs-tag">&lt;/<span class="hljs-name">workdir</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">cmd</span>&gt;</span>[&quot;java&quot;, &quot;-version&quot;]<span class="hljs-tag">&lt;/<span class="hljs-name">cmd</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">entryPoint</span>&gt;</span>[&quot;java&quot;, &quot;-jar&quot;, &quot;$&#123;project.build.finalName&#125;.jar&quot;]<span class="hljs-tag">&lt;/<span class="hljs-name">entryPoint</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 指定 Dockerfile 路径</span>
<span class="hljs-comment">                    &lt;dockerDirectory&gt;$&#123;project.basedir&#125;/src/main/docker&lt;/dockerDirectory&gt;</span>
<span class="hljs-comment">                    --&gt;</span>
        <span class="hljs-comment">&lt;!--指定远程 docker api地址--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dockerHost</span>&gt;</span>http://192.168.181.100:2375<span class="hljs-tag">&lt;/<span class="hljs-name">dockerHost</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- 这里是复制 jar 包到 docker 容器指定目录配置 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>/ROOT<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span>
                <span class="hljs-comment">&lt;!--用于指定需要复制的根目录，$&#123;project.build.directory&#125;表示target目录--&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>
                <span class="hljs-comment">&lt;!--用于指定需要复制的文件。$&#123;project.build.finalName&#125;.jar指的是打包后的jar</span>
<span class="hljs-comment">                            包文件。--&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>
        <span class="hljs-comment">&lt;!--当执行mvn package 时，执行： mvn clean package docker:build --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>build-image<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>build<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre></div></li></ol><h3 id="idea整合docker加密验证">IDEA整合Docker加密验证</h3><p>前面提到的配置是允许所有人都可以访问的，因为docker默认是root权限的，把2375端口暴露在外面，意味着别人随时都可以提取到你服务器的root权限，是很容易被黑客黑的，因此,docker官方推荐使用加密的tcp连接，以Https的方式与客户端建立连接。</p><ol type="1"><li><p>创建ca文件夹，存放CA私钥和公钥</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /usr/local/ca
<span class="hljs-built_in">cd</span> /usr/local/ca/</code></pre></div></li><li><p>生成CA私钥和公钥</p><p>记住设置的ca-key，后面还会用</p><div class="code-wrapper"><pre><code class="hljs bash">openssl genrsa -aes256 -out ca-key.pem 4096</code></pre></div></li><li><p>设置秘钥验证信息</p><p>依次输入密码、国家、省、市、组织名称、邮箱等信息</p><div class="code-wrapper"><pre><code class="hljs bash">openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem</code></pre></div></li><li><p>生成server-key.pem</p><p>现在已经有了CA，接下来创建一个服务器密钥和证书签名请求(CSR)。确保“公用名”与你用来连接到Docker的主机名匹配</p><div class="code-wrapper"><pre><code class="hljs bash">openssl genrsa -out server-key.pem 4096</code></pre></div></li><li><p>使用CA签署公钥</p><p>由于TLS连接可以通过IP地址和DNS名称进行，所以在创建证书时需要指定IP地址。例如，允许使用10.10.10.20和127.0.0.1进行连接</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># $Host换成你自己服务器外网的IP或者域名</span>
openssl req -subj <span class="hljs-string">&quot;/CN=<span class="hljs-variable">$HOST</span>&quot;</span> -sha256 -new -key server-key.pem -out server.csr
比如
openssl req -subj <span class="hljs-string">&quot;/CN=192.168.20.135&quot;</span> -sha256 -new -key server-key.pem -out server.csr
或
openssl req -subj <span class="hljs-string">&quot;/CN=www.javaqf.com&quot;</span> -sha256 -new -key server-key.pem -out server.csr</code></pre></div><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#此处使用虚拟机ip地址</span>
openssl req -subj <span class="hljs-string">&quot;/CN=192.168.181.100&quot;</span> -sha256 -new -key server-key.pem -out server.csr</code></pre></div></li><li><p>配置白名单</p><p>指定可以连接到Docker服务器的ip地址，多个ip用号分隔开。因为已经准备使用秘钥进行ssl连接，故ip地址可以配置为0.0.0.0，所有ip都可以连接，但只有拥有证书的才可以连接成功。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> subjectAltName = IP:0.0.0.0 &gt;&gt; extfile.cn</code></pre></div></li><li><p>设置秘钥</p><p>将Docker守护程序密钥的扩展使用属性设置为仅用于服务器身份验证:</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf</code></pre></div></li><li><p>生成签名证书</p><div class="code-wrapper"><pre><code class="hljs bash">openssl x509 -req -days 365 -sha256 -<span class="hljs-keyword">in</span> server.csr -CA ca.pem -CAkey ca-key.pem \
-CAcreateserial -out server-cert.pem -extfile extfile.cnf</code></pre></div></li><li><p>生成客户端的key.pem</p><div class="code-wrapper"><pre><code class="hljs bash">openssl genrsa -out key.pem 4096

openssl req -subj <span class="hljs-string">&#x27;/CN=client&#x27;</span> -new -key key.pem -out client.csr</code></pre></div></li><li><p>使密钥适合客户端身份验证</p><p>创建扩展配置文件</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf

<span class="hljs-built_in">echo</span> extendedKeyUsage = clientAuth &gt; extfile-client.cnf</code></pre></div></li><li><p>生成签名证书</p><div class="code-wrapper"><pre><code class="hljs bash">openssl x509 -req -days 365 -sha256 -<span class="hljs-keyword">in</span> client.csr -CA ca.pem -CAkey ca-key.pem \
-CAcreateserial -out cert.pem -extfile extfile-client.cnf</code></pre></div></li><li><p>删除不需要的文件</p><p>生成cert.pem和server-cert之后，就可以安全地删除两个证书签名请求和扩展配置文件:</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> -v client.csr server.csr extfile.cnf extfile-client.cnf</code></pre></div></li><li><p>修改权限</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#要保护您的密钥免受意外损坏，请删除其写入权限。要使它们只能被您读取，更改文件模式</span>
<span class="hljs-built_in">chmod</span> -v 0400 ca-key.pem key.pem server-key.pem
<span class="hljs-comment">#证书可以是对外可读的，删除写入权限以防止意外损坏</span>
<span class="hljs-built_in">chmod</span> -v 0444 ca.pem server-cert.pem cert.pem</code></pre></div></li><li><p>归集服务器证书</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> server-*.pem /etc/docker/
<span class="hljs-built_in">cp</span> ca.pem /etc/docker/</code></pre></div></li><li><p>修改Docker配置</p><p>使Docker守护程序仅接受来自提供CA信任的证书的客户端的连接</p><div class="code-wrapper"><pre><code class="hljs bash">vim /lib/systemd/system/docker.service
将
ExecStart=/usr/bin/dockerd
替换为：
ExecStart=/usr/bin/dockerd --tlsverify --tlscacert=/usr/local/ca/ca.pem --tlscert=/usr/local/ca/server-cert.pem --tlskey=/usr/local/ca/server-key.pem -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock</code></pre></div></li><li><p>开放2375端口</p><div class="code-wrapper"><pre><code class="hljs bash">/sbin/iptables -I INPUT -p tcp --dport 2375 -j ACCEPT</code></pre></div></li><li><p>重启Docker</p><div class="code-wrapper"><pre><code class="hljs bash">systemctl daemon-reload
systemctl restart docker</code></pre></div></li><li><p>保存相关客户端的pem文件到本地</p><p>将当前目录下的这四个文件拷贝到windows客户端，建立一个文件夹保存它们</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250705222702788-2025-7-522:27:31.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload></p></li><li><p>IDEA CA配置</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250705223322705-2025-7-522:33:45.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250705223322705"><figcaption aria-hidden="true">image-20250705223322705</figcaption></figure></li><li><p>修改之前pom插件中设置的Docker连接，从http改为https</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--指定远程 docker api地址--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dockerHost</span>&gt;</span>https://192.168.181.100:2375<span class="hljs-tag">&lt;/<span class="hljs-name">dockerHost</span>&gt;</span></code></pre></div></li></ol><h3 id="图形化界面">图形化界面</h3><p>docker 图形页面管理工具常用的有三种，DockerUI ，<strong>Portainer</strong> ，Shipyard 。DockerUI 是 Portainer 的前身，这三个工具通过docker api来获取管理的资源信息。平时我们常常对着shell对着这些命令行客户端，审美会很疲劳，如果有漂亮的图形化界面可以直观查看docker资源信息，也是非常方便的。今天我们就搭建单机版的三种常用图形页面管理工具。这三种图形化管理工具以<strong>Portainer</strong>最为受欢迎。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># portainer镜像下载</span>
docker pull portainer/portainer
<span class="hljs-comment"># 创建容器</span>
docker run -d --name portainerUI -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock \
--restart unless-stopped \
portainer/portainer

<span class="hljs-comment">#查看开发端口列表</span>
firewall-cmd --list-ports
<span class="hljs-comment">#开放9000端口</span>
firewall-cmd --zone=public --add-port=9000/tcp --permanent
<span class="hljs-comment">#重启防火墙</span>
firewall-cmd --reload</code></pre></div><p>访问http://192.168.100:9000</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250705225018020-2025-7-522:50:45.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250705225018020"><figcaption aria-hidden="true">image-20250705225018020</figcaption></figure><h3 id="搭建cig重量级监控平台">搭建CIG重量级监控平台</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gr4y1U7CY?spm_id_from=333.788.videopod.episodes&amp;vd_source=51d78ede0a0127d1839d6abf9204d1ee&amp;p=90">参考</a></p><h2 id="五持续集成持续交付">五、持续集成/持续交付</h2><h3 id="dockercompse">DockerCompse</h3><p>Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排，其定位是：<strong>定义和运行多个 Docker 容器的应用</strong></p><p>使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p><p>Compose 恰好满足了这样的需求。<strong>它允许用户通过一个单独的 docker-compose.yml 模板文件（来定</strong> <strong>义一组相关联的应用容器为一个项目。</strong></p><hr><p>Compose中有两个重要概念：</p><ul><li>服务（service）：一个 服务 对应一个容器化的应用组件（如 Web 服务器、数据库、缓存等），在 docker-compose.yml 文件中通过 services 块配置。</li><li>项目（project）：一个 项目 是一组关联服务的集合，代表一个完整的应用</li></ul><p>Compose 的默认管理对象是<strong>项目</strong>，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p><p>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。</p><h4 id="docker-compose安装">Docker Compose安装</h4><ol type="1"><li><p>从<a target="_blank" rel="noopener" href="https://github.com/docker/compose/releases">Docker Compose</a>的github仓库，下载RELEASE版本的文件</p></li><li><p>安装</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#1.将下载好的文件拖入Linux 并剪切到 /usr/local目录下</span>
<span class="hljs-built_in">mv</span> docker-compose-Linux-x86_64 /usr/local
<span class="hljs-comment">#2. 修改名称（为后面方便调用） 并 修改其为可执行文件</span>
<span class="hljs-built_in">mv</span> docker-compose-Linux-x86_64 docker-compose
<span class="hljs-built_in">chmod</span> 777 docker-compose
<span class="hljs-built_in">mv</span> docker-compose /usr/local/bin/</code></pre></div></li><li><p>验证</p><div class="code-wrapper"><pre><code class="hljs bash">[root@ai100 ~]# docker-compose --version
Docker Compose version v2.36.0</code></pre></div></li></ol><h4 id="docker-compose的使用">Docker Compose的使用</h4><p>常用命令：</p><ul><li><p>build 构建或重建服务</p></li><li><p>help 命令帮助</p></li><li><p>kill 杀掉容器</p></li><li><p>logs 显示容器的输出内容</p></li><li><p>port 打印绑定的开放端口</p></li><li><p>ps 显示容器pull 拉取服务镜像</p></li><li><p>restart 重启服务</p></li><li><p>rm 删除停止的容器</p></li><li><p>run 运行一个一次性命令</p></li><li><p>scale 设置服务的容器数目</p></li><li><p>start 开启服务</p></li><li><p>stop 停止服务</p></li><li><p>up 创建并启动容器</p></li><li><p>down 关闭并删除容器</p></li></ul><p>用compose的方式管理一个Tomcat容器和MySQL</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#1 管理文件夹，创建相应的目录</span>
<span class="hljs-string">mkdir</span> <span class="hljs-string">-p</span> <span class="hljs-string">/opt/docker_mysql_tomcat/</span>

<span class="hljs-comment">#2 在如上目录中 编写创建 docker-compose.yml配置文件</span>
<span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span>
<span class="hljs-attr">services:</span>
  <span class="hljs-attr">mysql:</span> <span class="hljs-comment"># 服务的名称</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span> <span class="hljs-comment"># 只要docker启动，容器会随着启动</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">daocloud.io/library/mysql:5.7.6</span> <span class="hljs-comment"># 指定镜像路径信息（默认官方镜像地址)</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">mysql-3306</span> <span class="hljs-comment"># 指定容器名称 --name</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-number">3306</span><span class="hljs-string">:3306</span> <span class="hljs-comment">#指定端口号映射</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">root</span> <span class="hljs-comment">#指定MYSQL ROOT用户的密码</span>
      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asiz/Shanghai</span> <span class="hljs-comment">#指定时区</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/docker_mysql_tomcat/mysql/data:/var/lib/mysql</span> <span class="hljs-comment">#映射mysql的数据目录到宿主机，保存数据</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/docker_mysql_tomcat/mysql/conf/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf</span> <span class="hljs-comment">#把mysql的配置文件映射到容器的相应目录</span>
  <span class="hljs-attr">tomcat:</span>
    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>
    <span class="hljs-attr">image:</span> <span class="hljs-string">daocloud.io/library/tomcat:8.5.15-jre8</span>
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">tomcat-8080</span>
    <span class="hljs-attr">ports:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:8080</span>
    <span class="hljs-attr">environment:</span>
      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asiz/Shanghai</span>
    <span class="hljs-attr">volumes:</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/docker_mysql_tomcat/tomcat/webapps:/usr/local/tomcat/webapps</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/docker_mysql_tomcat/tomcat/logs:/usr/local/tomcat/logs</span></code></pre></div><h4 id="tomcat集群搭建">tomcat集群搭建</h4><h4 id="redis集群搭建">redis集群搭建</h4><h3 id="基于dockerjenkinsgitlab搭建持续集成环境">基于Docker+Jenkins+Gitlab搭建持续集成环境</h3><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/JavaWeb/" class="category-chain-item">JavaWeb</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>Docker</div><div>https://catpaws.top/f5f9fa9b/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年7月2日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/f6253398/" title="Dubbo"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Dubbo</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/9d1ae18b/" title="二、链表"><span class="hidden-mobile">二、链表</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://catpaws.top/blog-resource/twikoo1.6.42/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本站由<img src="/img/upyun_logo.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="width:auto;height:auto">提供CDN加速/云存储服务</a></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备2025059828号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61032302000087" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="police-icon"> <span>陕公网安备61032302000087号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//catpaws.top/blog-resource/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="//catpaws.top/blog-resource/js/loader.js"></script><script src="//catpaws.top/blog-resource/js/blurpicload.js"></script><script src="//catpaws.top/blog-resource/js/axios.min.js"></script><script src="/js/boot.js"></script><!DOCTYPE html><html><head><style>#matechat-iframe-container{position:fixed;top:0;left:0;width:100%;height:100%;z-index:10000;opacity:0;visibility:hidden;transition:opacity .3s ease,visibility .3s ease}#matechat-iframe-container.active{opacity:1;visibility:visible}.matechat-iframe{width:100%;height:100%;border:none;background:#fff}#matechat-iframe-container.active .matechat-close-btn{opacity:1}body.matechat-open{overflow:hidden}</style></head><body><div id="matechat-iframe-container"><iframe class="matechat-iframe" src="https://chat.catpaws.top" allow="microphone" title="芙芙来帮你"></iframe></div><script>document.addEventListener("DOMContentLoaded",(function(){const e=document.getElementById("oml2d-stage"),t=document.getElementById("matechat-iframe-container");function n(){t.classList.remove("active"),document.body.classList.remove("matechat-open")}e?t?(e.addEventListener("click",(function(){t.classList.add("active"),document.body.classList.add("matechat-open")})),document.addEventListener("keydown",(function(e){"Escape"===e.key&&n()})),window.addEventListener("message",(function(e){"closeMateChat"!==e.data&&"close"!==e.data.type||n()})),t.addEventListener("click",(function(e){e.target===this&&n()}))):console.error("matechat-iframe-container 元素未找到"):console.error("oml2d-stage 元素未找到")}))</script><script data-pjax src="https://catpaws.top/blog-resource/live2d/index.min.js"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"https://catpaws.top/blog-resource/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"}}})</script></body></html><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>