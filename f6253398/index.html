<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><link rel="icon" href="https://catpaws.top/blog-resource/imgs/logo.jpg"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="猫爪在上"><meta name="keywords" content=""><meta name="description" content="一、基础知识 分布式理论 什么是分布式系统？ 《分布式系统原理与范型》定义：分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统。 分布式系统（distributed system）是建立在网络之上的软件系统。. 架构演进 随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条"><meta property="og:type" content="article"><meta property="og:title" content="Dubbo"><meta property="og:url" content="https://catpaws.top/f6253398/index.html"><meta property="og:site_name" content="猫爪在上の书桌"><meta property="og:description" content="一、基础知识 分布式理论 什么是分布式系统？ 《分布式系统原理与范型》定义：分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统。 分布式系统（distributed system）是建立在网络之上的软件系统。. 架构演进 随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250709110427953-2025-7-911:05:06.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250709101651674-2025-7-910:17:10.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250709110642348-2025-7-911:06:42.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250710204832288-2025-7-1020:48:51.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250710225318702-2025-7-1022:53:23.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2025-07-10_20-09-55-2025-7-1022:56:58.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250710205359612-2025-7-1020:54:00.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250710205943322-2025-7-1020:59:44.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250710214833729-2025-7-1021:48:59.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250710220808270-2025-7-1022:08:12.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250710222146140-2025-7-1022:21:50.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250710224747111-2025-7-1022:47:54.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250711095738095-2025-7-1109:57:40.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250711115343071-2025-7-1111:53:47.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250711120346818-2025-7-1112:03:48.png"><meta property="og:image" content="d:%5CDesktop%5C5f3f4b1b-dd06-4470-9738-c96a11e17af0.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250710110657346-2025-7-1011:07:20.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250709110642348-2025-7-911:06:42.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/dubbo-framework-2025-7-1410:25:20.jpg"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250714103904785-2025-7-1410:39:05.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250711224736865-2025-7-1122:47:38.png"><meta property="og:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250711225541100-2025-7-1122:56:02.png"><meta property="article:published_time" content="2025-07-09T01:48:02.000Z"><meta property="article:modified_time" content="2025-07-14T04:52:58.553Z"><meta property="article:author" content="猫爪在上"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://gitee.com/cmyk359/img/raw/master/img/image-20250709110427953-2025-7-911:05:06.png"><title>Dubbo - 猫爪在上の书桌</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/font.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/poem.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/shubiao.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/loader.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/twikoo_beautify.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/indeximg-hover.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/wave.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/blurpicload.css"><link rel="stylesheet" href="//catpaws.top/blog-resource/css/reward/iconfont.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"catpaws.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"https://catpaws.top/blog-resource/imgs/transparent.svg",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"TNTPv22capMq3aFV9S0sLqSm-gzGzoHsz",app_key:"G2BBAxXmiixopVg5mIJ2sxXR",server_url:"https://leancloud.catpaws.top",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loader-container"><div class="loader"><div class="wrapper"><div class="catContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 733 673" class="catbody"><path fill="#212121" d="M111.002 139.5C270.502 -24.5001 471.503 2.4997 621.002 139.5C770.501 276.5 768.504 627.5 621.002 649.5C473.5 671.5 246 687.5 111.002 649.5C-23.9964 611.5 -48.4982 303.5 111.002 139.5Z"></path><path fill="#212121" d="M184 9L270.603 159H97.3975L184 9Z"></path><path fill="#212121" d="M541 0L627.603 150H454.397L541 0Z"></path></svg> <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 158 564" class="tail"><path fill="#191919" d="M5.97602 76.066C-11.1099 41.6747 12.9018 0 51.3036 0V0C71.5336 0 89.8636 12.2558 97.2565 31.0866C173.697 225.792 180.478 345.852 97.0691 536.666C89.7636 553.378 73.0672 564 54.8273 564V564C16.9427 564 -5.4224 521.149 13.0712 488.085C90.2225 350.15 87.9612 241.089 5.97602 76.066Z"></path></svg><div class="text"><span class="bigzzz">Z</span> <span class="zzz">Z</span></div></div><div class="wallContainer"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 500 126" class="wall"><line stroke-width="6" stroke="#7C7C7C" y2="3" x2="450" y1="3" x1="50"></line><line stroke-width="6" stroke="#7C7C7C" y2="85" x2="400" y1="85" x1="100"></line><line stroke-width="6" stroke="#7C7C7C" y2="122" x2="375" y1="122" x1="125"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="500" y1="43"></line><line stroke-width="6" stroke="#7C7C7C" y2="1.99391" x2="115.5" y1="43.0061" x1="115.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00002" x2="189" y1="43.0122" x1="189"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.00612" x2="262.5" y1="43.0183" x1="262.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01222" x2="336" y1="43.0244" x1="336"></line><line stroke-width="6" stroke="#7C7C7C" y2="2.01833" x2="409.5" y1="43.0305" x1="409.5"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="153" y1="84.0122" x1="153"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="228" y1="84.0122" x1="228"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="303" y1="84.0122" x1="303"></line><line stroke-width="6" stroke="#7C7C7C" y2="43" x2="378" y1="84.0122" x1="378"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="192" y1="125.012" x1="192"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="267" y1="125.012" x1="267"></line><line stroke-width="6" stroke="#7C7C7C" y2="84" x2="342" y1="125.012" x1="342"></line></svg></div></div></div></div><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>猫爪在上の书桌</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-addrcard"></i> <span>个人主页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-books"></i> <span>博客</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/" target="_self"><i class="iconfont icon-pen"></i> <span>文章</span> </a><a class="dropdown-item" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/" target="_self"><i class="iconfont icon-category-fill"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></div></li><li class="nav-item"><a class="nav-link" href="/messages/" target="_self"><i class="iconfont icon-comment"></i> <span>留言板</span></a></li><li class="nav-item"><a class="nav-link" href="/timeline/" target="_self"><i class="iconfont icon-images"></i> <span>时光轴</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(https://catpaws.top/blog-resource/imgs/article-bg.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Dubbo"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2025-07-09 09:48" pubdate>2025年7月9日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 9.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 78 分钟 </span><span id="leancloud-page-views-container" class="post-meta" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="leancloud-page-views"></span> 次</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">Dubbo</h1><p id="updated-time" class="note note-info">本文最后更新于 2025年7月14日 下午</p><div class="markdown-body"><meta name="referrer" , content="no-referrer"><h2 id="一基础知识">一、基础知识</h2><h3 id="分布式理论">分布式理论</h3><p>什么是分布式系统？</p><p>《分布式系统原理与范型》定义：分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统。</p><p>分布式系统（distributed system）是建立在网络之上的软件系统。.</p><h3 id="架构演进">架构演进</h3><p>随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250709110427953-2025-7-911:05:06.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>1、单一应用架构</p><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM) 是关键。</p><p>2、垂直应用架构</p><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</p><p>3、分布式服务架构</p><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。</p><p>此时，用于提高业务复用及整合的分布式服务框架(RPC)，提供统一的服务是关键。</p><p>4、流动计算架构</p><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p><h3 id="rpc理论">RPC理论</h3><p>什么是RPC？</p><p>RPC【Remote Procedure Call】是指<strong>远程过程调用</strong>，是一种进程间通信方式，他是一种技术的思想，而不是规范。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。简言之，RPC使得程序能够像访问本地系统资源一样，去访问远端系统资源。解决的是子系统间模块功能的调用。</p><hr><p>RPC架构？</p><p>一个基本的RPC架构里面应该至少包含以下4个组件：</p><ol type="1"><li>客户端（Client）：服务调用方（服务消费者）</li><li>客户端存根（Client Stub）：存放服务端地址信息，将客户端的请求参数数据信息序列化成网络消息，再通过网络传输发送给服务端</li><li>服务端存根（Server Stub）：接收客户端发送过来的请求消息并进行反序列化，然后再调用本地服务进行处理</li><li>服务端（Server）：服务的真正提供者</li></ol><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250709101651674-2025-7-910:17:10.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p><strong>具体调用过程：</strong></p><ol type="1"><li><p>服务消费者（client客户端）通过调用本地服务的方式调用需要消费的服务；</p></li><li><p>客户端存根（client stub）接收到调用请求后负责将方法、参数等信息序列化（组装）成能够进行网络传 输的消息体；</p></li><li><p>客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端；</p></li><li><p>服务端存根（server stub）收到消息后进行解码（反序列化操作）；</p></li><li><p>服务端存根（server stub）根据解码结果调用本地的服务进行相关处理；</p></li><li><p>本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）；</p></li><li><p>服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方；</p></li><li><p>客户端存根（client stub）接收到消息，并进行解码（反序列化）；</p></li><li><p>服务消费方得到最终结果；</p></li></ol><p>而RPC框架的实现目标则是把2~8（调用、编码/解码）的过程给封装起来，让用户感觉上像调用本地服务一样的调用远程服务。</p><h2 id="二dubbo">二、Dubbo</h2><h3 id="简介">简介</h3><p>Apache Dubbo 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p><p><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/">官网</a></p><h3 id="设计架构">设计架构</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250709110642348-2025-7-911:06:42.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="Dubbo架构" style="zoom:80%"></p><p>其中包括以下模块：</p><ul><li>Registry：注册中心</li><li>Provider：服务提供者</li><li>Consumer：服务消费者</li><li>Container：Dubbo框架容器</li><li>Monitor：监控中心</li></ul><p>运行流程如下：</p><ol type="1"><li>初始化：<ul><li>Dubbo框架启动</li><li>服务提供者启动时，会将所提供的服务注册到注册中心</li><li>服务消费者启动时，会从注册中心订阅所需要的服务</li></ul></li><li>当某个服务提供者发生了变更，注册中心会基于长连接的方式将变更推送给服务消费者</li><li>服务消费者可以根据负载均衡算法从服务列表中选择所需的服务</li><li>在服务调用过程中，异步地将调用信息发送到监控中心，实时监控服务运行状态</li></ol><h3 id="dubbo3的新特性">Dubbo3的新特性</h3><ul><li><p>易用性</p><p>开箱即用易用性高，如Java版本的面向接口代理特性能实现本地透明调用功能丰富，基于原生库或轻量扩展即可实现绝大多数的微服务治理能力。更加完善了多语言支持（GO PYTHON RUST）</p></li><li><p>超大规模微服务实践</p><ul><li><p>高性能通信（Triple GRPC）</p></li><li><p>高可扩展性（SPI 多种序列化方式 多种协议）</p></li><li><p>丰富的服务治理能力</p></li><li><p>超大规模集群实例水平扩展</p></li></ul></li><li><p>云原生有好</p><ul><li><p>容器调度平台（Kubernetes）</p><p>将服务的组织与注册交给底层容器平台，如 Kubernetes，这是更云原生的方式。</p></li><li><p>Service Mesh</p><p>原有Mesh结构中通过Sidecar完成负载均衡、路由等操作，但是存在链路的性能损耗大，现有系统迁移繁琐等问题。Dubbo3引入Proxyless Mesh，直接和1控制面交互[istio]通信。集成ServiceMesh更为方便，效率更高。</p></li></ul></li></ul><p><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/what/xyz-difference/">参考</a></p><div class="note note-info"><p>Dubbo3支持 gRPC 作为通信协议。gRPC 基于 HTTP/2，支持二进制传输，性能非常高；gRPC 的通信协议是基于 protobuf 的二进制序列化，数据传输效率高。同时gRPC 支持多种语言，具备跨语言能力。</p><p>而SpringCloud中的OpenFeign基于 HTTP/1.1，通常使用 JSON 格式进行数据传输，性能取决于底层 HTTP 客户端。</p><p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1361633">OpenFeign与Dubbo对比</a></p></div><h3 id="快速入门">快速入门</h3><p>代码结构及相关术语介绍</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250710204832288-2025-7-1020:48:51.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><ul><li>registry: 服务注册中心</li><li>provider：服务提供者，consumer：服务调用者（消费者）</li><li>commens-api：通用内容，其中定义provider和consumer的公共实体和接口。</li></ul><div class="note note-danger"><p>JDK与Dubbo版本对应问题</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250710225318702-2025-7-1022:53:23.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>Spring与JDK版本的对应</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2025-07-10_20-09-55-2025-7-1022:56:58.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></div><hr><h4 id="项目初始化">项目初始化</h4><p>创建父项目dubbo-demo，在其下创建三个Module: dubbo-commons-api、dubbo-provider、dubbo-consumer，并让provider和consumer引用commons模块。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250710205359612-2025-7-1020:54:00.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><div class="note note-info"><p>在IDEA的编译设置中开启模块并行编译，就能在provider和consumer中直接引用commons模块，否则需要将commons模块进行 <code>mvn install</code>后才能被使用</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250710205943322-2025-7-1020:59:44.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></div><p>在父项目中引入相关依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.32<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><h4 id="commons-api模块开发">commons-api模块开发</h4><ol type="1"><li><p>创建实体</p><p>根据业务需要定义实体类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span>
<span class="hljs-meta">@NoArgsConstructor</span>
<span class="hljs-meta">@AllArgsConstructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;
    <span class="hljs-keyword">private</span> String userName;
    <span class="hljs-keyword">private</span> String password;
&#125;</code></pre></div></li><li><p>定义业务接口</p><p>定义RPC通信中的服务接口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String userName, String password)</span>;
&#125;</code></pre></div></li></ol><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250710214833729-2025-7-1021:48:59.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h4 id="provider模块开发">provider模块开发</h4><ol type="1"><li><p>导入commons-api模块</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-01-common-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>实现业务接口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.common.service.UserService;


<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String userName, String password)</span> &#123;
        System.out.println(<span class="hljs-string">&quot;userName:&quot;</span>+userName+<span class="hljs-string">&quot; password:&quot;</span>+password);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
&#125;</code></pre></div></li><li><p>使用Spring XML配置并创建RPC服务</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:dubbo</span>=<span class="hljs-string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span>
<span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span>
    
    <span class="hljs-comment">&lt;!--  1、定义服务名称，必须唯一  --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;service-provider&quot;</span>/&gt;</span>

    <span class="hljs-comment">&lt;!-- 2、定义RPC通信协议及端口  Dubbo默认端口为20880 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20880&quot;</span>/&gt;</span>

    <span class="hljs-comment">&lt;!--  3、定义服务接口实现  --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.provider.service.UserServiceImpl&quot;</span>/&gt;</span>

    <span class="hljs-comment">&lt;!--  4、发布服务 interface定义服务接口  ref指明接口的实现 --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.common.service.UserService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userService&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span></code></pre></div></li><li><p>启动服务</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;
        <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext-provider.xml&quot;</span>);
        context.start();

        <span class="hljs-comment">//阻塞，等待服务调用</span>
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>).await();
    &#125;
&#125;</code></pre></div></li><li><p>成功启动</p><div class="code-wrapper"><pre><code class="hljs bash">Dubbo Application[1.1](service-provider) is ready., dubbo version: 3.2.0, current host: 192.168.72.1</code></pre></div></li><li><p>在控制台日志中可以看到<code>UserService</code>这个接口的访问地址url，后面在consumer中通过RPC调用接口服务时，访问的就是这个url。后面引入注册中心后就不用记了。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250710220808270-2025-7-1022:08:12.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></li></ol><h4 id="consummer模块开发">consummer模块开发</h4><ol type="1"><li><p>导入commons-api模块</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-01-common-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>XML配置引入RPC服务</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 定义服务名称   --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;service-consumer&quot;</span>&gt;</span>
    <span class="hljs-comment">&lt;!--   关闭qos运维监控     --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;qos.enable&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:application</span>&gt;</span>

<span class="hljs-comment">&lt;!--  定义服务接口的访问地址，id为consumer中获取RPC远端服务的ID  --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.common.service.UserService&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;dubbo://192.168.72.1:20880/org.common.service.UserService&quot;</span>/&gt;</span></code></pre></div><div class="note note-warning"><p>后面连接到注册中心后，就不用指定url了，由注册中心完成。</p></div></li><li><p>运行consumer，获取provider的服务接口，调用其中的方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;
        <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext-consumer.xml&quot;</span>);
        <span class="hljs-comment">//获取服务接口</span>
        <span class="hljs-type">UserService</span> <span class="hljs-variable">userService</span> <span class="hljs-operator">=</span> (UserService) context.getBean(<span class="hljs-string">&quot;userService&quot;</span>);
        <span class="hljs-comment">//调用接口方法</span>
        <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> userService.login(<span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);
        System.out.println(result);
    &#125;
&#125;</code></pre></div></li></ol><div class="note note-warning"><p>关于Qos问题：</p><p>若在已启动provider的情况下再启动consumer，会抛出Qos服务端口22222被占用的错误，但不影响服务运行。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250710222146140-2025-7-1022:21:50.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>问题产生的原因：</p><p>Qos=Quality of Service，qos是Dubbo的在线运维命令，可以对服务进行动态的配置、控制及查询。</p><p>Dubboo2.5.8新版本重构了telnet模块，提供了新的telnet命令支持，新版本的telnet端口与dubbo协议的端口是不同的端口，默认为22222，正是因为这个问题：如果在一台服务器里面，启动provider时22222端口已使用，而consumer启动时就会报错了。</p><p>解决方法：</p><div class="code-wrapper"><pre><code class="hljs xml">在xml文件中----&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;qos.enable&quot;</span><span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span> &lt;！--是否开启在线运维命令--&gt;
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;qos.accept.foreign.ip&quot;</span><span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span> &lt;！-不允许其他机器的访问
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;qos.port&quot;</span><span class="hljs-attr">value</span>=<span class="hljs-string">&quot;33333&quot;</span>/&gt;</span> &lt;！--修改port--&gt;
    
在springboot的properties配置文件中---&gt;
dubbo.application.qos.enable=true
dubbo.application.qos.port=333333
dubbo.application.qos.accept.foreign. ip=false</code></pre></div></div><h4 id="细节补充">细节补充</h4><p>在provider中定义了通信协议为dubbo，默认端口为20880</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20880&quot;</span>/&gt;</span></code></pre></div><p>但是随着应用数量增加，如果显示指定协议端口，会容易造成端口冲突。所以建议按照如下写法配置端口，将协议端口设置为-1，默认指向20880端口，当该端口不可用时会继续尝试下一个端口20881是否可用，如果可用，就使用该端口，这样就避免了端口占用的问题。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;-1&quot;</span>/&gt;</span></code></pre></div><hr><p>思考：</p><p>1、为什么Provider提供了UserService的实现，而在另一个JVM中的Consumer中可以调用？Consumer中调用的到底是什么？</p><p>UserServiceImpl这个类只在Provider所在的JVM中被加载，按理说在Consumer所指的JVM中是无法识别并使用的。实际上，Consumer没有直接调用远端的UserServiceImpl，实际上调用的是远端UserServiceImpl的<strong>代理对象 Proxy</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250710224747111-2025-7-1022:47:54.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>2、这个代理的核心工作是什么</p><p>被consumer实际调用。通过代理，对consumer屏蔽了网络通信的过程（通信方式 协议 序列化），以及数据传递过程。</p><h3 id="springboot整合dubbo">Springboot整合Dubbo</h3><h4 id="基于注解的方式">基于注解的方式</h4><p>整合思路：深度封装，将公用的配置放到application.yml中，把个性化的配置通过注解来设置</p><ol type="1"><li><p>导入commons模块和Dubbo的starter</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-01-common-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>provider的处理</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250711095517388-2025-7-1109:56:02.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="image-20250711095517388"><figcaption aria-hidden="true">image-20250711095517388</figcaption></figure><p>关于服务名称的设置，可以直接在dubbo中设置，也可以通过Spring设置。默认从dubbo中读取，没有的话采用Spring application的名称。第二种方法更常用。</p><p><strong>注意：在启动类上加上@EnableDubbo注解</strong></p></li><li><p>consumer的处理</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250711095738095-2025-7-1109:57:40.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>在启动类上也加上@EnableDubbo注解consumer的处理</p></li></ol><hr><p><strong><span class="citation" data-cites="EnableDubbo">@EnableDubbo</span></strong>的作用：</p><ul><li><strong>用于扫描@DubboService并把对应的对象实例化，发布成RPC服务。</strong></li><li>扫描路径：应用这个注解的类所在的包及其子包</li></ul><p>如果@DubboService注解修饰的类没有在默认的扫描路径下，还希望能够被扫描到，该如何处理？</p><ul><li><p>在启动类上添加包扫描注解，指定包路径</p><ul><li><p><span class="citation" data-cites="DubboComponentScan">@DubboComponentScan</span>(basePackages={"xxx.xx"})</p></li><li><p>或者直接在@EnableDubbo中指定，它其中包含了@DubboComponentScan</p><p><span class="citation" data-cites="EnableDubbo">@EnableDubbo</span>(scanBasePackages ="xxx.xx" )</p></li></ul></li><li><p>在配置文件中指定要扫描的包</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">dubbo:</span>
  <span class="hljs-attr">scan:</span>
    <span class="hljs-attr">base-packages:</span> <span class="hljs-string">xxx.xx.xxx</span></code></pre></div></li></ul><p>这两个注解的作用类似于Spring中的 <span class="citation" data-cites="SpringBootApplication和">@SpringBootApplication和</span><span class="citation" data-cites="Componetscan的作用">@Componetscan的作用</span>。</p><hr><p><strong><span class="citation" data-cites="DubboService">@DubboService</span></strong>的作用：</p><ul><li>SpringBoot会创建该类型的对象，等同于@Component（<span class="citation" data-cites="Service">@Service</span>） <span class="citation" data-cites="Bean">@Bean</span></li><li>发布成RPC服务</li></ul><p>该注解完成了XML中的如下配置：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250711115343071-2025-7-1111:53:47.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>为了后序开发过程的兼容性，实现类不仅仅要加上@DubboService注解，还要加上原来的@Service。如果之后不使用Dubbo的RPC服务，这个注解就会失效，若还希望由Spring来管理，必须加上@Service。</p><hr><p><strong><span class="citation" data-cites="DubboReference">@DubboReference</span></strong>的作用：</p><p>在Consumer端，通过@DubboReference<strong>注入远端服务的代理对象</strong></p><p>该注解完成了XML中的如下配置，其中的interface和id可以通过反射获取</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250711120346818-2025-7-1112:03:48.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p><span class="citation" data-cites="DubboReference类似于原始Spring开发中的">@DubboReference类似于原始Spring开发中的</span><span class="citation" data-cites="Autowired或">@Autowired或</span><span class="citation" data-cites="Resource">@Resource</span>，只不过前者注入的是特定的RPC代理。</p><h4 id="结合xml的方式">结合XML的方式</h4><p>为什么还要使用XML文件进行配置？比如说对一个接口中的某个方法配置超时时间，重试次数等<strong>更精细</strong>的配置，用注解写起来比较臃肿。</p><p>一些关于服务的公共配置，如服务名称、注册中心地址、协议等，还在yml文件中配置，只在XML文件中配置相关服务接口实现和服务发布的内容。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 服务接口实现  --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.cmyk.dubbo04bootprovider.service.UserServiceImpl&quot;</span>/&gt;</span>

<span class="hljs-comment">&lt;!--  发布服务 interface定义服务接口  ref指明接口的实现 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;org.common.service.UserService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.0&quot;</span>&gt;</span>
    <span class="hljs-comment">&lt;!--  配置方法相关内容      --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;login&quot;</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">&quot;5000&quot;</span> <span class="hljs-attr">retries</span>=<span class="hljs-string">&quot;3&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:service</span>&gt;</span></code></pre></div><p>对应的实现类UserServiceImpl上就不用加@DubboService注解了，不使用注解来发布。为了让XML配置生效，需要在启动类上添加@ImportReource注解引入XML文件</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@ImportResource(locations = &quot;classpath:applicationContext-provider.xml&quot;)</span></code></pre></div><h4 id="java原生api的方式">Java原生API的方式</h4><p>自己编写一个配置类，为XML文件中的标签声明一个Bean对象，在其中设置相关属性。XML文件中的每个标签对应一个Config，如&lt;dubbo:application/&gt;对应一个ApplicationConfig，&lt;dubbo:registry/&gt;对应一个RegistryConfig。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDubboConfig</span> &#123;

    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> ApplicationConfig <span class="hljs-title function_">applicationConfig</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-type">ApplicationConfig</span> <span class="hljs-variable">applicationConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationConfig</span>();
        applicationConfig.setName(<span class="hljs-string">&quot;boot-service-provider&quot;</span>);
        <span class="hljs-keyword">return</span> applicationConfig;
    &#125;
    
    <span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> RegistryConfig <span class="hljs-title function_">registryConfig</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-type">RegistryConfig</span> <span class="hljs-variable">registryConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegistryConfig</span>();
        registryConfig.setAddress(<span class="hljs-string">&quot;zookeeper://localhost:2181&quot;</span>);
        <span class="hljs-keyword">return</span> registryConfig;
    &#125;
    
	<span class="hljs-meta">@Bean</span>
    <span class="hljs-keyword">public</span> ProtocolConfig <span class="hljs-title function_">protocolConfig</span><span class="hljs-params">()</span>&#123;
        <span class="hljs-type">ProtocolConfig</span> <span class="hljs-variable">protocolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtocolConfig</span>();
        protocolConfig.setName(<span class="hljs-string">&quot;Dubbo&quot;</span>);
        protocolConfig.setPort(-<span class="hljs-number">1</span>);
        <span class="hljs-keyword">return</span> protocolConfig;
    &#125;
    <span class="hljs-comment">//.....</span>
&#125;</code></pre></div><h3 id="高级功能">高级功能</h3><h4 id="启动检查">启动检查</h4><p>在消费方启动之前，如果提供方还没有启动，消费方会看到这样的报错信息：说明还暂时没有对应服务提供者，导致消费方无法启动成功</p><div class="code-wrapper"><pre><code class="hljs bash">java.lang.IllegalStateException: Failed to check the status of the service xxxx. No provider available <span class="hljs-keyword">for</span> the service xxxxx</code></pre></div><ul><li><p>方案 1：将提供方应用正常启动起来即可。</p></li><li><p>方案 2：可以考虑在消费方的 Dubbo XML 配置文件中，为对应服务添加check="false" 的属性，或者在@DubboReference注解中添加check属性，都能达到启动不检查服务的目的。</p><div class="code-wrapper"><pre><code class="hljs bash">&lt;dubbo:reference interface=<span class="hljs-string">&quot;org.common.service.UserService&quot;</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;userService&quot;</span> check=<span class="hljs-string">&quot;false&quot;</span>/&gt;

@DubboReference(check = <span class="hljs-literal">false</span>)</code></pre></div></li><li><p>方案 3：也可以考虑在消费方的 Dubbo XML 配置文件中，为整个消费方添加check="false" 的属性，来达到启动不检查服务的目的，即</p><div class="code-wrapper"><pre><code class="hljs bash">&lt;!-- 为整个消费方添加启动不检查提供方服务是否正常 --&gt;
&lt;dubbo:consumer check=<span class="hljs-string">&quot;false&quot;</span>&gt;&lt;/dubbo:consumer&gt;
或
dubbo:
  consumer:
    check: <span class="hljs-literal">false</span></code></pre></div></li></ul><p>三种方法分析：</p><ul><li>方案 1，耦合性太强，因为提供方没有发布服务而导致消费方无法启动，有点说不过去。</li><li>方案 2，需要针对指定的服务级别设置“启动不检查”，但一个消费方工程，会有几十上百甚至 上千个提供方服务配置，一个个设置起来特别麻烦，而且一般我们也很少会逐个设置。</li><li>方案 3，是我们比较常用的一种设置方式，保证不论提供方的服务处于何种状态，都不能影响消费方的启动，而且只需要一条配置，没有方案 2 需要给很多个提供方服务挨个配置的困扰。</li></ul><h4 id="超时重试">超时重试</h4><p>Dubbo 中超时配置是保障分布式系统稳定性的核心机制。其中超时时间默认值为1000ms，超时后会默认重试2次（不包括第一次的调用）。</p><p>通过<code>timeout</code>参数，在服务<strong>提供方</strong>和服务<strong>调用方</strong>中的<u>方法级</u>、<u>接口级</u>和<u>全局</u>配置超时时间。</p><p>通过<code>reties</code>参数，在服务<strong>调用方</strong>的<u>方法级</u>、<u>接口级</u>和<u>全局</u>配置重试次数</p><p>配置覆盖规则如下：</p><ul><li><p>细粒度优先（方法级 &gt; 接口级 &gt; 全局&gt;默认）</p></li><li><p>消费者优先（同一级别下，消费方 &gt; 提供方）</p></li><li><p>配置中心可实时覆盖所有本地配置</p></li></ul><hr><p>服务提供方中配置超时：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#全局配置</span>
&lt;dubbo:provider <span class="hljs-built_in">timeout</span>=<span class="hljs-string">&quot;5000&quot;</span>/&gt;

dubbo:
  provider:
    <span class="hljs-built_in">timeout</span>: 5000

<span class="hljs-comment">#接口级配置</span>
&lt;dubbo:service interface=<span class="hljs-string">&quot;org.common.service.UserService&quot;</span> ref=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-built_in">timeout</span>=<span class="hljs-string">&quot;5000&quot;</span>/&gt;

@DubboService(<span class="hljs-built_in">timeout</span> = 5000)

<span class="hljs-comment">#方法级配置</span>
&lt;dubbo:service interface=<span class="hljs-string">&quot;org.common.service.UserService&quot;</span> ref=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-built_in">timeout</span>=<span class="hljs-string">&quot;5000&quot;</span>&gt;
	&lt;dubbo:method name=<span class="hljs-string">&quot;login&quot;</span> <span class="hljs-built_in">timeout</span>=<span class="hljs-string">&quot;5000&quot;</span>/&gt;
&lt;/dubbo:service&gt;

@DubboService(methods = &#123;@Method(name = <span class="hljs-string">&quot;login&quot;</span>,<span class="hljs-built_in">timeout</span> = 2000)&#125;)</code></pre></div><p>服务调用方中配置超时：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#全局</span>
&lt;dubbo:consumer <span class="hljs-built_in">timeout</span>=<span class="hljs-string">&quot;5000&quot;</span> retries=<span class="hljs-string">&quot;5&quot;</span>/&gt;

dubbo:
  consumer:
    retries: 4
    <span class="hljs-built_in">timeout</span>: 5000

<span class="hljs-comment">#接口级</span>
&lt;dubbo:reference interface=<span class="hljs-string">&quot;org.common.service.UserService&quot;</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-built_in">timeout</span>=<span class="hljs-string">&quot;5000&quot;</span> retries=<span class="hljs-string">&quot;5&quot;</span>/&gt;

@DubboReference(interfaceClass = UserService.class,<span class="hljs-built_in">timeout</span> = 3000, retries=5)

<span class="hljs-comment">#方法级</span>
&lt;dubbo:reference interface=<span class="hljs-string">&quot;com.service.OrderService&quot;</span> retries=<span class="hljs-string">&quot;1&quot;</span>&gt;
    &lt;dubbo:method name=<span class="hljs-string">&quot;createOrder&quot;</span> retries=<span class="hljs-string">&quot;3&quot;</span>/&gt;
&lt;/dubbo:reference&gt;

@Reference(
    retries = 0,  // 接口级
    methods = &#123;@Method(name = <span class="hljs-string">&quot;login&quot;</span>,<span class="hljs-built_in">timeout</span> = 5000,retries = 5)&#125; // 方法级
)</code></pre></div><p>在集群模式下，Dubbo 通过 集群容错策略 控制重试行为，通过<code>cluster</code>属性指定重试行为。默认是 failover，即失败后自动切换提供者重试。常用的容错策略如下：</p><p><img src="D:%5CDesktop%5C5f3f4b1b-dd06-4470-9738-c96a11e17af0.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><p>重试要遵循三大黄金原则：</p><ol type="1"><li><strong>写操作禁用重试</strong>（保证幂等性）</li><li><strong>读操作合理重试</strong>（结合超时时间）</li><li><strong>动态策略调整</strong>（根据监控实时优化）</li></ol><p>重试带来的风险及防护方法：</p><ul><li><p>幂等性风险</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 危险操作：非幂等方法重试导致重复扣款</span>
<span class="hljs-meta">@Reference(retries = 3)</span>
AccountService.withdraw(amount);</code></pre></div><p>解决：写操作强制设置 <code>retries = 0</code>，或者在服务端实现幂等校验（如唯一流水号）</p></li><li><p>级联雪崩</p><p>触发条件：下游服务C响应变慢或故障，上游服务A配置了高重试。最终B线程池被阻塞 ，导致 A调用B也开始超时。</p><p>解决方案：</p><ul><li><p>合理设置重试次数和超时时间，使最大总耗时 ≤ 上级服务超时时间 * 0.7</p></li><li><p>熔断器模式，设置熔断策略：如当错误率&gt;=50%，熔断5s，半开状态放行少量请求探测</p></li></ul></li><li><p>重试风暴</p><p>触发条件：某服务出现短暂故障（如GC暂停），服务恢复瞬间遭遇海量重试请求</p><p>解决：</p><ul><li>采用随机退避算法，避免大量请求同时到达</li><li>服务端采用令牌桶算法控制重试速率</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">dubbo:</span>
  <span class="hljs-attr">consumer:</span>
    <span class="hljs-comment"># 核心防护三件套</span>
    <span class="hljs-attr">retries:</span> <span class="hljs-number">2</span>
    <span class="hljs-attr">timeout:</span> <span class="hljs-number">1000</span>
    <span class="hljs-attr">circuit-breaker:</span> <span class="hljs-string">sentinel</span>  
    
    <span class="hljs-comment"># 重试策略优化</span>
    <span class="hljs-attr">retry-backoff-multiplier:</span> <span class="hljs-number">1.5</span>  <span class="hljs-comment"># 退避系数</span>
    <span class="hljs-attr">max-retry-delay:</span> <span class="hljs-number">3000</span>          <span class="hljs-comment"># 最大退避时间</span>
    
    <span class="hljs-comment"># 资源隔离</span>
    <span class="hljs-attr">threadpool:</span> <span class="hljs-string">fixed</span>
    <span class="hljs-attr">threads:</span> <span class="hljs-number">200</span></code></pre></div><h4 id="多版本">多版本</h4><p>当一个接口实现，出现不兼容升级时，可以用<strong>版本号</strong>过渡，版本号不同的服务相互间不引用。通过<code>version</code>属性设置接口的版本。</p><p>使用多版本可以完成版本迁移：</p><ol type="1"><li><p>在低压力时间段，先升级一半提供者为新版本</p></li><li><p>再将所有消费者升级为新版本</p></li><li><p>然后将剩下的一半提供者升级为新版本</p></li></ol><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#服务提供方</span>
&lt;dubbo:service interface=<span class="hljs-string">&quot;org.common.service.UserService&quot;</span> ref=<span class="hljs-string">&quot;userService&quot;</span> version=<span class="hljs-string">&quot;2.0&quot;</span>&gt;

@DubboService(version = <span class="hljs-string">&quot;2.0&quot;</span>)

<span class="hljs-comment">#服务调用方</span>
&lt;dubbo:reference interface=<span class="hljs-string">&quot;com.service.OrderService&quot;</span> version=<span class="hljs-string">&quot;2.0&quot;</span>&gt;

@DubboReference(version = <span class="hljs-string">&quot;2.0&quot;</span>)</code></pre></div><h4 id="本地存根">本地存根</h4><p>远程服务后，客户端通常只剩下接口，而实现全在服务器端，但提供方有些时候想在客户端也执行部分逻辑，比如：做ThreadLocal缓存，提前验证参数，调用失败后伪造容错数据等等，此时就需要在API中带上Stub，客户端生成Proxy实例，会把Proxy通过构造函数传给Stub，然后把Stub暴露给用户，Stub可以决定要不要去调 Proxy。</p><p>本质：在客户端生成的代理类中插入自定义逻辑</p><p>使用场景：</p><ul><li><strong>服务降级</strong>：当远程服务调用失败时，返回默认值或缓存数据。</li><li><strong>数据预热</strong>：在系统启动时，通过本地存根加载缓存数据。</li><li><strong>参数校验</strong>：在发起远程调用前，先在本地进行参数校验，避免无效的远程调用。</li><li><strong>日志记录</strong>：在调用前后记录日志，用于调试或监控。</li></ul><p>本地存根类的实现要求：</p><ul><li>本地存根类必须实现服务接口</li><li>必须有一个带有远程服务代理对象作为参数的构造函数。</li><li>在实现方法中，可以通过调用远程服务代理对象执行真正的远程调用，并在需要时添加本地逻辑。</li></ul><p>示例：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceStub</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserService userService;

    <span class="hljs-comment">// 必须包含此构造函数</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceStub</span><span class="hljs-params">(UserService userService)</span> &#123;
        <span class="hljs-built_in">this</span>.userService = userService;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String userName, String password)</span> &#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//1.本地预处理，参数校验等</span>
            <span class="hljs-keyword">if</span>(StringUtils.isEmpty(userName) || StringUtils.isEmpty(password))
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;用户名，密码格式错误&quot;</span>);
            <span class="hljs-comment">//2. 尝试本地缓存等操作...</span>

            <span class="hljs-comment">//3. 正常调用远程服务</span>
            <span class="hljs-type">boolean</span> <span class="hljs-variable">loginStatus</span> <span class="hljs-operator">=</span> userService.login(userName, password);
            <span class="hljs-comment">//4.后处理，执行添加本地缓存等操作</span>
            <span class="hljs-keyword">return</span> loginStatus;
        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;
            <span class="hljs-comment">// 远程调用失败时，执行本地容错逻辑</span>
            System.out.println(<span class="hljs-string">&quot;xxxxx&quot;</span>);
            <span class="hljs-comment">//降级处理</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        &#125;
    &#125;
&#125;</code></pre></div><p>本地存根的执行流程：</p><ol type="1"><li>客户端发起远程调用。</li><li>本地存根类拦截调用，先执行自定义的前置逻辑（如参数校验）。</li><li>尝试调用远程服务。</li><li>如果远程调用失败（抛出异常），则执行本地存根中的容错逻辑。</li><li>将结果返回给客户端。</li></ol><p>本地存根的配置</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#xml格式</span>
&lt;dubbo:reference interface=<span class="hljs-string">&quot;org.common.service.UserService&quot;</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;userService&quot;</span> stub=<span class="hljs-string">&quot;com.example.UserServiceStub&quot;</span>&gt;

<span class="hljs-comment">#注解格式</span>
@DubboReference(stub = <span class="hljs-string">&quot;com.example.UserServiceStub&quot;</span>)</code></pre></div><p>注意点：</p><ul><li><p>本地存根一般放在commons模块中</p></li><li><p>本地存根类在客户端执行，应避免复杂的业务逻辑，以免影响客户端性能。</p></li><li><p>本地存根适用于需要灵活控制调用过程的场景，如果只是简单的返回默认值，可以使用Dubbo的Mock功能（本地伪装）</p></li></ul><h4 id="本地伪装">本地伪装</h4><p>Dubbo 的本地伪装 是一种服务降级容错机制，当远程服务调用失败时，自动触发本地预定义的降级逻辑返回安全结果。</p><p>Mock是一种轻量级的服务降级，常需要在出现 RpcException (比如网络失败，超时等)时进行容错，<strong>它的约定就是只有出现 RpcException 时才执行。</strong></p><p>使用场景包括：</p><ul><li>某服务或接口负荷超出最大承载能力范围，需要进行降级应急处理，避免系统崩溃</li><li>调用的某非关键服务或接口暂时不可用时，返回模拟数据或空，使业务还能继续可用</li><li>降级非核心业务的服务或接口，腾出系统资源，尽量保证核心业务的正常运行</li><li>某上游基础服务超时或不可用时，执行能快速响应的降级预案，避免服务整体雪崩</li></ul><p>Mock类实现规范</p><ul><li>类名以Moc结尾，推荐：[接口名]Mock</li><li>必须实现原始服务接口的所有方法</li><li>为了保证兼容性，写两个构造函数：一个无参构造，一个带有远程服务代理对象作为参数的构造函数</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceMock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceMock</span><span class="hljs-params">()</span>&#123;&#125;
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserServiceMock</span><span class="hljs-params">(UserService userService)</span> &#123;
        <span class="hljs-comment">// 通常不需要真实服务实例</span>
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(Long id)</span> &#123;
        <span class="hljs-comment">// 返回降级数据</span>
        <span class="hljs-keyword">return</span> User.DEFAULT_USER; 
    &#125;
    
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">listUsers</span><span class="hljs-params">()</span> &#123;
        <span class="hljs-comment">// 返回空集合避免NPE</span>
        <span class="hljs-keyword">return</span> Collections.emptyList(); 
    &#125;
&#125;
</code></pre></div><p>配置Mock</p><ul><li><p>XML格式</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 方法级Mock --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.example.UserService&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;getUser&quot;</span> <span class="hljs-attr">mock</span>=<span class="hljs-string">&quot;com.example.UserServiceMock&quot;</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span>

<span class="hljs-comment">&lt;!-- 接口级Mock（所有方法生效） --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;com.example.OrderService&quot;</span> </span>
<span class="hljs-tag">                <span class="hljs-attr">mock</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 默认查找OrderServiceMock类 --&gt;</span>
</code></pre></div></li><li><p>注解格式</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@DubboReference(mock = &quot;com.example.PaymentServiceMock&quot;)</span>
<span class="hljs-keyword">private</span> PaymentService paymentService;

<span class="hljs-comment">// 强制返回固定值</span>
<span class="hljs-meta">@DubboReference(mock = &quot;return null&quot;)</span> 
<span class="hljs-keyword">private</span> CartService cartService;

<span class="hljs-comment">// 抛出业务异常</span>
<span class="hljs-meta">@DubboReference(mock = &quot;throw com.example.ServiceDegradeException&quot;)</span> 
<span class="hljs-keyword">private</span> InventoryService inventoryService;</code></pre></div></li></ul><p>注：</p><ul><li><p>Mock实现类仅消费端可见，一般放在consumer端</p></li><li><p>过度复杂的 Mock 会引发二次故障，保持实现简单到极致，100% 线程安全</p></li></ul><table><thead><tr class="header"><th><strong>维度</strong></th><th>本地伪装 (Mock)</th><th>本地存根 (Stub)</th></tr></thead><tbody><tr class="odd"><td><strong>触发条件</strong></td><td><strong>仅远程调用失败时触发</strong></td><td>每次调用均执行</td></tr><tr class="even"><td><strong>执行位置</strong></td><td>客户端本地</td><td>客户端本地</td></tr><tr class="odd"><td><strong>主要目的</strong></td><td>服务不可用时的降级处理</td><td>增强调用流程（缓存/校验等）</td></tr><tr class="even"><td><strong>依赖远程服务</strong></td><td>不依赖（完全本地执行）</td><td>可能依赖远程服务结果</td></tr><tr class="odd"><td><strong>典型场景</strong></td><td>熔断降级、维护模式</td><td>参数校验、本地缓存</td></tr></tbody></table><h3 id="dubbo-admin安装">Dubbo-admin安装</h3><p>Admin 控制台提供了 Dubbo 集群的可视化视图。</p><p>采用zookeeper作为服务注册中心，使用Docker-Compose安装zookeeper和dubb-admin</p><ol type="1"><li><p>在<code>/usr/local</code>目录下创建<code>zookeeper</code>目录，并在其下创建data、conf、logs目录</p></li><li><p>dubbo-admin镜像版本为0.6.0，从<a target="_blank" rel="noopener" href="https://github.com/apache/dubbo-admin/tree/develop/docker">dubbo-admin</a>仓库下载 0.6.0版本的properties文件</p></li><li><p>创建网络，让两个容器处于同一网络下</p><div class="code-wrapper"><pre><code class="hljs bash">docker network create --driver=bridge dubbo-net</code></pre></div></li><li><p>修改<code>application.properties</code>，设置zookeeper的ip。此处由于同在一个 docker 网络下，所以直接改为容器名。</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># centers in dubbo2.7, if you want to add parameters, please add them to the url</span>
<span class="hljs-attr">admin.registry.address</span>=<span class="hljs-string">zookeeper://zookeeper:2181</span>
<span class="hljs-attr">admin.config-center</span>=<span class="hljs-string">zookeeper://zookeeper:2181</span>
<span class="hljs-attr">admin.metadata-report.address</span>=<span class="hljs-string">zookeeper://zookeeper:2181</span></code></pre></div></li><li><p>创建<code>docker-compose.yml</code>文件，内容如下：</p><div class="code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2.36.0&#x27;</span>  

<span class="hljs-attr">networks:</span>  
  <span class="hljs-attr">dubbo-net:</span>  
    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span>  
    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span>
    
<span class="hljs-attr">services:</span>
  <span class="hljs-attr">zookeeper:</span>  
    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;zookeeper:latest&quot;</span>  
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">&quot;zookeeper&quot;</span>  
    <span class="hljs-attr">ports:</span>  
      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;2181:2181&quot;</span>  
    <span class="hljs-attr">environment:</span>  
      <span class="hljs-attr">TZ:</span> <span class="hljs-string">&quot;Asia/Shanghai&quot;</span>  
    <span class="hljs-attr">volumes:</span>  
      <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/localtime:/etc/localtime:ro</span>  
      <span class="hljs-bullet">-</span> <span class="hljs-string">/usr/local/zookeeper/data:/data</span>
      <span class="hljs-bullet">-</span> <span class="hljs-string">/usr/local/zookeeper/logs:/datalog</span> 
      <span class="hljs-bullet">-</span> <span class="hljs-string">/usr/local/zookeeper/conf:/conf</span>
    <span class="hljs-attr">networks:</span>  
      <span class="hljs-bullet">-</span> <span class="hljs-string">dubbo-net</span> 
  
  <span class="hljs-attr">dubbo-admin:</span>  
    <span class="hljs-attr">image:</span> <span class="hljs-string">&quot;apache/dubbo-admin:latest&quot;</span>  
    <span class="hljs-attr">container_name:</span> <span class="hljs-string">&quot;dubbo-admin&quot;</span>  
    <span class="hljs-attr">environment:</span>  
      <span class="hljs-attr">TZ:</span> <span class="hljs-string">&quot;Asia/Shanghai&quot;</span>  
    <span class="hljs-attr">volumes:</span>  
      <span class="hljs-bullet">-</span> <span class="hljs-string">/etc/localtime:/etc/localtime:ro</span>  
      <span class="hljs-bullet">-</span> <span class="hljs-string">/usr/local/dubbo-admin/properties:/config</span>  
    <span class="hljs-attr">ports:</span>  
      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;38080:38080&quot;</span>  
    <span class="hljs-attr">depends_on:</span>  
      <span class="hljs-bullet">-</span> <span class="hljs-string">zookeeper</span>  
    <span class="hljs-attr">networks:</span>  
      <span class="hljs-bullet">-</span> <span class="hljs-string">dubbo-net</span></code></pre></div></li><li><p>执行<code>docker-compose up -d</code>运行容器</p></li><li><p>访问<code>http://192.168.181.100:38080/</code></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250710110657346-2025-7-1011:07:20.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></li></ol><h2 id="三高可用">三、高可用</h2><h3 id="zookeeper宕机">1、zookeeper宕机</h3><p>若zookeeper注册中心宕机，还可以消费 dubbo 暴露的服务。</p><h3 id="负载均衡">2、负载均衡</h3><p><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/what/core-features/load-balance/">官方文档</a></p><p><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/tasks/service-discovery/loadbalance/">Java中配置负载均衡策略</a></p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2025-07-12_23-31-16-2025-7-1223:52:55.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="负载均衡策略"><figcaption aria-hidden="true">负载均衡策略</figcaption></figure><h3 id="服务降级">3、服务降级</h3><p>什么是服务降级？</p><p>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</p><h2 id="四dubbo原理">四、Dubbo原理</h2><h3 id="核心组件">核心组件</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250709110642348-2025-7-911:06:42.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="Dubbo架构" style="zoom:80%"></p><p>其中包括以下模块：</p><ul><li><p>Registry：注册中心</p><p>生产者在此注册并发布内容，消费者在此订阅并接收发布的内容。</p></li><li><p>Provider：服务提供者</p><p>服务端，生产内容，生产前需要依赖容器（先启动容器）。</p></li><li><p>Consumer：服务消费者</p><p>客户端，从注册中心获取到方法，可以调用生产者中的方法。</p></li><li><p>Container：Dubbo框架容器</p><p>生产者在启动执行的时候，必须依赖容器才能正常启动（默认依赖的是spring容器），</p></li><li><p>Monitor：监控中心</p><p>统计服务的调用次数与时间等。</p></li></ul><p>运行流程如下：</p><ol type="1"><li>初始化：<ul><li>Dubbo框架启动</li><li>服务提供者启动时，会将所提供的服务注册到注册中心</li><li>服务消费者启动时，会从注册中心订阅所需要的服务</li></ul></li><li>当某个服务提供者发生了变更，注册中心会基于长连接的方式将变更推送给服务消费者</li><li>服务消费者可以根据负载均衡算法从服务列表中选择所需的服务</li><li>在服务调用过程中，异步地将调用信息发送到监控中心，实时监控服务运行状态</li></ol><h3 id="dubbo架构设计">Dubbo架构设计</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/dubbo-framework-2025-7-1410:25:20.jpg" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="dubbo-framework" style="zoom:80%"></p><h3 id="可扩展机制spi">可扩展机制SPI</h3><h3 id="标签解析">标签解析</h3><p>Dubbo 的标签解析过程基于 <strong>Spring 的自定义 XML 扩展机制</strong>（<code>NamespaceHandler</code> + <code>BeanDefinitionParser</code>），将 XML 配置转换为 Spring 容器管理的 Bean。</p><p>流程如下：</p><ol type="1"><li><p>Spring 扩展机制入口</p><p>Dubbo 在 <code>META-INF/spring.handlers</code> 中声明命名空间处理器：</p><div class="code-wrapper"><pre><code class="hljs java">http\:<span class="hljs-comment">//dubbo.apache.org/schema/dubbo=org.apache.dubbo.config.spring.schema.DubboNamespaceHandler</span>
http\:<span class="hljs-comment">//code.alibabatech.com/schema/dubbo=org.apache.dubbo.config.spring.schema.DubboNamespaceHandler</span></code></pre></div><p>当 Spring 解析到 <code>&lt;dubbo:xxx&gt;</code> 标签，会委托给 <code>DubboNamespaceHandler</code> 处理</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250714103904785-2025-7-1410:39:05.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p></li><li><p>注册标签解析器</p><p>在<code>DubboNamespaceHandler</code>中，会为每个Dubbo标签注册对应的<code>BeanDefinitionParser</code>。每个标签对应一个配置类，在这里定义好了，例如：</p><ul><li><p><code>application</code> -&gt; <code>ApplicationConfig</code></p></li><li><p><code>registry</code> -&gt; <code>RegistryConfig</code></p></li><li><p><code>protocol</code> -&gt; <code>ProtocolConfig</code></p></li><li><p><code>service</code> -&gt; <code>ServiceBean</code></p></li><li><p><code>reference</code> -&gt; <code>ReferenceBean</code></p></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;
    registerBeanDefinitionParser(<span class="hljs-string">&quot;application&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboBeanDefinitionParser</span>(ApplicationConfig.class));
    registerBeanDefinitionParser(<span class="hljs-string">&quot;module&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboBeanDefinitionParser</span>(ModuleConfig.class));
    registerBeanDefinitionParser(<span class="hljs-string">&quot;registry&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboBeanDefinitionParser</span>(RegistryConfig.class));
    registerBeanDefinitionParser(<span class="hljs-string">&quot;config-center&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboBeanDefinitionParser</span>(ConfigCenterBean.class));
    registerBeanDefinitionParser(<span class="hljs-string">&quot;metadata-report&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboBeanDefinitionParser</span>(MetadataReportConfig.class));
    registerBeanDefinitionParser(<span class="hljs-string">&quot;monitor&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboBeanDefinitionParser</span>(MonitorConfig.class));
    registerBeanDefinitionParser(<span class="hljs-string">&quot;metrics&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboBeanDefinitionParser</span>(MetricsConfig.class));
    registerBeanDefinitionParser(<span class="hljs-string">&quot;tracing&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboBeanDefinitionParser</span>(TracingConfig.class));
    registerBeanDefinitionParser(<span class="hljs-string">&quot;ssl&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboBeanDefinitionParser</span>(SslConfig.class));
    registerBeanDefinitionParser(<span class="hljs-string">&quot;provider&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboBeanDefinitionParser</span>(ProviderConfig.class));
    registerBeanDefinitionParser(<span class="hljs-string">&quot;consumer&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboBeanDefinitionParser</span>(ConsumerConfig.class));
    registerBeanDefinitionParser(<span class="hljs-string">&quot;protocol&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboBeanDefinitionParser</span>(ProtocolConfig.class));
    registerBeanDefinitionParser(<span class="hljs-string">&quot;service&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboBeanDefinitionParser</span>(ServiceBean.class));
    registerBeanDefinitionParser(<span class="hljs-string">&quot;reference&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DubboBeanDefinitionParser</span>(ReferenceBean.class));
    registerBeanDefinitionParser(<span class="hljs-string">&quot;annotation&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationBeanDefinitionParser</span>());
&#125;</code></pre></div></li><li><p>解析标签</p><p>当 Spring 遇到标签时，会调用相应解析器的 <code>DubboBeanDefinitionParser.parse()</code> 方法，根据标签对应的配置类创建 Spring 的 <code>RootBeanDefinition</code>，用于存储 Bean 的定义信息。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">DubboBeanDefinitionParser</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> &#123;
    <span class="hljs-built_in">this</span>.beanClass = beanClass;
&#125;
 <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> RootBeanDefinition <span class="hljs-title function_">parse</span><span class="hljs-params">(Element element, ParserContext parserContext, Class&lt;?&gt; beanClass, <span class="hljs-type">boolean</span> registered)</span> &#123;
        <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>();
        beanDefinition.setBeanClass(beanClass);
        beanDefinition.setLazyInit(<span class="hljs-literal">false</span>);
  <span class="hljs-comment">//....</span>
 &#125;</code></pre></div><p>将 XML 标签属性映射到 Bean 的属性：</p></li></ol><h3 id="服务暴露流程">服务暴露流程</h3><h3 id="服务引用流程">服务引用流程</h3><h3 id="服务调用流程">服务调用流程</h3><p>在Dubbo RPC直连应用中，Consumer直接访问Provider，而无需注册中心的接入，此时Dubbo完成的仅仅是RPC最基本的功能。从这个角度Dubbo RPC直连等价于SpringCloud体系中的OpenFeign，但OpenFeign效率较低。</p><p>RPC直连设计的核心概念</p><ul><li>Provider 服务的提供者</li><li>Consumer 服务的访问者</li><li>网络通信</li></ul><p>其中在网络通信中涉及三个重要内容：协议、服务器（通信方式）、序列化</p><ul><li><p>协议：定义通信双方的数据格式、传输顺序、错误处理等规则。包含：</p><ul><li>应用层协议：http1.x、http2.x</li><li>传输层协议：是一种私有协议，如dubbo、triple</li></ul><p>Dubbo既支持应用层的公有协议，也支持私有协议，可以在配置文件中指定</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;-1&quot;</span>/&gt;</span>
或
dubbo:
  protocol:
    name: dubbo
    port: -1</code></pre></div></li><li><p>通信方式</p><ul><li>若采用了传输层协议，则通信方式包括：BIO、NIO、Netty、Mina等</li><li>若采用了应用层协议，则通信方式包括：Tomcat、Resin、Jetty</li></ul><p>Dubbo内置默认通信方式是Netty4，可以在配置文件中通过transporter属性指定其他的方式</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;-1&quot;</span> <span class="hljs-attr">transporter</span>=<span class="hljs-string">&quot;Mina&quot;</span>/&gt;</span>
或
dubbo:
  protocol:
    name: dubbo
    port: -1
    transporter: Mina</code></pre></div></li><li><p>序列化：确定了数据、通信协议和通信方式，就可以进行网络数据传输了，但是若对数据不进行序列化就进行传输，则数据文件体积很大，网络传输效率低。序列化扮演者数据桥梁的核心角色，它实现了内存对象与网络传输二进制流之间的双向转换，好的序列化方式，所传输数据的体积小，速度快。</p><p>在Dubbo 3.2版本前默认的序列化方式是Hassian，之后版本的默认方式是FastJson2，可以在配置文件的serialization属性设置序列化方式</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;-1&quot;</span> <span class="hljs-attr">serialization</span>=<span class="hljs-string">&quot;hassian&quot;</span>/&gt;</span>
或
dubbo:
  protocol:
    name: dubbo
    port: -1
    serialization: hassian</code></pre></div></li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250711224736865-2025-7-1122:47:38.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="zoom:80%"></p><h3 id="序列化">序列化</h3><p>序列化：是Dubbo进行RPC中，非常重要的一个组成部分，其核心作用就是把网络传输中的数据，按照特定的格式进行传输。减小数据的体积，从而提高传输效率。</p><figure><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250711224952329-2025-7-1122:49:53.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="Dubbo序列化设计"><figcaption aria-hidden="true">Dubbo序列化设计</figcaption></figure><p>常见的Dubbo序列化方式：</p><ol type="1"><li><p>Hessian</p><p>Dubbo协议中默认的序列化实现方案</p></li><li><p>Java Serialization</p><p>JDK的序列化方式</p></li><li><p>Dubbo序列化 阿里尚未开发成熟的高效java序列化实现，阿里不建议在生产环境使用它。</p></li><li><p>Json序列化 目前有两种实现，一种是采用的阿里的fastison库，另一种是采用dubbo中自己实现的简单json库。</p></li><li><p>Kryo</p><p>Java序列化方式，后续替换Hessian2，是一种非常成熟的序列化实现，已经在Twitter、Groupon、Yahoo以及多个著名开源项目（如Hive，Storm）中广泛的使用。</p></li><li><p>FST</p><p>Java序列化方式，后续替换Hessian2，是一种较新的序列化实现，目前还缺乏足够多的成熟使用案例。</p></li><li><p>跨语言序列化方式 ProtoBuf，Thrift，Avro，MsgPack（MessagePack是一种高效的二进制序列化格式。它允许您在多种语言（如JSON）之间交换数据。但它更快更小。短整型被编码成一个字节）</p></li></ol><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250711225541100-2025-7-1122:56:02.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="Dubbo常见序列化方式效果对比" style="zoom:80%"></p><h4 id="kryo序列化">Kryo序列化</h4><ol type="1"><li><p>引入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-serialization-kryo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-comment">&lt;!--不引入dubbo-common模块，在Dubbo依赖中已经引入过了，会发生冲突--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>Provider端配置序列化方式</p><div class="code-wrapper"><pre><code class="hljs bash">&lt;dubbo:protocol name=<span class="hljs-string">&quot;dubbo&quot;</span> port=<span class="hljs-string">&quot;-1&quot;</span> serialization=<span class="hljs-string">&quot;kryo&quot;</span>/&gt;
或者
dubbo:
  protocol:
    name: dubbo
    port: -1
    serialization: kryo</code></pre></div></li><li><p>Consumer端调用</p><p>在调用的URL中添加参数 <code>serialization=kryo</code>。</p><p>后续如果引入注册中心 url就可以不写。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#xml格式</span>
&lt;dubbo:reference interface=<span class="hljs-string">&quot;org.common.service.UserService&quot;</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;userService&quot;</span> url=<span class="hljs-string">&quot;dubbo://192.168.72.1:20880/org.common.service.UserService?serialization=kryo&quot;</span>/&gt;

<span class="hljs-comment">#注解方式</span>
@DubboReference(url = <span class="hljs-string">&quot;dubbo://192.168.72.1:20880/org.common.service.UserService?serialization=kryo&quot;</span>)</code></pre></div></li></ol><h4 id="fst序列化">FST序列化</h4><p>与kryo的方式一模一样</p><ol type="1"><li><p>引入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-serialization-fst<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>provider端配置序列化方式</p><div class="code-wrapper"><pre><code class="hljs bash">&lt;dubbo:protocol name=<span class="hljs-string">&quot;dubbo&quot;</span> port=<span class="hljs-string">&quot;-1&quot;</span> serialization=<span class="hljs-string">&quot;fst&quot;</span>/&gt;
或者
dubbo:
  protocol:
    name: dubbo
    port: -1
    serialization: fst</code></pre></div></li><li><p>Consumer端调用</p><p>在调用的URL中添加参数 <code>serialization=fst</code>。</p><p>后续如果引入注册中心 url就可以不写。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#xml格式</span>
&lt;dubbo:reference interface=<span class="hljs-string">&quot;org.common.service.UserService&quot;</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;userService&quot;</span> url=<span class="hljs-string">&quot;dubbo://192.168.72.1:20880/org.common.service.UserService?serialization=fst&quot;</span>/&gt;

<span class="hljs-comment">#注解方式</span>
@DubboReference(url = <span class="hljs-string">&quot;dubbo://192.168.72.1:20880/org.common.service.UserService?serialization=fst&quot;</span>)</code></pre></div></li></ol><h4 id="fastjson2序列化">FastJson2序列化</h4><p>Fastjson2序列化仅Dubbo&gt;3.1.0版本支持，在Dubbo&gt;3.2.0中将替代Hessain作为默认序列化方式</p><p>若使用的Dubbo的版本在3.1.0~3.2.0之间，可以设置序列化方式为FastJson2，设置方式与前面完全一样</p><ol type="1"><li><p>引入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.fastjson2<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fastjson2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>provider端配置序列化方式</p><div class="code-wrapper"><pre><code class="hljs bash">&lt;dubbo:protocol name=<span class="hljs-string">&quot;dubbo&quot;</span> port=<span class="hljs-string">&quot;-1&quot;</span> serialization=<span class="hljs-string">&quot;fastjson2&quot;</span>/&gt;
或者
dubbo:
  protocol:
    name: dubbo
    port: -1
    serialization: fastjson2</code></pre></div></li><li><p>Consumer端调用</p><p>在调用的URL中添加参数 <code>serialization=fst</code>。</p><p>后续如果引入注册中心 url就可以不写。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#xml格式</span>
&lt;dubbo:reference interface=<span class="hljs-string">&quot;org.common.service.UserService&quot;</span> <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;userService&quot;</span> url=<span class="hljs-string">&quot;dubbo://192.168.72.1:20880/org.common.service.UserService?serialization=fst&quot;</span>/&gt;

<span class="hljs-comment">#注解方式</span>
@DubboReference(url = <span class="hljs-string">&quot;dubbo://192.168.72.1:20880/org.common.service.UserService?serialization=fst&quot;</span>)</code></pre></div></li></ol><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="category-chain-item">微服务</a></span></span></div></div><div class="license-box my-3"><div class="license-title"><div>Dubbo</div><div>https://catpaws.top/f6253398/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>猫爪在上</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2025年7月9日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/4f3efbd5/" title="三、哈希表"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">三、哈希表</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/f5f9fa9b/" title="Docker"><span class="hidden-mobile">Docker</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="twikoo"></div><script type="text/javascript">Fluid.utils.loadComments("#comments",(function(){Fluid.utils.createScript("https://catpaws.top/blog-resource/twikoo1.6.42/twikoo.all.min.js",(function(){var t=Object.assign({envId:"https://catpaws-comments.netlify.app/.netlify/functions/twikoo",region:"ap-shanghai",path:"window.location.pathname"},{el:"#twikoo",path:"window.location.pathname",onCommentLoaded:function(){Fluid.utils.listenDOMLoaded((function(){var t="#twikoo .tk-content img:not(.tk-owo-emotion)";Fluid.plugins.imageCaption(t),Fluid.plugins.fancyBox(t)}))}});twikoo.init(t)}))}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",(function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded((function(){Fluid.events.registerRefreshCallback((function(){"mermaid"in window&&mermaid.init()}))}))}))</script><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content">人山人海，欢迎你的到来 <i class="iconfont icon-love"></i><br><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><br><span><a target="_blank" rel="noopener" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral">本站由<img src="/img/upyun_logo.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload style="width:auto;height:auto">提供CDN加速/云存储服务</a></span></div><div class="beian"><span><a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">陕ICP备2025059828号 </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=61032302000087" rel="nofollow noopener" class="beian-police" target="_blank"><span style="visibility:hidden;width:0">|</span> <img src="/img/police_beian.png" srcset="https://catpaws.top/blog-resource/imgs/transparent.svg" lazyload alt="police-icon"> <span>陕公网安备61032302000087号</span></a></span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="//catpaws.top/blog-resource/js/timeDate.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script><script src="//catpaws.top/blog-resource/js/loader.js"></script><script src="//catpaws.top/blog-resource/js/blurpicload.js"></script><script src="//catpaws.top/blog-resource/js/axios.min.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script data-pjax src="https://catpaws.top/blog-resource/live2d/index.min.js"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!1,models:[{path:"https://catpaws.top/blog-resource/live2d/Frieren/Frieren.model3.json",motionPreloadStrategy:"IDLE",position:[-60,-100],scale:.06,stageStyle:{width:250,height:350}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:!1,tips:{style:{width:200,height:90,left:"calc(50% - 20px)",top:"-100px","font-size":"14px"}}})</script></body></html>