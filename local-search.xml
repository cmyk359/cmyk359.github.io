<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM学习</title>
    <link href="/f0242a65/"/>
    <url>/f0242a65/</url>
    
    <content type="html"><![CDATA[<meta name = "referrer", content = "no-referrer"/><h2 id="一jvm概述">一、JVM概述</h2><p>JVM，即<code>Java Virtual Machine</code>，是java程序的运行环境（java<u>二进制字节码</u>的运行环境）。Java虚拟机负责装载字节码到其内部，解释/编译为对应平台上的机器码指令执行</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250110105402958-2025-1-1116:57:19.png"alt="image-20250110105402958" /><figcaption aria-hidden="true">image-20250110105402958</figcaption></figure><h3 id="jvm的特点">1.1、JVM的特点</h3><p>‌<strong>1. 跨平台性</strong>‌：JVM通过解释执行字节码指令，实现了Java程序的跨平台性。由于Java字节码是与平台无关的中间代码，所以Java程序可以在任何安装了JVM的平台上运行，实现了“一次编写，到处运行”的特性‌</p><p>‌<strong>2. 自动内存管理</strong>‌：JVM提供了自动内存管理功能，包括垃圾回收机制，用于回收不再使用的内存对象，防止内存泄漏和碎片化。这一特性极大地减轻了开发人员的负担，使他们可以更加专注于业务逻辑的实现‌</p><p>‌<strong>3. 安全性</strong>‌：JVM通过字节码验证、类加载机制等手段保证程序的安全性和稳定性。这些机制确保了只有经过验证的字节码才能在JVM上执行，从而防止了恶意代码的执行‌</p><p><strong>4. 高性能</strong>‌：JVM通常包含即时编译器（JIT），它负责将热点代码（经常执行的代码）编译为本地机器码，以提高程序的执行效率。这使得Java程序在运行时能够获得接近本地代码的性能‌</p><p>‌<strong>5. 多态性</strong>‌：JVM支持多态性，允许通过相同的接口实现不同的实例，从而完成不同的业务操作。这一特性增强了Java程序的灵活性和可扩展性‌</p><blockquote><p><strong>区分：jvm和jdk、jre</strong></p><p>Jdk中包括了Jre，Jre中包括了JVM。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240801170549707-2024-8-117:06:24.png"alt="image-20240801170549707" /><figcaption aria-hidden="true">image-20240801170549707</figcaption></figure></blockquote><h3 id="常见的jvm">1.2 常见的JVM</h3><p>​ <imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250110105646605-2025-1-1010:56:57.png"alt="image-20250110105646605" /></p><h3 id="jvm组成部分">1.3、JVM组成部分</h3><ol type="1"><li>类加载器</li><li>运行时数据区（JVM内存结构）</li><li>执行引擎</li><li>本地库接口</li></ol><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240801171503494-2025-1-1116:57:00.png"alt="JVM结构" /><figcaption aria-hidden="true">JVM结构</figcaption></figure><blockquote><p>​ 程序在执行之前先要把 java 代码转换成字节码（class 文件），jvm首先需要把字节码通过一定的方式 <strong>类加载器（ClassLoader）</strong>把文件加载到内存中的<strong>运行时数据区（Runtime Data Area）</strong>，而字节码文件是 jvm的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器<strong>执行引擎（Execution Engine）</strong>将字节码翻译成底层系统指令再交由CPU去执行，而这个过程中可能需要调用其他语言的接口<strong>本地库接口（Native Interface）</strong>来实现整个程序的功能，这就是这 4 个主要组成部分的职责与功能。 ​而我们通常所说的 JVM 组成指的是 运行时数据区（Runtime Data Area），因为通常需要程序员调试分析的区域就是“运行时数据区”，或者更具体的来说就是“运行时数据区”里面的Heap（堆）模块。</p></blockquote><h2 id="二运行时数据区">二、运行时数据区</h2><h3 id="程序计数器">2.1、程序计数器</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250111170023475-2025-1-1117:00:24.png"alt="程序计数器在JVM中的位置" /><figcaption aria-hidden="true">程序计数器在JVM中的位置</figcaption></figure><p>http://img.catpaws.top/img/image-20250111170023475-2025-1-1117_00_24.png</p><p>image-20250111170023475-2025-1-1117_00_24.png</p><p>Program Counter Register程序计数器（寄存器）</p><p>作用：记住下一条<strong>JVM指令</strong>的执行地址。</p><p>特点：</p><ul><li><p>是<strong>线程私有的</strong>。</p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程中的指令。因此，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储。</strong>称之为“线程私有”的内存。</p></li><li><p>不会存在内存溢出</p><p>程序计数器内存区域是虚拟机中唯一没有规定OutOfMemoryError情况的区域。</p></li></ul><h3 id="虚拟机栈">2.2、虚拟机栈</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250111170226869-2025-1-1117:02:27.png"alt="虚拟机栈在JVM中的位置" /><figcaption aria-hidden="true">虚拟机栈在JVM中的位置</figcaption></figure><p>Java 虚拟机栈：Java Virtual MachineStacks，是<strong>每个线程运行时所需要的内存</strong>。</p><ul><li>每个栈由多个<strong>栈帧（Frame）</strong>组成，是每次<strong>方法调用时所占用的内存</strong>，包括参数、局部变量，返回地址等。</li><li>虚拟机栈是<strong>每个线程私有的</strong>，每个线程运行时只能有一个活动栈帧，对应着当前正在执行的那个方法。</li></ul><blockquote><p>虚拟机栈中的栈帧（StackFrame）是方法执行的基本单位。每当一个方法被调用时，都会在虚拟机栈中创建一个新的栈帧，该栈帧成为当前活动栈帧，用于存储该方法的局部变量、操作数栈等信息。当方法执行完成后，对应的栈帧会被移除，控制权回到前一个栈帧。</p></blockquote><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250110111943565-2025-1-1011:19:44.png" alt="image-20250110111943565" style="zoom:80%;" /></p><h4 id="问题辨析">问题辨析</h4><ul><li><p>垃圾回收是否涉及栈内存？</p><p>不涉及。每个线程所分配的栈内存由一次次的方法调用产生的栈帧内存组成，而栈帧内存在每次方法调用结束后就会出栈释放，故不需要垃圾回收来管理栈内存。垃圾回收只是回收堆内存中的无用对象。</p></li><li><p>栈分配地越大越好吗？</p><p>不是。在运行java代码时可以通过虚拟机参数<code>-Xss size</code>指定栈内存的大小，<strong>栈内存划分地越大，可以增加方法调用的次数，不会提高运行效率，反而会让可以分配的线程数变少</strong>。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240801182419579-2024-8-118:24:28.png"alt="image-20240801182419579" /><figcaption aria-hidden="true">image-20240801182419579</figcaption></figure></li><li><p>方法内部的局部变量是否线程安全？</p><ul><li>如果方法内局部变量没有逃离方法的作用范围，它是线程安全的（不会被其他线程所访问），如只在方法内部进行打印、运算等操作；超出范围，如被return，作为其他方法的参数等，就需要进线程安全相关控制。</li><li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全。</li></ul></li></ul><h4 id="栈内存溢出问题">栈内存溢出问题</h4><p><code>java.lang.StackOverflowError</code>，可能引起该异常的原因：</p><ul><li>栈帧过多导致栈内存溢出，如递归调用时没有设置正确的返回条件，进行若干次调用后导致栈溢出</li><li>栈帧过大导致栈内存溢出（不常出现）。</li></ul><h4 id="线程运行诊断">线程运行诊断</h4><p>案例一： CPU占用过多</p><ol type="1"><li><p>使用<code>top</code>命令定位哪个进程对cpu的占用过高，得到该进程的进程号PID</p></li><li><p><code>ps H -eo pid,tid,%cpu | grep 进程id</code>，用ps命令进一步定位是哪个线程引起cpu占用过高，得到其线程号TID</p></li><li><p>使用<code>jstack 进程id</code>，列出该进程中所有的java线程，包括虚拟机的线程和用户定义的线程。</p><p>可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240801185543016-2024-8-118:55:43.png"alt="image-20240801185543016" /><figcaption aria-hidden="true">image-20240801185543016</figcaption></figure></li></ol><p>案例二：程序运行很长时间没有结果</p><p>使用<code>jstack</code>工具检查死锁情况。</p><p>首先通过<code>top</code>命令得到cpu占用过高进程的PID，再使用<code>jstack PID</code>检查有无死锁情况。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240801190456065-2024-8-119:05:43.png"alt="image-20240801190456065" /><figcaption aria-hidden="true">image-20240801190456065</figcaption></figure><h3 id="本地方法栈">2.3、本地方法栈</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250111170334787-2025-1-1117:03:35.png"alt="本地方法栈在JVM中的位置" /><figcaption aria-hidden="true">本地方法栈在JVM中的位置</figcaption></figure><p><strong>本地方法栈</strong>的主要作用是<strong>支持本地方法的执行</strong>，为本地方法的运行提供内存空间。这些本地方法通常是用非Java语言（如C、C++）编写的，并通过JavaNativeInterface（JNI）或其他方式被Java程序调用。由于Java本身是跨平台的，有些操作无法直接用Java代码实现，因此需要通过本地方法来完成。</p><p>在Java中，<code>native</code>关键字用于声明一个方法是由本地代码（通常是用C或C++编写的）实现的，而不是由Java代码实现的。如<code>Object</code>类中的<code>clone</code>和<code>hashcode</code>等方法都是本地方法：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250111171412264-2025-1-1117:14:13.png"alt="image-20250111171412264" /><figcaption aria-hidden="true">image-20250111171412264</figcaption></figure><p>特点：</p><ul><li><p>‌<strong>线程私有</strong>‌：每个线程在执行本地方法时都会分配独立的本地方法栈空间，因此本地方法栈是线程私有的。</p></li><li><p>‌<strong>动态增长和收缩</strong>‌：根据需要，本地方法栈可以动态地增长和收缩。</p></li></ul><p>本地方法栈与Java栈的区别</p><ol type="1"><li>‌<strong>目的</strong>‌：Java虚拟机栈用于支持Java方法的调用，而本地方法栈用于支持本地方法的调用。</li><li>‌<strong>数据结构</strong>‌：Java虚拟机栈中的栈帧包含局部变量表、操作数栈等，而本地方法栈中的栈帧则可能包含本地方法特有的数据结构。</li><li>‌<strong>执行环境</strong>‌：Java虚拟机栈中的方法在JVM中执行，而本地方法栈中的方法则在本地环境中执行。</li></ol><h3 id="堆">2.4、堆</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250111171542343-2025-1-1117:15:43.png"alt="堆在JVM中的位置" /><figcaption aria-hidden="true">堆在JVM中的位置</figcaption></figure><h4 id="定义">定义</h4><p>通过 <code>new</code> 关键字，创建对象都会使用堆内存。</p><p>特点</p><ul><li>它是<strong>线程共享</strong>的，堆中对象都需要考虑线程安全的问题。</li><li>有垃圾回收机制。堆是JVM中管理的<strong>最大</strong>一块内存区域，<strong>是GC( Garbage Collection，垃圾收集器)执行垃圾回收的重点区域。</strong></li></ul><h4 id="堆内存的划分">堆内存的划分</h4><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250115141508944-2025-1-1514:15:14.png"alt="JVM内存划分" /><figcaption aria-hidden="true">JVM内存划分</figcaption></figure><p>JVM内存划分为堆内存和非堆内存，堆内存分为新生代（YoungGeneration）、老年代（Old Generation），非堆内存就一个永久代（PermanentGeneration）。</p><p><spanstyle="color : red">新生代</span>是用于存放新创建对象的区域，通常比较小。垃圾回收主要使用<strong>复制算法</strong>。新生代又可以进一步划分为以下三个部分：</p><ul><li><strong>Eden区</strong><ul><li>新创建的对象首先分配在Eden区。</li><li>当Eden区满时，会触发新生代的垃圾回收（<strong>MinorGC</strong>）。</li></ul></li><li><strong>Survivor区（S0和S1）</strong>：<ul><li>新生代中有两个Survivor区，分别称为<strong>From</strong>Space（S0）和<strong>To</strong>Space（S1）。</li><li>在Minor GC时，存活的对象会被复制到其中一个Survivor区。</li><li>经过一定次数的复制后，仍然存活的对象会被移动到老年代。</li></ul></li></ul><p><spanstyle="color : red">老年代</span>用于存放经过多次垃圾回收仍然存活的对象。老年代的特点是对象的生命周期较长，通常是应用程序中长期使用的对象。老年代的内存空间相对较大，垃圾回收（MajorGC）相对复杂，可能会使用标记-清除、标记-压缩等算法。</p><p><span style="color : red">永久代/元空间</span></p><ul><li><strong>永久代（PermGen）</strong>：<ul><li>在Java8之前，JVM使用永久代来存放类的元数据（如类的结构信息、方法等）。</li><li>永久代的大小是固定的，可能会导致<code>OutOfMemoryError</code>，尤其是在动态生成大量类的情况下。</li></ul></li><li><strong>元空间（Metaspace）</strong>：<ul><li>从Java8开始，永久代被元空间取代，元空间的内存不再使用堆内存，而是使用<strong>本地内存</strong></li><li>元空间的大小可以根据需要动态调整，解决了永久代固定大小的限制。</li></ul></li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250115143110584-2025-1-1514:31:25.png" style="zoom:80%;" /></p><blockquote><p><strong>JVM堆内存为什么要分代设计？</strong></p><p>JVM堆内存的分代设计是为了优化垃圾回收过程，基于对象生命周期的特征，能够提高回收效率、降低停顿时间、优化内存管理，并适应不同类型的应用程序。</p><ol type="1"><li><p>基于对象生命周期的特征</p><p>在Java应用程序中，大多数对象的生命周期相对较短。许多对象在创建后不久就会变得不可达，因此将这些短命对象与长命对象分开可以提高垃圾回收的效率。</p><ul><li><strong>新生代</strong>：存放新创建的对象，通常大多数对象在短时间内就会被回收。</li><li><strong>老年代</strong>：存放经过多次垃圾回收仍然存活的对象，这些对象的生命周期较长。</li></ul></li><li><p>分代垃圾回收策略能够针对不同代的对象采用不同的回收策略：</p><ul><li><strong>新生代的回收（MinorGC）</strong>：新生代的垃圾回收通常较快，因为大多数对象是短命的。MinorGC只需遍历Eden区和一个Survivor区，复制存活对象到另一个Survivor区，效率较高。</li><li><strong>老年代的回收（MajorGC）</strong>：老年代的对象通常存活时间较长，老年代的回收相对复杂且耗时。通过将老年代与新生代分开，JVM可以减少对老年代的频繁回收，从而降低停顿时间。</li></ul></li><li><p>降低停顿时间</p><p>分代垃圾回收的设计使得新生代的回收更频繁且快速，而老年代的回收相对少且耗时。这样可以显著降低应用程序的停顿时间，提升用户体验。</p></li><li><p>通过分代，JVM能够更有效地管理内存，减少内存碎片：</p><ul><li>新生代中的对象在MinorGC后被整理到Survivor区，消除了短命对象的内存碎片。</li><li>老年代中的对象经过复杂的回收算法（如标记-清除、标记-压缩）进行整理，减少内存碎片，优化内存使用。</li></ul></li><li><p>适应不同类型的应用</p><p>分代设计使得JVM能够适应不同类型的应用程序，特别是那些有大量短命对象的应用（如Web应用、游戏等）。通过优化新生代的回收策略，能够提高这些应用的性能。</p></li></ol></blockquote><h4 id="存储的内容">存储的内容</h4><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/3ee7f13d62ab1efbf981c6e138eba66f-2025-1-1210:28:02.png"alt="3ee7f13d62ab1efbf981c6e138eba66f" /><figcaptionaria-hidden="true">3ee7f13d62ab1efbf981c6e138eba66f</figcaption></figure><ul><li><p><strong>对象实例</strong>：new创建的对象，类初始化生成的对象，基本数据类型的数组也是对象实例(new创建)</p></li><li><p><strong>字符串常量池</strong></p><p>StringTable/String Pool： JVM为了提升性能和减少内存消耗针对字符串（String类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><blockquote><p>字符串常量池存储的是 String 对象的直接引用或者对象，是一张stringTable</p></blockquote></li><li><p><strong>静态变量</strong>：静态变量是有 static 修饰的变量，JDK8时从方法区迁移至堆中</p></li><li><p><strong>线程分配缓冲区</strong> Thread Local AllocationBuffer：线程私有但不影响堆的共性，可以提升对象分配的效率</p></li></ul><h4 id="字符串常量池">字符串常量池</h4><p>字符串常量池（String Pool / StringTable /串池）的主要目的是存储字符串字面量，确保相同的字符串只存储一份，从而减少内存使用和提高性能。</p><blockquote><p>串池是<strong>运行时常量池</strong>的一个特殊部分，专门用于存储字符串字面量。</p><p>StringTable通过<strong>哈希表</strong>的结构来存储字符串，以确保相同的字符串在StringTable中只存在一个实例。</p></blockquote><p>当JVM遇到一个字符串字面量时，它会按照以下步骤操作：</p><ol type="1"><li>‌<strong>检查</strong>‌：JVM首先会在字符串常量池中检查是否已经存在该字符串。</li><li>‌<strong>创建与返回</strong>‌：<ul><li>如果存在，JVM会直接返回该字符串的引用，而不会创建新的字符串对象。</li><li>如果不存在，JVM会在堆中创建一个新的字符串对象，将该对象的引用添加到字符串常量池中，并返回这个引用。</li></ul></li></ol><h5 id="内存位置">内存位置</h5><p>随着JDK版本的更新，字符串常量池的位置也发生了变化：</p><ul><li>‌<strong>JDK1.6及之前</strong>‌：字符串常量池位于方法区（也称为永久代）中。</li><li>‌<strong>JDK1.7</strong>‌：字符串常量池被移动到了堆中，而运行时常量池（包含其他类型的常量，如类名、字段名、方法名等）仍然保留在方法区中。</li><li>‌<strong>JDK1.8及之后</strong>‌：永久代被移除，方法区的实现变为了元空间（Metaspace），但字符串常量池仍然保留在堆中。</li></ul><h5 id="stringtable-特性">StringTable 特性</h5><p>1、<strong>字符串延迟加载</strong></p><p><strong>常量池中的字符串仅是符号，并不会立即被转换成对象。只有当字符串真正被使用时，它才会被加载到StringTable中，并转换成字符串对象。</strong></p><p>如下：常量池中的信息，都会被加载到运行时常量池中，这时 a、b 、ab都是常量池中的符号，还没有变为 java字符串对象，只有执行到引用它的代码时才会变为字符串对象，并该字符串对象放入字符串常量池中。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 初始时，字符串常量池(StringTable): []  </span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的</span>  <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;  <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<span class="hljs-comment">//此时，字符串常量池(StringTable): [&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;]  </span>&#125;</code></pre></div><p>对以上代码编译后class文件，使用<code>javap -v 类名.class</code>命令进行反编译，查看对应的字节码文件</p><div class="code-wrapper"><pre><code class="hljs bash">//常量池// 常量池中的信息，都会被加载到运行时常量池中， // 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象，是懒惰的Constant pool:    <span class="hljs-comment">#1 = Methodref          #6.#24         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span>   <span class="hljs-comment">#2 = String             #25            // a</span>   <span class="hljs-comment">#3 = String             #26            // b</span>   <span class="hljs-comment">#4 = String             #27            // ab</span>//运行代码        0: ldc           <span class="hljs-comment">#2                  // String a</span> 2: astore_1 //存入局部变量表slot 1号位 3: ldc           <span class="hljs-comment">#3                  // String b</span> 5: astore_2 6: ldc           <span class="hljs-comment">#4                  // String ab</span> 8: astore_3   // ldc <span class="hljs-comment">#2 会把 a 符号变为 &quot;a&quot; 字符串对象，并放入串池 StringTable: [&quot;a&quot;] </span>// ldc <span class="hljs-comment">#3 会把 b 符号变为 &quot;b&quot; 字符串对象，并放入串池 StringTable: [&quot;a&quot;, &quot;b&quot;] </span>// ldc <span class="hljs-comment">#4 会把 ab 符号变为 &quot;ab&quot; 字符串对象，并放入串池 StringTable: [&quot;a&quot;, &quot;b&quot; ,&quot;ab&quot;]    </span>          //局部变量表(栈)  LocalVariableTable:          Start  Length  Slot  Name   Signature            0      51     0  args   [Ljava/lang/String;            3      48     1    s1   Ljava/lang/String;            6      45     2    s2   Ljava/lang/String;            9      42     3    s3   Ljava/lang/String;</code></pre></div><blockquote><p>字符串常量池与<code>new String()</code>的区别</p><ul><li><p>‌<strong>字符串字面量</strong>‌：如<code>String str1 = "hello";</code>，这里的<code>"hello"</code>是一个字符串字面量，它会被存储在字符串常量池中。</p></li><li><p>‌<strong><code>new String()</code></strong>‌：如</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>); <span class="hljs-comment">//这里会创建两个对象：</span></code></pre></div><ol type="1"><li>首先，在字符串常量池中检查是否存在<code>"hello"</code>，如果存在则直接使用其引用，否则在常量池中创建它。</li><li>接着，在<strong>堆</strong>上创建一个新的<code>String</code>对象，其内容是<code>"hello"</code>，这个新对象与常量池中的字符串对象内容相同，但它们在内存中的位置（即引用）是不同的。</li></ol></li></ul></blockquote><p>2、<strong>字符串拼接</strong></p><ul><li>字符串变量的拼接原理是：使用StringBuilder的append方法（JDK1.8）</li><li>字符串<strong>常量</strong>拼接的原理是编译期优化，拼接结果放入常量池</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 初始时，字符串常量池(StringTable): []  </span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>; <span class="hljs-comment">// 懒惰的</span>  <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;  <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<span class="hljs-comment">//此时，字符串常量池(StringTable): [&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;]  </span>      <span class="hljs-comment">// 底层实现：new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString() --&gt;  new String(&quot;ab&quot;)   ，最终保存在堆中 </span>  <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2;   <span class="hljs-comment">//字符串变量   // 返回的是堆内地址</span>  <span class="hljs-comment">// javac 在编译期间的优化，结果已经在编译期确定为ab</span>  <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>; <span class="hljs-comment">//字符串常量</span>    System.out.println(s3 == s4); <span class="hljs-comment">// F</span>  System.out.println(s3 == s5); <span class="hljs-comment">// T</span>&#125;</code></pre></div><p>3、<code>intern</code>方法</p><p>在jdk1.8中，<code>intern</code>方法尝试将一个字符串对象尝试放入串池，在串池中：</p><ul><li>存在一个字符串对象和该对象的字符串值相等，则返回 String Pool中字符串的引用。</li><li>不存在，把该对象的<strong>引用地址复制一份</strong>放入串池，并返回串池中的引用地址</li></ul><blockquote><p>调用<code>intern</code>方法的字符串对象和串池中的对象<strong>是同一个</strong></p></blockquote><p>在jdk1.6中，<code>intern</code>方法尝试将一个字符串对象尝试放入串池，在串池中：</p><ul><li>存在一个字符串对象和该对象的字符串值相等，则返回 String Pool中字符串的引用。</li><li>不存在，会<strong>把此对象复制一份</strong>，放入串池，把串池中的对象返回</li></ul><blockquote><p>调用<code>intern</code>方法的字符串对象和串池中的对象<strong>不是同一个</strong></p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// StringTable: [&quot;ab&quot;, &quot;a&quot;, &quot;b&quot;]</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <span class="hljs-type">String</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// StringTable: [&quot;ab&quot;]</span>    <span class="hljs-comment">// 堆  new String(&quot;a&quot;)   new String(&quot;b&quot;)  new StringBuilder()  new String(&quot;ab&quot;)</span>  <span class="hljs-comment">// StringTable: [&quot;ab&quot;, &quot;a&quot;, &quot;b&quot;]</span>  <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>); <span class="hljs-comment">//动态拼接的字符串只存在于堆中，还没有加入串池</span>  <span class="hljs-comment">// 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串池中的对象返回</span>  <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s.intern();   System.out.println(s == x);  <span class="hljs-comment">// F</span>  System.out.println(s2 == x); <span class="hljs-comment">// T</span>  &#125;</code></pre></div><h5 id="stringtable-垃圾回收">StringTable 垃圾回收</h5><p>​ 在Java7及以前的版本中，StringTable位于堆内部的永久代（PermGen）中。由于永久代的空间有限，且只有在FullGC时才会进行垃圾回收，因此可能会导致很多已经无用的字符串对象仍存在于堆中，占用内存资源。</p><p>​ 然而，在Java8及以后的版本中，StringTable被移动到了JVM外部的元空间（Metaspace）中。在这里，GC会正常进行，因此StringTable中的无用字符串对象可以得到及时的回收。</p><p>​当JVM进行垃圾回收时，如果StringTable中的<strong>某个字符串对象不再被引用</strong>，那么该字符串对象就会被视为垃圾，并会在后续的垃圾回收过程中被回收掉。</p><p>​在某些情况下，当StringTable中的字符串对象数量过多时，可能会触发垃圾回收。例如，当向StringTable中添加大量字符串对象并使其失去引用时，垃圾回收器会回收这些无用的字符串对象所占用的内存空间。</p><h5 id="stringtable-性能调优">StringTable 性能调优</h5><p>两种方法：</p><ul><li>使用虚拟机参数<code>-XX:StringTableSize=桶个数</code>,可以通过调整StringTable的桶（bucket）数量来优化其性能。增加桶的数量可以减少哈希碰撞次数，从而提高插入和取出字符串对象的效率。</li><li>使用<code>String.intern()</code>方法可以将字符串常量添加到StringTable中，从而实现字符串的复用，减少堆内存的占用。</li></ul><h4 id="堆内存溢出">堆内存溢出</h4><p>JVM堆在JVM启动时即被创建，其空间大小也随之确定，但可以通过JVM参数（如<code>-Xms</code>设置初始内存，<code>-Xmx</code>设置最大内存）进行调节。</p><p>虽然堆内存中会执行GC，但当创建的对象一直都有使用时，就无法被回收。这样的对象一直创建下去，最终会使堆内存没有足够的空间去存储生成的对象，JVM会抛出<code>java.lang.OutOfMemoryError</code>异常，即堆内存溢出‌。</p><h4 id="堆内存诊断工具">堆内存诊断工具</h4><ol type="1"><li>jps工具：查看当前系统中有哪些 java 进程</li><li>jmap 工具：查看堆内存占用情况，<code>jmap -heap 进程id</code></li><li>jconsole工具：图形界面的，多功能的监测工具，可以连续监测</li><li>jvisualvm工具：以可视化的方法展示虚拟机，其中，“堆dump”功能可以查看堆的详细状态，包括堆的概况以及堆中所有的类，还能点进具体的一个类查看这个类的状态。</li></ol><h3 id="方法区">2.5、方法区</h3><h4 id="定义-1">定义</h4><p><strong>方法区</strong> （MethodArea）：是JVM中各个<strong>线程共享</strong>的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>尽管《Java虚拟机规范》中将方法区描述为堆的一个逻辑部分，但它通常被称为“非堆”（Non-Heap），以与Java堆区分开来。</p><p>它是JVM规范中定义的一个概念，用于描述这部分内存的功能和用途。在不同的JVM实现中，方法区可以有不同的具体实现方式。</p><ul><li>在Java8之前的版本中，HotSpot虚拟机使用<strong>永久代</strong>（PermGenspace）来作为方法区的具体实现。</li><li>从Java8开始，HotSpot虚拟机移除了永久代的概念，取而代之的是<strong>元空间</strong>（Metaspace）。元空间同样用于存储类的元数据，但它并不在虚拟机内存中，而是使用本地内存（即操作系统的内存）。<strong>将字符串常量池移动到堆中了</strong>。</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250112111605466-2025-1-1211:16:06.png"alt="image-20250112111605466" /><figcaption aria-hidden="true">image-20250112111605466</figcaption></figure><blockquote><p><strong>方法区是一个概念（规范），而永久代或元空间是它的具体实现</strong>‌。</p></blockquote><h4 id="方法区组成">方法区组成</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250112110859615-2025-1-1211:09:00.png" alt="方法区结构" style="zoom:80%;" /></p><ul><li><p><strong>类元信息</strong>：在类编译期间放入方法区，存放了类的基本信息，包括类的方法、参数、接口以及常量池表</p></li><li><p><strong>常量池表</strong>（Constant Pool Table）是 Class文件的一部分，存储了<strong>类在编译期间生成的静态常量、符号引用</strong>。虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。</p><ul><li><p>静态常量：不需要后续解析，例如字符串字面量、数值字面量等。</p><p>java代码在编译过程中是无法构建引用的，字面量就是在编译时对于数据的一种表示。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//这个1便是字面量</span><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jwt&quot;</span>;<span class="hljs-comment">//jwt便是字面量</span></code></pre></div></li><li><p>符号引用：需要进一步进行解析处理，如类、字段、方法、接口等的符号引用。</p><p>在编译过程中并不知道每个类的地址，因为可能这个类还没有加载，如果在一个类中引用了另一个类，无法知道它的内存地址，只能用它的类名作为符号引用，在类加载完后用这个符号引用去获取内存地址</p></li></ul></li><li><p><strong>运行时常量池</strong></p><p>常量池是*.class文件中的，当类加载到内存中后，JVM就会将常量池中的内容存放到运行时常量池中，并把里面的符号地址变为真实地址。</p><p>运行期间可以动态放入新的常量。</p></li></ul><h4 id="方法区内存溢出">方法区内存溢出</h4><p>​ 在JDK 7及之前的版本中，JVM方法区是通过永久代（PermGenspace）来实现的。当系统中存在大量的类加载，或者静态变量占用了过多的内存，就可能导致永久代内存不足，从而引发方法区内存溢出。此时，系统会抛出<code>java.lang.OutOfMemoryError: PermGen space</code>错误‌。可以通过调整<code>-XX:PermSize</code>和<code>-XX:MaxPermSize</code>参数来增加永久代的大小。</p><p>​ 在JDK8及之后的版本中，JVM方法区的实现改为了元空间（Metaspace）。元<strong>空间使用本地内存，而不是JVM堆内存，因此其大小仅受本地内存限制。</strong>然而，当系统中加载的类过多，或者静态变量占用了过多的内存，仍然可能导致元空间内存溢出。此时，系统会抛出<code>java.lang.OutOfMemoryError: Metaspace</code>错误‌。可以通过调整<code>-XX:MetaspaceSize</code>和<code>-XX:MaxMetaspaceSize</code>参数来设置元空间内存大小。‌</p><p>减少不必要的类加载，避免静态变量占用过多内存。</p><h3 id="直接内存">2.6、直接内存</h3><h4 id="概念">概念</h4><p>‌<strong>直接内存是Java中一种基于操作系统内存的区域，直接分配在操作系统内存中，而不是在JVM的堆中，且不受JVM垃圾回收机制的管理</strong>‌。常见于NIO操作时，用作数据缓冲区。由于属于操作系统内存，分配回收成本较高，但读写性能高。</p><p>直接内存主要应用于需要高效处理大量数据的场景，特别是那些对性能要求较高的应用。</p><p>使用传统IO进行大文件读写时，操作系统需要从用户态切换到内核态，从磁盘中将数据先读到内核中的缓冲区，由于java程序不能直接操作系统缓冲区数据，需要再将内核缓冲区的数据拷贝到java缓冲区中，以便用户程序进行处理。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250112182557560-2025-1-1218:26:04.png"alt="image-20250112182557560" /><figcaption aria-hidden="true">image-20250112182557560</figcaption></figure><p>而采用NIO时，操作系统会开辟一片特殊的系统缓冲区，允许Java应用程序直接访问。这样，在操作系统内存和Java应用程序之间直接传输，避免了数据在用户空间和内核空间之间的频繁拷贝，提升了性能。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250112184751864-2025-1-1218:47:53.png" alt="image-20250112184751864" style="zoom:80%;" /></p><blockquote><p>在传统的I/O模型中，数据需要在用户空间和内核空间之间频繁复制，这导致了大量的CPU和内存开销。而使用直接内存作为缓冲区，可以减少这种开销，因为数据可以直接在操作系统的内存区域中处理，而无需先复制到JVM的堆内存中。</p></blockquote><h4 id="内存溢出">内存溢出</h4><p>报错：<code>" java.lang.OutOfMemoryError: Direct buffer memory</code></p><p>在Java程序中，可以使用<code>ByteBuffer.allocateDirect()</code>方法来分配直接内存。例如：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">directBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>); <span class="hljs-comment">// 分配1MB的直接内存</span></code></pre></div><p>ByteBuffer 有两种类型：</p><ul><li>一种是基于直接内存（非堆内存）：DirectByteBuffer</li><li>一种是非直接内存（堆内存）：HeapByteBuffer</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/0c785bdb248d0b747ef9f8abde64d93f-2025-1-1218:55:28.png"alt="0c785bdb248d0b747ef9f8abde64d93f" /><figcaptionaria-hidden="true">0c785bdb248d0b747ef9f8abde64d93f</figcaption></figure><table><thead><tr class="header"><th></th><th>描述</th><th>优点</th></tr></thead><tbody><tr class="odd"><td>HeapByteBuffer</td><td>在jvm堆上面的一个buffer，底层的本质是一个数组</td><td>由于内容维护在jvm里，所以把内容写进buffer里速度会快些；并且，可以更容易回收</td></tr><tr class="even"><td>DirectByteBuffer</td><td>底层的数据其实是维护在操作系统的内存中，而不是jvm里，DirectByteBuffer里维护了一个引用address指向了数据，从而操作数据</td><td>跟外设（IO设备）打交道时会快很多，因为外设读取jvm堆里的数据时，不是直接读取的，而是把jvm里的数据读到一个内存块里，再在这个块里读取的，如果使用DirectByteBuffer，则可以省去这一步，实现zerocopy</td></tr></tbody></table><p>需要注意的是，直接内存的分配和释放需要由开发者手动管理。如果忘记释放已分配的直接内存，可能会导致内存泄漏和操作系统内存不足的问题。因此，在使用直接内存时，应确保在适当的时候释放内存。</p><p>此外，可以通过设置JVM参数<code>-XX:MaxDirectMemorySize</code>来限制直接内存的最大使用量。</p><h4 id="分配和回收原理">分配和回收原理</h4><ul><li>使用了 <code>Unsafe</code> 对象的 allocateMemory方法完成直接内存的分配，setMemory 方法完成初始化</li><li>在ByteBuffer 的实现类内部，使用了 Cleaner（虚引用）来监测 ByteBuffer对象，一旦ByteBuffer 对象被垃圾回收，那么 ReferenceHandler 线程通过Cleaner 的 clean 方法调用 Deallocator 的 run方法，最后通过 freeMemory来释放直接内存。</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/直接内存分配和回收原理-2025-1-1221:30:59.png"alt="源码分析" /><figcaption aria-hidden="true">源码分析</figcaption></figure><h3 id="总结">总结</h3><p>三种常量池对比</p><p>JVM运行原理</p><h2 id="三执行引擎">三、执行引擎</h2><h3 id="垃圾回收">3.1、垃圾回收</h3><h4 id="如何判断对象可以回收">如何判断对象可以回收</h4><p>在Java虚拟机（JVM）中，判断一个对象是否可以被回收主要依赖于两种算法：<strong>引用计数法</strong>和<strong>可达性分析算法</strong>。</p><h5 id="引用计数法">引用计数法</h5><p>为每个对象创建一个引用计数，当有对象引用它时，计数器加1；引用被释放时，计数器减1。当计数器的值为0时，表示该对象没有被任何引用指向，可以被回收。</p><ul><li><p>‌<strong>优点</strong>‌：简单高效，实时判断对象是否可达。</p></li><li><p>‌<strong>缺点</strong>‌：无法处理<strong>循环引用</strong>的问题。如果两个或多个对象相互引用，即使它们没有其他外部引用，引用计数也不会降为零，导致内存泄漏。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250112215142926-2025-1-1221:51:49.png"alt="循环引用示例" /><figcaption aria-hidden="true">循环引用示例</figcaption></figure></li></ul><h5 id="可达性分析算法">可达性分析算法</h5><p><img src="https://gitee.com/cmyk359/img/raw/master/img/8981fe05be9e4951813435cdc8590b35-2025-1-1511:52:39.png" style="zoom:67%;" /></p><p><strong>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象。</strong></p><p>原理：从一组称为<strong>GCRoots</strong>的根对象出发，通过引用关系向下搜索，找到所有可以被直接或间接引用的对象。如果一个对象无法从GCRoots通过引用链找到，则被视为垃圾，可以被回收。</p><p>哪些对象可以作为GC Root？</p><p>GC Roots是一组被认为是<strong>活跃对象的引用</strong>，它们是垃圾回收的起始点。</p><ul><li><strong>虚拟机栈中的引用</strong>：每个线程都有自己的虚拟机栈，其中的局部变量和方法参数引用的对象。</li><li><strong>方法区中的类静态属性</strong>：被类的静态属性引用的对象。</li><li><strong>方法区中的常量</strong>：被常量引用的对象，通常是在方法区中定义的字符串常量等。</li><li><strong>JNI（Java Native Interface）引用</strong>：通过 JNI引用的对象。</li><li><strong>被系统类加载器加载的类</strong>：在 JVM 中运行的系统类（如<code>java.lang.String</code>）及其引用的对象。</li><li><strong>活动线程</strong>：所有正在运行的线程都被视为 GCRoots。</li><li><strong>其他引用</strong>：如某些特殊的引用或数据结构（例如，某些JVM 实现可能会将特定的对象视为 GC Roots）。</li></ul><h5 id="四种引用">四种引用</h5><p>在 Java 中，JVM提供了四种引用类型，用于管理对象的生命周期和垃圾回收的行为。此外还提供了<strong>引用队列</strong>机制，是与<strong>弱引用</strong>和<strong>虚引用</strong>结合使用的一种机制，用于在对象被垃圾回收后接收通知。</p><p><strong>强引用（Strong Reference）</strong>：</p><ul><li>定义：强引用是 Java中最常见的引用类型。只要强引用存在，垃圾回收器就不会回收被引用的对象。</li><li>特点：<ul><li>默认情况下创建的对象引用都是强引用。</li><li>例如：<code>Object obj = new Object();</code> 这里的<code>obj</code> 是一个强引用。</li><li><strong>即使在内存不足的情况下，强引用指向的对象也不会被回收。</strong></li></ul></li><li>使用场景：适用于需要确保对象在整个生命周期内都存在的情况。</li></ul><p><strong>软引用（Soft Reference）</strong>：</p><ul><li>定义：软引用用于描述一些有用但并非必需的对象，适合用于实现内存敏感的缓存。</li><li>特点：<ul><li><strong>当系统内存不足时，垃圾回收器会尽可能回收软引用指向的对象，但在内存充足的情况下，软引用指向的对象不会被回收。</strong></li><li>通过 <code>SoftReference</code> 类来创建软引用。</li></ul></li><li>使用场景：软引用通常用于实现内存敏感的缓存。例如图片缓存、数据缓存等，能够在内存不足时自动释放不再使用的对象。</li></ul><p><strong>弱引用（Weak Reference）</strong>：</p><ul><li>定义：弱引用用于描述一些非必需的对象，垃圾回收器在运行时会回收弱引用指向的对象。</li><li>特点：<ul><li>当垃圾回收器运行时，如果一个对象只被弱引用指向，那么<strong>无论内存是否充足，该对象都会被回收。</strong></li><li>通过 <code>WeakReference</code> 类来创建弱引用。</li></ul></li><li>使用场景：适用于需要在内存中存储对象但不想影响其被回收的场景，例如监听器、事件处理等。</li></ul><p><strong>虚引用（Phantom Reference）</strong>：</p><ul><li>定义：虚引用是最弱的一种引用类型，几乎没有实际用途。</li><li>特点：<ul><li><strong>虚引用的存在并不会影响对象的生命周期，即使对象被虚引用指向，也可以被垃圾回收器回收。</strong></li><li>主要用于跟踪对象的回收状态，通常与引用队列结合使用。</li><li>通过 <code>PhantomReference</code> 类来创建虚引用。</li></ul></li><li>使用场景：适用于需要在对象被回收后执行特定清理操作的场景，如释放资源、关闭文件等。</li></ul><p><strong>引用队列（Reference Queue）</strong></p><ul><li><p>定义：引用队列是与<strong>弱引用</strong>和<strong>虚引用</strong>一起使用的一种机制，用于在对象被垃圾回收后接收通知。</p></li><li><p>特点：</p><ul><li>当与弱引用或虚引用关联的对象被回收时，相关的引用会被加入到引用队列中。</li><li>开发者可以通过检查引用队列来判断对象是否已被回收，并进行相应的处理。</li></ul></li><li><p>使用场景：常用于资源管理和清理操作，确保在对象被回收后执行必要的清理工作。</p></li><li><p>工作流程：</p><ol type="1"><li><p><strong>创建引用队列</strong>：使用 ReferenceQueue类创建一个引用队列。</p><div class="code-wrapper"><pre><code class="hljs java">ReferenceQueue&lt;MyObject&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();</code></pre></div></li><li><p><strong>创建弱引用或虚引用</strong>：创建一个弱引用或虚引用，并将其与引用队列关联。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();WeakReference&lt;MyObject&gt; weakRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(myObject, referenceQueue);</code></pre></div></li><li><p><strong>对象被回收</strong>：当 myObject对象被垃圾回收时，weakRef 将被加入到 referenceQueue 中。</p></li><li><p><strong>处理引用队列</strong>：调用 <code>poll()</code> 或<code>remove()</code> 方法来检查引用队列，获取已被回收的对象的引用。</p><div class="code-wrapper"><pre><code class="hljs java">WeakReference&lt;MyObject&gt; ref = (WeakReference&lt;MyObject&gt;) referenceQueue.poll();<span class="hljs-keyword">while</span> (ref != <span class="hljs-literal">null</span>) &#123;    <span class="hljs-comment">// 对象已经被回收，可以执行清理操作</span>    ...    ref = referenceQueue.poll();&#125;</code></pre></div></li></ol></li></ul><blockquote><p>补充：</p><p>在 Java 中，<strong>终结器引用</strong>（FinalizerReference）并不是一种正式的引用类型，而是与对象的终结方法（<code>finalize()</code>）相关的概念。每个Java 对象都可以重写 finalize() 方法，在对象被垃圾回收前，JVM会调用这个方法。这个方法可以用于释放非内存资源，例如关闭文件、网络连接等。当一个对象的finalize() 方法被调用时，JVM会将该对象的引用放入一个特殊的队列中，等待处理。存在的问题：</p><ul><li>对象的回收可能会延迟，直到 <code>finalize()</code>方法执行完毕。</li><li><code>finalize()</code>方法的调用时机不确定，可能导致资源的延迟释放。</li><li>如果对象的 <code>finalize()</code>方法中抛出异常，可能会导致对象无法被正确回收。</li><li>终结器引用可能会导致内存泄漏，因为如果一个对象的<code>finalize()</code>方法中持有对其他对象的引用，这些对象可能无法被回收。</li></ul><p>由于 <code>finalize()</code> 方法的缺陷，Java 9 以后引入了<code>java.lang.ref.Cleaner</code>类，作为一种更灵活和安全的资源管理方式。</p></blockquote><h4 id="垃圾回收算法">垃圾回收算法</h4><h5id="标记-清除算法mark-and-sweep">标记-清除算法（Mark-and-Sweep）</h5><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250115115546268-2025-1-1511:55:47.png"alt="标记-清除算法" /><figcaption aria-hidden="true">标记-清除算法</figcaption></figure><p>标记清除算法的基本思想是分为两个阶段：</p><ul><li><p><strong>标记阶段</strong>：遍历所有可达对象，从根对象（GCRoots）开始，标记所有可达的对象。</p></li><li><p><strong>清除阶段</strong>：遍历整个堆，清除未被标记的对象，从而释放内存。</p><blockquote><p>JVM会将这些对象的内存回收到堆的空闲列表中，供后续的对象分配使用。</p></blockquote></li></ul><p>优点</p><ul><li><strong>简单易实现</strong>：标记清除算法的实现相对简单，易于理解和实现。</li><li><strong>空间利用率高</strong>：在清除阶段，所有未被标记的对象都被回收，能有效释放内存。</li></ul><p>缺点</p><ul><li><strong>内存碎片</strong>：标记清除算法在清除阶段只会释放未被标记的对象的内存，但不会整理已被标记的对象，导致内存碎片问题。随着时间的推移，可能会导致内存中产生大量的小块空闲内存，影响后续的内存分配效率。</li><li><strong>暂停时间</strong>：在标记和清除阶段，JVM会暂停应用程序的执行，可能导致较长的停顿时间，影响应用程序的响应性。</li></ul><blockquote><p>为了克服标记清除算法的缺点，后来的垃圾回收算法如标记压缩算法（Mark-Compact）和分代收集算法（GenerationalGC）应运而生。</p><ul><li><strong>标记压缩算法</strong>：在清除阶段不仅清除未被标记的对象，还会对存活的对象进行整理，消除内存碎片。</li><li><strong>分代收集算法</strong>：将对象分为新生代和老年代，针对不同代的对象采用不同的回收策略，以提高垃圾回收的效率。</li></ul></blockquote><h5id="标记-压缩算法mark-and-compact">标记-压缩算法（Mark-and-Compact）</h5><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250115124530620-2025-1-1512:45:35.png"alt="标记-压缩（整理）算法" /><figcaption aria-hidden="true">标记-压缩（整理）算法</figcaption></figure><p>标记压缩算法在标记清除的基础上进行了改进，增加了内存整理的步骤：</p><ul><li><strong>标记阶段</strong>：与标记清除相同，标记所有可达对象。</li><li><strong>压缩阶段</strong>：在清除未标记对象后，将存活的对象移动到堆的一端，整理内存，消除碎片。</li></ul><p><strong>优点</strong>：</p><ul><li>消除了内存碎片，提高了内存的利用率。</li><li>由于对象是连续存放的，后续的内存分配效率提高。</li></ul><p><strong>缺点</strong>：</p><ul><li>移动对象可能会导致指针更新，增加了实现复杂性。</li></ul><h5 id="复制算法copying">复制算法（Copying）</h5><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250115124610042-2025-1-1512:46:21.png"alt="复制算法" /><figcaption aria-hidden="true">复制算法</figcaption></figure><p>复制算法将堆内存分为两个相等的区域（通常称为“From区”和“To区”），在垃圾回收时只使用其中一个区域。</p><ul><li><strong>From区</strong>：当前正在使用的区域，存放新生代对象。</li><li><strong>To区</strong>：空闲区域，准备接收存活的对象。</li></ul><p>在进行垃圾回收时，算法会从根对象（GCRoots）开始，遍历From区中的所有可达对象。将存活的对象复制到To区，并更新对象的引用。一旦复制完成，From区中的所有对象都被视为不可达的，整个From区的内存可以被直接回收。之后，From区和To区的角色会交换，To区变成From区，准备下一次的垃圾回收。</p><ul><li>优点：内存碎片少，适用于存活对象较少的情况。</li><li>缺点：需要两倍的内存空间。</li></ul><blockquote><p>复制算法特别适合用于新生代的垃圾回收，因为：</p><ul><li>新生代中的对象生命周期较短，大多数对象在垃圾回收时会被清除。</li><li>存活对象相对较少，复制的开销相对较小。</li></ul></blockquote><h5 id="分代收集算法generational-collection">分代收集算法（GenerationalCollection）</h5><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250115145827992-2025-1-1514:58:30.png"alt="image-20250115145827992" /><figcaption aria-hidden="true">image-20250115145827992</figcaption></figure><ul><li>新创建的对象，都会先分配到<code>Eden</code>（伊甸园）区</li><li>当<code>Eden</code>区内存不足时，会触发<code>Minor GC</code>，通常会导致较短的STW 事件。</li><li>标记伊甸园与from中的存活对象，将存活对象采用<strong>复制算法</strong>复制到to中，复制完毕后，伊甸园和from内存都得到释放。最终存活的对象年龄加一，并且交换from和to。</li><li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（幸存区内存不足或大对象会导致提前晋升）</li><li>当老年代空间不足，会先尝试触发minorgc，如果之后空间仍不足，那么触发<code>Full GC</code>，可能会导致较长的STW 事件。</li></ul><blockquote><p>补充：</p><p>1、相关的分代GC概念</p><ul><li>部分收集（PartialGC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为<ul><li>新生代收集（Minor GC / Young GC）：指目标只是新生代的垃圾收集</li><li>老年代收集（Major GC / OldGC）:指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外注意，“MajorGC”这个说法现在有点混淆，在不同的资料上常有不同所指，需按照上下文区别到底是指老年代的收集还是整堆收集。</li><li>混合收集（MixedGC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li></ul></li><li>整堆收集（Full GC）：整个Java堆和方法区的垃圾收集</li></ul><p>2、STW（stop-the-world）</p><p>STW 是指在进行垃圾回收时，JVM会暂停所有应用程序线程的执行，以便安全地进行内存清理和整理。这意味着在GC 进行的期间，所有用户线程都会被暂停，无法执行任何代码。STW的原因如下：</p><ul><li><strong>内存管理</strong>：在进行垃圾回收时，JVM需要确保没有其他线程在访问或修改对象的状态。这是为了避免在回收过程中出现不一致性或数据损坏。</li><li><strong>保证安全性</strong>：通过暂停所有线程，JVM可以确保在标记、清除或整理对象时，所有引用都是有效的，从而保证内存的安全性。</li></ul></blockquote><h4 id="hotspot的算法实现细节">HotSpot的算法实现细节</h4><p>前面讲的垃圾收集算法在运行时是怎样去保证其执行效率和正确性的呢？在此分析HotSpot的算法实现细节，同时<u>为介绍各款垃圾收集器做前置知识铺垫</u>。（内容都很枯燥，可以暂时跳过，遇到相关知识的时候再返回来看，该部分内容主要参考《深入理解Java虚拟机》第三章的内容）</p><h5 id="根节点枚举">根节点枚举</h5><p>​ 我们以可达性分析算法中从GCRoots集合找引用链这个操作作为介绍虚拟机高效实现的第一个例子。固定可作为GCRoots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应用越做越庞大，里面的类、常量等更是恒河沙数，若要逐个检查以这里为起源的引用肯定得消耗不少时间。</p><p>​迄今为止，<strong>所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</strong>，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的“StopTheWorld”的困扰。现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但<strong>根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行</strong>——这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因，即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、ZGC等收集器，枚举根节点时也是必须要停顿的。</p><p>​由于目前主流Java虚拟机使用的都是准确式垃圾收集（这个概念在第1章介绍ExactVM相对于ClassicVM的改进时介绍过），所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，<strong>虚拟机应当是有办法直接得到哪些地方存放着对象引用的</strong>。在HotSpot的解决方案里，是使用一组称为<spanstyle="color: red"><strong>OopMap</strong></span>的数据结构来达到这个目的。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译（过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GCRoots开始查找。</p><h5 id="安全点">安全点</h5><p>​ 在OopMap的协助下，HotSpot可以快速准确地完成GCRoots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。</p><p>​实际上HotSpot也的确没有为每条指令都生成OopMap，前面已经提到<strong>，只是在“特定的位置”记录了这些信息</strong>，这些位置被称为<spanstyle="color: red">安全点</span>（Safepoint）。<u>有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。</u></p><p>​因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。安全点位置的选取基本上是以“<strong>是否具有让程序长时间执行的特征</strong>”为标准进行选定的，因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这样的原因而长时间执行，“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p><p>​对于安全点，另外一个需要考虑的问题是，如何在垃圾收集发生时让所有线程（这里其实不包括执行JNI调用的线程）都跑到最近的安全点，然后停顿下来。这里有两种方案可供选择：<strong>抢先式中断</strong>（PreemptiveSuspension）和<strong>主动式中断</strong>（Voluntary Suspension）.</p><ul><li>抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件。</li><li>主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</li></ul><p>由于轮询操作在代码中会频繁出现，这要求它必须足够高效。HotSpot使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程度。下面代码清单3-4中的<code>test</code>指令就是HotSpot生成的轮询指令，当需要暂停用户线程时，虚拟机把0x160100的内存页设置为不可读，那线程执行到test指令时就会产生一个自陷异常信号，然后在预先注册的异常处理器中挂起线程实现等待，这样仅通过一条汇编指令便完成安全点轮询和触发线程中断了。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250118112752886-2025-1-1811:27:55.png"alt="轮询指令" /><figcaption aria-hidden="true">轮询指令</figcaption></figure><h5 id="安全区域">安全区域</h5><p>使用安全点的设计似乎已经完美解决如何停顿用户线程，让虚拟机进入垃圾回收状态的问题了，但实际情况却并不一定。安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于Sleep状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。对于这种情况，就必须引入安全区域（SafeRegion）来解决。</p><p>安全区域是指<strong>能够确保在某一段代码片段之中，引用关系不会发生变化</strong>，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被<u>扩展拉伸</u>了的安全点。</p><p><strong>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</strong></p><h5 id="记忆集与卡表">记忆集与卡表</h5><p>由于<strong>对象不是孤立的，对象之间会存在跨代引用</strong>，当进行新生代的垃圾收集时，新生代中的对象完全有可能被老年代的对象引用，为了找出该区域（新生代）中的存活对象，不得不在固定的GCRoots之外，再遍历整个老年代中所有的对象来保证可达性分析结果的正确性。老年代占用的空间更大，存活的对象更多，这样花费的时间就更长了。</p><blockquote><p>不只是新生代和老年代之间有跨代引用问题，所有涉及部分区域收集（PartialGC）行为的垃圾收集器，如G1，ZGC，都会面临同样的问题。</p></blockquote><p>为了解决跨带引用问题，垃圾收集在新生代中建立了名为<spanstyle="color : red"><strong>记忆表</strong>（<strong>RememberedSet</strong>）</span>的数据结构，用以避免将整个老年代加入GCRoots的扫描范围。记忆集是<strong>一种用于记录从非收集区域指向收集区域的指针集合</strong>的<u>抽象数据结构</u>。收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向收集区域的指针就可以了，并不需要了解这些跨代指针的具体信息。因此，记忆集有三种精度的方案来记录跨代指针：</p><ul><li>字长精度：每个记录精确到一个机器字长，该字包含跨代指针。</li><li>对象精度：每个记录精确到一个对象，该对象中包含跨代指针。</li><li>卡精度：每个记录精确到一个内存区域，该区域中包含跨代指针。</li></ul><p>为了节省记忆集的存储和维护成本，可以采用更为粗犷的记忆粒度。第三种“卡精度”所指的是使用一种称为<spanstyle="color : red">“<strong>卡表（CardTable）</strong>”</span>的方式去实现记忆集，也是目前最常用的记忆集实现方式。</p><blockquote><p>记忆集其实是一种抽象的数据结构，只定义了记忆集的行为意图，并没有定义其行为的具体实现。而卡表就是记忆集的一种具体实现，它定义了记忆集的的记录精度，与堆内存的映射关系等。</p></blockquote><p>卡表最简单的实现形式可以是一个<strong>字节数组</strong>，而HotSpot虚拟机确实也是这样做的。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// HotSpot默认的卡表标记逻辑</span>CARD_TABLE [<span class="hljs-built_in">this</span> address &gt;&gt; <span class="hljs-number">9</span>] = <span class="hljs-number">0</span>;</code></pre></div><p>字节数组<code>CARD_TABLE</code>的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称为<spanstyle="color : red"><strong>卡页（CardPage）</strong></span>，一个卡页中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段包含跨代指针，那就将对应卡表的数据元素标识为1，称为这个元素<spanstyle="color : red">变脏（Dirty）</span>,没有则表示为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，只需把它们加入GCRoots中一并扫描，就能避免对整个老年代中所有对象扫描。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250118110852229-2025-1-1811:09:13.png" alt="卡表和卡页对应示意图" style="zoom:80%;" /></p><h5 id="写屏障">写屏障</h5><p>我们已经解决了如何使用记忆集来缩减GCRoots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁来把它们变脏等。</p><p>卡表元素何时变脏的答案是很明确的——<strong>有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻</strong>。但问题是如何变脏，即如何在对象赋值的那一刻去更新维护卡表呢？假如是解释执行的字节码，那相对好处理，虚拟机负责每条字节码指令的执行，有充分的介入空间；但在编译执行的场景中呢？经过即时编译后的代码已经是纯粹的机器指令流了，这就必须找到一个在机器码层面的手段，<strong>把维护卡表的动作放到每一个赋值操作之中</strong>。</p><p>在HotSpot虚拟机里是通过<span style="color:red"><strong>写屏障（WriteBarrier）</strong></span>技术维护卡表状态的。写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的<strong>AOP</strong>切面（类似于与Spring中的AOP操作），会在引用对象赋值前后做一些额外的动作。主要分为两个：</p><ul><li><strong>写前屏障（Pre-WriteBarrier）</strong>：引用对象赋值前的特殊处理</li><li><strong>写后屏障（Post-WriteBarrier）</strong>：引用对象赋值后的特殊处理</li></ul><p>应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与MinorGC时扫描整个老年代的代价相比还是低得多的。</p><p>除了写屏障的开销外，卡表在高并发场景下还面临着“<strong>伪共享</strong>”（FalseSharing）问题。伪共享是处理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行（CacheLine）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题。</p><p>​假设处理器的缓存行大小为64字节，由于一个卡表元素占1个字节，64个卡表元素将共享同一个缓存行。这64个卡表元素对应的卡页总的内存为32KB（64×512字节），也就是说如果不同线程更新的对象正好处于这32KB的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能。为了避免伪共享问题，一种简单的解决方案是<strong>不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏</strong>。</p><p>在JDK7之后，HotSpot虚拟机增加了一个新的参数-XX：+UseCondCardMark，用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损耗，是否打开要根据应用实际运行情况来进行测试权衡。</p><h5 id="并发的可达性分析">并发的可达性分析</h5><p>​当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，<strong>可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析，这意味着必须全程冻结用户线程的运行</strong>。在根节点枚举这个步骤中，由于GCRoots相比起整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技巧（如OopMap）的加持下，它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长）的了。可从GCRoots再继续往下遍历对象图，这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了：堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长，这听起来是理所当然的事情。</p><p>​要知道包含“标记”阶段是所有追踪式垃圾收集算法的共同特征，如果这个阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾收集器，同理可知，如果能够削减这部分停顿时间的话，那收益也将会是系统性的。</p><p>想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？为了能解释清楚这个问题，我们引入<spanstyle="color: red"><strong>三色标记（Tri-colorMarking）</strong></span>作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照“<strong>是否访问过</strong>”这个条件标记成以下三种颜色：</p><ul><li><strong>白色</strong>：<strong>表示对象尚未被垃圾收集器访问过</strong>。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li><li><strong>黑色</strong>：<strong>表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。</strong>黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</li><li><strong>灰色</strong>：<strong>表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过</strong>。</li></ul><blockquote><p>关于可达性分析的扫描过程，读者不妨发挥一下想象力，把它看作对象图上一股以灰色为波峰的波纹从黑向白推进的过程。</p></blockquote><p>如果用户线程此时是冻结的，只有收集器线程在工作，那不会有任何问题。但如果用户线程与收集器是并发工作呢？收集器在对象图上标记颜色，同时用户线程在修改引用关系——即修改对象图的结构，这样可能出现两种后果。</p><ul><li><p>一种是把原本消亡的对象错误标记为存活，这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。(<strong>多标)</strong></p></li><li><p>另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误。（<strong>漏标</strong>）</p><p>下面表演示了这样的致命错误具体是如何产生的。</p></li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250118114200926-2025-1-1811:42:11.png"alt="并发出现“对象消失”问题的示意图" /><figcaptionaria-hidden="true">并发出现“对象消失”问题的示意图</figcaption></figure><p>Wilson于1994年在理论上证明了，当且仅当以下两个条件<strong>同时满足时</strong>，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：</p><ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li></ul><p>因此，要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：<strong>增量更新</strong>（IncrementalUpdate）和<strong>原始快照</strong>（Snapshot At The Beginning，<strong>SATB</strong>）。</p><p>增量更新要破坏的是第一个条件，<strong>当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来</strong>，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</p><p>原始快照要破坏的是第二个条件，<strong>当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来</strong>，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p><p>以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。在HotSpot虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，譬如，<strong>CMS是基于增量更新来做并发标记的</strong>，<strong>G1、Shenandoah则是用原始快照来实现。</strong></p><h4 id="gc相关的虚拟机参数">GC相关的虚拟机参数</h4><table><thead><tr class="header"><th>参数</th><th>含义</th></tr></thead><tbody><tr class="odd"><td>堆初始大小</td><td>-Xms</td></tr><tr class="even"><td>堆最大大小</td><td>-Xmx或-XX:MaxHeapSize=size</td></tr><tr class="odd"><td>新生代大小</td><td>-Xmn或（-XX:NewSize=size + -XX:MaxNewSize=size）</td></tr><tr class="even"><td>幸存区比例（动态）</td><td>-XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy</td></tr><tr class="odd"><td>幸存区比例</td><td>-XX:SurvivorRatio=ratio</td></tr><tr class="even"><td>晋升阈值</td><td>-XX:MaxTenuringThreshold=threshold</td></tr><tr class="odd"><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr class="even"><td>GC详情</td><td>-XX:+PrintGCDetails -verbose:gc</td></tr><tr class="odd"><td>FullGC 前执行 MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><h4 id="垃圾收集器">垃圾收集器</h4><h5 id="串行垃圾收集器">串行垃圾收集器</h5><p>‌JVM串行垃圾回收器是<strong>单线程</strong>的垃圾回收器，用于新生代和老年代的垃圾回收‌。</p><p>串行垃圾回收器主要分为<strong>Serial</strong>（用于新生代）和<strong>SerialOld</strong>（用于老年代）。</p><ul><li>Serial作用于新生代，采用<strong>复制算法</strong></li><li>Serial Old作用于老年代，采用<strong>标记-整理算法</strong></li></ul><p>垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250115214257033-2025-1-1521:43:11.png"alt="image-20250115214257033" /><figcaption aria-hidden="true">image-20250115214257033</figcaption></figure><p><strong>优点</strong></p><ul><li>实现简单</li><li>内存占用小：由于只使用单线程，串行垃圾回收器的内存占用较小，适合资源有限的环境。</li><li>适合小型应用：在小型应用程序或内存需求不高的场景中，串行垃圾回收器能够提供良好的性能。</li></ul><p><strong>缺点</strong></p><ul><li>不适合多核处理器：串行垃圾回收器只能使用一个线程进行垃圾回收，无法充分利用多核处理器的计算能力，导致性能瓶颈。</li><li>较长的停顿时间：由于在垃圾回收期间暂停所有应用程序线程，可能导致较长的停顿时间，影响用户体验。</li><li>不适合大规模应用：在内存需求较高或对象存活时间较长的应用中，串行垃圾回收器可能导致性能下降和响应延迟。</li></ul><p>JVM参数：</p><div class="code-wrapper"><pre><code class="hljs bash">-XX:+UseSerialGC  <span class="hljs-comment">#启用串行垃圾回收器</span></code></pre></div><h5 id="并行垃圾收集器">并行垃圾收集器</h5><p>JVM并行垃圾收集器是一个<strong>多线程</strong>的收集器，它通过使用多个线程并行执行垃圾回收任务，用于在多个处理器或多线程硬件上加速应用程序的吞吐量‌。</p><p><strong>Parallel New</strong>和<strong>ParallelOld</strong>是一个并行垃圾回收器，<strong>JDK8默认使用此垃圾回收器</strong></p><ul><li>Parallel New作用于新生代，采用复制算法</li><li>Parallel Old作用于老年代，采用标记-整理算法</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250115220147508-2025-1-1522:01:49.png"alt="image-20250115220147508" /><figcaption aria-hidden="true">image-20250115220147508</figcaption></figure><p><strong>优点</strong></p><ul><li>高吞吐量：并行垃圾收集器能够充分利用多核处理器，通过并行执行垃圾回收任务，提高了整体吞吐量。</li><li>适合长时间运行的应用：对于需要长时间运行的应用程序（如服务器应用），并行垃圾收集器能够有效减少内存的使用和回收时间。</li><li>较短的停顿时间：由于多个线程同时工作，垃圾回收的时间相对较短，尽管仍然会出现停顿，但相比于串行垃圾回收器会有所改善。</li></ul><p><strong>缺点</strong></p><ul><li>STW停顿：尽管并行垃圾收集器减少了停顿时间，但在进行垃圾回收时仍然会暂停所有应用程序线程</li><li>内存使用：内存使用的增加，因为并行回收需要更多的内存来存储线程的状态和堆的结构。</li></ul><p><strong>JVM参数</strong></p><ul><li><p>启用并行垃圾收集器（启用其中一个，另一个也会自动启用）</p><div class="code-wrapper"><pre><code class="hljs bash">-XX:+UseParallelGC  <span class="hljs-comment">#启用新生代并行垃圾收集器</span>-XX:+UseParallelOldGC <span class="hljs-comment">#启用老年代并行垃圾收集器</span></code></pre></div></li><li><p>设置并行线程的数量</p><div class="code-wrapper"><pre><code class="hljs bash">-XX:ParallelGCThreads=&lt;number&gt;</code></pre></div></li><li><p>允许 JVM根据运行时的内存使用情况动态调整堆的大小和各个代的比例</p><div class="code-wrapper"><pre><code class="hljs bash">-XX:+UseAdaptiveSizePolicy</code></pre></div></li><li><p>控制垃圾回收时间与应用程序运行时间的比率(<strong>影响垃圾回收的频率</strong>)</p><div class="code-wrapper"><pre><code class="hljs bash">-XX:GCTimeRatio=ratio<span class="hljs-comment">#ratio 是一个整数值，表示在 100 个时间单位中，允许垃圾回收占用的最大时间。</span><span class="hljs-comment">#该参数的设置会影响垃圾回收的频率和策略。</span><span class="hljs-comment">#较低的 GCTimeRatio 值会使 JVM 更加频繁地进行垃圾回收，以保持应用程序的响应性，而较高的值则可能导致更少的垃圾回收。</span></code></pre></div></li><li><p>设置垃圾回收的最大停顿时间(<strong>影响每次垃圾回收的持续时间</strong>)</p><div class="code-wrapper"><pre><code class="hljs bash">-XX:MaxGCPauseMillis=ms<span class="hljs-comment">#ms 是一个整数值，表示最大期望的停顿时间,默认设置为 200ms</span><span class="hljs-comment">#当启用此参数时，JVM 会尽量调整垃圾回收的策略，以满足这一停顿时间的要求。这可能会导致更频繁的垃圾回收或使用不同的回收算法，以确保停顿时间在设定的阈值内。</span></code></pre></div></li></ul><blockquote><p><code>-XX:GCTimeRatio</code> 可以影响垃圾回收的频率，而<code>-XX:MaxGCPauseMillis</code>则可以影响每次垃圾回收的持续时间。这两个参数可以结合使用，以优化 Java应用程序的性能，减少停顿时间，提高响应能力。合理配置和调优这两个参数将有助于满足不同应用程序的性能需求。</p></blockquote><h5 id="cms并发垃圾收集器">CMS（并发）垃圾收集器</h5><p>CMS全称 Concurrent MarkSweep，是一款<strong>并发</strong>的、使用<strong>标记-清除算法</strong>的垃圾回收器，该回收器是<strong>针对老年代</strong>垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是<strong>在进行垃圾回收时，应用程序仍然能正常运行</strong>。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250115224356132-2025-1-1522:43:57.png"alt="image-20250115224356132" /><figcaption aria-hidden="true">image-20250115224356132</figcaption></figure><p>CMS 垃圾收集器的工作过程主要分为以下几个阶段：</p><ol type="1"><li>‌<strong>初始标记</strong>‌：标记存活的对象，此阶段会引发STW，但时间较短‌（只需标记直接可达的对象）</li><li><strong>并发标记</strong>‌：沿着初始标记阶段标记的对象寻找存活对象，该阶段与应用程序并发运行‌</li><li><strong>重新标记</strong>：标记在并发标记阶段中发生变更的对象，此阶段也会引发STW，但时间相对较短‌</li><li><strong>并发清除‌</strong>：清除未被标记的对象，该阶段与应用程序并发运行‌</li></ol><p>在CMS的并发标记阶段，应用程序线程可能会创建新的对象引用或修改现有的对象引用。为了确保这些新增的对象引用能够被正确标记，CMS使用了<strong>增量更新</strong>技术。增量更新通过写屏障来实现。当写屏障检测到新增的跨代引用时，它会将这些引用记录到一个增量更新队列中。在并发标记的后续阶段（如重新标记阶段），CMS会遍历这个增量更新队列，重新扫描这些新增的引用，并将它们标记为存活对象。</p><blockquote><p>其中<strong>初始标记</strong>、<strong>重新标记</strong>这两个阶段仍然需要"Stop The Wold"</p></blockquote><p><strong>优点</strong></p><ul><li><strong>低停顿时间</strong>：CMS垃圾收集器的并发特性使得大部分垃圾回收过程可以在应用程序运行时进行，从而显著减少了停顿时间。</li></ul><p><strong>缺点</strong></p><ul><li><p><strong>对处理器资源敏感</strong>：在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。</p></li><li><p><strong>无法处理浮动垃圾，并且可能发生Concurrent ModeFailure（并发模式失败）</strong></p><p>​浮动垃圾是指在并发标记阶段完成后，但在实际的清除阶段之前，被创建或引用的新对象。由于这部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。</p><p>​由于在垃圾收集阶段用户线程还需要持续运行，就需要预留足够的内存空间供给用户线程使用，因此CMS会在老年代空间使用达到一定比例（默认值为92%）后就开始执行清理。如果设定的CMS启动阈值太大，导致预留的内存空间无法满足程序分配新对象的需要，就会出现“并发失败”。此时，JVM会冻结用户线程执行，临时启用SerialOld收集器来重新进行老年代的垃圾收集，这种情况下停顿时间就很长了。</p></li><li><p><strong>产生内存碎片</strong>：CMS 使用的是标记-清除算法，在清除未被标记的对象后，可能会导致内存碎片的产生。这可能会影响老年代的可用内存，导致Full GC（完全垃圾回收）的发生。</p></li></ul><p><strong>JVM参数</strong></p><ul><li><p>启用 CMS 垃圾收集器</p><div class="code-wrapper"><pre><code class="hljs bash">-XX:+UseConcMarkSweepGC</code></pre></div></li><li><p>设置并发标记的线程数</p><div class="code-wrapper"><pre><code class="hljs bash">-XX:ConcGCThreads=&lt;number&gt;</code></pre></div></li><li><p>设置CMS 的触发百分比（默认为92%）</p><div class="code-wrapper"><pre><code class="hljs bash">-XX:CMSInitiatingOccupancyFraction=percent</code></pre></div></li><li><p>在执行重新标记阶段之前，会先执行一次新生代的垃圾回收</p><div class="code-wrapper"><pre><code class="hljs bash">-XX:+CMSScavengeBeforeRemark<span class="hljs-comment">#通过清理新生代，可以减少需要在老年代进行标记的对象数量，降低老年代的内存压力，从而降低 Full GC的发生概率。</span></code></pre></div></li></ul><h5 id="g1-垃圾收集器">G1 垃圾收集器</h5><p>G1（<strong>GarbageFirst</strong>）垃圾回收器不同于上述的几款垃圾回收器，其采用独特的<strong>内存管理策略</strong>，实现对整个堆空间的垃圾回收。</p><p>G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（<strong>Region</strong>）,每个Region都可以根据需要，扮演新生代的eden空间、Survivor空间、或者老年代空间。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250116233802743-2025-1-1623:38:07.png" alt="G1垃圾回收器的Region图示" style="zoom:80%;" /></p><p>其中区域Region的内存大小默认是通过整个堆内存大小除以<code>2048</code>得到的，例如整个堆内存为<code>4G</code>，则Region= 4G / 2048 = 2M，同时也支持通过JVM参数来指定Region的内存大小。</p><p>Region中还有一类特殊的<code>Humongous</code>区域，专门用来存放大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。对于超过了整个Region容量的超级大对象，将会被存放在N个连续的HumongousRegion中。G1会把HumongousRegion作为<strong>老年代</strong>的一部分来看待（由于大对象的复制成本较高，直接放入老年代可以减少内存碎片和复制开销）。</p><p>G1收集器突出表现出来的一点是通过一个停顿预测模型来根据<strong>用户配置的收集停顿时间</strong>（默认为200ms）来选择Region组成<strong>回收集（CollectionSet，简称CSet）</strong>，优先处理这些回收价值收益最大的Region，即那些大部分空间是可回收垃圾的区域。这种策略使得G1能够高效地回收垃圾，同时减少停顿时间。这也是G1得名“Garbage-First”的原因‌。</p><blockquote><p>关于停顿时间的设置不是越短越好，设置的太短导致每次选出来的回收集只占堆内存的一小部分，回收速度赶不上分配速度，导致垃圾慢慢堆积，最多占满堆引发FullGC反而降低了性能。停顿时间设置的过长，那么会导致每次都会产生长时间的停顿，影响了程序对外的响应时间。通常将其设置为一两百或者两三百毫秒是比较合适的。</p></blockquote><p>G1垃圾收集器如何建立起可靠的停顿预测模型？G1垃圾收集器之所以能够建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集的都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。用户可以使用JVM参数指定收集的停顿时间，G1收集器会记录每个Region的回收耗时、每个Region记忆集中的脏卡数量等各个可测量的步骤花费的成本，并得出平均值、标准偏差、置信度等统计信息，然后通过这些信息预测现在开始回收的话，由哪些Region组成的回收集才可以在不超过期望停顿时间的约束下获得最高的收益。</p><p>G1从整体来看是基于标记-整理算法实现的，但从局部（两个Region之间）上看又是基于标记-复制算法实现，无论如何，这两种算法都意味着G1运行期间不会产生内存空间碎块。</p><p>JVM参数</p><ul><li><p>启用G1的垃圾回收器</p><div class="code-wrapper"><pre><code class="hljs bash">-XX:+UseG1GC</code></pre></div></li><li><p>指定Region的内存大小</p><div class="code-wrapper"><pre><code class="hljs bash">-XX:G1HeapRegionSize=n</code></pre></div></li><li><p>设置最大暂停时间（默认200ms）</p><div class="code-wrapper"><pre><code class="hljs bash">-XX:MaxGCPauseMillis=n</code></pre></div></li><li><p>指定垃圾回收工作的线程数量</p><div class="code-wrapper"><pre><code class="hljs bash">-XX:ParallelGCThreads=n</code></pre></div></li></ul><h5 id="g1垃圾收集器原理">G1垃圾收集器原理</h5><p>G1垃圾回收有两种方式：新生代回收（<strong>Young GC</strong>）和混合回收（<strong>Mixed GC</strong>）</p><ul><li>YoungGC：主要针对新生代区域的垃圾回收，包括<code>Eden</code>区和<code>Survivor</code>区。当所有<code>Eden</code>区使用率达到最大阀值（默认60%）或者G1计算出来的回收时间接近用户设定的最大暂停时间时，会触发一次YoungGC，回收<code>Eden</code>区和<code>Survivor</code>区，复制移动到另外的<code>Survivor</code>幸存者（年龄+1）或Old老年代区（提前晋升的）.</li><li>Mixed GC：MixedGC是G1垃圾回收器<strong>独有的</strong>，针对新生代和部分老年代区域的垃圾回收。当老年代的占有率达到阀值（默认45%）或新生代被分配大对象时，会触发一次MixedGC，回收所有新生代和一部分老年代区（选取的策略是垃圾对象最多的老年代区域，确保释放更多内存空间，即回收价值高的），控制最大暂停时间。</li></ul><h6 id="young-gc原理">Young GC原理</h6><p>G1垃圾回收器新生代回收时，采用了三种关键技术，分别是<strong>记忆集</strong>、<strong>卡表</strong>和<strong>写屏障</strong>。接下来我们层层递进，研究一下这些技术分别解决了什么问题。</p><p>当G1触发<strong>YoungGC</strong>时，只会扫描新生代区域（扮演<code>Eden</code>区 和<code>Survivor</code>区的Region）的对象，从<code>GC Root</code>根对象出发时，很容易扫描出新生代的对象以及新生代对象引用的其它新生代的对象。但对象不是孤立的，对象之间会存在跨代引用，新生代中的对象完全有可能被老年代的对象引用。</p><p>为了解决跨Region的引用对象问题，G1使用<ahref="https://www.catpaws.top/f0242a65/#记忆集与卡表">记忆集</a>来记录跨代引用，避免对全部扮演老年代的Region的扫描。在G1收集器上记忆集的应用要复杂很多，它将所有的<code>Region</code>区域按大小划分为多个分块，称为<strong>卡页（CardPage）</strong>，并对每个卡页进行编号。每个<code>Region</code>都维护有自己的记忆集，每个<code>Region</code>区域都会有额外配备一小块内存，这块内存称为<strong>卡表（CardTable）</strong>，用于记录整个堆空间中有哪些卡页引用了自己<code>Region</code>区域的对象。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250118135812675-2025-1-1813:58:17.png" style="zoom:80%;" /></p><p>卡表的底层数据结构是字节数组，每一个字节对应一个卡页，当某个卡页中的对象引用自己<code>Region</code>区域的对象时，会将卡表对应编号位置的字节修改为<code>1</code>，为<code>1</code>的字节被称之为<strong>脏卡</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250118140108976-2025-1-1814:01:10.png" style="zoom:80%;" /></p><p>此时，进行YongGC时，只用遍历各个<code>Region</code>的卡表，找到所有字节为<code>1</code>的脏卡，将其也加入到<code>GC Root</code>根对象集合中，就能确保被老年代引用的新生代对象标记为存活，也避免了对所有老年代对象的扫描。</p><p>更新卡表状态的底层采用了<strong>写屏障</strong>技术（具体为写后屏障），当执行对象引用相关的代码时，会在其代码前后插入对应的指令。写屏障类似与Spring中的<code>AOP</code>，会在引用对象赋值前后做一些额外的动作，主要分为两个：</p><ul><li><strong>写前屏障</strong>：引用对象赋值前的特殊处理</li><li><strong>写后屏障</strong>：引用对象赋值后的特殊处理</li></ul><p>写后屏障指令判断到老年代对象引用年轻代对象时，会更改卡表中对应的字节为脏卡，同时会将脏卡放入到一个<strong>脏卡队列</strong>中，<strong>JVM会通过单独的线程，定期读取脏卡队列中的数据，更新记忆集</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250118141509292-2025-1-1814:15:10.png" style="zoom:80%;" /></p><h6 id="mixed-gc原理">Mixed GC原理</h6><p>混合回收是针对<strong>年轻代</strong>和<strong>部分老年代</strong>区域的垃圾回收，当老年代内存占用率达到设定阈值，或分配大对象时，将会触发混合回收<strong>MixedGC</strong>。</p><p>由于<code>Old</code>老年代区往往存在较多对象，G1垃圾回收器为提升执行效率，减少STW，部分耗时较长的阶段采用了与用户线程并发执行。</p><blockquote><p>由于用户程序要继续运行，在这个过程中肯定会持续有新对象被创建，G1为每个Region设计了两个名为<strong>TAMS</strong> (Top at MarkStart)的指针，把Region中的一部分空间划分出来用于并发回收过程中新对象的分配，并发回收时新分配的对象地址都必须在这两个指针的位置以上。G1收集器默认在这个地址以上的对象都是被隐式标记过的，即默认它是存活的，不纳入回收范围。</p><p>与CMS中的并发失败导致FullGC类型，如果内存回收速度赶不上内存分配速度，G1收集器也要被迫冻结用户线程执行，导致FullGC而产生长时间的STW。</p></blockquote><p>同时为进一步提升处理速度，以及解决并发阶段可能存在的对象引用变化问题，采用<strong>三色标记</strong>和<strong>SATB</strong>技术。总体分为<strong>初始标记</strong>、<strong>并发标记</strong>、<strong>最终标记</strong>、<strong>筛选回收</strong>四个阶段。</p><ol type="1"><li><p><strong>初始标记</strong></p><p>初始标记阶段仅仅是标记一下GCRoots能直接关联到的对象，并且修改<strong>TAMS</strong>指针的值，让下一阶段用户线程并发运行时能正确地在可用的Region内分配对象。</p><p>该阶段需要线程停顿，但耗时很短，而是借用进行 MinorGC的时候同步完成的。</p><p>实际上，标记对象其实是通过<strong>位图</strong>（<strong>bitmap</strong>）实现的。在对象的内存布局中，G1会使用一个标记位图来记录对象是否被标记。每个对象都有一个标记位，初始状态为未标记（或清除状态），对于每个从GCRoots可达的对象，G1会在对象的标记位中设置标记，表示该对象是存活的。</p></li><li><p><strong>并发标记</strong></p><p>从GCRoot开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这个阶段耗时较长，但可以与用户线程并发执行。</p><p>由于应用程序线程仍在运行，可能会产生新的对象引用关系或者修改了已有对象的引用关系，导致标记结果不准确。为了解决这个问题，G1收集器采用了<ahref="https://www.catpaws.top/f0242a65/#并发的可达性分析">三色标记法</a>，并使用原始快照（<strong>SATB</strong>）解决并发标记阶段可能产生的对象引用变化问题。</p><p>SATB算法通过<strong>写前屏障</strong>来破坏“对象消失”问题的条件。在并发标记过程中，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来。这些记录的信息在<u>最终标记</u>阶段被用来修正并发标记过程中可能出现的误标或漏标情况，从而确保标记的准确性。</p><blockquote><p>CMS垃圾回收器也使用到了三色标记算法，但它使用<strong>增量更新</strong>解决并发中对象引用变化问题</p></blockquote></li><li><p><strong>最终标记</strong></p><p>最终标记阶段会暂停用户线程，主要用于<strong>修正并发标记期间产生变动的对象</strong>。</p><p>G1会遍历在并发标记期间记录的写屏障信息，检查哪些对象的引用发生了变化。对于这些引用，G1会再次从GCRoots出发，标记所有新增的可达对象。</p></li><li><p><strong>筛选回收</strong></p><p>负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region中的存活对象复制到空的Region中，再清理掉旧Region的全部空间。这里的操作设计存活对象的移动，必须暂停用户线程，由多条收集器线程并行完成。</p></li></ol><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250118152622942-2025-1-1815:26:24.png"alt="Mixed GC运行示意图" /><figcaption aria-hidden="true">Mixed GC运行示意图</figcaption></figure><blockquote><p>除了并发标记阶段，其余三个阶段都需要暂停用户进程</p></blockquote><h5 id="zgc-收集器">ZGC 收集器</h5><p><ahref="https://blog.csdn.net/qq_42192693/article/details/145106593">参考文章</a></p><h4 id="垃圾回收调优">垃圾回收调优</h4><h2 id="四类加载和字节码技术">四、类加载和字节码技术</h2><h3 id="类文件结构">4.1、类文件结构</h3><p>根据JVM规范，类文件结构如下：</p><div class="code-wrapper"><pre><code class="hljs java">ClassFile &#123;    u4             magic; <span class="hljs-comment">//Class 文件的标志</span>    u2             minor_version;<span class="hljs-comment">//Class 的小版本号</span>    u2             major_version;<span class="hljs-comment">//Class 的大版本号</span>    u2             constant_pool_count;<span class="hljs-comment">//常量池的数量</span>    cp_info        constant_pool[constant_pool_count-<span class="hljs-number">1</span>];<span class="hljs-comment">//常量池</span>    u2             access_flags;<span class="hljs-comment">//Class 的访问修饰</span>    u2             this_class;<span class="hljs-comment">//当前类信息</span>    u2             super_class;<span class="hljs-comment">//父类信息</span>    u2             interfaces_count;<span class="hljs-comment">//包含接口的数量</span>    u2             interfaces[interfaces_count];<span class="hljs-comment">//一个类可以实现多个接口</span>    u2             fields_count;<span class="hljs-comment">//Class 文件的字段数量</span>    field_info     fields[fields_count];<span class="hljs-comment">//一个类可以有多个字段</span>    u2             methods_count;<span class="hljs-comment">//Class 文件的方法数量</span>    method_info    methods[methods_count];<span class="hljs-comment">//一个类可以有个多个方法</span>    u2             attributes_count;<span class="hljs-comment">//此类的属性表中的属性数</span>    attribute_info attributes[attributes_count];<span class="hljs-comment">//属性表集合</span>&#125;</code></pre></div><p>将以下代码使用 <code>javac</code>编译成Class文件后，使用idea的BinEd插件查看其十六进制内容。 <div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> ClassStructureExplore;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);    &#125;&#125;</code></pre></div></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119111901788-2025-1-1911:21:44.png" style=" width: 80%;height: auto;"></p><h4 id="魔数">魔数</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119154747077-2025-1-1915:47:48.png" style="zoom:80%;" /></p><p>每个 Class 文件开头的 4 个字节的无符号整数称为魔数（MagicNumber）。</p><p>0-3字节，表示它是否是【class】类型的文件。</p><ul><li>魔数值固定为 <code>0xCAFEBABE</code>，不符合则会抛出错误</li></ul><h4 id="版本">版本</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119154830103-2025-1-1915:48:31.png" style="zoom:80%;" /></p><p>4-7字节，共4个字节。其中 4-5字节代表的是编译的副版本号minor_version，6-7字节是编译的主版本号 major_version</p><p>案例中<code>0x0037</code>转化为十进制为55，代表JDK 11（56 代表JDK12，以此类推）</p><h4 id="常量池">常量池</h4><p>第8、9字节为<code>constant_pool_count</code>，即常量池长度。constant_pool是一种表结构以 1 ~ constant_pool_count - 1为索引，表明有多少个常量池表项。案例中第8、9字节为<code>0x001F</code>（31），表示常量池有#1~#30项，注意#0项不计入，也没有值。</p><p>表项中存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池</p><ul><li><p>字面量（Literal） ：基本数据类型、字符串类型常量、声明为 final的常量值等</p></li><li><p>符号引用（SymbolicReferences）：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</p></li></ul><p><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/8832b8158e55fe19bef734c32fc91767-2025-1-1915:42:18.png" /></p><blockquote><p>查表方法：例如标志为<code>0x0A</code>，转化为十进制为10，查表得标志为10对应的常量是<code>CONSTANT_Methodref_info</code>方法引用信息，其中信息包含三部分，分别为 <code>tag</code>1字节值为10，两个索引项<code>index</code>分别占两个字节，指向方法的所属类和方法名称在常量池中的位置索引。</p></blockquote><p>尝试分析：</p><p>第 #1 项 标志为<code>0x0A</code>表示一个方法引用信息。<code>0x0006</code>和<code>0x0011</code> (17)表示它引用了常量池中#6 和#17 项来获得这个方法的【所属类】 和【方法名】</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119155347744-2025-1-1915:53:49.png" style="zoom:67%;" /></p><p>第 #2 项 标志为<code>0x09</code>表示一个字段的引用信息，<code>0x0012</code>（18）和<code>0x0013</code>（19）表示它引用了第常量池中的第#18、#19项来获得这个字段的【所属类】和【字段描述】</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119155347744-2025-1-1915:53:49.png" style="zoom: 67%;" /></p><p>第 #3项，标志为<code>0x08</code>表示它是一个字符串字面量，<code>0x0014</code>(20)表示该字符串的字面量保存在常量池中第#20 项。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119161400969-2025-1-1916:14:02.png" style="zoom: 67%;" /></p><p>第 #4 项，标志为<code>0x0A</code>表示是一个方法引用信息，<code>0x0015</code>和<code>0x0016</code>表示引用了第常量池中的第 #21、#22项来获得这个方法的【所属类】 和【方法名】。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119161851115-2025-1-1916:18:52.png" style="zoom: 67%;" /></p><p>第 #5 项，标志为<code>0x07</code>表示一个Class信息，<code>0x0017</code>表示它引用了常量池中#23 项</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119162125562-2025-1-1916:21:26.png" style="zoom: 67%;" /></p><p>第 #6 项，标志为<code>0x07</code>表示一个Class信息，<code>0x0018</code>表示它引用了常量池中#24项</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119162540728-2025-1-1916:25:42.png" style="zoom: 67%;" /></p><p>第 #7 项，标志为<code>0x01</code> 表示一个utf8字符串，<code>0x0006</code> 表示字符串长度为6，字符串内容为<code>&lt;init&gt;</code></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119163514390-2025-1-1916:35:15.png" style="zoom: 67%;" /></p><p>第 #8 项，标志为<code>0x01</code> 表示一个utf8字符串，<code>0x0003</code> 表示字符串长度为，字符串内容为<code>()V</code>，表示方法无参、无返回值。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119173448460-2025-1-1917:34:57.png" style="zoom:67%;" /></p><p>......依次分析下去。</p><p>可以使用<code>javap -v xxx.class &gt;xxx.txt</code>将Class文件反编译并写入到一个txt文件中进行查看，其中常量池信息如下，可以和上面字节码的分析结果对比，二者是吻合的。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250119174911689-2025-1-1917:49:43.png"alt="image-20250119174911689" /><figcaption aria-hidden="true">image-20250119174911689</figcaption></figure><h4 id="访问标识">访问标识</h4><p>访问标识（access_flag），又叫访问标志、访问标记，访问标识符用于描述类或接口的访问权限（如public、private 等）、是否为抽象类、是否为接口、是否声明为 final等信息。</p><p>访问标识符在 Java字节码文件中占用<strong>两个字节</strong>（16位），这些位被用来表示不同的访问权限和特性。</p><p>访问标识符的具体内容‌：</p><p><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250119182107640-2025-1-1918:21:10.png" /></p><p>访问标识符是通过位操作来组合的。例如，如果一个类既是 public 的又是final 的，那么它的访问标识符将是 ACC_PUBLIC（0x0001）和ACC_FINAL（0x0010）的并集，即 0x0011。</p><p>在案例中，该类的访问修饰符为<code>0x0021</code> = <code>0x0020</code>+ <code>0x0001</code>，代表 ACC_PUBLIC 和 ACC_SUPER</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119182524858-2025-1-1918:25:26.png" style="zoom: 80%;" /></p><h4 id="索引集合">索引集合</h4><p>‌<strong>本类索引、父类索引、接口索引</strong>，这些索引用于确定类的继承关系，包括类的名称、父类的名称、实现的接口列表等。这些值指向常量池中的对应常量。</p><ul><li><p>本类索引：用于确定这个类的全限定名</p><p>当前案例中，<code>0x0005</code>: cp_info #5 (即常量池第5项) -&gt;cp_info #23 -&gt; ClassStructureExplore/HelloWorld</p></li><li><p>父类索引：用于确定这个类的父类的全限定名，Java语言不允许多重继承，所以父类索引只有一个</p><p>当前案例中，<code>0x0006</code>: cp_info #6 -&gt; cp_info #24-&gt;java/lang/Object</p></li><li><p>接口索引集合：用来描述这个类实现了哪些接口</p><ul><li>interfaces_count 表示接口数量</li><li>interfaces[] 接口索引集合，被实现的接口将按 implements语句后的接口顺序从左到右排列在接口索引集合中</li></ul><p>当前案例中，<code>0x0000</code>：表示当前类没有实现接口</p></li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250119184458104-2025-1-1918:45:06.png" style="zoom:80%;" /></p><h4 id="字段表集合">字段表集合</h4><p>​ 字段 fields用于描述接口或类中声明的变量，包括类变量以及实例变量，但不包括方法内部、代码块内部声明的局部变量（localvariables）以及从父类或父接口继承。字段叫什么名字、被定义为什么数据类型，都是无法固定的，只能引用常量池中的常量来描述。</p><ul><li><p><code>fields_count</code>（字段计数器）：表示当前 class 文件fields 表的成员个数，用两个字节来表示</p><p>本案例中，<code>0x0000</code>表示当前 class 文件没有字段</p><p><img src= style="zoom:67%;" /></p></li><li><p><code>fields[]</code>（字段表）: fields表中的每个成员都是一个<code>fields_info</code>结构的数据项，用于表示当前类或接口中某个字段的完整描述</p></li></ul><h4 id="方法表集合">方法表集合</h4><h4 id="属性表集合">属性表集合</h4>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis - 原理篇</title>
    <link href="/284457ed/"/>
    <url>/284457ed/</url>
    
    <content type="html"><![CDATA[<meta name = "referrer", content = "no-referrer"/><h2 id="一数据结构">一、数据结构</h2><h3 id="动态字符串sds">1.1、动态字符串SDS</h3><p>Redis中保存的Key是字符串，value往往是字符串或者字符串的集合。可见字符串是Redis中最常用的一种数据结构。</p><p>不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241230172432582-2024-12-3017:25:02.png" alt="image-20241230172432582" style="zoom:80%;" /></p><ul><li><p>没有内置的字符串类</p><p>C语言没有像其他高级语言那样提供内置的字符串类型。字符串在C语言中是以空字符<code>\0</code>'结尾的字符数组。</p></li><li><p>获取字符串长度的需要通过运算</p><p>由于C语言字符串没有内置的长度字段，获取字符串长度需要遍历整个字符数组，时间复杂度为O(N)。</p></li><li><p>非二进制安全</p><p>C语言字符串以空字符结尾，因此不能包含空字符作为数据的一部分。这限制了字符串在保存二进制数据（如图片、音频、视频文件等）方面的能力。</p></li></ul><p>Redis构建了一种新的字符串结构，称为<strong>简单动态字符串</strong>（SimpleDynamic String），简称<strong>SDS</strong></p><p>例如，执行<code>set name jack</code>，Redis会创建两个SDS，其中一个是包含'name'的SDS，另一个是包含'jack'的SDS。</p><p>Redis是C语言实现的，其中SDS是一个结构体，源码如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230173117353-2024-12-3017:31:36.png"alt="image-20241230173117353" /><figcaption aria-hidden="true">image-20241230173117353</figcaption></figure><p>其中包含头信息和字符数组</p><ul><li><p><code>len</code>：buf已保存的字符串字节数，不包含结束标示。</p></li><li><p><code>alloc</code>：buf申请的总的字节数，不包含结束标示。</p><blockquote><p>初始时<code>alloc</code>和<code>len</code>相同，但随着动态扩容，两者会有差异。</p></blockquote></li><li><p><code>flags</code>：不同SDS的头类型，用来控制SDS的头大小。</p><p>为了适应不同长度的字符串，Redis设计了五种SDS头部结构，这些结构的主要区别在于它们能够表示的字符串长度的范围不同。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230172940680-2024-12-3017:29:42.png"alt="image-20241230172940680" /><figcaption aria-hidden="true">image-20241230172940680</figcaption></figure></li><li><p>字符数组<code>buf[]</code>，保存字符串。为了兼容C语言，SDS存储字符串时也会在字符数组末尾添加一个结束标识<code>/0</code>。</p></li></ul><p>例如：保存一个字符串'name'的SDS结构如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241230173709674-2024-12-3017:37:11.png" alt="image-20241230173709674" style="zoom:80%;" /></p><p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为“hi”的SDS：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/1653984787383-2024-12-3017:51:27.png"alt="1653984787383" /><figcaption aria-hidden="true">1653984787383</figcaption></figure><p>假如我们要给SDS追加一段字符串“,Amy”，这里首先会申请新内存空间：</p><p>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1（'1'是存储结束标识<code>\0</code>花费的空间）；</p><p>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为内存预分配。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230175235061-2024-12-3017:52:36.png"alt="image-20241230175235061" /><figcaption aria-hidden="true">image-20241230175235061</figcaption></figure><p>优点：</p><ol type="1"><li>获取字符串长度的时间复杂度为<spanclass="math inline">\(O(1)\)</span></li><li>支持动态扩容</li><li>减少内存分配次数</li><li>二进制安全</li></ol><blockquote><p>当Redis需要存储一个字符串时，它会根据字符串的实际长度来选择合适的SDS头部结构。</p><p>‌<strong>当Redis中存储的字符串长度发生变化超出当前SDS（简单动态字符串）结构存储上限时，SDS会进行动态扩容，而不是切换到其他SDS结构存储</strong>‌。</p><p>SDS还采用了<strong>内存预分配</strong>和<strong>惰性空间释放</strong>策略来优化内存使用。</p><ul><li>当字符串需要扩容时，SDS会根据一定的规则（如小于1MB时按原长度两倍扩容，大于1MB时最多分配1MB空间）来分配新的内存空间‌。</li><li>当字符串缩短时，SDS并不会立即回收多余的内存空间，而是将其记录下来，以便将来使用。这种惰性空间释放策略减少了内存分配和释放的次数，提高了性能‌。</li></ul></blockquote><h3 id="intset">1.2、Intset</h3><h4 id="intset的结构">IntSet的结构</h4><p>IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。结构如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/1653984923322-2024-12-3018:33:13.png"alt="1653984923322" /><figcaption aria-hidden="true">1653984923322</figcaption></figure><p>其中的encoding包含三种模式，表示存储的整数大小不同：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/1653984942385-2024-12-3018:33:14.png"alt="1653984942385" /><figcaption aria-hidden="true">1653984942385</figcaption></figure><p>为了方便查找，Redis会将intset中所有的整数按照<strong>升序</strong>依次保存在contents数组中。</p><p>假设有一个intset，元素为{5，10，20}，采用的编码是<code>INTSET_ENC_INT16</code>，则每个整数占2字节：结构如图：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230183956901-2024-12-3018:39:59.png"alt="image-20241230183956901" /><figcaption aria-hidden="true">image-20241230183956901</figcaption></figure><p>现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是<code>INTSET_ENC_INT16</code>，每部分占用的字节大小为：encoding：4字节 length：4字节 contents：2字节 * 3 = 6字节</p><blockquote><p>由于数组中每个数字都采用相同的编码方式，即所占用的空间大小相同，可以结合数组起始地址和数组下标快速定位到每个元素的物理地址<code>startPtr + (sizeof(int16) * index)</code></p><p>数组下标理解为<strong>当前元素到数组起始地址间隔了多少个元素</strong></p></blockquote><h4 id="intset升级">IntSet升级</h4><p>当前的IntSet中，元素为（5，10，20），采用的编码是<code>INTSET_ENC_INT16</code>，则每个整数占2字节：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230212623555-2024-12-3021:26:29.png"alt="image-20241230212623555" /><figcaption aria-hidden="true">image-20241230212623555</figcaption></figure><p>我们向该其中添加一个数字：50000，这个数字超出了<code>INTSET_ENC_INT16</code>的范围，intset会自动<strong>升级</strong>编码方式到合适的大小。以当前案例来说流程如下：</p><ul><li>升级编码为INTSET_ENC_INT32,每个整数占4字节，并按照新的编码方式及元素个数扩容数组</li><li><strong>倒序</strong>依次将数组中的元素拷贝到扩容后的正确位置（这样向后移动元素时不会覆盖还未处理的元素）</li><li>将待添加的元素放入数组末尾</li><li>最后，将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241230213128501-2024-12-3021:31:30.png" alt="image-20241230213128501" style="zoom:80%;" /></p><p>源码分析：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230215915090-2024-12-3021:59:16.png"alt="intsetAdd" /><figcaption aria-hidden="true">intsetAdd</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230215809558-2024-12-3021:58:20.png"alt="intsetUpgradeAndAdd" /><figcaption aria-hidden="true">intsetUpgradeAndAdd</figcaption></figure><h3 id="dict">1.3、Dict</h3><h4 id="dict的结构">Dict的结构</h4><p>Redis是一个键值型（Key-ValuePair）的数据库，可以根据键实现快速的增删改查。而键与值的映射关系正是通过Dict来实现的。</p><p>Dict由三部分组成，分别是：<strong>哈希表（DictHashTable）</strong>、<strong>哈希节点（DictEntry）</strong>、<strong>字典（Dict）</strong></p><p>1、哈希结点（DictEntry）</p><p>包含一对key:value和指向下一个Entry的指针。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230223826657-2024-12-3022:38:28.png"alt="DictEntry的数据结构" /><figcaption aria-hidden="true">DictEntry的数据结构</figcaption></figure><p>​ <imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230224000025-2024-12-3022:40:02.png"alt="DictEntry的图示" /></p><p>2、哈希表（DictHashTable）</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230224110016-2024-12-3022:41:11.png"alt="DictHashTable的数据结构" /><figcaption aria-hidden="true">DictHashTable的数据结构</figcaption></figure><p>哈希表实际上就是一个数组，其中：</p><ul><li><code>dictEntry **table</code>是一个<code>DictEntry</code>类型的数组指针，而数组内保存的是指向一个个<code>DictEntry</code>对象的指针。</li><li><code>size</code>：哈希表数组的大小。总是 <spanclass="math inline">\(\color{red}2^n\)</span>，<strong>默认为4</strong>。</li><li><code>siezmask</code>：哈希表大小的掩码，总等于<spanclass="math inline">\(\color{red}size -1\)</span></li><li><code>used</code>：哈希表数组中已存在的entry的个数</li></ul><p>当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用<code>h &amp; sizemask</code>来计算元素应该存储到数组中的哪个索引位置。</p><blockquote><p><code>h &amp; sizemask</code>就相当于<code>h % size</code>。由于size总是<spanclass="math inline">\(2^n\)</span>，则它的余数就是1之后的那些位组成的数字，而sizemask= size-1，<code>h &amp; sizemask</code>就将余数部分保留下来了，相当于完成了取余操作。如：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230225659603-2024-12-3022:57:01.png"alt="image-20241230225659603" /><figcaption aria-hidden="true">image-20241230225659603</figcaption></figure><p><strong>因此，size必须始终为<spanclass="math inline">\(2^n\)</span>,sizemask才能保证对应size余数部分的二进制都为1，与hash值做与运算后才能得到余数，即新元素在哈希表中的索引位置。</strong></p></blockquote><p>例如：存储k1=v1，假设k1的哈希值h =1，则1&amp;3=1，因此k1=v1要存储到数组角标1位置。此时，再次插入的新的键值k2=v2经过hash运算，也要存储到数组下标1的位置，会产生<strong>哈希冲突</strong>。Redis解决冲突的方式是<strong>拉链法</strong>，将同义词通过链表连接起来，每次将新的同义词插入链表<strong>头部</strong>即可（若加到队尾，需要进行遍历）。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230230514385-2024-12-3023:05:16.png"alt="image-20241230230514385" /><figcaption aria-hidden="true">image-20241230230514385</figcaption></figure><p>3、字典（Dict）</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230230632158-2024-12-3023:06:34.png"alt="image-20241230230632158" /><figcaption aria-hidden="true">image-20241230230632158</figcaption></figure><p>其中：</p><ul><li><code>type</code>和<code>privdata</code>都是用来做哈希运算的</li><li><code>dictht ht[2]</code>:一个Dict包含两个哈希表，其中<code>ht[0]</code>保存当前数据；<code>ht[1]</code>一般是空，<strong>rehash</strong>时使用</li><li><code>rehashidx</code>：rehash的进度，-1表示未进行。<strong>Dict的rehash并不是一次性完成的，而是分多次、渐进式的完成。</strong>rehash开始时设置为0，在每次执行新增、查询、修改、删除操作时，执行一次rehash，将<code>ht[0]</code>中<code>rehashindex</code>对应下标的链表迁移到<code>ht[1]</code>，并且<code>rehashindex++</code>，直至<code>ht[0]</code>的所有数据都rehash到<code>ht[1]</code></li><li><code>pauserehash</code>：rehash是否暂停，1则暂停，0则继续</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230232051927-2024-12-3023:20:54.png"alt="Dict的结构" /><figcaption aria-hidden="true">Dict的结构</figcaption></figure><h4 id="dict的扩容">Dict的扩容</h4><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。</p><p>Dict在每次<strong>新增</strong>键值对时都会检查负载因子（<code>LoadFactor = used/size</code>），满足以下两种情况时会触发哈希表扩容：</p><ul><li>哈希表的 LoadFactor &gt;= 1，并且服务器没有执行 BGSAVE 或者BGREWRITEAOF 等后台进程；</li><li>哈希表的 LoadFactor &gt; 5 ；</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230233412969-2024-12-3023:34:15.png"alt="HashTable扩容" /><figcaption aria-hidden="true">HashTable扩容</figcaption></figure><h4 id="dict的收缩">Dict的收缩</h4><p>Dict除了扩容以外，每次<strong>删除</strong>元素时，也会对负载因子做检查，当<code>LoadFactor</code>&lt; 0.1时，会做哈希表收缩：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241231000236670-2024-12-3100:02:39.png"alt="HashTable收缩逻辑" /><figcaption aria-hidden="true">HashTable收缩逻辑</figcaption></figure><p>Dict的扩容和收缩都会调用<code>dictExpand</code>方法，其源码如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230235746690-2024-12-3023:57:49.png"alt="image-20241230235746690" /><figcaption aria-hidden="true">image-20241230235746690</figcaption></figure><h4 id="dict的rehash">Dict的rehash</h4><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此<strong>必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash</strong>。但是rehash是在执行增删操作时判断是否要执行rehash，而这些操作是在Redis的主进程中进行的，若一次迁移太多的entry会导致主进程阻塞，直至完成rehash后才能处理新命令。</p><p>因此，Dict的rehash并不是一次性完成的。<strong>Dict的rehash是分多次、渐进式的完成</strong>，因此称为<strong>渐进式rehash</strong>。流程如下：</p><ol type="1"><li><p>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：</p><ul><li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的 <spanclass="math inline">\(2^n\)</span></li><li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的 <spanclass="math inline">\(2^n\)</span>（不得小于4）</li></ul></li><li><p>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</p></li><li><p>设置dict.rehashidx = 0，标示开始rehash</p></li><li><p>每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，如果是则将dict.ht[0].table[rehashidx]的entryl链表rehash到dict.ht[1]，并且将rehashidx++。直至dict.ht[0]的所有数据都rehash到dict.ht[1]</p><blockquote><p>即每次执行新增、查询、修改、删除操作时，都将ht[0]中<code>rehashindex</code>所指下标的链表迁移到ht[1]，每次只迁移一条链表的数据，并且<code>rehashindex++</code>，直至将ht[0]中的数据都迁移到ht[1]</p></blockquote></li><li><p>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</p></li><li><p>将rehashidx赋值为-1，代表rehash结束</p></li><li><p>在rehash过程中，<strong>新增操作，则直接写入ht[1]</strong>，<strong>查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行</strong>。这样可以确保ht[0]的数据只减不增，随着rehash最终为空。</p></li></ol><h3 id="ziplist">1.4、ZipList</h3><p>Dict是由数组+单链表实现的，其数据存储在不连续的存储单元中，使用指针相互关联，这种方式存在的主要问题是内存的浪费，容易产生内存碎片，并且每个指针本身还要占据一定的字节空间。</p><p>ziplist是一种压缩存储结构，用于存储字符串或整数。它通过一系列特殊编码的<strong>连续内存块</strong>来存储数据，以减少内存使用。由于其设计结构，ZipList可以看作特殊“双端链表”，它没有使用指针记录前后结点的地址，而是通过<strong>记录结点长度</strong>来推算出前后结点的位置，它可以在任意一端进行压入/弹出操作,并且该操作的时间复杂度为 O(1)。</p><h4 id="ziplist的结构">ZipList的结构</h4><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241231115108381-2024-12-3111:51:09.png"alt="ZipList结构" /><figcaption aria-hidden="true">ZipList结构</figcaption></figure><p>ZipList主要包含四部分数据，分别是</p><ul><li><code>zlbytes</code> ：类型<code>uint32_t</code>，长度4字节，<strong>记录整个压缩列表占用的内存字节数</strong></li><li><code>zltail</code>：类型<code>uint32_t</code>，长度4字节<strong>，记录压缩列表表尾节点距离压缩列表的起始地址有多少字节</strong>，通过这个偏移量，可以确定表尾节点的地址。</li><li><code>zllen</code>：类型<code>uint16_t</code>，长度2字节，<strong>记录了压缩列表包含的节点数量</strong>。最大值为UINT16-MAX（65534），如果超过这个值，此处会记录为65535，但节点的真实数量需要遍历整个压缩列表才能计算得出。</li><li><code>entry</code>：压缩列表包含的各个节点，节点的长度由节点保存的内容决定，长度不定</li><li><code>zlend</code>：类型<code>uint8_t</code>，长度1字节，特殊值OxFF（十进制255），<strong>用于标记压缩列表的末端。</strong></li></ul><h4 id="entry的结构">Entry的结构</h4><p>ZipList中的Entry并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241231115851490-2024-12-3111:58:54.png" alt="ZipList entry的结构" style="zoom:80%;" /></p><ul><li><code>previous_entry_length</code>：前一节点的长度，占1个或5个字节。<ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li><li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li></ul></li><li><code>encoding</code>：编码属性，记录<strong>content的数据类型</strong>（字符串还是整数）以及<strong>长度</strong>，占用1个、2个或5个字节</li><li><code>contents</code>：负责保存节点的数据，可以是字符串或整数</li></ul><blockquote><p>要获得下一节点的地址。只需用当前节点的地址 + entry 的长度即可</p><p>要获得前一结点的地址，只需用当前节点的地址 -<code>previous_entry_length</code>即可</p><p>ZipList中所有存储长度的数值均采用<strong>小端存储</strong>，即先存储低字节，低地址存低字节，高地址存高字节。例如：数值0x1234，采用小端字节序后实际存储值为：0x3412</p><p><strong>如果列表数据过多，导致链表过长，查询中间的某个数据时要经过多次计算寻址，可能影响查询性能</strong></p></blockquote><h4 id="entry的encoding编码">Entry的Encoding编码</h4><p>ZipListEntry中的encoding编码分为字符串和整数两种：</p><p><strong>字符串</strong>：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241231195137157-2024-12-3119:52:06.png"alt="image-20241231195137157" /><figcaption aria-hidden="true">image-20241231195137157</figcaption></figure><p>例如，我们要保存字符串：“ab”和“bc”。ZipList中第一个Entry保存的是"ab"，其中<code>previous_entry_length</code>= 0，"ab"的占两个字节，<code>encoding</code> =00000010，a和b的ASCII码分别为61和62，故存储"ab"的Entry内容如下，左侧为十六进制存储。存储“bc”的Entry内容同理可得。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241231195950607-2024-12-3120:00:06.png"alt="ab的Entry内容" /><figcaption aria-hidden="true">ab的Entry内容</figcaption></figure><p>整个ZIPList的内容如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241231200702856-2024-12-3120:07:06.png"alt="image-20241231200702856" /><figcaption aria-hidden="true">image-20241231200702856</figcaption></figure><p><strong>整数</strong>：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241231201103448-2024-12-3120:11:06.png"alt="image-20241231201103448" /><figcaption aria-hidden="true">image-20241231201103448</figcaption></figure><p>整数的编码通常只有<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>，对应的数据分别为1、2、4、8个字节，用两位编码即可区分，故除了最高位的11用来表示整数，之后的两位用来表示是哪种编码。Redis中多了一种3字节的整数，所以多用了一种编码表示该类型。</p><p>对于一些比较小的数字，如1,3,8等，用一个字节表示还是有点浪费，Redis直接把这些小数字的值保存在类型编码里，范围是0001-1101（低四位的0000和1110都被使用了，为了不和编码产生冲突，只能存储这个范围内的数字），减一后结果为实际值，即0001表示0,0010表示1。</p><p>例如，一个ZipList中包含两个整数值："2"和"5"，其Entry结构和整个ZipList结构如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241231202638438-2024-12-3120:26:56.png"alt="整数2和5的Entry结构" /><figcaption aria-hidden="true">整数2和5的Entry结构</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241231202829878-2024-12-3120:28:30.png"alt="整个ZipList的结构" /><figcaption aria-hidden="true">整个ZipList的结构</figcaption></figure><h4 id="ziplist的连锁更新问题">ZipList的连锁更新问题</h4><p>ZipList的每个Entry都包含<code>previous_entry_length</code>字段来记录上一个节点的大小。这个字段的长度是1个或5个字节：</p><ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值。</li><li>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，其中第一个字节为0xfe，后四个字节才是真实长度数据。</li></ul><p>当在ZipList中插入、删除或修改数据时，如果新元素的长度改变了相邻元素的<code>previous_entry_length</code>字段的值（例如，从1个字节变为5个字节），那么就需要更新这个字段。更糟糕的是，这个更新可能会触发后续元素的连续更新，因为后续元素的<code>previous_entry_length</code>字段也可能需要调整以反映新的前一个元素的大小。这种连续多次的空间扩展操作就被称为<strong>连锁更新。</strong></p><p>例如：有N个连续的、长度为250-253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241231204258567-2024-12-3120:42:59.png"alt="image-20241231204258567" /><figcaption aria-hidden="true">image-20241231204258567</figcaption></figure><p>若此时，在表头插入一个长度为254字节的entry，原来表头entry的<code>previous_entry_length</code>就要从1个字节变为5个字节，那么这个entry的长度就变成254字节。原来第二个entry为了记录前面entry的长度，它的<code>previous_entry_length</code>也要从1个字节变为5个字节，它的长度也变成254字节，又会引起后面一个entry的<code>previous_entry_length</code>变大......</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241231204815306-2024-12-3120:48:16.png"alt="image-20241231204815306" /><figcaption aria-hidden="true">image-20241231204815306</figcaption></figure><blockquote><p>由于ZipList的entry是连续存储，<code>previous_entry_length</code>要从1个字节变为5个字节，需要将之后的数据整体向后迁移，若空间不足还要申请新的空间，对性能影响较大。但这种情况<strong>发生概率是极低</strong>的，连锁更新通常发生在特定的条件下。</p></blockquote><p>为了缓解ZipList的连锁更新问题，可以采取以下几种解决方案：</p><ol type="1"><li><p>‌<strong>限制ZipList的长度和Entry大小</strong>‌：</p><p>通过配置Redis的相关参数（如<code>hash-max-ziplist-entries</code>、<code>hash-max-ziplist-value</code>、<code>zset-max-ziplist-entries</code>、<code>zset-max-ziplist-value</code>等），限制ZipList的长度和Entry的大小。当数据超过这些限制时，Redis会自动将ZipList转换为其他数据结构（如Hash、SkipList+Dict）来存储。</p></li><li><p>‌<strong>使用多个ZipList分片存储数据</strong>‌：</p><p>如果需要存储大量数据，可以考虑将数据分片存储到多个ZipList中。这样，每个ZipList的大小都会受到限制，从而减少了连锁更新发生的可能性。</p></li><li><p>‌<strong>升级Redis版本</strong>‌：</p><p>在Redis5版本中，引入了ZipList的替代版本ListPack。ListPack移除了<code>prevlen</code>字段，采用了不同的结构来存储数据，从而避免了连锁更新的问题。如果可能的话，可以考虑升级到支持ListPack的Redis版本。</p><blockquote><p>为了解决ziplist的连锁更新问题，Redis引入了listpack结构。Listpack同样采用了紧凑的内存布局，但<strong>它摒弃了ziplist中的prevlen字段，改为让每个元素只记录自己的长度信息。这样，当修改某个元素时，就不会影响到其他元素，从而避免了连锁更新的发生。</strong></p></blockquote><p><ahref="https://blog.csdn.net/m0_51504545/article/details/126078789">ListPack参考文章</a></p></li></ol><h3 id="quicklist">1.5、QuickList</h3><p>ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p><p>为了缓解这个问题，我们必须限制ZipList的长度和entry大小。</p><p>但是我们要存储大量数据，超出了ZipList最佳的上限该怎么办？</p><p>我们可以创建多个ZipList来分片存储数据。</p><p>数据拆分后比较分散，不方便管理和查找，这多个ZipList如何建立联系？</p><p>Redis在3.2版本引入了新的数据结构<strong>Quicklist</strong>，<strong>它是一个双端链表，只不过链表中的每个节点都是一个ZipList</strong>。它结合了ziplist和双向链表的优点，旨在提供高效的内存利用率和快速的插入、删除操作。其结构如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101104308576-2025-1-110:43:25.png"alt="QuickList结构" /><figcaption aria-hidden="true">QuickList结构</figcaption></figure><p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：<code>list-max-ziplist-size</code>来限制。</p><p>如果值为正，则代表ZipList的允许的<strong>entry个数的最大值</strong></p><p>如果值为负，则代表<strong>ZipList的最大内存大小</strong>，分5种情况：</p><ul><li>-1：每个ZipList的内存占用不能超过4kb</li><li>-2：每个ZipList的内存占用不能超过8kb</li><li>-3：每个ZipList的内存占用不能超过16kb4</li><li>-4：每个ZipList的内存占用不能超过32kb</li><li>-5：每个ZipList的内存占用不能超过64kb</li></ul><p>其默认值为：-2</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250101104658228-2025-1-110:47:00.png" alt="list-max-ziplist-size的默认值" style="zoom:80%;" /></p><p>除了控制ZipList的大小，QuickList还可以对节点的ZipList做压缩。通过配置项<code>list-compress-depth</code>来控制。因为链表一般都是从首尾访问较多，所以首尾是不压缩的。这个参数是控制<strong>首尾不压缩的节点个数</strong>：</p><ul><li>0：特殊值，代表不压缩</li><li>1：标示QuickList的首尾各有1个节点不压缩，中间节点压缩</li><li>2：标示QuickList的首尾各有2个节点不压缩，中间节点压缩</li><li>以此类推</li></ul><p>默认值为0，默认不进行压缩</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250101104919212-2025-1-110:49:20.png" alt="list-compress-depth的默认值" style="zoom:80%;" /></p><p>源码分析：</p><p>以下是QuickList的和QuickListNode的结构源码，及内存结构图</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101105404993-2025-1-110:54:06.png"alt="image-20250101105404993" /><figcaption aria-hidden="true">image-20250101105404993</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101105543536-2025-1-110:55:45.png"alt="image-20250101105543536" /><figcaption aria-hidden="true">image-20250101105543536</figcaption></figure><p>QuickList的优势主要体现在以下几个方面：</p><ul><li>‌<strong>内存占用低</strong>‌：通过结合ziplist和双向链表的优点，QuickList进一步压缩了内存的使用量。</li><li>‌<strong>操作速度快</strong>‌：QuickList提供了高效的遍历算法和快速的插入、删除操作。</li><li>‌<strong>灵活性高</strong>‌：QuickList可以根据实际情况动态调整节点的大小和数量，以适应不同的应用场景。</li></ul><blockquote><p>当向QuickList中插入一个元素时，Redis会根据一定的策略选择一个合适的quicklistNode，并将元素插入到该节点中。如果插入操作导致quicklistNode中的元素数量超过了一定的阈值（由list-max-ziplist-size参数决定），Redis会将该节点拆分成两个节点。同样，如果删除操作导致quicklistNode中的元素数量过少，Redis会将相邻的两个节点合并成一个节点。</p></blockquote><p>从Redis3.2版本开始，list数据结构就使用了QuickList来代替之前的压缩列表（ziplist）和链表（linkedlist）。因此，当使用Redis的list命令（如lpush、rpush、lpop、rpop等）时，实际上就是在操作QuickList。</p><p>总结：QuickList是一个节点为ZipList的双端链表，节点采用ZipList，解决了传统链表的内存占用问题；控制了ZipList大小，解决连续内存空间申请效率问题；中间节点可以压缩，进一步节省了内存。</p><h3 id="skiplist">1.6、SkipList</h3><p>SkipList是为了解决有序集合的高效查找、插入和删除操作而设计的。它结合了平衡树和链表的优点，既保持了数据的有序性，又提供了快速的访问速度。主要用于实现Redis中的有序集合（SortedSet）</p><p><strong>SkipList（跳表）</strong>首先是链表，但与传统链表相比有几点差异：</p><ul><li><p>元素按照升序排列存储</p></li><li><p>节点可能<strong>包含多个指针，指针跨度不同</strong>。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101112809753-2025-1-111:28:10.png"alt="image-20250101112809753" /><figcaption aria-hidden="true">image-20250101112809753</figcaption></figure></li></ul><p>其结构定义如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101112015649-2025-1-111:20:34.png"alt="SkipList的结构定义" /><figcaption aria-hidden="true">SkipList的结构定义</figcaption></figure><p>SkipList本身的定义中包含头尾节点指针，链表中结点的数量和最大的索引层级，默认是1。</p><p>SkipList结点的定义中包括：</p><ul><li>结点的值，类型是动态字符串；</li><li>结点的分数，<strong>按分数对结点升序排列存储</strong>，用于排序和查找；</li><li>前一个结点的指针</li><li>多级索引数组，每个结点中包含的指针数量不确定，首节点的最多，中间节点的较少，故用数组保存。这些指针分布在不同的层级上，用于实现多级索引。每个索引包括指向下一节点的指针和该指针的跨度</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101113225469-2025-1-111:32:26.png"alt="SkipList内存结构" /><figcaption aria-hidden="true">SkipList内存结构</figcaption></figure><p><strong>查找操作</strong>‌：</p><ul><li>从最高层开始，通过前进指针逐层向下查找。</li><li>如果当前节点的下一个节点的值小于要查找的值，则向右移动；如果大于要查找的值，则向下移动。</li><li>重复上述过程，直到找到目标节点或确定目标节点不存在。</li></ul><p>‌<strong>插入操作</strong>‌：</p><ul><li><p>首先进行查找操作，找到插入位置。</p></li><li><p>随机生成一个层数，根据这个层数在每一层插入新节点。</p><blockquote><p>SkipList的一个关键特性是它允许节点在不同的层级上存在。为了确定新节点的层级，通常会使用一个概率模型来随机选择。例如，可以设置一个预设值p（通常是一个小于1的常数），然后生成一个0到1之间的随机数。如果这个随机数小于p，就将节点的层数加1，直到达到一个预设的最大层数或者随机数不再小于p为止。这个过程确保了节点层级的随机性，从而有助于保持SkipList的平衡性。</p></blockquote></li><li><p>更新相关节点的前进指针和跨度。</p></li></ul><p><strong>删除操作</strong>‌：</p><ul><li>首先进行查找操作，找到要删除的节点。</li><li>然后在每一层删除这个节点，并调整相关节点的前进指针和跨度。</li></ul><h3 id="redisobject">1.7、RedisObject</h3><p>RedisObject是Redis中表示数据对象的结构体，它是Redis数据库中的基本数据类型的抽象。在Redis中，<strong>所有的数据都被存储为RedisObject类型的对象</strong>。</p><p>RedisObject结构体中包含了多个字段，用于表示对象的类型、编码方式、引用计数、最近访问时间以及指向实际存储数据的指针等信息。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;       <span class="hljs-comment">// 数据类型，如字符串、列表、哈希等</span>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;   <span class="hljs-comment">// 编码方式，如int、raw、hashtable等</span>    <span class="hljs-type">unsigned</span> lru:LRU_BITS; <span class="hljs-comment">// Least Recently Used，用于记录对象最近被访问的时间</span>    <span class="hljs-type">int</span> refcount;          <span class="hljs-comment">// 引用计数，用于自动内存管理</span>    <span class="hljs-type">void</span> *ptr;             <span class="hljs-comment">// 指向实际存储数据的指针</span>&#125; robj;</code></pre></div><ul><li><p>‌<strong>type</strong>‌：表示数据对象的类型，用4位表示，对应着Redis的几种基本数据类型，分别是string、hash、list、set和zset。</p><blockquote><p>#define OBJ_STRING 0 #define OBJ_LIST 1 #define OBJ_SET 2 #defineOBJ_ZSET 3 #define OBJ_HASH 4</p></blockquote></li><li><p>‌<strong>encoding</strong>‌：底层编码方式，共有11种，占4个bit位，不同的编码方式对应不同的存储结构。</p></li><li><p>‌<strong>lru</strong>‌：记录对象最近被访问的时间，占用24个bit位，用于实现LRU（LeastRecently Used）策略，即最近最少使用策略，用于内存淘汰。</p></li><li><p>‌<strong>refcount</strong>‌：对象引用计数器，，用于自动内存管理。当引用计数为0时，表示对象可以被释放。Redis通过引用计数来管理内存，避免内存泄漏。</p></li><li><p>‌<strong>ptr</strong>‌：指向实际存储数据的指针，根据不同的数据类型和编码方式，指向不同的数据结构。</p></li></ul><blockquote><p>一个RedisObject的头信息所占用的空间是16字节。若有n个字符串要存储，每个字符串都选用String类型存储，每个都需要一个RedisObject头，会造成大量空间浪费在头信息的存储。若使用List等集合类型存储这些字符串，只需一个RedisObject头就可以完成。</p><p>因此，当有大量数据存储时，尽量选择集合类型进行存储，避免内存浪费。</p></blockquote><p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101120941750-2025-1-112:09:43.png"alt="11种编码类型" /><figcaption aria-hidden="true">11种编码类型</figcaption></figure><p>每种数据类型的使用的编码方式如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101121049469-2025-1-112:10:50.png"alt="image-20250101121049469" /><figcaption aria-hidden="true">image-20250101121049469</figcaption></figure><p>RedisObject的作用：</p><ul><li>‌<strong>统一对象管理</strong>‌：RedisObject为Redis中的各种数据类型提供了一个统一的接口，使得Redis能够以一致的方式处理不同类型的数据。</li><li>‌<strong>内存优化</strong>‌：通过引用计数和LRU机制，RedisObject实现了自动内存管理和淘汰策略，有效地节省了内存空间，提高了内存利用率。</li><li>‌<strong>操作一致性</strong>‌：RedisObject为不同类型的数据提供了统一的操作接口，如获取对象类型、编码方式、值等，保证了操作的一致性。</li></ul><p>Redis底层数据结构包括SDS（简单动态字符串）、IntSet（整数集合）、Dict（字典）、ZipList（压缩列表）、QuickList（快速列表）、SkipList（跳跃表）等。这些数据结构被广泛应用于Redis的各种功能模块中，如字符串、哈希、列表、集合、有序集合等。</p><p>RedisObject与这些底层数据结构的关系是：RedisObject是对这些底层数据结构的抽象和封装。RedisObject的<code>ptr</code>字段指向实际存储数据的指针，这个数据结构由<code>type</code>和<code>encoding</code>属性决定。例如，如果一个RedisObject的<code>type</code>属性为<code>OBJ_LIST</code>，<code>encoding</code>属性为<code>OBJ_ENCODING_QUICKLIST</code>，那么这个对象就是一个Redis列表（List），它的值保存在一个QuickList的数据结构内，而<code>ptr</code>指针就指向QuickList的对象。</p><h3 id="五种不同的数据类型">1.8、五种不同的数据类型</h3><h4 id="string">String</h4><p>String是Redis中最常见的数据存储类型，基于<strong>简单动态字符串（SDS）</strong>实现。String类型的底层编码方式有三种，分别是<code>raw</code>、<code>embstr</code>和<code>int</code>。</p><ul><li><p>当存储的字符串长度超过44字节时，会采用<code>raw</code>编码方式。，存储上限为512mb。</p><p>RedisObject对象头和SDS对象在内存地址不是连续的，需要分配两次内存，性能较差。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101155622345-2025-1-115:56:28.png"alt="raw类型编码" /><figcaption aria-hidden="true">raw类型编码</figcaption></figure></li><li><p>当存储的字符串长度小于等于<strong>44字节</strong>时，Redis使用<code>embstr</code>编码。在embstr编码中，RedisObject对象头和SDS（SimpleDynamicString）对象在内存中地址是连在一起的，申请内存时只需要调用一次内存分配函数，操作字符串时不用做额外的寻址操作，效率较高。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101165235446-2025-1-116:52:36.png"alt="embstr编码" /><figcaption aria-hidden="true">embstr编码</figcaption></figure><blockquote><p>为什么是44字节？SDS的头信息中<code>len</code>、<code>alloc</code>、<code>flags</code>各占一字节，字符结束符<code>\0</code>占一字节，字符串内容44字节，整个SDS共占48字节，RedisObject头信息共占16字节，加起来是64字节。<strong>Redis中，jemalloc是默认的内存分配器</strong>，Jemalloc会为不同大小的内存请求分配固定大小的块（这些块的大小通常是2的幂次），在分配内存时会尽量满足内存对齐的要求，以减少由于频繁的内存分配和释放操作导致的内存碎片。64字节刚好是Jemalloc的一个内存分配单位，能把这些数据存储在一个连续的内存块中而不产生内存碎片。</p></blockquote></li><li><p>当存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用<code>INT</code>编码：<strong>直接将数据保存在RedisObject的ptr指针位置，不再需要SDS了</strong>。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101172324620-2025-1-117:23:25.png"alt="image-20250101172324620" /><figcaption aria-hidden="true">image-20250101172324620</figcaption></figure><blockquote><p>一个指针占8字节，而不论Java还是C中的整数最多占8个字节，因此刚好可以用ptr指针的内存空间存储整数值</p></blockquote></li></ul><h4 id="list">List</h4><p>Redis的List类型可以从首、尾操作列表中的元素。哪一个数据结构能满足上述特征？</p><ul><li>LinkedList：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li><li>ZipList：压缩列表，可以从双端访问，内存占用低，存储上限低</li><li>QuickList：LinkedList +ZipList，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高</li></ul><p>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量小于512并且元素大小小于64字节时采用ZipList编码，超过则采用LinkedList编码。</p><p>在3.2版本之后，Redis统一采用<strong>QuickList</strong>来实现List</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101185826611-2025-1-118:58:34.png"alt="List结构" /><figcaption aria-hidden="true">List结构</figcaption></figure><h4 id="set">Set</h4><p>Set是Redis中的单列集合，满足下列特点：</p><ul><li>不保证有序性</li><li>保证元素唯一（可以判断元素是否存在）</li><li>求交集、并集、差集</li></ul><p>由于Set要保证集合中元素唯一，在很多操作中都要判断一个元素是否已经存在，如插入时需判断元素是否存在，求交集时要找出两个集合都存在的元素等等。可以看出，<strong>Set对查询元素的效率要求非常高</strong>。</p><p>为了查询效率和唯一性，set采用<strong>HT编码</strong>（<strong>Dict</strong>）。<strong><u>Dict中的key用来存储元素，value统一为null。</u></strong></p><p>当存储的所有数据都是整数，并且元素数量不超过<code>set-max-intset-entries</code>时，Set会采用<strong>IntSet编码</strong>，以节省内存。</p><blockquote><p><code>set-max-intset-entries</code>可以在配置文件中设置，默认为512</p></blockquote><p>当第一次向set中添加元素时会创建新的set，会根据元素的值来决定采用什么编码，创建什么结构来存储。如果该字符是数值类型，会采用Intset编码，并创建IntSet存储元素；如果该字符不是数值类型，则会采用HT编码，创建Dict存储元素。</p><p><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101201119665-2025-1-120:11:37.png"alt="image-20250101201119665" />在向set插入元素过程中</p><ul><li><p>若原来的编码类型是HT，则直接插入。</p></li><li><p>若当前的编码是IntSet，需要进行判断。当<u>目前插入的元素不是数值类型</u>或者<u>该元素是数值类型，但成功插入后Set中的元素个数超过了设定值</u>时，该Set的编码会从IntSet切换为HT，并使用Dict存储当前IntSet中的值。若这两个条件都满足，则继续在原来的IntSet中存储新元素。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101202638679-2025-1-413:44:38.png"alt="image-20250101202638679" /><figcaption aria-hidden="true">image-20250101202638679</figcaption></figure></li></ul><p>插入过程的源码分析如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250101202110049-2025-1-120:21:37.png" style="zoom:80%;" /></p><h4 id="zset">ZSet</h4><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/1653992091967-2025-1-120:50:56.png" alt="1653992091967" style="zoom:80%;" /></p><p>具备以下功能：</p><ul><li>可以根据score值排序</li><li>member必须唯一</li><li>可以根据member查询分数</li></ul><p>因此，zset底层数据结构必须满足<strong>键值存储</strong>、<strong>键必须唯一</strong>、<strong>可排序</strong>这几个需求。哪种编码结构可以满足？</p><ul><li>SkipList：可以排序，并且可以同时存储score和ele值（member），但无法保证键的唯一性。</li><li>HT（Dict）：可以键值存储，并且可以根据key找value，但无法排序。</li></ul><p>Zset底层同时使用了这两种编码结构，结合它们的功能满足Zset的需要，ZSet的结构定义如下，在创建ZsetObject对象时，先创建了Zset对象，再为Zset对象创建了Dict和SkipList，并将编码方式设置为<code>OBJ_ENCODING_SKIPLIST</code></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101205736858-2025-1-120:57:37.png"alt="Zset结构" /><figcaption aria-hidden="true">Zset结构</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/1653992172526-2025-1-120:59:11.png"alt="Zset内存结构" /><figcaption aria-hidden="true">Zset内存结构</figcaption></figure><p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存，同一份数据存储了两份。因此zset还会采用<strong>ZipList</strong>结构来节省内存，不过需要同时满足两个条件：</p><ul><li>元素数量小于zset_max_ziplist_entries，默认值128</li><li>每个元素都小于zset_max_ziplist_value字节，默认值64</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250101210256404-2025-1-121:02:57.png" alt="image-20250101210256404" style="zoom:80%;" /></p><p>但是ziplist本身没有排序功能，而且没有键值对的概念，因此需要通过逻辑编码实现：</p><ul><li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry，element在前，score在后</li><li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101210507745-2025-1-121:05:08.png"alt="Zset使用ZipList时的内存结构" /><figcaption aria-hidden="true">Zset使用ZipList时的内存结构</figcaption></figure><p>源码分析：</p><p>创建Zset：在zadd添加元素时，先根据key找到zset，不存在则创建新的zset。创建时判断配置文件中<code>zset_max_ziplist_entries</code>值是否为0，设置为0就是禁用了zipList；或者value大小超过了<code>zset_max_ziplist_value</code>，此时采用HT和SKipList的方案，否则采用ZipList。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250101210931134-2025-1-121:09:32.png" alt="image-20250101210931134" style="zoom:80%;" /></p><p>由于Zset存在两种编码方式，在添加元素可能发生编码转换。向Zset中添加元素时，首先判断编码方式，若本身是SKIPLIST编码，无序转换。否则，可能存在编码转换的可能，具体逻辑如代码所示。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250101211648500-2025-1-121:16:49.png" alt="image-20250101211648500" style="zoom:80%;" /></p><h4 id="hash">Hash</h4><p>Hash结构与Redis中的Zset非常类似：</p><ul><li>都是键值存储</li><li>都需求根据键获取值</li><li>键必须唯一</li></ul><p>不同的是，zset要根据score排序；hash则无需排序。因此，Hash底层采用的编码与Zset也基本一致，只需要把排序有关的SkipList去掉即可。</p><p>Hash结构<strong>默认采用ZipList编码</strong>，用以节省内存。ZipList中相邻的两个entry分别保存field和value。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101220515346-2025-1-122:05:16.png"alt="ZipList编码方式" /><figcaption aria-hidden="true">ZipList编码方式</figcaption></figure><p>当数据量较大时，Hash结构会转为HT编码，也就是Dict，触发条件有两个：</p><ul><li>ZipList中的元素数量超过了hash-max-ziplist-entries（默认512）</li><li>ZipList中的任意entry大小超过了hash-max-ziplist-value（默认64字节）</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250101220835623-2025-1-122:08:36.png"alt="HT编码格式" /><figcaption aria-hidden="true">HT编码格式</figcaption></figure><p>源码分析：</p><p>Hash结构在创建默认采用ZipList编码，由于存在两种编码格式，在添加元素时也会发生格式转换，代码分析如图：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/无标题-2025-1-122:10:10.png" alt ="Hash创建及添加数据代码分析" style="zoom:50%;" /></p><h2 id="二网络模型">二、网络模型</h2><h3 id="用户空间和内核空间">2.1、用户空间和内核空间</h3><p>ubuntu和Centos都是Linux的发行版，发行版可以看成对linux包了一层壳，任何Linux发行版，其系统内核都是Linux。</p><p>用户的应用，比如redis，mysql等其实是没有办法去执行访问系统的硬件的，所以可以通过发行版的这个壳子去访问内核，再通过内核去访问计算机硬件。</p><p>计算机硬件包括，如cpu，内存，网卡等等，内核（通过寻址空间）可以操作硬件，但是内核需要不同设备的驱动，有了这些驱动之后，内核就可以去对计算机硬件去进行内存管理，文件系统的管理，进程的管理等等。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/1653896065386-2025-1-209:23:22.png"alt="1653896065386" /><figcaption aria-hidden="true">1653896065386</figcaption></figure><p>我们想要用户的应用来访问，计算机就必须要通过对外暴露的一些接口，才能访问到，从而间接的实现对内核的操控，但是内核本身上来说也是一个应用，所以他本身也需要一些内存，cpu等设备资源，用户应用本身也在消耗这些资源。为了避免了用户程序随意的去操作系统资源，错误地或恶意地执行危险指令，如清空内存、修改时钟等，需要把用户和<strong>内核隔离开</strong>。</p><p>进程的寻址空间划分成两部分：<strong>内核空间、用户空间</strong></p><p>应用程序也好，还是内核空间也好，都是没有办法直接去物理内存的，而是通过分配虚拟内存映射到物理内存中。通过虚拟内存可以将内核空间与用户空间隔离开来，避免用户程序错误地或恶意地访问内核空间。在32位Linux操作系统中，虚拟内存空间大小为4GB，其被划分为两部分：高位的1G空间作为内核空间，低位的3G空间作为用户空间。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250102195140543-2025-1-219:51:44.png" alt="虚拟内存划分" style="zoom:80%;" /></p><p>在linux中，他们权限分成两个等级，0和3，用户空间只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访问。内核空间可以执行特权命令（Ring0），调用一切系统资源，所以一般情况下，用户的操作是运行在用户空间，而内核运行的数据是在内核空间的，而有的情况下，一个应用程序需要去调用一些特权资源，去调用一些内核空间的操作，所以此时他俩需要<strong>在用户态和内核态之间进行切换</strong>。</p><h3 id="linux-io模型">2.2、Linux IO模型</h3><p>Linux系统为了提高IO效率，会在用户空间和内核空间都加入缓冲区：</p><ul><li><p>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</p></li><li><p>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</p></li></ul><p>针对这个操作：用户在读数据时，会去向内核态申请，想要读取内核的数据，而内核数据要去等待驱动程序从硬件上读取数据，当从磁盘上加载到数据之后，内核会将数据写入到内核的缓冲区中，然后再将数据拷贝到用户态的buffer中，然后再返回给应用程序。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/1653896687354-2025-1-219:54:18.png" alt="1653896687354" style="zoom:80%;" /></p><p>该过程中主要的时间花费就是用在了用户等待数据就绪以及用户态和内核态数据缓冲区之间的数据拷贝。为了提高IO效率，Linux的五种不同的IO模型就是在<strong>等待数据就绪</strong>和<strong>读取数据</strong>这两个阶段做了不同的处理。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250102200444084-2025-1-220:04:45.png"alt="image-20250102200444084" /><figcaption aria-hidden="true">image-20250102200444084</figcaption></figure><p>在《UNIX网络编程》一书中，总结归纳了5种IO模型：</p><ul><li>阻塞IO（Blocking IO）</li><li>非阻塞IO（Nonblocking IO）</li><li>IO多路复用（IO Multiplexing）</li><li>信号驱动IO（Signal Driven IO）</li><li>异步IO（Asynchronous IO）</li></ul><h4 id="阻塞io">阻塞IO</h4><p>顾名思义，阻塞IO就是两个阶段都必须阻塞等待：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250102201324645-2025-1-220:13:26.png"alt="image-20250102201324645" /><figcaption aria-hidden="true">image-20250102201324645</figcaption></figure><p>当应用程序调用IO函数（如read或write）时，如果数据没有准备好，用户进程会被阻塞，直到数据准备好并被复制到应用程序的缓冲区中。</p><p>在阻塞期间，进程无法执行其他任务，CPU资源被浪费在等待上。</p><h4 id="非阻塞io">非阻塞IO</h4><p>非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程。如果数据没有准备好，函数会立即返回，并返回一个错误码（如EWOULDBLOCK），表示当前没有数据可读或可写。用户程序需要<strong>不断轮询内核</strong>，检查数据是否准备好，这会导致CPU资源的浪费。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250102201821482-2025-1-220:18:23.png"alt="image-20250102201821482" /><figcaption aria-hidden="true">image-20250102201821482</figcaption></figure><p>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增。</p><h4 id="io多路复用">IO多路复用</h4><p>无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：</p><ul><li>如果调用recvfrom时，恰好<strong>没有</strong>数据，阻塞IO会使CPU阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用。</li><li>如果调用recvfrom时，恰好<strong>有</strong>数据，则用户进程可以直接进入第二阶段，读取并处理数据</li></ul><p>比如服务端处理客户端Socket请求时，在单线程情况下，只能依次处理每一个socket，如果正在处理的socket恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有其它客户端socket都必须等待，性能自然会很差。</p><p>就比如服务员给顾客点餐，<strong>分两步</strong>：</p><ul><li>顾客思考要吃什么（等待数据就绪）</li><li>顾客想好了，开始点餐（读取数据）</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250102202456528-2025-1-220:24:58.png"alt="image-20250102202456528" /><figcaption aria-hidden="true">image-20250102202456528</figcaption></figure><p>要提高效率有几种办法？</p><p>方案一：增加更多服务员（多线程）方案二：不排队，谁想好了吃什么（数据就绪了），服务员就给谁点餐（用户应用就去读取数据）</p><p>那么问题来了：用户进程如何知道内核中数据是否就绪呢？</p><p><strong>文件描述符</strong>（FileDescriptor）：简称<strong>FD</strong>，<strong>是一个从0开始递增的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）</strong>。<ahref="https://blog.csdn.net/ye_yumo/article/details/143252968">参考文章</a></p><p><strong>IO多路复用：是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</strong></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250102203443599-2025-1-220:34:45.png"alt="image-20250102203443599" /><figcaption aria-hidden="true">image-20250102203443599</figcaption></figure><p>不过在Linux系统中监听FD的方式、通知的方式又有多种实现，常见的有：<code>select</code>、<code>poll</code>和<code>epoll</code>。它们是Linux提供的用于监听多个文件描述符状态的系统调用。这些系统调用允许程序将一组文件描述符注册到监听队列中，当其中任何一个文件描述符的状态发生变化时（如可读、可写或发生错误），系统调用会返回并通知应用程序。</p><p>区别：</p><ul><li><code>select</code>和<code>poll</code>适用于监听文件描述符数量较少的情况，而<code>epoll</code>在大量文件描述符的监听场景中性能更优。</li><li>在通知方式上，<code>select</code>和<code>poll</code>只会通知用户进程有FD就绪，但不确定具体是哪个FD，需要用户进程逐个遍历FD来确认；<code>epoll</code>则会在通知用户进程FD就绪的同时，把已就绪的FD写入用户空间。</li></ul><h5 id="io多路复用之select">IO多路复用之select</h5><p>select是Linux中最早的I/O多路复用实现方案，select函数相关源码如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/select-2025-1-221:10:44.png"alt="select" /><figcaption aria-hidden="true">select</figcaption></figure><p>通过select方式进行IO多路复用的流程如下：</p><ol type="1"><li>假设现在的IO都是读操作，创建<code>fd_set rfds</code>，初始时将所有比特位都置为零。</li><li>假如要监听 fd = 1，2，5，将<code>rfds</code>中对应的比特位置为1</li><li>调用select函数将这些fd信息拷贝到内核空间，内核负责对这些fd进行监听。执行<code>select(5 + 1, rfds, null, null, 3)</code></li><li>内核遍历<code>rfds</code>，从最低位开始，到传入的最大值为止，判断这个范围内被标记的fd是否已经就绪</li><li>若当前没有就绪的fd，休眠等待数据就绪被唤醒或超时</li></ol><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250102212349537-2025-1-221:23:50.png" alt="image-20250102212349537" style="zoom:80%;" /></p><ol start="6" type="1"><li>当有fd就绪时，内核会将结果写回到内核的<code>rfds</code>中。具体做法是，遍历内核中的<code>rfds</code>，遍历过程中找到被监听的fd，将其与已就绪的fd比较，相同则保留，其余的fd对应比特位置为0。之后将内核中的<code>rfds</code>拷贝回用户空间的<code>rfds</code>中，此时<code>rfds</code>中保存的就是已就绪的fd，并且select函数会返回已就绪fd的数量。</li></ol><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250102213454924-2025-1-221:34:57.png" alt="image-20250102213454924" style="zoom:80%;" /></p><ol start="7" type="1"><li>用户进程<strong>遍历</strong>fd_set，找到就绪的fd，读取其中的数据</li></ol><p>以上是执行一次select函数的过程，之后要读取还未就绪的fd或者其他数据时，按照上面的流程将要读取的fd添加到<code>rfds</code>中（<strong>可能将一个fd循环拷贝多次</strong>），传到内核中进行监听，数据准备就绪时再去读取。循环往复处理各种读写数据的请求。</p><p>select模式存在的问题：</p><ul><li>需要将整个fd_set从用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间</li><li>select无法得知具体是哪个fd就绪，需要遍历整个fd_set fd_set</li><li>监听的fd数量不能超过1024</li></ul><h5 id="io多路复用之poll">IO多路复用之poll</h5><p>poll模式对select模式做了简单改进，但性能提升不明显，部分关键代码如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250102214720250-2025-1-221:47:22.png" alt="poll模式" style="zoom:80%;" /></p><p>IO流程：</p><ol type="1"><li><p>‌<strong>用户进程调用poll()函数</strong>‌：</p><p>用户进程通过调用<code>poll()</code>函数，将需要监听的fd及其关注的事件类型（如读就绪、写就绪等）传递给内核。</p><p>传递给<code>poll()</code>函数的是一个<code>pollfd</code>结构体数组，每个结构体中包含了一个文件描述符和该文件描述符所关注的事件类型。</p></li><li><p>‌<strong>内核处理poll()请求</strong>‌：</p><p>内核接收到<code>poll()</code>调用后，会将这些文件描述符和事件类型注册到内核内部的监听列表中（<strong>转链表存储，无上限</strong>）。</p><p>内核会监视这些文件描述符的状态，当其中一个或多个文件描述符的事件就绪时，内核会进行相应的处理。</p></li><li><p>‌<strong>内核通知用户进程</strong>‌：</p><p>当内核检测到某个fd的事件已经就绪时，它会修改该fd的<code>pollfd</code>结构体中的<code>revents</code>为已就绪，并将<code>pollfd</code>结构体数组从内核空间<strong>拷贝回用户空间</strong>，并返回就绪fd数量</p></li><li><p>‌<strong>用户进程处理就绪事件</strong>‌：</p><p>用户进程通过调用<code>poll()</code>函数，阻塞等待直到有文件描述符就绪或者超时。</p><p>当<code>poll()</code>函数返回时，用户进程通过<strong>遍历</strong><code>pollfd</code>结构体数组中的<code>revents</code>成员，可以得知哪些文件描述符的事件已经就绪，进而可以读取对应fd的数据。</p></li></ol><p><strong>与select对比：</strong></p><ul><li>select模式中的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</li><li><code>poll()</code>函数在内核中是通过轮询的方式来检查文件描述符的状态的。监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li></ul><h5 id="io多路复用之epoll">IO多路复用之epoll</h5><p><strong>epoll</strong>‌是对<code>select</code>和<code>poll</code>的改进，能够显著减少数据复制的开销并提高系统资源的利用率。</p><p>主要工作原理如下：</p><ul><li>‌<strong>事件驱动</strong>‌：<code>epoll</code>采用事件通知机制，只有当文件描述符有事件发生时才会被通知。与<code>select</code>和<code>poll</code>的轮询机制相比，<code>epoll</code>避免了无效轮询，提高了处理效率。</li><li>‌<strong>数据结构</strong>‌：<code>epoll</code>使用<strong>红黑树</strong>和<strong>就绪队列</strong>来管理文件描述符。红黑树用于快速查找和管理注册的文件描述符，就绪列表则用于存储已经准备好进行IO操作的文件描述符。</li><li>‌<strong>回调机制</strong>‌：<code>epoll</code>通过回调函数来通知用户进程文件描述符的事件状态。当事件发生时，内核会调用相应的回调函数，将事件信息添加到就绪列表中。</li></ul><p>具体源码分析，它提供了三个函数：</p><p>1、<code>epoll_create</code>：在内核创建eventpoll结构体，返回对应的句柄epfd，即该eventpoll的唯一标识。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250102221030671-2025-1-222:10:31.png" alt="epoll_create" style="zoom:80%;" /></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250102221248791-2025-1-413:40:19.png" alt="执行epoll_create" style="zoom:80%;" /></p><p>2、<code>epoll_ctl</code>：与select和poll相比，该函数只是将一个fd添加到eventpoll的红黑树中，对这个fd进行监听，但<strong>不会等待</strong>该fd对应的数据就绪。而是对该fd设置要监听的事件发生时的回调函数函数<code>ep_poll_callback</code>，当要监听的事件发生时，自动调用该回调函数，就把对应的FD加入到就绪列表中</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250102221353073-2025-1-222:13:55.png" alt="epoll_ctl" style="zoom:80%;" /></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250102222040358-2025-1-413:40:46.png" alt="执行epoll_ctl" style="zoom:80%;" /></p><p>3、<code>epoll_wait</code>：将fd添加到红黑树中后，调用epoll_wait<strong>检查就绪列表</strong>是否为空，不为空则返回就绪的FD的数量，同时将就绪列表中的fd拷贝到用户空间中的<code>events</code>中。（与select和poll不同，它们是将所有的fd列表拷贝过去，而epoll拷贝过去的只是就绪的fd）</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250102222307077-2025-1-222:23:09.png" alt="epoll_wait" style="zoom:80%;" /></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250102222811692-2025-1-222:28:12.png" alt="执行epoll_wait" style="zoom:67%;" /></p><p>小结：</p><p>select模式存在的三个问题：</p><ul><li>能监听的FD最大不超过1024</li><li>每次select都需要把所有要监听的FD都拷贝到内核空间</li><li>每次都要遍历所有FD来判断就绪状态</li></ul><p>poll模式的问题：</p><ul><li>poll利用链表解决了select中监听FD上限的问题，但依然要遍历所有FD，如果监听较多，性能会下降</li></ul><p>epoll模式中如何解决这些问题的？</p><ul><li>基基于epoll实例中的红黑树保存要监听的FD，理论上无上限，而且增删改查效率都非常高，性能不会随监听的FD数量增多而下降</li><li><strong>每个FD只需要执行一次epoll_ctl添加到红黑树</strong>，以后每次epol_wait无需传递任何参数，无需重复拷贝FD到内核空间</li><li>内核会将就绪的FD直接拷贝到用户空间的指定位置，用户进程无需遍历所有FD就能知道就绪的FD是谁</li></ul><h5id="基于epoll模式的web服务的基本流程">基于epoll模式的web服务的基本流程</h5><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250103101024427-2025-1-310:10:25.png"alt="image-20250103101024427" /><figcaption aria-hidden="true">image-20250103101024427</figcaption></figure><ol type="1"><li>在服务端调用<code>epoll_create</code>创建epoll实例，在内核中创建红黑树和就绪列表</li><li>创建serverSocket，得到一个服务端的套接字文件描述符，记为<code>ssfd</code>。</li><li>调用<code>epoll_ctl</code>将监听套接字添加到红黑树中，并指定监听的事件类型（如<code>EPOLLIN</code>表示读就绪事件），同时注册fd就绪时的回调函数。</li><li>进入事件循环，使用<code>epoll_wait</code>函数等待<code>ssfd</code>上有事件发生。</li><li>等待指定时间后若无事件发生，则再次调用<code>epoll_wait</code>。</li><li>当被监听的fd上有事件发生时，根据<code>epoll_wait</code>返回的事件类型，进行相应的处理。</li><li>如果<code>ssfd</code>发生读就绪事件，则说明有客户端进行连接，调用<code>accpt()</code>函数接收客户端socket，得到对应的fd，并调用<code>epoll_ctl</code>为客户端socket添加监听。</li><li>如果发生的是客户端socket的读就绪事件，则使用<code>read()</code>或<code>recv()</code>函数读取客户端发送的数据，进行处理后返回响应。</li><li>如果客户端连接关闭或发生错误，则使用<code>close()</code>函数关闭客户端套接字，并从epoll树中删除。</li><li>循环处理事件，重复步骤4-9‌，继续等待并处理下一个事件，直到服务器进程被终止。</li></ol><h5 id="事件通知机制">事件通知机制</h5><p>在IO多路复用中，事件通知机制有两种主要的触发模式<code>LT</code>和<code>ET</code>，它们定义了当文件描述符上的事件就绪时，内核如何通知用户进程，并且用户进程应该如何处理这些事件。</p><p>水平触发（Level Triggered, <strong>LT</strong>）</p><ul><li><p>工作原理：当FD有数据可读时，每次调用<code>epoll_wait</code>时，都会返回该事件（<strong>会重复通知多次</strong>），直至数据处理完成。是Epoll的默认模式。</p></li><li><p>特点：LT模式相对简单直观，用户进程可以在每次调用<code>epoll_wait</code>时处理一部分数据，而不必担心遗漏事件。然而，如果事件处理不及时，可能会导致事件堆积，增加处理复杂度。</p></li></ul><p>边缘触发（Edge Triggered, <strong>ET</strong>）</p><ul><li>工作原理：当FD有数据可读时，<strong>只会被通知一次</strong>，不管数据是否处理完成。用户进程必须确保在接收到通知后，<strong>能够一次性处理完所有就绪的事件</strong>，否则可能会遗漏后续的事件。</li><li>特点：ET模式要求用户进程对事件进行高效处理，以避免遗漏。它通常与非阻塞IO结合使用，可以提高系统的吞吐量和响应速度。然而，实现起来相对复杂，需要用户进程仔细管理事件的处理逻辑。</li></ul><p>在epoll模式中，当fd的监听事件发生时，会调用该函数的回调函数，将该fd添加到就绪列表中。当调用<code>epoll_wait</code>时，会将就绪队列中的fd拷贝到用户空间去，但再次之前会将就绪的fd从就绪列表中断开，再完成拷贝动作。可能这次拷贝并没有将所有fd都拷贝过去，若当前采用的是<code>ET</code>模式，下次再来拷贝剩余的数据时会失败，因为之前的就绪的fd已经从就绪列表中断开了。而当采用的是<code>LT</code>模式时，若还有数据没有拷贝完，会将这些fd数据重写添加回就绪列表中，以便下次继续拷贝剩余的数据。</p><p>在实际应用中，选择LT模式还是ET模式取决于具体的应用场景和需求。</p><ul><li>‌<strong>LT模式</strong>‌适用于那些可以容忍一定延迟，但希望简化事件处理逻辑的应用场景。</li><li>‌<strong>ET模式</strong>‌则更适用于那些需要高效处理大量并发事件，对延迟敏感的应用场景，如高性能网络服务器。</li></ul><h4 id="信号驱动io">信号驱动IO</h4><p>它允许用户进程通过注册一个信号处理函数来<strong>异步</strong>接收数据可用的通知。当设备数据可用时，内核会向用户进程发送一个SIGIO信号，触发用户进程预先注册的信号处理函数，进而执行相应的IO操作。期间用户应用可以执行其它业务，无需阻塞等待。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250103091322550-2025-1-309:13:33.png" alt="image-20250103091322550" style="zoom:80%;" /></p><p><strong>与其他IO模型的比较</strong>‌：</p><ul><li>与阻塞IO相比，信号驱动IO避免了用户进程在IO操作完成前的阻塞，提高了IO效率。</li><li>与非阻塞IO相比，信号驱动IO不需要用户进程通过轮询方式不断尝试读写文件描述符，减少了CPU资源的浪费。</li><li>与IO复用（如select、poll、epoll）相比，信号驱动IO通过信号机制实现IO操作的异步通知，不需要进程主动调用轮询函数来检查IO状态。</li><li>与异步IO相比，信号驱动IO仍然需要用户进程在信号处理函数中执行IO操作，而异步IO则完全由内核处理IO操作，并在完成后通知用户进程。</li></ul><p>存在的问题：当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出而且内核空间与用户空间的频繁信号交互性能也较低。</p><h4 id="异步io">异步IO</h4><p>异步IO的<strong>整个过程都是非阻塞的</strong>，用户进程调用完异步API后就可以去做其它事情，内核等待数据就绪并拷贝到用户空间后才会递交信号，通知用户进程。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250103091746704-2025-1-309:17:47.png"alt="image-20250103091746704" /><figcaption aria-hidden="true">image-20250103091746704</figcaption></figure><p><strong>优点</strong></p><ol type="1"><li>‌<strong>高性能</strong>‌：异步IO能够在IO操作进行的同时，让CPU去执行其他任务，从而提高系统的整体性能。</li><li>‌<strong>资源利用率高</strong>‌：异步IO可以让一个线程同时处理多个IO操作，避免了频繁的线程切换，从而提高了CPU和内存的利用率。</li><li>‌<strong>提高响应速度</strong>‌：由于异步IO不需要等待IO操作完成，可以立即返回执行其他任务，因此可以提高系统的响应速度。</li><li>‌<strong>高并发处理能力</strong>‌：异步IO可以处理大量的并发IO请求，使得系统能够更有效地处理多个IO操作。</li></ol><p><strong>缺点</strong></p><ol type="1"><li>‌<strong>编程复杂度增加</strong>‌：异步编程模型相对于同步编程模型更加复杂，因为它涉及到事件循环、回调函数等概念，可能会增加代码的编写和维护成本。</li><li>‌<strong>错误处理困难</strong>‌：异步编程中可能存在回调地狱(CallbackHell)等问题，导致代码难以理解和调试，容易出现逻辑错误和内存泄漏等问题。</li><li>‌<strong>调试困难</strong>‌：异步程序中的事件顺序可能比较随机，因此在调试时可能会很难追踪代码的执行流程，特别是当存在大量异步操作时更加困难。</li><li>‌<strong>资源竞争</strong>‌：如果异步操作涉及共享资源的读写，可能会导致资源竞争和数据一致性问题，需要额外的同步机制来解决。</li></ol><p>注意：在IO操作中，<strong>同步和异步</strong> 与<strong>阻塞和非阻塞</strong>没有直接关系。</p><p>IO操作是同步还是异步，<strong>关键看数据在内核空间与用户空间的拷贝过程</strong>（数据读写的10操作），也就是阶段二是同步还是异步：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250103092223705-2025-1-309:22:24.png" alt="image-20250103092223705" style="zoom:80%;" /></p><h3 id="redis网络模型">2.3、Redis网络模型</h3><p>Redis是单线程还是多线程？</p><p>如果仅仅聊Redis的核心业务部分（命令处理），答案是单线程</p><p>如果是聊整个Redis，那么答案就是多线程</p><p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p><ul><li>Redisv4.0：引入多线程异步处理一些耗时较长的任务，例如异步删除命令unlink</li><li>Redisv6.0：在核心网络模型中引入多线程，进一步提高对于多核CPU的利用率</li></ul><p>为什么Redis要选择单线程？</p><ul><li><p>抛开持久化不谈，Redis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升。</p></li><li><p>多线程会导致过多的上下文切换，带来不必要的开销</p></li><li><p>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</p></li></ul><p>Redis通过IO多路复用来提高网络性能，并且支持各种不同的多路复用实现，并且将这些实现进行封装，提供了<strong>统一的</strong>高性能事件库API库AE。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250103093722861-2025-1-309:37:24.png"alt="image-20250103093722861" /><figcaption aria-hidden="true">image-20250103093722861</figcaption></figure><p>在<code>ae.c</code>中根据当前系统支持的多路复用方式，引入对应响应的API库，之后调用API时就会调用对应文件中的函数。</p><p>在Linux系统下，Redis底层使用epoll实现多路复用，可以参考<ahref="https://www.catpaws.top/284457ed/#基于epoll模式的web服务的基本流程">基于epoll模式的web服务流程</a>，分析Redis单线程网络模型的源码：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/Redis单线程网络模型的代码执行流程-2025-1-313:12:44.png"alt="Redis单线程网络模型的代码执行流程" /><figcaptionaria-hidden="true">Redis单线程网络模型的代码执行流程</figcaption></figure><ul><li><code>server.c</code>中的<code>main</code>方法是整个服务的入口</li><li>首先在<code>main</code>方法中，执行<code>initServer()</code>初始化服务，在该方法中调用aeApiCreate（类似于epoll_create）创建epoll实例，创建ServerSocket并得到对应的fd。同时注册Socket连接处理器，在该处理器内部会调用<code>aeApiAddEvent</code>监听ServerSocket的读事件，并为为其绑定事件触发时的处理器<code>acceptTcpHandler</code>。</li><li>在<code>acceptTcpHandler</code>中，处理ServerSocket上的读事件，接收客户端请求，得到客户端socket的fd。监听Socket的读事件，并为其绑定读事件触发时的处理器<code>readQueryFromClient</code>。</li><li><code>readQueryFromClient</code>负责处理客户端发来的命令请求，首先从客户端的读缓冲区中读取命令字符串，再解析这些字符串，转为Redis命令参数存入c-&gt;argv数组。从argv数组中获得要执行的命令和参数，通过对应命令的command函数执行命令，并将结果写到客户端写缓冲区c-&gt;buf，若缓冲区写不下，写到c-&gt;reply，这是一个链表，容量无上限。最后将客户端添加到server.clients_pending_write这个队列，等待被写出。</li><li>之后执行<code>main</code>方法中的<code>aeMain</code>开始循环监听事件，等待fd就绪。</li><li>当开始监听后，若指定的fd未就绪，则需要休眠等待。因此在开始监听前，会先调用前置处理器<code>beforesleep</code>，对clients_pending_write这个队列中等待写出的客户端进行处理，依次将对应客户端缓存区中的数据返回给客户端。</li><li>之后，开始监听fd，执行<code>aeApiPoll</code>（类似以epoll_wait）。当就绪队列中有fd时，会返回就绪fd的数量，调用对应的处理器处理就绪的fd。</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250103114438782-2025-1-311:44:40.png"alt="image-20250103114438782" /><figcaption aria-hidden="true">image-20250103114438782</figcaption></figure><p>整体来讲，Redis使用了IO多路复用技术，允许单个线程同时监听多个文件描述符（包括服务端的ServerSocket和客户端的socket），并在有数据可读或可写时将任务派发给不同的处理器进行处理。具体来说：</p><ul><li>当服务端的ServerSocket发生读事件时，说明有客户端进行连接，将对应的任务分配给连接应答处理器<code>tcpAcceptHandler</code>，获取客户端socket对应的fd，并为其注册监听；</li><li>当客户端socket发生读事件时，说明用客户端命令请求到达，将对应的任务分配给命令请求处理器<code>readQueryFromClient</code>，从客户端读缓冲区中读取命令字符串并解析为Redis命令进行处理，将处理结果写到客户端写缓冲区，并将该客户端放入clients_pending_write队列等待数据写回；</li><li>在每次循环监听fd之前，通过<code>beforesleep</code>方法调用命令回复处理器<code>sendReplyToClient</code>处理clients_pending_write队列中的客户端，将存储在客户端输出缓冲区（<code>buf</code>字段）或输出链表（<code>reply</code>字段）中的响应数据发送给客户端。</li></ul><p>Redis 6.0版本中引入了多线程，目的是为了提高IO读写效率。</p><p>在处理客户端命令请求时，需要从客户端Socket中读出命令，在此过程中涉及到了网络IO的读操作，会受到网络带宽等影响。同样的，在将服务端处理结果写回客户端Socket中时，涉及到了网络IO的写操作，这又是一个性能瓶颈。</p><p>对于redis来说在监听fd，以及命令执行的时候，（主线程）单线程是完成足够的（纯内存操作），真正影响性能的永远是IO。</p><p>因此在<strong>解析客户端命令</strong>、<strong>写响应结果</strong>时采用了多线程。核心的命令执行、IO多路复用模块依然是由主线程执行。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250103115210756-2025-1-311:52:11.png"alt="image-20250103115210756" /><figcaption aria-hidden="true">image-20250103115210756</figcaption></figure><h2 id="三通信协议---resp协议">三、通信协议 - RESP协议</h2><p>Redis是一个CS架构的软件，通信一般分两步（不包括pipeline和PubSub）：</p><ol type="1"><li>客户端（client）向服务端（server）发送一条命令</li><li>服务端解析并执行命令，返回响应结果给客户端</li></ol><p>因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。</p><p>而在Redis中采用的是RESP（Redis Serialization Protocol）协议：</p><ul><li>Redis 1.2版本引入了RESP协议</li><li>Redis 2.0版本中成为与Redis服务端通信的标准，称为RESP2</li><li>Redis6.0版本中，从RESP2升级到了RESP3协议，增加了更多数据类型并且支持6.0的新特性--客户端缓存</li></ul><p>但目前，默认使用的依然是RESP2协议（以下简称RESP）。</p><p>在RESP中，通过<strong>首字节</strong>的字符来区分不同数据类型，常用的数据类型包括5种：</p><ul><li><p>单行字符串：首字节是 <code>+</code>，后面跟上单行字符串，以CRLF（<code>\r\n</code>）结尾。例如返回OK： <code>+OK\r\n</code>。</p><blockquote><p>单行字符串的数据中只能包含普通字符串，不允许包含<code>\r\n</code>，是非二进制安全的。通常用于服务端返回的信息</p></blockquote></li><li><p>错误（Errors）：首字节是 <code>-</code>，与单行字符串格式一样，只是字符串是异常信息，例如："-Errormessage"。</p></li><li><p>数值：首字节是<code>:</code>，后面跟上数字格式的字符串，以CRLF结尾。例如：":10"</p></li><li><p>多行字符串：首字节是 <code>$</code>，表示二进制安全的字符串，最大支持512MB。记录时保存<strong>字符串长度</strong>和<strong>字符串本身</strong>，例如：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250103141407181-2025-1-314:14:08.png"alt="image-20250103141407181" /><figcaption aria-hidden="true">image-20250103141407181</figcaption></figure><ul><li><p>如果大小为0，则代表空字符串："$0"</p></li><li><p>如果大小为-1，则代表不存在："$-1"</p></li></ul></li><li><p>数组：首字节是<code>*</code>，后面跟上数组元素个数，再跟上元素，元素数据类型不限，例如：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250103141609254-2025-1-314:16:10.png"alt="image-20250103141609254" /><figcaption aria-hidden="true">image-20250103141609254</figcaption></figure></li></ul><h2 id="四内存策略">四、内存策略</h2><p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。</p><p>我们可以通过修改配置文件来设置Redis的最大内存。当内存使用达到上限时，就无法存储更多数据了。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250103144051474-2025-1-314:40:52.png" alt="image-20250103144051474" style="zoom:80%;" /></p><h4 id="过期策略">过期策略</h4><p>在Redis中，可以通过<code>expire</code>命令给Redis的key设置TTL（存活时间）</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250103214944506-2025-1-321:50:18.png" alt="image-20250103214944506" style="zoom:80%;" /></p><p>可以发现，当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放，从而起到内存回收的目的。</p><p>那么，Redis如何知道一个Key是否过期呢？</p><p>答：利用两个Dict分别记录key-value对及key-ttl对</p><p>Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在Dict结构中。不过在其database结构体中，对key进行了划分，使用多个Dict数组保存。其中，<strong><code>dict</code>中存放所有的key及value，而<code>expires</code>只包含设置了TTL的key，在其中存储key及其对应的TTL存活时间</strong>。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250103215311967-2025-1-321:53:13.png"alt="database结构体" /><figcaption aria-hidden="true">database结构体</figcaption></figure><p><img src="https://gitee.com/cmyk359/img/raw/master/img/redisDb-2025-1-322:35:25.png" alt="redisDb" style="zoom:80%;" /></p><p>是不是TTL到期就立即删除了呢？</p><p><strong>惰性删除</strong>：顾明思议并不是在TTL到期后就立刻删除，而是在<strong>访问</strong>一个key的时候，检查该key的存活时间，如果已经过期才执行删除。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250103223836841-2025-1-322:38:38.png"alt="惰性删除" /><figcaption aria-hidden="true">惰性删除</figcaption></figure><p>若有很多key过期后很长时间没有被访问，只采用惰性删除时，这些key就无法被释放。</p><p><strong>周期删除</strong>：顾明思议是通过一个定时任务，周期性的<strong>抽样部分过期的key</strong>，然后执行删除。</p><p>执行周期有两种：</p><ul><li><p>Redis服务初始化函数initServer()中设置定时任务，按照server.hz的频率来执行过期key清理，模式为<strong>SLOW</strong></p></li><li><p>Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为<strong>FAST</strong></p></li></ul><p>SLOW模式规则：</p><ul><li>执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</li><li>执行清理耗时不超过一次执行周期的25%.</li><li>逐个遍历db，逐个遍历db中的bucket（相当于dict中哈希表的一个角标下的链表），抽取20个key判断是否过期</li><li>如果没达到时间上限（25ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li></ul><p>FAST模式规则（过期key比例小于10%不执行）：</p><ul><li>执行频率受<code>beforesleep()</code>调用频率影响，但两次FAST模式间隔不低于2ms</li><li>执行清理耗时不超过1ms</li><li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li><li>如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li></ul><p>源码分析：</p><p>Slow模式会在服务初始化时调用一次<code>serverCron</code>进行清理，并返回下一次调用<code>serverCron</code>的时间间隔，所以可以通过设置<code>server.hz</code>来控制Slow模式的清理频率。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250103230109701-2025-1-323:01:10.png" alt="Slow模式的处理过程" style="zoom:80%;" /></p><p>Fast模式会在每次调用<code>beforesleep</code>函数时执行一次。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250103230330831-2025-1-323:03:31.png" alt="fast模式的处理过程" style="zoom:80%;" /></p><p>在Redis进入事件循环后，每次循环都会执行<code>beforesleep</code>方法，在其中进行Fast模式的清理。而当有fd就绪，处理完对应的IO事件后，会检查当前是否到了执行Slow清理模式的时间，若还在时间间隔内，则不做处理；若到了执行时间，则会调用<code>serverCron</code>进行Slow模式的清理。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250103230423489-2025-1-323:04:24.png" alt="两种模式生效时机" style="zoom: 67%;" /></p><h4 id="淘汰策略">淘汰策略</h4><p>当Redis中没有key过期，但现在Redis的内存已经满了，就需要基于淘汰策略删除一部分key。</p><blockquote><p>被删除的key及其对应的数据不再存储在Redis中，即数据丢失‌。因此应该采取适当的数据持久化策略（如RDB或AOF）来确保数据的可靠性和可恢复性‌。</p><p>需要注意的是，持久化策略也不能完全保证数据的绝对安全。例如，在RDB持久化中，如果数据在快照保存之前被淘汰，那么这些数据将不会包含在持久化文件中。在AOF持久化中，如果数据被淘汰后还没有被写入到AOF文件中，那么这些数据也将丢失。</p></blockquote><p><strong>内存淘汰</strong>：就是当Redis内存使用达到设置的阈值时，Redis主动挑选<strong>部分key</strong>删除以释放更多内存的流程。</p><p>由于任何一条数据的写入操作都会导致内存溢出，因此Redis会在每一条命令执行前检查内存是否足够，如果不够会进行内存清理。</p><p>Redis会在处理客户端命令的方法processCommand（）中尝试做内存淘汰：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250103235731736-2025-1-323:57:42.png" alt="image-20250103235731736" style="zoom:80%;" /></p><p>Redis支持8种不同策略来选择要删除的key，这八种策略可以归为五类：</p><ol type="1"><li>不淘汰任何key</li></ol><p><code>noeviction</code>：不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略。</p><ol start="2" type="1"><li>清理设置了TTL的key</li></ol><p><code>volatile-ttl</code>：对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰（送你一程）</p><p>之后的三种策略，根据是要作用在所有key上（前缀为<code>allkeys</code>），还是只作用在设置了TTL的key上(前缀为<code>volatile</code>)，各分为两种。</p><ol start="3" type="1"><li>随机淘汰</li></ol><p><code>allkeys-random</code>：对全体key，随机进行淘汰。也就是直接从db-&gt;dkt中随机挑选</p><p><code>volatile-random</code>：对设置了TTL的key，随机进行淘汰。也就是从db-&gt;expires中随机挑选。</p><ol start="4" type="1"><li>LRU</li></ol><p><code>allkeys-lru</code>：对全体key，基于LRU算法进行淘汰</p><p><code>volatile-lru</code>：对设置了TTL的key，基于LRU算法进行淘汰</p><ol start="5" type="1"><li>LFU</li></ol><p><code>allkeys-lfu</code>：对全体key，基于LFU算法进行淘汰</p><p><code>volatile-lfu</code>：对设置了TTL的key，基于LFI算法进行淘汰</p><blockquote><p><strong>LRU</strong>（Least RecentlyUsed），最近最少使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p><p><strong>LFU</strong>（Least FrequentlyUsed），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高。</p></blockquote><p>若采用<code>LRU</code>或者<code>LFU</code>淘汰策略，Redis如何统计<strong>一个key最近一次的访问时间</strong>以及<strong>最近一次访问的频率</strong>？</p><p>Redis的数据都会被封装为RedisObject结构：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20250104001134324-2025-1-400:11:35.png"alt="image-20250104001134324" /><figcaption aria-hidden="true">image-20250104001134324</figcaption></figure><p>其中的<code>unsigned lru:LRU_BITS</code>属性就是用来统计当前RedisObject对象的访问信息。<strong>根据配置文件中设置的淘汰策略，这个字段会记录不同的值</strong>。</p><p>若采用<code>LRU</code>淘汰策略，该字段会以秒为单位记录最近一次访问时间，长度24bit</p><p>若采用<code>LFU</code>淘汰策略，该字段会用高16位以<strong>分钟</strong>为单位记录最近一次访问时间，低8位记录<spanstyle="color: red;">逻辑访问次数</span></p><p>LFU的访问次数之所以叫做<strong>逻辑访问次数</strong>，是因为并不是每次key被访问都计数，而是通过运算：</p><ol type="1"><li>生成0~1之间的随机数R</li><li>计算1/（旧次数 * <code>Ifu_log_factor</code>+1），记录为P，<code>lfu_log_factor</code>默认为10</li><li>如果R&lt;P，则计数器 +1，且最大不超过255</li><li>访问次数会随时间衰减，距离上一次访问时间每隔<code>lfu_decay_time</code> 分钟（默认1），计数器-1</li></ol><p>分析：随着访问该key的次数增多，得到的p越来越小，R&lt;P的可能就越来越小，该key的逻辑访问次数增加的可能也会越来越小。如果长时间不访问，访问次数会随时间衰减。逻辑访问次数虽然不是真正访问次数，但是对所有key来说，这个次数还是说明一个key的访问频率的高低。</p><p>之前说过，Redis会在执行每一条客户端命令前执行<code>processCommand()</code>进行内存淘汰。在该函数中会根据当前设定的淘汰策略淘汰一部分key，具体执行流程如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20250104004036495-2025-1-400:40:37.png" alt="processCommand函数执行流程" style="zoom:80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态字符串SDS</tag>
      
      <tag>IntSet</tag>
      
      <tag>Dict</tag>
      
      <tag>ZipList</tag>
      
      <tag>QuickList</tag>
      
      <tag>SkipList</tag>
      
      <tag>RedisObject</tag>
      
      <tag>Linux IO模型</tag>
      
      <tag>Redis网络模型</tag>
      
      <tag>内存策略</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis - 高级篇</title>
    <link href="/29be09bb/"/>
    <url>/29be09bb/</url>
    
    <content type="html"><![CDATA[<meta name = "referrer", content = "no-referrer"/><p><a href="https://www.cnblogs.com/kreo/p/4423362.html">redis.conf配置详解</a></p><h2 id="一分布式缓存">一、分布式缓存</h2><p>单节点Redis问题</p><ul><li>数据丢失问题：Redis是内存存储，服务重启可能会丢失数据。（通过<strong>实现Redis数据持久化</strong>解决）</li><li>并发能力问题：单节点的Redis的性能虽然不错，但无法满足如618这样的该并发场景（通过<strong>搭建主从集群，实现读写分离</strong>解决）</li><li>故障恢复问题：如果Redis宕机，则服务不可用，需要一种自动的故障恢复手段（<strong>利用Redis哨兵，实现健康检测和自动恢复</strong>）</li><li>存储能力问题：Redis是基于内存存储，单节点能存储的数据量难以满足海量数据需求（<strong>搭建分片集群，利用插槽机制实现动态扩容</strong>）。</li></ul><h3 id="redis持久化">1.1、Redis持久化</h3><p>Redis有两种持久化方案：</p><ul><li>RDB持久化</li><li>AOF持久化</li></ul><h4 id="rdb持久化">RDB持久化</h4><p>RDB全称<code>Redis Database Backup file</code>（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是<strong>把内存中的所有数据都记录到磁盘中</strong>。Redis的RDB持久化通过定期保存数据快照至一个rdb文件中，并在启动时自动加载rdb文件，以恢复之前保存的数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p><h5 id="执行时机">执行时机</h5><ul><li><p>执行save命令</p><div class="code-wrapper"><pre><code class="hljs bash">[root@localhost ~]#redis-cli127.0.0.1：6379&gt; save   <span class="hljs-comment">#由Redis主进程来执行RDB，会阻塞所有命令ok</span>127.0.0.1：6379&gt;</code></pre></div><p>save命令会导致<strong>主进程</strong>执行RDB，这个过程中其它所有命令都会被<strong>阻塞</strong>。只有在数据迁移时可能用到。</p></li><li><p>执行bgsave命令</p><p>下面的命令可以异步执行RDB：</p><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1：6379&gt; bgsave#开启子进程执行RDB，避免主进程受到影响Background saving started</code></pre></div><p>这个命令执行后会<strong>开启独立进程完成RDB</strong>，主进程可以持续处理用户请求，不受影响。</p></li><li><p>Redis停机时</p><p>Redis停机时会执行一次save命令，实现RDB持久化。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241224104159899-2024-12-2410:42:10.png"alt="image-20241224104159899" /><figcaption aria-hidden="true">image-20241224104159899</figcaption></figure></li><li><p>触发RDB条件时</p><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是 save &quot;&quot; 则表示禁用RDB</span><span class="hljs-attr">save</span> <span class="hljs-string">900 1  </span><span class="hljs-attr">save</span> <span class="hljs-string">300 10  </span><span class="hljs-attr">save</span> <span class="hljs-string">60 10000 </span></code></pre></div></li></ul><p>RDB的其它配置也可以在redis.conf文件中设置：</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span><span class="hljs-attr">rdbcompression</span> <span class="hljs-string">yes</span><span class="hljs-comment"></span><span class="hljs-comment"># RDB文件名称</span><span class="hljs-attr">dbfilename</span> <span class="hljs-string">dump.rdb  </span><span class="hljs-comment"></span><span class="hljs-comment"># 文件保存的路径目录</span><span class="hljs-attr">dir</span> <span class="hljs-string">./ </span><span class="hljs-attr">docker</span> <span class="hljs-string">run -p 6379:6379 --name redis6.2.6 -v /usr/local/bin/redis/dockerRedis/conf/redis.config:/etc/redis/redis.conf -v /usr/local/bin/redis/dockerRedis/data:/data -v /usr/local/bin/redis/dockerRedis/logs:/logs -d redis:6.2.6 redis-server /etc/redis/redis.conf</span></code></pre></div><h5 id="原理">原理</h5><p>bgsave开始时会fork主进程得到子进程，子进程<strong>共享</strong>主进程的内存数据。完成fork后，由子进程读取内存数据并写入新的RDB 文件，用新RDB文件替换旧的RDB文件。</p><blockquote><p>fork的作用是复制一个与当前进程（父进程）完全相同的子进程。新进程（子进程）的所有数据（变量、环境变量、程序计数器等）的数值都和原进程（父进程）一致，但子进程是一个全新的进程。</p><p>在fork过程中父进程是<strong>阻塞</strong>的，完成后才可继续处理请求</p></blockquote><p>fork采用了写时拷贝（<strong>Copy-On-Write</strong>,COW）技术，在fork发生时，并不会立即复制父进程的全部内存数据到子进程，而是将父进程的<strong>页表</strong>拷贝给子进程，此时父子进程会通过相同的页表映射关系共享相同的物理内存页。</p><p>在子进程读取内存数据时，这些内存页设置为<strong>只读模式</strong>，防止父进程在此期间进行写操作而出现脏数据。当父进程修改内存数据时，操作系统会将相应的内存数据复制一份作为副本，主进程对副本数据进行修改，下次读取时也会读取副本数据。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/无标题-2024-12-2410:58:16.png"alt="fork过程" /><figcaption aria-hidden="true">fork过程</figcaption></figure><h5 id="总结">总结</h5><p>RDB方式bgsave的基本流程？</p><ul><li>fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的RDB文件</li><li>用新RDB文件替换旧的RDB文件</li></ul><p>RDB的缺点？</p><ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul><h4 id="aof持久化">AOF持久化</h4><p>AOF全称为<code>Append Only File</code>（追加文件）。Redis处理的<strong>每一个写命令</strong>都会记录在AOF文件，可以看做是命令日志文件。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/无标题-2024-12-2411:24:48.png" alt="AOF" style="zoom:80%;" /></p><h5 id="相关配置">相关配置</h5><p>AOF<strong>默认是关闭</strong>的，需要修改redis.conf配置文件来开启AOF：</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 是否开启AOF功能，默认是no</span><span class="hljs-attr">appendonly</span> <span class="hljs-string">yes</span><span class="hljs-comment"># AOF文件的名称</span><span class="hljs-attr">appendfilename</span> <span class="hljs-string">&quot;appendonly.aof&quot;</span></code></pre></div><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 表示每执行一次写命令，立即记录到AOF文件</span><span class="hljs-attr">appendfsync</span> <span class="hljs-string">always </span><span class="hljs-comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是**默认方案**</span><span class="hljs-attr">appendfsync</span> <span class="hljs-string">everysec </span><span class="hljs-comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span><span class="hljs-attr">appendfsync</span> <span class="hljs-string">no</span></code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241224112620896-2024-12-2411:26:22.png"alt="三种策略对比" /><figcaption aria-hidden="true">三种策略对比</figcaption></figure><h5 id="aof文件重写">AOF文件重写</h5><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但<strong>只有最后一次写操作才有意义</strong>。通过执行<code>bgrewriteaof</code>命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241224112752086-2024-12-2411:27:53.png"alt="image-20241224112752086" /><figcaption aria-hidden="true">image-20241224112752086</figcaption></figure><blockquote><p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><p><code>bgrewriteaof</code>命令也是<strong>异步</strong>的，会开启新的进程完成。</p></blockquote><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span><span class="hljs-attr">auto-aof-rewrite-percentage</span> <span class="hljs-string">100</span><span class="hljs-comment"># AOF文件体积最小多大以上才触发重写 </span><span class="hljs-attr">auto-aof-rewrite-min-size</span> <span class="hljs-string">64mb </span></code></pre></div><h4 id="rdb和aof对比">RDB和AOF对比</h4><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241224112928342-2024-12-2411:29:29.png"alt="RDB和AOF对比" /><figcaption aria-hidden="true">RDB和AOF对比</figcaption></figure><h3 id="redis主从">1.2、Redis主从</h3><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241224151621838-2024-12-2415:16:43.png"alt="image-20241224151621838" /><figcaption aria-hidden="true">image-20241224151621838</figcaption></figure><h4 id="搭建主从集群">搭建主从集群</h4><p><ahref="https://catpaws.top/3e4345d9/#redis主从集群">参考教程</a></p><h4 id="开启主从关系">开启主从关系</h4><p>现在三个实例还没有任何关系，要配置主从可以使用<code>replicaof</code>或者<code>slaveof</code>（5.0以前）命令。</p><p>有临时和永久两种模式：</p><ul><li><p>修改配置文件（<strong>永久生效</strong>）</p><p>在redis.conf中添加一行配置：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p></li><li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令（<strong>重启后失效</strong>）：</p><div class="code-wrapper"><pre><code class="hljs sh">slaveof &lt;masterip&gt; &lt;masterport&gt;</code></pre></div></li></ul><p>通过redis-cli命令连接7002，执行下面命令：</p><div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 连接 7002</span>redis-cli -p 7002<span class="hljs-comment"># 执行slaveof</span>slaveof 192.168.150.101 7001</code></pre></div><p>通过redis-cli命令连接7003，执行下面命令：</p><div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 连接 7003</span>redis-cli -p 7003<span class="hljs-comment"># 执行slaveof</span>slaveof 192.168.150.101 7001</code></pre></div><p>然后连接 7001节点，查看集群状态：</p><div class="code-wrapper"><pre><code class="hljs sh"><span class="hljs-comment"># 连接 7001</span>redis-cli -p 7001<span class="hljs-comment"># 查看状态</span>info replication</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241224152930388-2024-12-2415:29:31.png"alt="image-20241224152930388" /><figcaption aria-hidden="true">image-20241224152930388</figcaption></figure><p>测试：只有在7001这个master节点上可以执行写操作，7002和7003这两个slave节点只能执行读操作。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241224153322376-2024-12-2415:33:55.png"alt="image-20241224153322376" /><figcaption aria-hidden="true">image-20241224153322376</figcaption></figure><h4 id="主从数据同步原理">主从数据同步原理</h4><h5 id="全量同步">全量同步</h5><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/无标题-2024-12-2415:39:06.png"alt="全量同步" /><figcaption aria-hidden="true">全量同步</figcaption></figure><p>master如何得知salve是第一次来连接呢？？</p><p>有几个概念，可以作为判断依据：</p><ul><li><strong><code>Replication Id</code></strong>：简称<code>replid</code>，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的<code>replid</code>，slave则会继承master节点的<code>replid</code></li><li><strong><code>offset</code></strong>：偏移量，随着记录在<code>repl_baklog</code>中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的<code>offset</code>。如果slave的<code>offset</code>小于master的<code>offset</code>，说明slave数据落后于master，需要更新。</li></ul><p>因此slave做数据同步，必须向master声明自己的<code>replication id</code>和<code>offset</code>，master才可以判断到底需要同步哪些数据。</p><blockquote><p>slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。</p><p>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p><p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p></blockquote><p>完整流程：</p><ul><li>slave节点请求增量同步</li><li>master节点判断replid，发现不一致，拒绝增量同步</li><li>master将完整内存数据生成RDB，发送RDB到slave</li><li>slave清空本地数据，加载master的RDB</li><li>master将RDB期间的命令记录在repl_backlog，并持续将log中的命令发送给slave</li><li>slave执行接收到的命令，保持与master之间的同步</li></ul><h5 id="增量同步">增量同步</h5><p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，耗时太长。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p><p>增量同步：只更新slave与master存在差异的部分数据</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241224154926283-2024-12-2415:49:27.png"alt="image-20241224154926283" /><figcaption aria-hidden="true">image-20241224154926283</figcaption></figure><p>主节点会维护一个 <code>repl_backlog</code><strong>环形缓冲区</strong>，并不断更新其中的命令日志和偏移量信息。从节点在断连并重新连接主节点时，会发送自己的当前偏移量给主节点。主节点会根据从节点提供的偏移量，在<code>repl_backlog</code>中查找对应的日志位置，将之后的新命令发送给从节点，实现数据同步。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241224160654992-2024-12-2416:06:56.png"alt="image-20241224160654992" /><figcaption aria-hidden="true">image-20241224160654992</figcaption></figure><p>如果slave出现网络阻塞，导致master的offset远远超过了slave的offset，此时master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖。棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了，只能做<strong>全量同步</strong>。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241224160909032-2024-12-2416:09:10.png"alt="image-20241224160909032" /><figcaption aria-hidden="true">image-20241224160909032</figcaption></figure><h4 id="主从同步优化">主从同步优化</h4><p>主从同步可以保证主从数据的一致性，非常重要。可以从以下几个方面来优化Redis主从就集群：</p><ul><li><p>在master中配置repl-diskless-syncyes启用无磁盘复制，避免全量同步时的磁盘IO。</p><blockquote><p>当设置<code>repl-diskless-sync yes</code>时，主节点会直接将内存中的数据通过网络发送给从节点，省去了生成RDB文件和写入磁盘的步骤，从而提高了复制的效率‌</p></blockquote></li><li><p>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</p></li><li><p>适当提高<code>repl_backlog</code>的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</p></li><li><p>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241224161546157-2024-12-2416:15:47.png"alt="主-从-从链式结构" /><figcaption aria-hidden="true">主-从-从链式结构</figcaption></figure></li></ul><h4 id="总结-1">总结</h4><p>简述全量同步和增量同步区别？</p><ul><li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在<code>repl_baklog</code>，逐个发送给slave。</li><li>增量同步：slave提交自己的offset到master，master获取<code>repl_baklog</code>中从offset之后的命令给slave</li></ul><p>什么时候执行全量同步？</p><ul><li>slave节点第一次连接master节点时</li><li>slave节点断开时间太久，<code>repl_baklog</code>中的offset已经被覆盖时</li></ul><p>什么时候执行增量同步？</p><ul><li>slave节点断开又恢复，并且在r<code>epl_baklog</code>中能找到offset时</li></ul><h3 id="redis哨兵">1.3、Redis哨兵</h3><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和功能如下:</p><ul><li><strong>监控</strong>：Sentinel会不断检查您的master和slave是否按预期工作</li><li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li><li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241224162530556-2024-12-2416:25:32.png" alt="image-20241224162530556" style="zoom:80%;" /></p><h4 id="集群监控原理">集群监控原理</h4><p>Sentinel基于<strong>心跳机制</strong>监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><p>•主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p><p>•客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241224162742910-2024-12-2416:27:44.png" alt="image-20241224162742910" style="zoom:80%;" /></p><h4 id="集群故障恢复原理">集群故障恢复原理</h4><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，规则如下：</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds* 10）则会排除该slave节点。（数据太旧了）</li><li>然后判断slave节点的<code>slave-priority</code>值，越小优先级越高，如果是0则永不参与选举</li><li>如果<code>slave-priority</code>一样，则判断slave节点的<code>offset</code>值，越大说明数据越新，优先级越高（主要）</li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ul><p>当选出一个新的master后，由哨兵实现结点角色切换，流程如下：</p><ul><li>sentinel给备选的slave1节点，如7002，发送<code>slaveof no one</code>命令，让该节点成为master</li><li>sentinel给所有其它slave发送<code>slaveof 192.168.150.101 7002</code>命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li><li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241224163250288-2024-12-2416:32:51.png" alt="image-20241224163250288" style="zoom:80%;" /></p><h4 id="搭建哨兵集群">搭建哨兵集群</h4><p><a href="https://catpaws.top/3e4345d9/#搭建哨兵集群">参考教程</a></p><h4 id="redistemplate的哨兵模式">RedisTemplate的哨兵模式</h4><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</p><p>1）引入依赖</p><p>在项目的pom文件中引入依赖：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2）配置Redis地址</p><p>然后在配置文件application.yml中指定redis的<strong>sentinel</strong>相关信息：</p><blockquote><p>在集群模式下，主从结点的地址会发生变更，不能写死，只需指定哨兵的地址即可</p></blockquote><div class="code-wrapper"><pre><code class="hljs java">spring:  redis:    sentinel:      master: mymaster      nodes:        - <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span>:<span class="hljs-number">27001</span>        - <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span>:<span class="hljs-number">27002</span>        - <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span>:<span class="hljs-number">27003</span></code></pre></div><p>3）配置读写分离</p><p>在配置类，添加一个新的bean，指定读写策略</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="hljs-title function_">clientConfigurationBuilderCustomizer</span><span class="hljs-params">()</span>&#123;    <span class="hljs-keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);&#125;</code></pre></div><p>这个bean中配置的就是读写策略，包括四种：</p><ul><li>MASTER：从主节点读取</li><li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li><li>REPLICA：从slave（replica）节点读取</li><li>REPLICA_PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master</li></ul><h3 id="redis分片集群">1.4、Redis分片集群</h3><h4 id="搭建分片集群">搭建分片集群</h4><p><a href="https://catpaws.top/3e4345d9/#搭建分片集群">参考教程</a></p><h4 id="散列插槽">散列插槽</h4><p>Redis会把每一个master节点映射到0~16383共<strong>16384</strong>个插槽（hashslot）上，查看集群信息时就能看到：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241226104103728-2024-12-2610:41:17.png"alt="集群建成时显示的信息" /><figcaption aria-hidden="true">集群建成时显示的信息</figcaption></figure><p>连接到某节点使用<code>cluster nodes</code>查看集群节点信息</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241226104236033-2024-12-2610:42:37.png" alt="使用命令查看集群结点信息" style="zoom:80%;" /></p><p><strong><u>数据key不是与节点绑定，而是与插槽绑定。</u></strong></p><blockquote><p>‌<strong>Redis的数据与插槽绑定而不是与节点绑定，主要是为了实现集群的动态伸缩和高可用性。</strong>‌</p><p>详细来说，与插槽绑定相比，与节点绑定存在明显的局限性。如果数据与特定节点绑定，那么一旦该节点出现故障或需要扩容，数据的迁移和重新分配将变得非常复杂和耗时。而与插槽绑定则不同，插槽可以灵活地映射到不同的节点上。当某个节点出现故障或需要扩容时，<u>只需将相关插槽重新映射到其他健康的节点上即可，无需大规模的数据迁移‌</u>。</p><p>此外，与插槽绑定还使得Redis集群能够更轻松地实现数据的均衡分布。通过散列插槽的方式，可以将数据均匀地分散到集群中的各个节点上，从而避免某些节点过载或闲置的情况‌。这种均衡分布不仅提高了集群的整体性能，还增强了集群的可扩展性和灵活性‌</p></blockquote><p>redis会根据key的有效部分计算插槽值，分两种情况：</p><ul><li>key中包含"{}"，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</li><li>key中不包含“{}”，整个key都是有效部分</li></ul><p>在分片集群模式下，要获得/设置一个key对应的数据，会首先根据key的有效部分计算哈希值，对16384取余，余数作为插槽，定位到该插槽所在的节点，重定向到目标节点，在该节点上执行数据存入或读取操作。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241226105823747-2024-12-2610:58:25.png"alt="image-20241226105823747" /><figcaption aria-hidden="true">image-20241226105823747</figcaption></figure><p>如上，在7001节点执行<code>set a 111</code>命令，a对应的插槽值为15495，该插槽分配给了7003节点，故先重定向到7003节点，再执行该命令。此时在7003结点上执行<code>set num 123</code>命令，执行过程相同。在7001结点读取a对应的值，会先切换到7003节点再返回a的值。</p><blockquote><p>在分片集群模式下连接到某个节点时，在命令中一定要加上<code>-c</code>参数，如</p><div class="code-wrapper"><pre><code class="hljs bash">redis-cli -c -p 7001</code></pre></div></blockquote><p>如何将同一类数据固定的保存在同一个Redis实例？</p><ul><li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li></ul><h4 id="集群伸缩">集群伸缩</h4><p>redis-cli--cluster提供了很多操作集群的命令，可以新增节点，删除节点，重新分配插槽等，可以通过<code>redis-cli --cluster help</code>命令查看：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241226110615386-2024-12-2611:06:16.png"alt="image-20241226110615386" /><figcaption aria-hidden="true">image-20241226110615386</figcaption></figure><p>需求：向集群中添加一个新的master节点，并向其中存储 num = 10</p><ul><li>启动一个新的redis实例，端口为7004</li><li>添加7004到之前的集群，并作为一个master节点</li><li>给7004节点<u>分配插槽</u>，使得num这个key可以存储到7004实例</li></ul><p>1、创建新的redis实例</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#创建一个文件夹</span><span class="hljs-built_in">mkdir</span> 7004<span class="hljs-comment">#拷贝配置文件</span><span class="hljs-built_in">cp</span> redis.conf /7004<span class="hljs-comment">#修改配置文件 将其中初始的所有6379改为7004</span>sed /s/6379/7004/g 7004/redis.conf<span class="hljs-comment">#启动</span>redis-server 7004/redis.conf</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241226112143003-2024-12-2611:21:44.png"alt="image-20241226112143003" /><figcaption aria-hidden="true">image-20241226112143003</figcaption></figure><p>2、添加新结点到Redis集群</p><p>通过<code>redis-cli --cluset help</code>命令查看集群相关操作，其中有关添加新节点的命令如下</p><div class="code-wrapper"><pre><code class="hljs bash">add-node       new_host:new_port existing_host:existing_port <span class="hljs-comment">#新节点地址和端口，集群中某节点的地址和端口（将新节点的信息通过它通知给其他节点）</span>                --cluster-slave   <span class="hljs-comment">#设置为slave节点，默认为master节点</span>                --cluster-master-id &lt;arg&gt; <span class="hljs-comment">#对应master的id</span></code></pre></div><p>将7004节点加入集群：</p><div class="code-wrapper"><pre><code class="hljs bash">redis-cli --cluster add-node 192.168.181.100:7004 192.168.181.100:7001</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241226113344409-2024-12-2611:33:45.png"alt="image-20241226113344409" /><figcaption aria-hidden="true">image-20241226113344409</figcaption></figure><p>3、转移插槽</p><p>num的插槽值为2765，要将num这个key移到7004节点，只需将前2766个插槽移到7004节点。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241226113557285-2024-12-2611:36:02.png"alt="num的插槽值为2765" /><figcaption aria-hidden="true">num的插槽值为2765</figcaption></figure><p>集群中插槽转移的命令如下，</p><div class="code-wrapper"><pre><code class="hljs bash">reshard        &lt;host:port&gt; or &lt;host&gt; &lt;port&gt; - separated by either colon or space                 --cluster-from &lt;arg&gt;                 --cluster-to &lt;arg&gt;                 --cluster-slots &lt;arg&gt;                 --cluster-yes                 --cluster-timeout &lt;arg&gt;                 --cluster-pipeline &lt;arg&gt;                 --cluster-replace</code></pre></div><p>使用<code>redis-cli --cluster reshard 192.168.181.100:7004</code>采用交互式方式输入参数。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241226120318618-2024-12-2612:03:48.png"alt="image-20241226120318618" /><figcaption aria-hidden="true">image-20241226120318618</figcaption></figure><p>4、在7004结点上读取num值</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241226120412193-2024-12-2612:04:13.png"alt="image-20241226120412193" /><figcaption aria-hidden="true">image-20241226120412193</figcaption></figure><blockquote><p>此时若要删除7004节点，需要先将分配给该结点的插槽转移到其他节点后再删除。</p></blockquote><h4 id="故障转移">故障转移</h4><p>集群的初始状态如下，其中7001、7002、7003都是master，计划让7002宕机。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241226124827478-2024-12-2612:48:29.png"alt="image-20241226124827478" /><figcaption aria-hidden="true">image-20241226124827478</figcaption></figure><h5 id="自动故障转移">自动故障转移</h5><p>执行<code>redis-cli -p 7002 shutdown</code>让7002节宕机，通过<code>watch redis-cli -p 7001 cluster nodes</code>监视集群节点的情况。</p><p>1）首先是该实例与其它实例失去连接</p><p>2）然后是疑似宕机：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/8b80a1c09i77259f06581dc277354178-2024-12-2612:47:21.jpg"alt="8b80a1c09i77259f06581dc277354178" /><figcaptionaria-hidden="true">8b80a1c09i77259f06581dc277354178</figcaption></figure><p>3）最后是确定下线，自动提升一个slave为新的master：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241226125056817-2024-12-2612:50:58.png"alt="image-20241226125056817" /><figcaption aria-hidden="true">image-20241226125056817</figcaption></figure><p>4）当7002再次启动，就会变为一个slave节点了，自动完成主从切换</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/7f4b21650k45c7f367c97946638748d2-2024-12-2612:52:06.jpg"alt="7f4b21650k45c7f367c97946638748d2" /><figcaptionaria-hidden="true">7f4b21650k45c7f367c97946638748d2</figcaption></figure><h5 id="手动故障转移数据迁移">手动故障转移（数据迁移）</h5><p>利用<code>cluster failover</code>命令可以手动让集群中的某个master宕机，切换到执行clusterfailover命令的这个<strong>slave节点</strong>，实现无感知的数据迁移。其流程如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241226125548348-2024-12-2612:55:49.png" alt="image-20241226125548348" style="zoom:80%;" /></p><p>手动的Failover支持三种不同模式：</p><ul><li>缺省：默认的流程，如图1~6步</li><li>force：省略了对offset的一致性校验</li><li>takeover：直接执行第5步，忽略数据一致性、忽略master状态和其它master的意见</li></ul><p>需求：在7002这个slave节点执行手动故障转移，重新夺回master地位</p><p>步骤如下：</p><p>1）利用redis-cli连接7002这个节点</p><p>2）执行cluster failover命令</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241226130403702-2024-12-2613:04:05.png"alt="image-20241226130403702" /><figcaption aria-hidden="true">image-20241226130403702</figcaption></figure><h4 id="redistemplate访问分片集群">RedisTemplate访问分片集群</h4><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p><p>1）引入redis的starter依赖</p><p>2）配置分片集群地址</p><p>3）配置读写分离</p><p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">redis:</span>    <span class="hljs-attr">cluster:</span>      <span class="hljs-attr">nodes:</span>  <span class="hljs-comment">#指定分片集群的每一个节点信息</span>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:7001</span>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:7002</span>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:7003</span>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:8001</span>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:8002</span>        <span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.150</span><span class="hljs-number">.101</span><span class="hljs-string">:8003</span></code></pre></div><h2 id="二多级缓存">二、多级缓存</h2><h3 id="什么是多级缓存">2.1、什么是多级缓存</h3><p>传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，如图：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821075259137-2024-12-2614:46:17.png"alt="image-20210821075259137" /><figcaption aria-hidden="true">image-20210821075259137</figcaption></figure><p>存在下面的问题：</p><p>•请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈</p><p>•Redis缓存失效时，会对数据库产生冲击</p><p>多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻Tomcat压力，提升服务性能：</p><ul><li>浏览器访问静态资源时，优先读取浏览器本地缓存</li><li>访问非静态资源（ajax查询数据）时，访问服务端</li><li>请求到达Nginx后，优先读取Nginx本地缓存</li><li>如果Nginx本地缓存未命中，则去直接查询Redis（不经过Tomcat）</li><li>如果Redis查询未命中，则查询Tomcat</li><li>请求进入Tomcat后，优先查询JVM进程缓存</li><li>如果JVM进程缓存未命中，则查询数据库</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821075558137-2024-12-2614:47:22.png"alt="image-20210821075558137" /><figcaption aria-hidden="true">image-20210821075558137</figcaption></figure><p>在多级缓存架构中，Nginx内部需要编写本地缓存查询、Redis查询、Tomcat查询的业务逻辑，因此这样的nginx服务不再是一个<strong>反向代理服务器</strong>，而是一个编写<strong>业务的Web服务器了</strong>。</p><p>因此这样的业务Nginx服务也需要搭建集群来提高并发，再有专门的nginx服务来做反向代理。同时，Tomcat服务将来也会部署为集群模式</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821080954947-2024-12-2614:50:15.png"alt="image-20210821080954947" /><figcaption aria-hidden="true">image-20210821080954947</figcaption></figure><p>可见，多级缓存的关键有两个：</p><ul><li><p>一个是在nginx中编写业务，实现nginx本地缓存、对Redis和Tomcat的查询</p></li><li><p>另一个就是在Tomcat中实现JVM进程缓存</p></li></ul><p>其中Nginx编程则会用到<code>OpenResty</code>框架结合Lua这样的语言。</p><h3 id="导入案例">2.2、导入案例</h3><p><ahref="https://www.bilibili.com/video/BV1cr4y1671t?vd_source=51d78ede0a0127d1839d6abf9204d1ee&amp;spm_id_from=333.788.videopod.episodes&amp;p=115">参考视频</a></p><p><ahref="https://pan.baidu.com/s/1189u6u4icQYHg_9_7ovWmA?pwd=eh11&amp;_at_=1735005945139#list/path=%2Fsharelink3232509500-235828228909890%2F7%E3%80%81Redis%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B%2FRedis-%E7%AC%94%E8%AE%B0%E8%B5%84%E6%96%99%2F03-%E9%AB%98%E7%BA%A7%E7%AF%87%2F%E8%B5%84%E6%96%99%2Fitem-service&amp;parentPath=%2Fsharelink3232509500-235828228909890">后端文件</a></p><p><ahref="https://pan.baidu.com/s/1189u6u4icQYHg_9_7ovWmA?pwd=eh11&amp;_at_=1735005945139#list/path=%2Fsharelink3232509500-235828228909890%2F7%E3%80%81Redis%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B%2FRedis-%E7%AC%94%E8%AE%B0%E8%B5%84%E6%96%99%2F03-%E9%AB%98%E7%BA%A7%E7%AF%87%2F%E8%B5%84%E6%96%99%2Fnginx-1.18.0&amp;parentPath=%2Fsharelink3232509500-235828228909890">前端文件</a></p><h3 id="jvm进程缓存">2.3、JVM进程缓存</h3><h4 id="初识caffeine">初识Caffeine</h4><p>缓存在日常开发中启动至关重要的作用，由于是存储在内存中，数据的读取速度是非常快的，能大量减少对数据库的访问，减x少数据库的压力。我们把缓存分为两类：</p><ul><li>分布式缓存，例如Redis：<ul><li>优点：存储容量更大、可靠性更好、可以在集群间共享</li><li>缺点：访问缓存有网络开销</li><li>场景：缓存数据量较大、可靠性要求较高、需要在集群间共享</li></ul></li><li>进程本地缓存，例如HashMap、GuavaCache：<ul><li>优点：读取本地内存，没有网络开销，速度更快</li><li>缺点：存储容量有限、可靠性较低、无法共享</li><li>场景：性能要求较高，缓存数据量较小</li></ul></li></ul><p><strong>Caffeine</strong>是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。GitHub地址：https://github.com/ben-manes/caffeine</p><p>Caffeine的性能非常好，下图是官方给出的性能对比：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821081826399-2024-12-2618:34:57.png"alt="image-20210821081826399" /><figcaption aria-hidden="true">image-20210821081826399</figcaption></figure><p>缓存API基本使用</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">testBasicOps</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 构建cache对象</span>    Cache&lt;String, String&gt; cache = Caffeine.newBuilder().build();    <span class="hljs-comment">// 存数据</span>    cache.put(<span class="hljs-string">&quot;gf&quot;</span>, <span class="hljs-string">&quot;迪丽热巴&quot;</span>);    <span class="hljs-comment">// 取数据</span>    <span class="hljs-type">String</span> <span class="hljs-variable">gf</span> <span class="hljs-operator">=</span> cache.getIfPresent(<span class="hljs-string">&quot;gf&quot;</span>);    System.out.println(<span class="hljs-string">&quot;gf = &quot;</span> + gf);    <span class="hljs-comment">// 取数据，包含两个参数：</span>    <span class="hljs-comment">// 参数一：缓存的key</span>    <span class="hljs-comment">// 参数二：Lambda表达式，表达式参数就是缓存的key，方法体是查询数据库的逻辑</span>    <span class="hljs-comment">// 优先根据key查询JVM缓存，如果未命中，则执行参数二的Lambda表达式</span>    <span class="hljs-type">String</span> <span class="hljs-variable">defaultGF</span> <span class="hljs-operator">=</span> cache.get(<span class="hljs-string">&quot;defaultGF&quot;</span>, key -&gt; &#123;        <span class="hljs-comment">// 根据key去数据库查询数据</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;柳岩&quot;</span>;    &#125;);    System.out.println(<span class="hljs-string">&quot;defaultGF = &quot;</span> + defaultGF);&#125;</code></pre></div><p>Caffeine既然是缓存的一种，肯定需要有缓存的清除策略，不然的话内存总会有耗尽的时候。</p><p>Caffeine提供了三种缓存驱逐策略：</p><ul><li><p><strong>基于容量</strong>：设置缓存的数量上限</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建缓存对象</span>Cache&lt;String, String&gt; cache = Caffeine.newBuilder()    .maximumSize(<span class="hljs-number">1</span>) <span class="hljs-comment">// 设置缓存大小上限为 1</span>    .build();</code></pre></div></li><li><p><strong>基于时间</strong>：设置缓存的有效时间</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 创建缓存对象</span>Cache&lt;String, String&gt; cache = Caffeine.newBuilder()    <span class="hljs-comment">// 设置缓存有效期为 10 秒，从最后一次写入开始计时 </span>    .expireAfterWrite(Duration.ofSeconds(<span class="hljs-number">10</span>))     .build();</code></pre></div></li><li><p><strong>基于引用</strong>：设置缓存为软引用或弱引用，利用GC来回收缓存数据。性能较差，不建议使用。</p></li></ul><blockquote><p><strong>注意</strong>：在默认情况下，当一个缓存元素过期的时候，Caffeine不会自动立即将其清理和驱逐。而是在一次读或写操作后，或者在空闲时间完成对失效数据的驱逐。</p></blockquote><h4 id="实现jvm进程缓存">实现JVM进程缓存</h4><p>利用Caffeine实现下列需求：</p><ul><li>给根据id查询商品的业务添加缓存，缓存未命中时查询数据库</li><li>给根据id查询商品库存的业务添加缓存，缓存未命中时查询数据库</li><li>缓存初始大小为100</li><li>缓存上限为10000</li></ul><p>首先，我们需要定义两个Caffeine的缓存对象，分别保存商品、库存的缓存数据。</p><p>在item-service的<code>com.heima.item.config</code>包下定义<code>CaffeineConfig</code>类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.heima.item.config;<span class="hljs-keyword">import</span> com.github.benmanes.caffeine.cache.Cache;<span class="hljs-keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;<span class="hljs-keyword">import</span> com.heima.item.pojo.Item;<span class="hljs-keyword">import</span> com.heima.item.pojo.ItemStock;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CaffeineConfig</span> &#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> Cache&lt;Long, Item&gt; <span class="hljs-title function_">itemCache</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> Caffeine.newBuilder()                .initialCapacity(<span class="hljs-number">100</span>)                .maximumSize(<span class="hljs-number">10_000</span>)                .build();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> Cache&lt;Long, ItemStock&gt; <span class="hljs-title function_">stockCache</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> Caffeine.newBuilder()                .initialCapacity(<span class="hljs-number">100</span>)                .maximumSize(<span class="hljs-number">10_000</span>)                .build();    &#125;&#125;</code></pre></div><p>修改item-service中的<code>com.heima.item.web</code>包下的ItemController类，添加缓存逻辑</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;item&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemController</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IItemService itemService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IItemStockService stockService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Cache&lt;Long, Item&gt; itemCache;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Cache&lt;Long, ItemStock&gt; stockCache;        <span class="hljs-comment">// ...其它略</span>        <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span>    <span class="hljs-keyword">public</span> Item <span class="hljs-title function_">findById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;        <span class="hljs-keyword">return</span> itemCache.get(id, key -&gt; itemService.query()                .ne(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">3</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, key)                .one()        );    &#125;    <span class="hljs-meta">@GetMapping(&quot;/stock/&#123;id&#125;&quot;)</span>    <span class="hljs-keyword">public</span> ItemStock <span class="hljs-title function_">findStockById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;        <span class="hljs-keyword">return</span> stockCache.get(id, key -&gt; stockService.getById(key));    &#125;&#125;</code></pre></div><h3 id="lua入门">2.4、Lua入门</h3><p>Nginx编程需要用到Lua语言，因此我们必须先入门Lua的基本语法。</p><h4 id="初识lua">初识Lua</h4><p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放，其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。<ahref="https://www.lua.org/">官网</a></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821091437975-2024-12-2619:13:40.png"alt="image-20210821091437975" /><figcaption aria-hidden="true">image-20210821091437975</figcaption></figure><p>Lua经常嵌入到C语言开发的程序中，例如游戏开发、游戏插件等。</p><p>Nginx本身也是C语言开发，因此也允许基于Lua做拓展。</p><p><ahref="https://www.runoob.com/lua/lua-tutorial.html">语法参考</a></p><h4 id="hello-world">Hello World</h4><p>CentOS7默认已经安装了Lua语言环境，所以可以直接运行Lua代码。</p><p>在Linux虚拟机的任意目录下，新建一个hello.lua文件</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> hello.lua</code></pre></div><p><code>vi hello.lua</code>向文件中添加</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>)</code></pre></div><p>运行该文件</p><div class="code-wrapper"><pre><code class="hljs bash">[root@ai100 tmp]# lua hello.luaHello World!</code></pre></div><h4 id="变量">变量</h4><p>学习任何语言必然离不开变量，而变量的声明必须先知道数据的类型。</p><p>Lua中支持的常见数据类型包括：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821091835406-2024-12-2619:20:37.png"alt="image-20210821091835406" /><figcaption aria-hidden="true">image-20210821091835406</figcaption></figure><p>另外，Lua提供了type()函数来判断一个变量的数据类型：</p><div class="code-wrapper"><pre><code class="hljs bash">[root@ai100 tmp]# luaLua 5.1.4  Copyright (C) 1994-2008 Lua.org, PUC-Rio&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>))string&gt; <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(10*.314))number</code></pre></div><blockquote><p>控制台输入 <code>lua</code>，进入lua的命令行模式</p></blockquote><p>Lua声明变量的时候无需指定数据类型，而是用local来声明变量为<strong>局部变量</strong>：</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 声明字符串，可以用单引号或双引号，</span><span class="hljs-keyword">local</span> str = <span class="hljs-string">&#x27;hello&#x27;</span><span class="hljs-comment">-- 字符串拼接可以使用 ..</span><span class="hljs-keyword">local</span> str2 = <span class="hljs-string">&#x27;hello&#x27;</span> .. <span class="hljs-string">&#x27;world&#x27;</span><span class="hljs-comment">-- 声明数字</span><span class="hljs-keyword">local</span> num = <span class="hljs-number">21</span><span class="hljs-comment">-- 声明布尔类型</span><span class="hljs-keyword">local</span> flag = <span class="hljs-literal">true</span></code></pre></div><p>Lua中的table类型既可以作为数组，又可以作为Java中的map来使用。数组就是特殊的table，key是数组角标而已：</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 声明数组 ，key为角标的 table</span><span class="hljs-keyword">local</span> arr = &#123;<span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;lua&#x27;</span>&#125;<span class="hljs-comment">-- 声明table，类似java的map</span><span class="hljs-keyword">local</span> map =  &#123;name=<span class="hljs-string">&#x27;Jack&#x27;</span>, age=<span class="hljs-number">21</span>&#125;</code></pre></div><p>Lua中的数组角标是从1开始，访问的时候与Java中类似：</p><blockquote><p>lua数组的角标从1开始</p></blockquote><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 访问数组，lua数组的角标从1开始</span><span class="hljs-built_in">print</span>(arr[<span class="hljs-number">1</span>])</code></pre></div><p>Lua中的table可以用key来访问：</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 访问table</span><span class="hljs-built_in">print</span>(map[<span class="hljs-string">&#x27;name&#x27;</span>])<span class="hljs-built_in">print</span>(map.name)</code></pre></div><h4 id="循环">循环</h4><p><strong>while循环</strong></p><p>语法如下</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">while</span>(condition)<span class="hljs-keyword">do</span>   statements<span class="hljs-keyword">end</span></code></pre></div><p><strong>statements(循环体语句)</strong>可以是一条或多条语句，<strong>condition(条件)</strong>可以是任意表达式，在 <strong>condition(条件)</strong> 为 true时执行循环体语句。</p><p>Lua 编程语言中 for语句有两大类：：</p><ul><li><p>数值for循环</p></li><li><p>泛型for循环</p></li></ul><p><strong>数值for循环</strong></p><p>语法如下：</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> var=exp1,exp2,exp3 <span class="hljs-keyword">do</span>      &lt;执行体&gt;  <span class="hljs-keyword">end</span></code></pre></div><p>var 从 exp1 变化到 exp2，每次变化以 exp3 为步长递增 var，并执行一次<strong>"执行体"</strong>。exp3是可选的，如果不指定，<strong>默认为1</strong>。</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> i=<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span> <span class="hljs-keyword">do</span>    <span class="hljs-built_in">print</span>(i)<span class="hljs-keyword">end</span><span class="hljs-comment">-- 输出 10 9 8  7  6 5 4 3 2 1</span></code></pre></div><p>for的三个表达式在循环开始前一次性求值，以后不再进行求值。比如下面f(x)只会在循环开始前执行一次，其结果用在后面的循环中。</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(x)</span></span>      <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;function&quot;</span>)      <span class="hljs-keyword">return</span> x*<span class="hljs-number">2</span>   <span class="hljs-keyword">end</span>  <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,f(<span class="hljs-number">5</span>) <span class="hljs-keyword">do</span>     <span class="hljs-built_in">print</span>(i)  <span class="hljs-keyword">end</span><span class="hljs-comment">-- 输出 function 1 2 3 4 5 6 7 8 9 10</span></code></pre></div><p><strong>泛型for循环</strong></p><p>泛型 for 循环通过一个迭代器函数来遍历所有值，类似 java 中的 foreach语句。</p><p>遍历数组型table</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 声明数组 key为索引的 table</span><span class="hljs-keyword">local</span> arr = &#123;<span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;lua&#x27;</span>&#125;<span class="hljs-comment">-- 遍历数组</span><span class="hljs-keyword">for</span> index,value <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(arr) <span class="hljs-keyword">do</span>    <span class="hljs-built_in">print</span>(index, value) <span class="hljs-keyword">end</span></code></pre></div><p>遍历普通table</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 声明map，也就是table</span><span class="hljs-keyword">local</span> map = &#123;name=<span class="hljs-string">&#x27;Jack&#x27;</span>, age=<span class="hljs-number">21</span>&#125;<span class="hljs-comment">-- 遍历table</span><span class="hljs-keyword">for</span> key,value <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(map) <span class="hljs-keyword">do</span>   <span class="hljs-built_in">print</span>(key, value) <span class="hljs-keyword">end</span></code></pre></div><blockquote><p>注：在lua中pairs与ipairs两个迭代器的用法相近，但仍有区别：</p><p>pairs可以遍历表中所有的key，并且除了迭代器本身以及遍历表本身还可以返回nil;</p><p>但是ipairs则不能返回nil,只能返回数字0，如果遇到nil则退出。ipairs在迭代过程中是会直接跳过所有手动设定key值的变量。</p></blockquote><h4 id="条件控制">条件控制</h4><p>类似Java的条件控制，例如if、else语法：</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">if</span>(布尔表达式)<span class="hljs-keyword">then</span>   <span class="hljs-comment">--[ 布尔表达式为 true 时执行该语句块 --]</span><span class="hljs-keyword">else</span>   <span class="hljs-comment">--[ 布尔表达式为 false 时执行该语句块 --]</span><span class="hljs-keyword">end</span></code></pre></div><p>与java不同，布尔表达式中的逻辑运算是基于英文单词：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821092657918-2024-12-2619:47:35.png"alt="image-20210821092657918" /><figcaption aria-hidden="true">image-20210821092657918</figcaption></figure><h4 id="函数">函数</h4><p>定义函数的语法：</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名<span class="hljs-params">( argument1, argument2..., argumentn)</span></span>    <span class="hljs-comment">-- 函数体</span>    <span class="hljs-keyword">return</span> 返回值<span class="hljs-keyword">end</span></code></pre></div><p>例如，定义一个函数，用来打印数组：</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printArr</span><span class="hljs-params">(arr)</span></span>    <span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(arr) <span class="hljs-keyword">do</span>        <span class="hljs-built_in">print</span>(value)    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span></code></pre></div><h3 id="实现多级缓存">2.5、实现多级缓存</h3><p>多级缓存的实现离不开Nginx编程，而Nginx编程又离不开<strong>OpenResty</strong>。</p><h4 id="安装openresty">安装OpenResty</h4><p>OpenResty® 是一个基于 Nginx的高性能 Web平台，用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web服务和动态网关。具备下列特点：</p><ul><li>具备Nginx的完整功能</li><li>基于Lua语言进行扩展，集成了大量精良的 Lua 库、第三方模块</li><li>允许使用Lua<strong>自定义业务逻辑</strong>、<strong>自定义库</strong></li></ul><p><a href="https://openresty.org/cn/">官方网站</a></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821092902946-2024-12-2621:38:27.png"alt="image-20210821092902946" /><figcaption aria-hidden="true">image-20210821092902946</figcaption></figure><p><a href="https://catpaws.top/50a9e6bc/">安装教程</a></p><p>安装后的所在目录：<code>/usr/local/openresty</code></p><h4 id="openresty快速入门">OpenResty快速入门</h4><p>多级缓存架构如图：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/yeVDlwtfMx-2024-12-2622:06:36.png"alt="yeVDlwtfMx" /><figcaption aria-hidden="true">yeVDlwtfMx</figcaption></figure><p>其中：</p><ul><li>windows上的nginx用来做反向代理服务，将前端的查询商品的ajax请求代理到OpenResty集群</li><li>OpenResty集群用来编写多级缓存业务</li></ul><h5 id="反向代理流程">反向代理流程</h5><p>现在，商品详情页使用的是假的商品数据。不过在浏览器中，可以看到页面有发起ajax请求查询真实商品数据。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241226220907274-2024-12-2622:09:08.png" alt="image-20241226220907274" style="zoom:67%;" /></p><p>在Windows的nginx中配置反向代理逻辑，将以<code>/api</code>为前缀的请求反向代理给OpenRestry集群处理</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241226221349893-2024-12-2622:13:57.png" alt="image-20241226221349893" style="zoom:67%;" /></p><h5 id="openresty监听请求">OpenResty监听请求</h5><p>OpenResty的很多功能都依赖于其目录下的Lua库，需要在nginx.conf中指定依赖库的目录，并导入依赖：</p><p>1）添加对OpenResty的Lua模块的加载</p><p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，在其中的http下面，添加下面代码：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-comment">#lua 模块</span><span class="hljs-attribute">lua_package_path</span> <span class="hljs-string">&quot;/usr/local/openresty/lualib/?.lua;;&quot;</span>;<span class="hljs-comment">#c模块     </span><span class="hljs-attribute">lua_package_cpath</span> <span class="hljs-string">&quot;/usr/local/openresty/lualib/?.so;;&quot;</span>;</code></pre></div><p>2）监听/api/item路径</p><p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，在nginx.conf的server下面，添加对/api/item这个路径的监听：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">location</span>  /api/item &#123;    <span class="hljs-comment"># 默认的响应类型</span>    <span class="hljs-attribute">default_type</span> application/json;    <span class="hljs-comment"># 响应结果由lua/item.lua文件来决定</span>    <span class="hljs-attribute">content_by_lua_file</span> lua/item.lua;&#125;</code></pre></div><blockquote><p>这个监听，就类似于SpringMVC中的<code>@GetMapping("/api/item")</code>做路径映射。</p><p>而<code>content_by_lua_file lua/item.lua</code>则相当于调用item.lua这个文件，执行其中的业务，把结果返回给用户。相当于java中调用service。</p></blockquote><h5 id="编写item.lua">编写item.lua</h5><p>在<code>/usr/loca/openresty/nginx</code>目录创建文件夹<code>lua</code>，并在lua文件夹下新建文件 <code>item.lua</code></p><div class="code-wrapper"><pre><code class="hljs bash">[root@ai100 nginx]# <span class="hljs-built_in">mkdir</span> lua[root@ai100 nginx]# <span class="hljs-built_in">touch</span> lua/item.lua</code></pre></div><p>item.lua中，利用<code>ngx.say()</code>函数返回数据到Response中，<strong>此处暂时写入假数据，之后在lua文件中向reids和Tomcat发起请求获取真实数据</strong>。修改其中商品价格为19900</p><div class="code-wrapper"><pre><code class="hljs lua">ngx.say(<span class="hljs-string">&#x27;&#123;&quot;id&quot;:10001,&quot;name&quot;:&quot;SALSA AIR&quot;,&quot;title&quot;:&quot;RIMOWA 21寸托运箱拉杆箱 SALSA AIR系列果绿色 820.70.36.4&quot;,&quot;price&quot;:19900,&quot;image&quot;:&quot;https://m.360buyimg.com/mobilecms/s720x720_jfs/t6934/364/1195375010/84676/e9f2c55f/597ece38N0ddcbc77.jpg!q70.jpg.webp&quot;,&quot;category&quot;:&quot;拉杆箱&quot;,&quot;brand&quot;:&quot;RIMOWA&quot;,&quot;spec&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;createTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;updateTime&quot;:&quot;2019-04-30T16:00:00.000+00:00&quot;,&quot;stock&quot;:2999,&quot;sold&quot;:31290&#125;&#x27;</span>)</code></pre></div><p>重新加载配置</p><div class="code-wrapper"><pre><code class="hljs bash">nginx -s reload</code></pre></div><p>刷新商品页面即可查看效果</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241226222109001-2024-12-2622:21:57.png"alt="image-20241226222109001" /><figcaption aria-hidden="true">image-20241226222109001</figcaption></figure><h4 id="请求参数处理">请求参数处理</h4><p>OpenResty中提供了一些API用来获取不同类型的前端请求参数：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821101433528-2024-12-2622:25:47.png"alt="image-20210821101433528" /><figcaption aria-hidden="true">image-20210821101433528</figcaption></figure><p>前端请求路径为：<code>http://localhost:8088/api/item/10001</code>，其中商品id是以路径参数传递的，因此可以利用正则表达式匹配的方式来获取ID。</p><p>修改<code>/usr/loca/openresty/nginx/nginx.conf</code>文件中监听/api/item的代码，利用正则表达式获取ID</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">location</span> <span class="hljs-string">~ /api/item/(\d+) &#123;</span><span class="hljs-comment">    # 默认的响应类型</span>    <span class="hljs-attr">default_type</span> <span class="hljs-string">application/json;</span><span class="hljs-comment">    # 响应结果由lua/item.lua文件来决定</span>    <span class="hljs-attr">content_by_lua_file</span> <span class="hljs-string">lua/item.lua;</span><span class="hljs-attr">&#125;</span></code></pre></div><p>在<code>item.lua</code>中获取商品id</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 获取商品id</span><span class="hljs-keyword">local</span> id = ngx.var[<span class="hljs-number">1</span>]</code></pre></div><h4 id="查询tomcat">查询TomCat</h4><p>拿到商品ID后，本应去缓存中查询商品信息，不过目前我们还未建立nginx、redis缓存。因此，这里我们先根据商品id去tomcat查询商品信息。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821111023255-2024-12-2721:29:43.png"alt="image-20210821111023255" /><figcaption aria-hidden="true">image-20210821111023255</figcaption></figure><h5 id="发送http请求的api">发送http请求的API</h5><p>nginx提供了内部API用以发送http请求：</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> resp = ngx.location.capture(<span class="hljs-string">&quot;/path&quot;</span>,&#123;    method = ngx.HTTP_GET,   <span class="hljs-comment">-- 请求方式</span>    args = &#123;a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>&#125;,  <span class="hljs-comment">-- get方式传参数</span>&#125;)</code></pre></div><p>返回的响应内容包括：</p><ul><li>resp.status：响应状态码</li><li>resp.header：响应头，是一个table</li><li>resp.body：响应体，就是响应数据</li></ul><p><strong>注意：这里的path是路径，并不包含IP和端口。这个请求会被nginx内部的server监听并处理。</strong></p><p><strong>为了让请求发送到Tomcat服务器，所以还需要编写一个server来对这个路径做反向代理</strong>：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /path &#123;    <span class="hljs-comment"># 这里是windows电脑的ip和Java服务端口，需要确保windows防火墙处于关闭状态</span>    <span class="hljs-attribute">proxy_pass</span> http://192.168.181.1:8081; &#125;</code></pre></div><p>原理如图：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821104149061-2024-12-2622:33:57.png"alt="image-20210821104149061" /><figcaption aria-hidden="true">image-20210821104149061</figcaption></figure><h5 id="封装http工具">封装http工具</h5><p>封装一个发送Http请求的工具，基于<code>ngx.location.capture</code>来实现查询tomcat</p><p>1）添加反向代理，到windows的Java服务</p><p>因为item-service中的接口都是/item开头，所以需要监听/item路径，代理到windows上的tomcat服务。</p><p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，添加一个location：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /item &#123;    <span class="hljs-attribute">proxy_pass</span> http://192.168.181.1:8081;&#125;</code></pre></div><p>之后只要使用<code>ngx.location.capture("/item")</code>，就一定能发送请求到windows的tomcat服务。</p><p>2）封装工具类</p><p>在<code>/usr/local/openresty/lualib</code>目录下，新建一个common.lua文件，编写请求代码</p><div class="code-wrapper"><pre><code class="hljs bash">vi /usr/local/openresty/lualib/common.lua</code></pre></div><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 封装函数，发送http请求，并解析响应</span><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read_http</span><span class="hljs-params">(path, params)</span></span>    <span class="hljs-keyword">local</span> resp = ngx.location.capture(<span class="hljs-built_in">path</span>,&#123;        method = ngx.HTTP_GET,  <span class="hljs-comment">-- 处理GET请求</span>        args = params,    &#125;)    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> resp <span class="hljs-keyword">then</span>        <span class="hljs-comment">-- 记录错误信息，返回404</span>        ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;http请求查询失败, path: &quot;</span>, <span class="hljs-built_in">path</span> , <span class="hljs-string">&quot;, args: &quot;</span>, args)        ngx.<span class="hljs-built_in">exit</span>(<span class="hljs-number">404</span>)    <span class="hljs-keyword">end</span>    <span class="hljs-keyword">return</span> resp.body<span class="hljs-keyword">end</span><span class="hljs-comment">-- 将方法导出</span><span class="hljs-keyword">local</span> _M = &#123;      read_http = read_http&#125;  <span class="hljs-keyword">return</span> _M</code></pre></div><blockquote><p>这个工具将read_http函数封装到_M这个<strong>table类型</strong>的变量中，并且返回，这类似于导出。使用的时候，可以利用<code>require('common')</code>来导入该函数库，这里的common是函数库的文件名。</p><p>lua的工具类都存放在<code>/usr/local/openresty/lualib</code>路径下</p></blockquote><h5 id="实现商品查询">实现商品查询</h5><p>修改<code>/usr/local/openresty/lua/item.lua</code>文件，利用刚刚封装的函数库实现对tomcat的查询</p><div class="code-wrapper"><pre><code class="hljs applescript"><span class="hljs-comment">-- 引入自定义common工具模块，返回值是common中返回的 _M</span><span class="hljs-keyword">local</span> common = require(<span class="hljs-string">&quot;common&quot;</span>)<span class="hljs-comment">-- 导入cjson工具包</span><span class="hljs-keyword">local</span> cjson = require(<span class="hljs-string">&quot;cjson&quot;</span>)<span class="hljs-comment">-- 从common中获取read_quest函数</span><span class="hljs-keyword">local</span> read_quest = common.read_quest<span class="hljs-comment">-- 获取路径参数</span><span class="hljs-keyword">local</span> <span class="hljs-built_in">id</span> = ngx.var[<span class="hljs-number">1</span>]<span class="hljs-comment">-- 根据id查询商品</span><span class="hljs-keyword">local</span> itemJson = read_quest(<span class="hljs-string">&quot;/item/&quot;</span> .. <span class="hljs-built_in">id</span>, nil)<span class="hljs-comment">-- 根据id查询商品库存</span><span class="hljs-keyword">local</span> itemStockJSON = read_http(<span class="hljs-string">&quot;/item/stock/&quot;</span>.. <span class="hljs-built_in">id</span>, nil)<span class="hljs-comment">-- 查询到的是商品、库存的json格式数据，我们需要将两部分数据组装，需要用到JSON处理函数库。</span><span class="hljs-comment">-- 将JSON转化为lua的table进行数据拼接</span><span class="hljs-keyword">local</span> <span class="hljs-built_in">item</span> = cjson.decode(itemJson)<span class="hljs-keyword">local</span> itemStock = cjson.decode(itemStockJSON)<span class="hljs-comment">--数据拼接</span><span class="hljs-built_in">item</span>.stock = itemStock.stock<span class="hljs-built_in">item</span>.sold = itemStock.sold<span class="hljs-comment">-- 把item序列化为json 返回结果</span>ngx.<span class="hljs-built_in">say</span>(cjson.endcode(<span class="hljs-built_in">item</span>))</code></pre></div><blockquote><p>OpenResty提供了一个<strong>cjson</strong>的模块用来处理JSON的序列化和反序列化，使用方法如下：</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 引入cjson模块</span><span class="hljs-keyword">local</span> cjson = <span class="hljs-built_in">require</span> <span class="hljs-string">&quot;cjson&quot;</span> <span class="hljs-comment">-- 序列化，使用encode方法</span><span class="hljs-keyword">local</span> obj = &#123;    name = <span class="hljs-string">&#x27;jack&#x27;</span>,    age = <span class="hljs-number">21</span>&#125;<span class="hljs-keyword">local</span> json = cjson.encode(obj) <span class="hljs-comment">-- 把 table 序列化为 json</span><span class="hljs-comment">-- 反序列化，使用decode方法</span><span class="hljs-keyword">local</span> json = <span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;jack&quot;, &quot;age&quot;: 21&#125;&#x27;</span><span class="hljs-keyword">local</span> obj = cjson.decode(json) <span class="hljs-comment">-- 反序列化 json为 table</span><span class="hljs-built_in">print</span>(obj.name)</code></pre></div></blockquote><h4id="tomcat集群的负载均衡基于id的负载均衡">Tomcat集群的负载均衡（基于ID的负载均衡）</h4><p>OpenResty对tomcat集群负载均衡的默认策略是<strong>轮询模式</strong>。当查询/item/10001时假设访问的是8081端口的tomcat服务，查询完成会在该服务器内部建立JVM缓存，而当第二次查询时，由于是轮询所以会去访问其他端口的服务，而其他服务器内部没有该商品的JVM缓存，需要查询数据库，导致之前的JVM缓存失效，并且在多个服务器建立冗余的缓存。</p><p>如果能让同一个商品，每次查询时都访问同一个tomcat服务，那么JVM缓存就一定能生效了。</p><p>也就是说，我们需要根据<strong>商品id</strong>做负载均衡，而不是轮询。</p><h5 id="原理-1">原理</h5><p>nginx提供了<strong>基于请求路径做负载均衡</strong>的算法：</p><p>nginx根据请求路径做hash运算，把得到的数值对tomcat服务的数量取余，余数是几，就访问第几个服务，实现负载均衡。只要id不变，每次hash运算结果也不会变，那就可以保证同一个商品，一直访问同一个tomcat服务，确保JVM缓存生效。</p><h5 id="实现">实现</h5><p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，实现基于ID做负载均衡。</p><p>首先，定义tomcat集群，并设置基于路径做负载均衡：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> tomcat-cluster &#123;    <span class="hljs-attribute">hash</span> <span class="hljs-variable">$request_uri</span>;  <span class="hljs-comment">#设置负载均衡策略</span>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.150.1:8081</span>;    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.150.1:8082</span>;&#125;</code></pre></div><p>然后，修改对tomcat服务的反向代理，目标指向tomcat集群：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /item &#123;    <span class="hljs-attribute">proxy_pass</span> http://tomcat-cluster;&#125;</code></pre></div><p>重新加载OpenResty</p><div class="code-wrapper"><pre><code class="hljs sh">nginx -s reload</code></pre></div><h4 id="添加redis缓存">添加Redis缓存</h4><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821113340111-2024-12-2721:29:07.png"alt="image-20210821113340111" /><figcaption aria-hidden="true">image-20210821113340111</figcaption></figure><h5 id="缓存预热">缓存预热</h5><p><strong>冷启动</strong>：服务刚刚启动时，Redis中并没有缓存，如果所有商品数据都在第一次查询时添加缓存，可能会给数据库带来较大压力。</p><p><strong>缓存预热</strong>：在实际开发中，可以利用大数据统计用户访问的热点数据，在项目启动时将这些热点数据提前查询并保存到Redis中。</p><p>1、利用Docker安装Redis</p><p>2、在item-service服务中引入Redis依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>3、配置redis地址</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">spring</span>:<span class="hljs-string"></span><span class="hljs-attr">redis</span>:<span class="hljs-string"></span>   <span class="hljs-attr">host</span>: <span class="hljs-string">192.168.181.100</span>    <span class="hljs-attr">port</span>: <span class="hljs-string">6379</span>    <span class="hljs-attr">password</span>: <span class="hljs-string">liuhao123</span></code></pre></div><p>4、编写初始化类</p><p>缓存预热需要在项目启动时完成，并且必须是拿到RedisTemplate之后。</p><blockquote><p>这里利用<code>InitializingBean</code>接口来实现，该接口定义了一个方法<code>afterPropertiesSet()</code>，<u><strong>该方法在Bean的所有属性被Spring容器设置之后自动被调用</strong></u>。这允许开发者在Bean的初始化阶段执行一些必要的操作，如检查配置的正确性、初始化资源、建立数据库连接等。</p></blockquote><blockquote><p><code>ObjectMapper</code>是Jackson库中的一个核心类，它提供了Java对象和JSON数据之间转换的功能。</p><p>序列化：<code>writeValueAsString(xxx)</code></p><p>反序列化：<code>readValue(xxx)</code></p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IItemService iItemService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> IItemStockService iItemStockService;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();        <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">//初始化缓存</span>        <span class="hljs-comment">//1、查询数据库</span>        List&lt;Item&gt; itemList = iItemService.list();        List&lt;ItemStock&gt; stockList = iItemStockService.list();        <span class="hljs-comment">//2、存入redis</span>        <span class="hljs-keyword">for</span> (Item item : itemList) &#123;            <span class="hljs-comment">//将item对象序列化为JSON字符串</span>            <span class="hljs-type">String</span> <span class="hljs-variable">itemJson</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(item);            stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;item:id&quot;</span>+item.getId(),itemJson);        &#125;        <span class="hljs-keyword">for</span> (ItemStock itemStock : stockList) &#123;            <span class="hljs-comment">//将itemStock对象序列化为JSON字符串</span>            <span class="hljs-type">String</span> <span class="hljs-variable">stockJson</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(itemStock);            stringRedisTemplate.opsForValue()                .set(<span class="hljs-string">&quot;item:stock:id&quot;</span>+itemStock.getId(),stockJson);        &#125;    &#125;&#125;</code></pre></div><h5 id="查询redis缓存">查询redis缓存</h5><p>OpenResty提供了操作Redis的模块，我们只要引入该模块就能直接使用：</p><ol type="1"><li><p>引入Redis模块，并初始化Redis对象</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 导入redis</span><span class="hljs-keyword">local</span> redis = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;resty.redis&quot;</span>)<span class="hljs-comment">-- 初始化redis对象</span><span class="hljs-keyword">local</span> red = redis:new()  <span class="hljs-comment">-- 通过 ：调用方法</span><span class="hljs-comment">--设置redis超时时间</span>red:set_timeouts(<span class="hljs-number">1000</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">1000</span>)</code></pre></div></li><li><p>从连接池获取redis连接</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> ip = <span class="hljs-string">&quot;127.0.0.1&quot;</span>  <span class="hljs-keyword">local</span> port = <span class="hljs-number">6379</span><span class="hljs-keyword">local</span> ok, err = red:connect(ip,port)<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span>    ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;连接redis失败&quot;</span>,err)    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><span class="hljs-keyword">end</span><span class="hljs-comment">--连接后验证密码</span><span class="hljs-comment">-- 使用 red:get_reused_times 方法可以得知当前连接被使用的次数</span><span class="hljs-keyword">local</span> count, err = red:get_reused_times()<span class="hljs-keyword">if</span> <span class="hljs-number">0</span> == count <span class="hljs-keyword">then</span> <span class="hljs-comment">----新建连接，需要认证密码</span>    ok, err = red:auth(<span class="hljs-string">&quot;liu123&quot;</span>)    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span>        ngx.say(<span class="hljs-string">&quot;failed to auth: &quot;</span>, err)        <span class="hljs-keyword">return</span>    <span class="hljs-keyword">end</span><span class="hljs-keyword">elseif</span> err <span class="hljs-keyword">then</span>  <span class="hljs-comment">----从连接池中获取连接，无需再次认证密码</span>    ngx.say(<span class="hljs-string">&quot;failed to get reused times: &quot;</span>, err)    <span class="hljs-keyword">return</span><span class="hljs-keyword">end</span></code></pre></div></li><li><p>操作Redis：<code>red:xxx()</code>。其中对各种数据类型的操作方法与在redis中一致，如对String类型操作的<code>set</code> <code>get</code>方法，对List操作的<code>lpush</code><code>rpop</code>等等，</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 设置字符串</span><span class="hljs-keyword">local</span> ok, err = red:set(<span class="hljs-string">&quot;string_key&quot;</span>, <span class="hljs-string">&quot;string_value&quot;</span>)<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span>    ngx.say(<span class="hljs-string">&quot;failed to set string: &quot;</span>, err)    <span class="hljs-keyword">return</span><span class="hljs-keyword">end</span> <span class="hljs-comment">-- 获取字符串</span><span class="hljs-keyword">local</span> res, err = red:get(<span class="hljs-string">&quot;string_key&quot;</span>)<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res <span class="hljs-keyword">then</span>    ngx.say(<span class="hljs-string">&quot;failed to get string: &quot;</span>, err)    <span class="hljs-keyword">return</span><span class="hljs-keyword">end</span> ngx.say(<span class="hljs-string">&quot;got string: &quot;</span>, res) <span class="hljs-comment">-- 设置哈希</span><span class="hljs-keyword">local</span> ok, err = red:hset(<span class="hljs-string">&quot;hash_key&quot;</span>, <span class="hljs-string">&quot;field1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>)<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span>    ngx.say(<span class="hljs-string">&quot;failed to set hash: &quot;</span>, err)    <span class="hljs-keyword">return</span><span class="hljs-keyword">end</span> <span class="hljs-comment">-- 获取哈希字段</span><span class="hljs-keyword">local</span> res, err = red:hget(<span class="hljs-string">&quot;hash_key&quot;</span>, <span class="hljs-string">&quot;field1&quot;</span>)<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res <span class="hljs-keyword">then</span>    ngx.say(<span class="hljs-string">&quot;failed to get hash field: &quot;</span>, err)    <span class="hljs-keyword">return</span><span class="hljs-keyword">end</span> ngx.say(<span class="hljs-string">&quot;got hash field: &quot;</span>, res) <span class="hljs-comment">-- 设置列表</span><span class="hljs-keyword">local</span> ok, err = red:rpush(<span class="hljs-string">&quot;list_key&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>)<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span>    ngx.say(<span class="hljs-string">&quot;failed to set list: &quot;</span>, err)    <span class="hljs-keyword">return</span><span class="hljs-keyword">end</span> <span class="hljs-comment">-- 获取列表</span><span class="hljs-keyword">local</span> res, err = red:lrange(<span class="hljs-string">&quot;list_key&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res <span class="hljs-keyword">then</span>    ngx.say(<span class="hljs-string">&quot;failed to get list: &quot;</span>, err)    <span class="hljs-keyword">return</span><span class="hljs-keyword">end</span> ngx.say(<span class="hljs-string">&quot;got list: &quot;</span>, <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(res, <span class="hljs-string">&quot;, &quot;</span>)) <span class="hljs-comment">-- 设置集合</span><span class="hljs-keyword">local</span> ok, err = red:sadd(<span class="hljs-string">&quot;set_key&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>)<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span>    ngx.say(<span class="hljs-string">&quot;failed to set set: &quot;</span>, err)    <span class="hljs-keyword">return</span><span class="hljs-keyword">end</span> <span class="hljs-comment">-- 获取集合</span><span class="hljs-keyword">local</span> res, err = red:smembers(<span class="hljs-string">&quot;set_key&quot;</span>)<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res <span class="hljs-keyword">then</span>    ngx.say(<span class="hljs-string">&quot;failed to get set: &quot;</span>, err)    <span class="hljs-keyword">return</span><span class="hljs-keyword">end</span> ngx.say(<span class="hljs-string">&quot;got set: &quot;</span>, <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(res, <span class="hljs-string">&quot;, &quot;</span>)) <span class="hljs-comment">-- 设置有序集合</span><span class="hljs-keyword">local</span> ok, err = red:zadd(<span class="hljs-string">&quot;zset_key&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-string">&quot;value1&quot;</span>)<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span>    ngx.say(<span class="hljs-string">&quot;failed to set zset: &quot;</span>, err)    <span class="hljs-keyword">return</span><span class="hljs-keyword">end</span> <span class="hljs-comment">-- 获取有序集合</span><span class="hljs-keyword">local</span> res, err = red:zrange(<span class="hljs-string">&quot;zset_key&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)<span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> res <span class="hljs-keyword">then</span>    ngx.say(<span class="hljs-string">&quot;failed to get zset: &quot;</span>, err)    <span class="hljs-keyword">return</span><span class="hljs-keyword">end</span> ngx.say(<span class="hljs-string">&quot;got zset: &quot;</span>, <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(res, <span class="hljs-string">&quot;, &quot;</span>))</code></pre></div></li><li><p>关闭连接池。redis的连接是TCP连接，建立TCP连接需要三次握手，而释放TCP连接需要四次握手，耗时较长，应该将该TCP连接放入连接池进行复用。</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">close_redis</span><span class="hljs-params">(red)</span></span>  <span class="hljs-comment">-- 封装成函数方便调用</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> red <span class="hljs-keyword">then</span>          <span class="hljs-keyword">return</span>      <span class="hljs-keyword">end</span>      <span class="hljs-comment">--释放连接(连接池实现)  </span>    <span class="hljs-keyword">local</span> pool_max_idle_time = <span class="hljs-number">10000</span> <span class="hljs-comment">--连接的最大空闲时间（毫秒），超出该时间还未被使用则断开该连接  </span>    <span class="hljs-keyword">local</span> pool_size = <span class="hljs-number">100</span> <span class="hljs-comment">--连接池大小  </span>    <span class="hljs-keyword">local</span> ok, err = red:set_keepalive(pool_max_idle_time, pool_size)  <span class="hljs-comment">--将连接放回连接池中</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span>          ngx.say(<span class="hljs-string">&quot;set keepalive error : &quot;</span>, err)      <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span></code></pre></div></li></ol><p>将建立和释放redis连接，查询redis数据等操作封装到<code>common.lua</code>中方便调用</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 导入redis</span><span class="hljs-keyword">local</span> redis = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;resty.redis&#x27;</span>)<span class="hljs-comment">-- 初始化redis</span><span class="hljs-keyword">local</span> red = redis:new()red:set_timeouts(<span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>, <span class="hljs-number">1000</span>)<span class="hljs-comment">-- 关闭redis连接的工具方法，其实是放入连接池</span><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">close_redis</span><span class="hljs-params">(red)</span></span>    <span class="hljs-keyword">local</span> pool_max_idle_time = <span class="hljs-number">10000</span> <span class="hljs-comment">-- 连接的空闲时间，单位是毫秒</span>    <span class="hljs-keyword">local</span> pool_size = <span class="hljs-number">100</span> <span class="hljs-comment">--连接池大小</span>    <span class="hljs-keyword">local</span> ok, err = red:set_keepalive(pool_max_idle_time, pool_size)    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span>        ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;放入redis连接池失败: &quot;</span>, err)    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-comment">-- 查询redis的方法 ip和port是redis地址，key是查询的key</span><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read_redis</span><span class="hljs-params">(ip, port, key)</span></span>    <span class="hljs-comment">-- 获取一个连接</span>    <span class="hljs-keyword">local</span> ok, err = red:connect(ip, port)    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ok <span class="hljs-keyword">then</span>        ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;连接redis失败 : &quot;</span>, err)        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>    <span class="hljs-keyword">end</span>    red.auth(<span class="hljs-string">&quot;liuhao123&quot;</span>) <span class="hljs-comment">--验证密码</span>    <span class="hljs-comment">-- 查询redis</span>    <span class="hljs-keyword">local</span> resp, err = red:get(key)    <span class="hljs-comment">-- 查询失败处理</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> resp <span class="hljs-keyword">then</span>        ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;查询Redis失败: &quot;</span>, err, <span class="hljs-string">&quot;, key = &quot;</span> , key)    <span class="hljs-keyword">end</span>    <span class="hljs-comment">--得到的数据为空处理</span>    <span class="hljs-keyword">if</span> resp == ngx.null <span class="hljs-keyword">then</span>        resp = <span class="hljs-literal">nil</span>        ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;查询Redis数据为空, key = &quot;</span>, key)    <span class="hljs-keyword">end</span>    <span class="hljs-comment">-- 归还redis连接</span>    close_redis(red)     <span class="hljs-keyword">return</span> resp<span class="hljs-keyword">end</span><span class="hljs-comment">-- 封装函数，发送http请求，并解析响应</span><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read_http</span><span class="hljs-params">(path, params)</span></span>    <span class="hljs-keyword">local</span> resp = ngx.location.capture(<span class="hljs-built_in">path</span>,&#123;        method = ngx.HTTP_GET,        args = params,    &#125;)    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> resp <span class="hljs-keyword">then</span>        <span class="hljs-comment">-- 记录错误信息，返回404</span>        ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;http查询失败, path: &quot;</span>, <span class="hljs-built_in">path</span> , <span class="hljs-string">&quot;, args: &quot;</span>, args)        ngx.<span class="hljs-built_in">exit</span>(<span class="hljs-number">404</span>)    <span class="hljs-keyword">end</span>    <span class="hljs-keyword">return</span> resp.body<span class="hljs-keyword">end</span><span class="hljs-comment">-- 将方法导出</span><span class="hljs-keyword">local</span> _M = &#123;      read_http = read_http,    read_redis = read_redis&#125;  <span class="hljs-keyword">return</span> _M</code></pre></div><p>修改<code>item.lua</code>实现对Reids查询。封装一个<code>read_data</code>函数，其中数据请求到达后先查询Reids，查询失败后再查Tomcat，将查询结果返回。</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 引入common库中封装的函数</span><span class="hljs-keyword">local</span> common = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;common&quot;</span>)<span class="hljs-keyword">local</span> read_redis = common.read_redis<span class="hljs-keyword">local</span> read_http = common.read_http<span class="hljs-comment">-- 导入cjson库</span><span class="hljs-keyword">local</span> cjson = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cjson&#x27;</span>)<span class="hljs-comment">-- 封装查询函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read_data</span><span class="hljs-params">(key, path, params)</span></span>    <span class="hljs-comment">-- 查询本地缓存</span>    <span class="hljs-keyword">local</span> val = read_redis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>, key)    <span class="hljs-comment">-- 判断查询结果</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> val <span class="hljs-keyword">then</span>        ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)        <span class="hljs-comment">-- redis查询失败，去查询http</span>        val = read_http(<span class="hljs-built_in">path</span>, params)    <span class="hljs-keyword">end</span>    <span class="hljs-comment">-- 返回数据</span>    <span class="hljs-keyword">return</span> val<span class="hljs-keyword">end</span><span class="hljs-comment">-- 获取路径参数</span><span class="hljs-keyword">local</span> id = ngx.var[<span class="hljs-number">1</span>]<span class="hljs-comment">-- 查询商品信息</span><span class="hljs-keyword">local</span> itemJSON = read_data(<span class="hljs-string">&quot;item:id:&quot;</span> .. id,  <span class="hljs-string">&quot;/item/&quot;</span> .. id, <span class="hljs-literal">nil</span>)<span class="hljs-comment">-- 查询库存信息</span><span class="hljs-keyword">local</span> stockJSON = read_data(<span class="hljs-string">&quot;item:stock:id:&quot;</span> .. id, <span class="hljs-string">&quot;/item/stock/&quot;</span> .. id, <span class="hljs-literal">nil</span>)<span class="hljs-comment">-- JSON转化为lua的table</span><span class="hljs-keyword">local</span> item = cjson.decode(itemJSON)<span class="hljs-keyword">local</span> stock = cjson.decode(stockJSON)<span class="hljs-comment">-- 组合数据</span>item.stock = stock.stockitem.sold = stock.sold<span class="hljs-comment">-- 把item序列化为json 返回结果</span>ngx.say(cjson.encode(item))</code></pre></div><h4 id="nginx本地缓存">Nginx本地缓存</h4><p>多级缓存的最后一环</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821114742950-2024-12-2721:28:27.png"alt="image-20210821114742950" /><figcaption aria-hidden="true">image-20210821114742950</figcaption></figure><h5 id="本地缓存api">本地缓存API</h5><p>OpenResty为Nginx提供了<code>shard dict</code>的功能，可以<strong>在一个nginx服务的多个worker之间共享数据</strong>，实现缓存功能。</p><ol type="1"><li><p>开启共享字典，在nginx.conf的http下添加配置：</p><div class="code-wrapper"><pre><code class="hljs nginx"><span class="hljs-comment"># 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m</span> <span class="hljs-attribute">lua_shared_dict</span> item_cache <span class="hljs-number">150m</span>;</code></pre></div></li><li><p>操作共享字典：</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 获取本地缓存对象</span><span class="hljs-keyword">local</span> item_cache = ngx.shared.item_cache<span class="hljs-comment">-- 存储, 指定key、value、过期时间，单位s，默认为0代表永不过期</span>item_cache:set(<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;value&quot;</span>,<span class="hljs-number">100</span>)<span class="hljs-comment">-- 读取</span><span class="hljs-keyword">local</span> val = item_cache:get(<span class="hljs-string">&#x27;key&#x27;</span>)</code></pre></div></li></ol><h5 id="实现本地缓存查询">实现本地缓存查询</h5><p>修改<code>/usr/local/openresty/lua/item.lua</code>文件，修改read_data查询函数，添加本地缓存逻辑：</p><ul><li>优先查询本地缓存，未命中时再查询Redis、Tomcat</li><li>查询Redis或Tomcat成功后，将数据写入本地缓存，并设置有效期。商品基本信息，有效期30分钟；库存信息，有效期1分钟</li></ul><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">--导入共享词典，本地缓存</span><span class="hljs-keyword">local</span> item_cache =  ngx.shared.item_cache<span class="hljs-comment">-- 封装查询函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read_data</span><span class="hljs-params">(key,expire, path, params)</span></span>    <span class="hljs-comment">-- 查询本地缓存</span>    <span class="hljs-keyword">local</span> val = item_cache.get(key)    <span class="hljs-comment">--判断本地缓存查询结果</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> val <span class="hljs-keyword">then</span>        ngx.<span class="hljs-built_in">log</span>(ngx.ERR,<span class="hljs-string">&quot;本地缓存查询失败，尝试查询redis缓存，key:&quot;</span>,key)        <span class="hljs-comment">--查询redis缓存</span>        val = read_redis(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>, key)        <span class="hljs-comment">-- 判断redis查询结果</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> val <span class="hljs-keyword">then</span>            ngx.<span class="hljs-built_in">log</span>(ngx.ERR, <span class="hljs-string">&quot;redis查询失败，尝试查询http， key: &quot;</span>, key)            <span class="hljs-comment">-- redis查询失败，去查询http</span>            val = read_http(<span class="hljs-built_in">path</span>, params)        <span class="hljs-keyword">end</span>    <span class="hljs-keyword">end</span>    <span class="hljs-comment">--查询成功，将数据写入本地缓存</span>    item_cache.set(key,val,expire)    <span class="hljs-comment">-- 返回数据</span>    <span class="hljs-keyword">return</span> val<span class="hljs-keyword">end</span><span class="hljs-comment">--调用read_data时，需再传入一个参数：key的过期时间</span></code></pre></div><h3 id="缓存同步">2.6、缓存同步</h3><p>大多数情况下，浏览器查询到的都是缓存数据，如果缓存数据与数据库数据存在较大差异，可能会产生比较严重的后果。</p><p>所以必须保证数据库数据、缓存数据的一致性，这就是缓存与数据库的同步。</p><h4 id="数据同步策略">数据同步策略</h4><p>缓存数据同步的常见方式有三种：</p><p><strong>设置有效期</strong>：给缓存设置有效期，到期后自动删除。再次查询时更新</p><ul><li>优势：简单、方便</li><li>缺点：时效性差，缓存过期之前可能不一致</li><li>场景：更新频率较低，时效性要求低的业务</li></ul><p><strong>同步双写</strong>：在修改数据库的同时，直接修改缓存</p><ul><li>优势：时效性强，缓存与数据库强一致</li><li>缺点：有代码侵入，耦合度高；</li><li>场景：对一致性、时效性要求较高的缓存数据</li></ul><p><strong>异步通知：</strong>修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据</p><ul><li>优势：低耦合，可以同时通知多个缓存服务</li><li>缺点：时效性一般，可能存在中间不一致状态</li><li>场景：时效性要求一般，有多个服务需要同步</li></ul><p>而异步实现又可以基于MQ或者Canal来实现：</p><p>1）基于MQ的异步通知：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821115552327-2024-12-2721:56:52.png"alt="image-20210821115552327" /><figcaption aria-hidden="true">image-20210821115552327</figcaption></figure><ul><li>商品服务完成对数据的修改后，只需要发送一条消息到MQ中。</li><li>缓存服务监听MQ消息，然后完成对缓存的更新</li></ul><p>依然有少量的代码侵入。</p><p>2）基于Canal的通知</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821115719363-2024-12-2721:56:50.png"alt="image-20210821115719363" /><figcaption aria-hidden="true">image-20210821115719363</figcaption></figure><ul><li>商品服务完成商品修改后，业务直接结束，没有任何代码侵入</li><li>Canal监听MySQL变化，当发现变化后，立即通知缓存服务</li><li>缓存服务接收到canal通知，更新缓存</li></ul><p>代码零侵入</p><h4 id="初识canal">初识Canal</h4><p><strong>Canal</strong>译意为水道/管道，canal是阿里巴巴旗下的一款开源项目，基于Java开发。<strong>基于数据库增量日志解析，提供增量数据订阅&amp;消费</strong>。<ahref="https://github.com/alibaba/canal">GitHub的地址</a></p><p>Canal是基于<strong>MySQL的主从同步</strong>来实现的，MySQL主从同步的原理如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821115914748-2024-12-2723:01:28.png"alt="image-20210821115914748" /><figcaption aria-hidden="true">image-20210821115914748</figcaption></figure><ol type="1"><li>MySQL master 将数据变更写入二进制日志( binarylog），其中记录的数据叫做binary log events</li><li>MySQL slave 将 master 的 binary log events拷贝到它的中继日志(relaylog)</li><li>MySQL slave 重放 relay log 中事件，将数据变更反映它自己的数据</li></ol><p><strong>而Canal就是把自己伪装成MySQL的一个slave节点，从而监听master的binarylog变化。再把得到的变化信息通知给Canal的客户端，进而完成对其它数据库的同步。</strong></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821115948395-2024-12-2723:03:46.png"alt="image-20210821115948395" /><figcaption aria-hidden="true">image-20210821115948395</figcaption></figure><h4 id="安装canal">安装Canal</h4><p><a href="https://catpaws.top/ceeb6373/">安装教程</a></p><p><ahref="https://www.bilibili.com/video/BV1cr4y1671t?vd_source=51d78ede0a0127d1839d6abf9204d1ee&amp;spm_id_from=333.788.videopod.episodes&amp;p=131">参考视频</a></p><h4 id="监听canal">监听Canal</h4><p>Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。此处利用Canal提供的Java客户端，监听Canal通知消息。当收到变化的消息时，完成对缓存的更新。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20210821120049024-2024-12-2723:19:34.png"alt="image-20210821120049024" /><figcaption aria-hidden="true">image-20210821120049024</figcaption></figure><p>对于springboot项目，GitHub上的第三方开源的<ahref="https://github.com/NormanGyllenhaal/canal-client">canal-starter</a>与SpringBoot完美整合，自动装配，比官方客户端要简单好用很多。</p><p>1、引入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>top.javatool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>canal-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.1-RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2、添加配置</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">canal</span>:<span class="hljs-string"></span>  <span class="hljs-attr">destination</span>: <span class="hljs-string">item-service  # canal的集群名字，要与安装canal时设置的名称一致</span>  <span class="hljs-attr">server</span>: <span class="hljs-string">192.168.150.101:11111  # canal服务地址</span></code></pre></div><p>3、Canal推送给canal-client的是被修改的这一行数据（row），而我们引入的canal-client则会帮我们把行数据封装到指定的实体类中。这个过程中需要知道数据库与实体的映射关系，要用到JPA的几个注解：<code>@Id</code>、<code>@Column</code>、<code>@Transient</code>等，说明实体类和表中字段的映射关系。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241227233005012-2024-12-2723:30:06.png"alt="常用注解的作用" /><figcaption aria-hidden="true">常用注解的作用</figcaption></figure><p>4、添加监听器。通过实现<code>EntryHandler&lt;T&gt;</code>接口编写监听器，监听Canal消息。注意两点：</p><ul><li>实现类通过<code>@CanalTable("tb_item")</code>指定监听的表信息</li><li>EntryHandler的泛型是与表对应的实体类</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241227233153170-2024-12-2723:31:54.png"alt="监听器基本结构" /><figcaption aria-hidden="true">监听器基本结构</figcaption></figure><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@CanalTable(&quot;tb_item&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ItemHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EntryHandler</span>&lt;Item&gt; &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Cache&lt;Long,Item&gt; itemCache;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Item item)</span> &#123;        <span class="hljs-comment">//添加数据到JVM缓存</span>        itemCache.put(item.getId(),item);        <span class="hljs-comment">//添加数据到Redis缓存</span>        saveItem(item);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Item before, Item after)</span> &#123;        <span class="hljs-comment">//添加数据到JVM缓存</span>        itemCache.put(after.getId(),after);        <span class="hljs-comment">//添加数据到Redis缓存</span>        saveItem(after);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Item item)</span> &#123;        <span class="hljs-comment">//删除JVM缓存中对应的数据</span>        itemCache.invalidate(item.getId());        <span class="hljs-comment">//删除Redis缓存中对应的数据</span>        deleteItem(item);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 向Redis中添加商品数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveItem</span><span class="hljs-params">(Item item)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-type">String</span> <span class="hljs-variable">itemJson</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(item);            stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;item:id&quot;</span>+item.getId(),itemJson);        &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 删除Redis中对应的商品数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> item</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteItem</span><span class="hljs-params">(Item item)</span> &#123;        stringRedisTemplate.delete(<span class="hljs-string">&quot;item:id&quot;</span>+item.getId());    &#125;&#125;</code></pre></div><h2 id="三redis最佳实践">三、Redis最佳实践</h2><h3 id="redis键值设计">3.1、Redis键值设计</h3><h4 id="优雅的key结构">优雅的Key结构</h4><p>Redis的Key虽然可以自定义，但最好遵循下面的几个最佳实践约定：</p><ul><li>遵循基本格式：<strong>[业务名称]：[数据名]：[id]</strong></li><li><strong>长度不超过44字节</strong></li><li>不包含特殊字符</li></ul><p>例如：我们的登录业务，保存用户信息，其key是这样的：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241229104044294-2024-12-2910:40:57.png" alt="image-20241229104044294" style="zoom:80%;" /></p><p>优点：</p><ol type="1"><li>可读性强</li><li>避免key冲突</li><li>方便管理</li><li>更节省内存</li></ol><p>为什么key的长度不要超过44字节？查看<ahref="https://catpaws.top/284457ed/#string">Redis的String类型编码详解</a></p><blockquote><p>通过<code>OBJECT ENCODING &lt;key&gt;</code>命令可以查看一个数据库键的值对象的编码。</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241229210405733-2024-12-2921:04:20.png"alt="image-20241229210405733" /><figcaption aria-hidden="true">image-20241229210405733</figcaption></figure><h4 id="拒绝bigkey">拒绝BigKey</h4><h5 id="什么是bigkey"><strong>什么是BigKey？</strong></h5><p>BigKey通常以<strong>Key的大小</strong>和<strong>Key中成员的数量</strong>来综合判定，例如：</p><ul><li>Key本身的数据量过大：一个String类型的Key，它的值为5 MB。</li><li>Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10，000个。</li><li>Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1，000个但这些成员的Value（值）总大小为100MB。</li></ul><p>推荐值：</p><ul><li>单个key的value小于10KB</li><li>对于集合类型的key，建议元素数量小于1000</li></ul><h5 id="bigkey的危害"><strong>BigKey的危害</strong></h5><ul><li><p>网络阻塞</p><p>对BigKey执行读请求时，少量的QPS就可能导致带宽使用率被占满，导致Redis实例，乃至所在物理机变慢</p></li><li><p>数据倾斜集群中各节点内存空间使用可能非常不均衡，BigKey所在的Redis实例内存使用率远超其他实例，无法使数据分片的内存资源达到均衡。也会导致在集群模式下，数据迁移和复制变得困难</p></li><li><p>Redis阻塞对元素较多的hash、list、zset等做运算会耗时较旧，使主线程被阻塞</p></li><li><p>CPU压力对BigKey的数据序列化和反序列化会导致CPU的使用率飙升，影响Redis实例和本机其它应用</p></li></ul><h5 id="如何发现bigkey"><strong>如何发现BigKey</strong></h5><ul><li><p><code>redis-cli--bigkeys</code></p><p>利用redis-cli提供的--bigkeys参数，可以遍历分析所有key，并返回Key的整体统计信息与<strong>每个数据类型的Top1</strong>的bigkey。当然，每个类型的Top1未必就是BigKey，也有可能Top2也是BigKey，但该命令无法列出，该命令的结果只做参考，</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241229213242858-2024-12-2921:33:24.png"alt="image-20241229213242858" /><figcaption aria-hidden="true">image-20241229213242858</figcaption></figure></li><li><p>scan扫描自己编程，利用<code>scan</code>命令扫描Redis中的所有key，利用strlen，hlen等命令判断key的长度（此处不建议使用MEMORYUSAGE）。</p><p><code>SCAN</code>命令是扫描redis中所有的key，而Redis还提供了针对集合key的扫描命令<ahref="https://redis.io/docs/latest/commands/hscan/">HSCAN</a>、<ahref="https://redis.io/docs/latest/commands/sscan/">SSCAN</a>、<ahref="https://redis.io/docs/latest/commands/zscan/">ZSCAN</a>。</p><blockquote><p>Redis的SCAN命令是一个<strong>基于游标的迭代器</strong>，用于逐步遍历数据库中的key。与KEYS命令不同，SCAN命令不会一次性返回所有匹配的key，而是<strong>分批返回</strong>，从而减轻了对Redis服务器的负担。</p><p>基本语法：</p><div class="code-wrapper"><pre><code class="hljs bash">SCAN cursor [MATCH pattern] [COUNT count]</code></pre></div><ul><li>‌<strong>cursor</strong>‌：表示当前遍历的位置，初始值为0。每次调用SCAN命令后，Redis会返回一个新的游标值，用于下一次迭代。</li><li>‌<strong>MATCHpattern</strong>‌：可选参数，用于指定匹配的模式，只返回符合模式的key。</li><li>‌<strong>COUNTcount</strong>‌：可选参数，用于指定每次迭代返回的key数量。这是一种提示（hint），并不保证精确返回指定数量的key。</li></ul></blockquote><p>使用jedis连接Reids，使用<code>Scan</code>命令分批读取所有key，对读取的key按数据类型进行分类判断是不是BigKey，若超过指定标准，则输出该key的相关信息。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.heima.jedis.util.JedisConnectionFactory;<span class="hljs-keyword">import</span> org.junit.jupiter.api.AfterEach;<span class="hljs-keyword">import</span> org.junit.jupiter.api.BeforeEach;<span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<span class="hljs-keyword">import</span> redis.clients.jedis.ScanResult;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisTest</span> &#123;    <span class="hljs-keyword">private</span> Jedis jedis;    <span class="hljs-meta">@BeforeEach</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// 1.建立连接</span>        <span class="hljs-comment">// jedis = new Jedis(&quot;192.168.150.101&quot;, 6379);</span>        jedis = JedisConnectionFactory.getJedis();        <span class="hljs-comment">// 2.设置密码</span>        jedis.auth(<span class="hljs-string">&quot;123321&quot;</span>);        <span class="hljs-comment">// 3.选择库</span>        jedis.select(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">// BigKey判断标准，单个key大小不要超过10kB，集合key不要超过500个成员</span>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">STR_MAX_LEN</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> * <span class="hljs-number">1024</span>;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_MAX_LEN</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testScan</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">long</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;        <span class="hljs-type">String</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0&quot;</span>;        <span class="hljs-keyword">do</span> &#123;            <span class="hljs-comment">// 扫描并获取一部分key</span>            ScanResult&lt;String&gt; result = jedis.scan(cursor);            <span class="hljs-comment">// 记录cursor</span>            cursor = result.getCursor();            List&lt;String&gt; list = result.getResult();            <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span> || list.isEmpty()) &#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-comment">// 遍历</span>            <span class="hljs-keyword">for</span> (String key : list) &#123;                <span class="hljs-comment">// 判断key的类型</span>                <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> jedis.type(key);                <span class="hljs-keyword">switch</span> (type) &#123;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;string&quot;</span>:                        len = jedis.strlen(key);                        maxLen = STR_MAX_LEN;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;hash&quot;</span>:                        len = jedis.hlen(key);                        maxLen = HASH_MAX_LEN;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;list&quot;</span>:                        len = jedis.llen(key);                        maxLen = HASH_MAX_LEN;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;set&quot;</span>:                        len = jedis.scard(key);                        maxLen = HASH_MAX_LEN;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;zset&quot;</span>:                        len = jedis.zcard(key);                        maxLen = HASH_MAX_LEN;                        <span class="hljs-keyword">break</span>;                    <span class="hljs-keyword">default</span>:                        <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-keyword">if</span> (len &gt;= maxLen) &#123;                    System.out.printf(<span class="hljs-string">&quot;Found big key : %s, type: %s, length or size: %d %n&quot;</span>, key, type, len);                &#125;            &#125;        &#125; <span class="hljs-keyword">while</span> (!cursor.equals(<span class="hljs-string">&quot;0&quot;</span>));    &#125;        <span class="hljs-meta">@AfterEach</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;            jedis.close();        &#125;    &#125;&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241229214647372-2024-12-2921:47:24.png"alt="image-20241229214647372" /><figcaption aria-hidden="true">image-20241229214647372</figcaption></figure></li><li><p>第三方工具 利用第三方工具，如<ahref="https://github.com/sripathikrishnan/redis-rdb-tools">Redis-Rdb-Tools</a>离线分析RDB快照文件，全面分析内存使用情况，对Redis性能没有任何影响，但可能存在数据时效性的差异。</p></li><li><p>网络监控自定义工具，监控进出Redis的网络数据，超出预警值时主动告警。</p></li></ul><h5 id="删除bigkey"><strong>删除BigKey</strong></h5><p>在找到BigKey后，应该将BigKey的数据进行拆分，重新存储，之后再删除该key。</p><p>Bigkey内存占用较多，即便时删除这样的key也需要耗费很长时间，导致Redis主线程阻塞，引发一系列问题。</p><ul><li>redis 3.0 及以下版本如果是集合类型，则遍历BigKey的元素，<strong>先逐个删除子元素，最后删除BigKey</strong></li><li>Redis 4.0以后 <code>UNLINK</code> 是 Redis 4.0及更高版本中引入的一个新命令，用于异步地删除一个或多个键。与<code>DEL</code> 命令不同，<code>UNLINK</code>命令不会立即释放与键相关联的内存，而是将键的删除操作放入后台线程中异步执行，从而避免在删除大量键时对Redis 的主线程造成阻塞。</li></ul><blockquote><p>补充：<ahref="https://www.zhihu.com/question/631094333/answer/3299005487">Redis的HotKey</a></p></blockquote><h4 id="恰当的数据类型">恰当的数据类型</h4><h5 id="例一">例一</h5><p>比如存储一个User对象，我们有三种存储方式：</p><p><strong>①方式一：json字符串</strong></p><div class="line-block">user:1 | {"name": "Jack", "age": 21} |</div><p>优点：实现简单粗暴</p><p>缺点：数据耦合，不够灵活</p><p><strong>②方式二：字段打散</strong></p><table><thead><tr class="header"><th style="text-align: center;">user:1:name</th><th style="text-align: center;">Jack</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">user:1:age</td><td style="text-align: center;">21</td></tr></tbody></table><p>优点：可以灵活访问对象任意字段</p><p>缺点：占用空间大、没办法做统一控制</p><p><strong>③方式三：hash（推荐）</strong></p><table><tr><td rowspan="2">user:1</td><td>name</td><td>jack</td></tr><tr><td>age</td><td>21</td></tr></table><p>优点：底层使用ziplist，空间占用小，可以灵活访问对象的任意字段</p><p>缺点：代码相对复杂</p><h5 id="例二">例二</h5><p>假如有hash类型的key，其中有100万对field和value，field是自增id，这个key存在什么问题？如何优化？</p><table><tr style="color:red"><td>key</td><td>field</td><td>value</td></tr><tr><td rowspan="3">someKey</td><td>id:0</td><td>value0</td></tr><tr><td>.....</td><td>.....</td></tr><tr><td>id:999999</td><td>value999999</td></tr></table><p>存在的问题：</p><ul><li><p>hash的entry数量超过500时，会使用哈希表而不是ZipList，内存占用较多</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220521142943350-2024-12-2922:20:10.png"alt="image-20220521142943350" /><figcaption aria-hidden="true">image-20220521142943350</figcaption></figure></li><li><p>可以通过hash-max-ziplist-entries配置entry上限。但是如果entry过多就会导致BigKey问题</p></li></ul><p><strong>方案一</strong></p><p>拆分为string类型</p><table><tr style="color:red"><td>key</td><td>value</td></tr><tr><td>id:0</td><td>value0</td></tr><tr><td>.....</td><td>.....</td></tr><tr><td>id:999999</td><td>value999999</td></tr></table><p>存在的问题：</p><ul><li>string结构底层没有太多内存优化，内存占用较多</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220521143458010-2024-12-2922:20:18.png"alt="image-20220521143458010" /><figcaption aria-hidden="true">image-20220521143458010</figcaption></figure><ul><li>想要批量获取这些数据比较麻烦</li></ul><p><strong>方案二</strong></p><p>拆分为小的hash，<strong>将 id / 100 作为key， 将id % 100作为field</strong>，这样每100个元素为一个Hash</p><table><tr style="color:red"><td>key</td><td>field</td><td>value</td></tr><tr><td rowspan="3">key:0</td><td>id:00</td><td>value0</td></tr><tr><td>.....</td><td>.....</td></tr><tr><td>id:99</td><td>value99</td></tr><tr><td rowspan="3">key:1</td><td>id:00</td><td>value100</td></tr><tr><td>.....</td><td>.....</td></tr><tr><td>id:99</td><td>value199</td></tr><tr><td colspan="3">....</td></tr><tr><td rowspan="3">key:9999</td><td>id:00</td><td>value999900</td></tr><tr><td>.....</td><td>.....</td></tr><tr><td>id:99</td><td>value999999</td></tr></table><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220521144339377-2024-12-2922:20:21.png"alt="image-20220521144339377" /><figcaption aria-hidden="true">image-20220521144339377</figcaption></figure><h3 id="批处理优化">3.2、批处理优化</h3><p>对于海量数据进行处理时，可以选择N条命令逐个执行，也可以选择每次执行m条，分n次执行完。</p><p>一次Redis命令的执行耗时，主要客户端和Redis服务器之间一次往返的网络传输耗时+ 一次Redis命令处理耗时，其中网络传输耗时占命令耗时的主要部分。</p><p>若N条命令依次执行，则<strong>N条命令的响应时间 =N次往返的网络传输耗时 + N次Redis执行命令耗时</strong></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241229224534815-2024-12-2922:46:24.png"alt="N条命令依次执行" /><figcaption aria-hidden="true">N条命令依次执行</figcaption></figure><p>若N条命令批量执行，<strong>N次命令的响应时间 =m次往返的网络传输耗时 +N次Redis执行命令耗时</strong></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241229224753860-2024-12-2922:47:54.png"alt="N条命令批量执行" /><figcaption aria-hidden="true">N条命令批量执行</figcaption></figure><blockquote><p>注：不要在一次批处理中传输太多命令，否则单次命令占用带宽过多，会导致网络阻塞</p></blockquote><h4 id="单机模式下的批处理pipeline">单机模式下的批处理：Pipeline</h4><p>Redis提供了很多<code>Mxxx</code>这样的命令，可以实现批量插入数据，例如：<code>MSET</code>,<code>MHSET</code>等，但这些命令虽然可以批处理，但是却只能操作部分数据类型，因此如果有对复杂数据类型的批处理需要，建议使用Pipeline功能。使用Pipeline可以添加对任意数据类型操作的命令，十分灵活。</p><p>Pipeline 允许客户端将多个命令一次性发送到 Redis服务器，而不是逐个发送命令并等待响应。这种方式显著减少了网络延迟和通信开销，从而提高了命令执行的效率。</p><p><strong>大致工作流程如下：</strong></p><ol type="1"><li>客户端创建一个Pipeline对象，并向其中添加需要执行的命令。</li><li>客户端将所有命令一次性发送到Redis服务器。</li><li>由于<strong>Redis是单线程执行命令</strong>，Redis服务器接收到命令后，会对命令进行<strong>排队</strong>，依次执行这些命令，并将每个命令的结果存储起来。</li><li>客户端等待所有命令执行完成后，从服务器获取结果并按照命令发送的顺序进行处理。</li></ol><p>例如，使用Jedis的pipeline功能，批量处理100000条数据</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">testPipeline</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 创建管道</span>    <span class="hljs-type">Pipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> jedis.pipelined();    <span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> System.currentTimeMillis();    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100000</span>; i++) &#123;        <span class="hljs-comment">// 放入命令到管道</span>        pipeline.set(<span class="hljs-string">&quot;test:key_&quot;</span> + i, <span class="hljs-string">&quot;value_&quot;</span> + i);        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// 每放入1000条命令，批量执行</span>            pipeline.sync();        &#125;    &#125;    <span class="hljs-type">long</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> System.currentTimeMillis();    System.out.println(<span class="hljs-string">&quot;time: &quot;</span> + (e - b));&#125;</code></pre></div><blockquote><p>注意事项：</p><ol type="i"><li><p>Pipeline中的命令<strong>不具备原子性</strong>，即如果其中一个命令失败，不会影响到其他命令的执行。</p></li><li><p>使用Pipeline时，应该避免一次性发送过多命令，以免造成服务器处理阻塞，影响其他客户端的请求。</p></li></ol></blockquote><p>Spring DataRedis也封装了对Pipeline的使用方法。<code>executePipelined</code> 是Spring Data Redis 提供的一个方法，用于执行 Redis 的 Pipeline 操作。</p><p>在 Spring Data Redis 中，<code>executePipelined</code> 方法被定义在<code>RedisTemplate</code> 类中。该方法接受一个<code>RedisCallback&lt;List&lt;Object&gt;&gt;</code>类型的参数，这个参数是一个回调接口，用于定义要在 Redis上执行的命令。在回调接口的 <code>doInRedis</code> 方法中，可以使用<code>RedisConnection</code> 来执行任意数量的 Redis命令。这些命令会被打包成一个 Pipeline 请求发送到 Redis 服务器。</p><p><code>executePipelined</code> 方法的返回值是一个<code>List&lt;Object&gt;</code>，包含了所有命令的执行结果。这些结果的顺序与你在<code>doInRedis</code> 方法中执行命令的顺序是一致的。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisCallback;<span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisService</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeRedisPipeline</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// 使用 Pipeline 执行多个命令</span>        List&lt;Object&gt; results = redisTemplate.executePipelined(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisCallback</span>&lt;List&lt;Object&gt;&gt;() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">doInRedis</span><span class="hljs-params">(org.springframework.data.redis.connection.RedisConnection connection)</span> <span class="hljs-keyword">throws</span> Exception &#123;                <span class="hljs-comment">// 开启 Pipeline（实际上，Spring Data Redis 在调用这个方法时已经为你管理了 Pipeline）</span>                <span class="hljs-comment">// 执行命令，这些命令会被打包成一个 Pipeline 请求</span>                connection.set(<span class="hljs-string">&quot;key1&quot;</span>.getBytes(), <span class="hljs-string">&quot;value1&quot;</span>.getBytes());                connection.set(<span class="hljs-string">&quot;key2&quot;</span>.getBytes(), <span class="hljs-string">&quot;value2&quot;</span>.getBytes());                connection.get(<span class="hljs-string">&quot;key1&quot;</span>.getBytes());                <span class="hljs-comment">// 注意：这里不需要关闭连接，因为 Spring Data Redis 会为你处理</span>                <span class="hljs-comment">// 返回 null 或者一个空列表，因为结果会通过 Pipeline 异步获取</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;            &#125;        &#125;);        <span class="hljs-comment">// 处理结果</span>        <span class="hljs-keyword">for</span> (Object result : results) &#123;            <span class="hljs-comment">// 根据命令的类型和顺序解析结果</span>            System.out.println(result);        &#125;    &#125;&#125;</code></pre></div><blockquote><p>参考文章：<ahref="https://blog.csdn.net/qq_39363204/article/details/125665896?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-1-125665896-blog-119837981.235%5Ev43%5Epc_blog_bottom_relevance_base8&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7EPaidSort-1-125665896-blog-119837981.235%5Ev43%5Epc_blog_bottom_relevance_base8&amp;utm_relevant_index=2">RedisTemplatePipeline 管道使用</a></p></blockquote><p>有的系统对延迟要求很高，那么redis管道第一次请求很慢，就需要在系统启动时进行管道的预热，保证系统启动后每次请求的低延迟。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostConstruct</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();    redisTemplate.executePipelined(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionCallback</span>&lt;Object&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> &lt;K, V&gt; Object <span class="hljs-title function_">execute</span><span class="hljs-params">(RedisOperations&lt;K, V&gt; operations)</span> <span class="hljs-keyword">throws</span> DataAccessException &#123;            operations.hasKey((K) <span class="hljs-string">&quot;&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;    &#125;);    log.info(<span class="hljs-string">&quot;redis初始化管道请求end，耗时：&#123;&#125;ms&quot;</span>, System.currentTimeMillis() - startTime);&#125;</code></pre></div><h4 id="集群下的批处理">集群下的批处理</h4><p>如果Redis是一个集群，那<strong>批处理命令的多个key必须落在一个插槽中</strong>，否则就会导致执行失败。</p><p>Pipeline并不支持跨节点的命令执行。如果pipeline中的命令涉及多个不同的槽（即多个不同的节点），那么这些命令将无法在一个pipeline中成功执行。因为Redis集群是由多个节点组成的，每个节点只负责维护一部分数据。当尝试在属于不同节点的数据上使用Pipeline 时，Redis会返回错误，因为它不知道如何在不同节点之间协调和执行这些命令。同时，Pipeline的主要目的是减少网络延迟和开销。如果pipeline中的命令需要跨多个节点执行，那么每个节点都需要处理并响应这些命令，这会增加网络延迟和处理的复杂度。</p><p><strong>四种解决方案</strong></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/1653126446641-2024-12-3010:03:44.png"alt="1653126446641" /><figcaption aria-hidden="true">1653126446641</figcaption></figure><p>综合考虑下，使用并行slot处理较为合理，虽然实现较为复杂，需要创建多个线程并行执行各组pipeline命令，但其性能优于串行Slot，也不会出现像hash_tag方案的数据倾斜问题。</p><p>在Spring集群环境下的<code>mset</code>、<code>hmset</code>等命令已经实现了并行slot，解决了集群模式下的批处理问题。</p><p>测试代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMSetInCluster</span><span class="hljs-params">()</span> &#123;     Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">3</span>);     map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Rose&quot;</span>);     map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>);     map.put(<span class="hljs-string">&quot;sex&quot;</span>, <span class="hljs-string">&quot;Female&quot;</span>);     stringRedisTemplate.opsForValue().multiSet(map);     List&lt;String&gt; strings = stringRedisTemplate.opsForValue().multiGet(Arrays.asList(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>));     strings.forEach(System.out::println); &#125;</code></pre></div><p>原理分析：</p><p>在RedisAdvancedClusterAsyncCommandsImpl 类中</p><p>首先根据slotHash算出来一个partitioned的map，map中的key就是slot，而他的value就是对应的对应相同slot的key对应的数据</p><p>通过 RedisFuture<String> mset = super.mset(op);进行异步的消息发送</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> RedisFuture&lt;String&gt; <span class="hljs-title function_">mset</span><span class="hljs-params">(Map&lt;K, V&gt; map)</span> &#123;    Map&lt;Integer, List&lt;K&gt;&gt; partitioned = SlotHash.partition(codec, map.keySet());    <span class="hljs-keyword">if</span> (partitioned.size() &lt; <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.mset(map);    &#125;    Map&lt;Integer, RedisFuture&lt;String&gt;&gt; executions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, List&lt;K&gt;&gt; entry : partitioned.entrySet()) &#123;        Map&lt;K, V&gt; op = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();        entry.getValue().forEach(k -&gt; op.put(k, map.get(k)));        RedisFuture&lt;String&gt; mset = <span class="hljs-built_in">super</span>.mset(op);        executions.put(entry.getKey(), mset);    &#125;    <span class="hljs-keyword">return</span> MultiNodeExecution.firstOfAsync(executions);&#125;</code></pre></div><h3 id="服务端优化">3.3、服务端优化</h3><h4 id="持久化配置"><strong>持久化配置</strong></h4><p>Redis的持久化虽然可以保证数据安全，但也会带来很多额外的开销，因此持久化请遵循下列建议：</p><ul><li><p>用来做缓存的Redis实例尽量不要开启持久化功能</p></li><li><p>建议关闭RDB持久化功能，使用AOF持久化（AOF数据时效性和安全性更好）</p><blockquote><p>redis.conf</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># 关闭RDB持久化</span><span class="hljs-comment"># save 900 1</span><span class="hljs-comment"># save 300 10</span><span class="hljs-comment"># save 60 10000</span><span class="hljs-comment"></span><span class="hljs-comment"># 开启AOF持久化</span><span class="hljs-attr">appendonly</span> <span class="hljs-string">yes</span><span class="hljs-comment"></span><span class="hljs-comment"># 设置AOF同步频率</span><span class="hljs-attr">appendfsync</span> <span class="hljs-string">everysec</span></code></pre></div></blockquote></li><li><p>利用脚本定期在slave节点做RDB，实现数据<strong>备份</strong>。频繁的RDBfork操作耗时较久，涉及大量磁盘IO，对性能影响较大。</p></li><li><p>设置合理的rewrite阈值，避免频繁对AOF文件做bgrewrite。(bgrewrite对CPU和磁盘占用较高)</p><blockquote><p>redis.conf</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment"># redis会记录上一次bgrewrite时的文件大小，当AOF文件大小超过上次文件大小指定的百分比后，会触发bgrewrite机制</span><span class="hljs-attr">auto-aof-rewrite-percentage</span> <span class="hljs-string">100</span><span class="hljs-comment"># 执行bgrewrite时AOF文件的最小容量</span><span class="hljs-attr">auto-aof-rewrite-min-size</span> <span class="hljs-string">64mb</span></code></pre></div></blockquote></li><li><p>配置<code>no-appendfsync-on-rewrite = yes</code>，禁止在rewrite期间做aof，避免因AOF引起的阻塞。</p><p>在执行bgrewrite时对CPU和磁盘的占用较高，且这个过程持续时间较长，而AOF默认的同步刷盘频率是每秒执行一次。在开启AOF机制后，主线程执行完一条命令后，要判断当前的刷盘时间是否小于2秒，若超过两秒会阻塞等待刷盘操作完成。在执行bgrewrite期间肯定会影响到AOF的刷盘效率，可能进一步导致主线程阻塞。在设置了<code>no-appendfsync-on-rewrite = yes</code>后，Redis若发现当前在做bgrewrite，就不会做AOF同步，主线程执行完命令直接返回。但由于在此期间没有做AOF持久化，可能出现数据丢失的问题。</p><p>是否开启在bgrewrite期间禁止做AOF同步，要视业务需求而定，若追求数据的安全，则设置为no，若追求的是性能，则开启。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230103348982-2024-12-3010:34:05.png"alt="image-20241230103348982" /><figcaption aria-hidden="true">image-20241230103348982</figcaption></figure></li><li><p>部署有关建议：</p><ul><li>Redis实例的物理机要预留足够内存，应对fork和rewrite</li><li>单个Redis实例内存上限不要太大，例如4G或8G。可以加快fork的速度、减少主从同步、数据迁移压力</li><li>不要与CPU密集型应用部署在一起</li><li>不要与高硬盘负载应用一起部署。例如：数据库、消息队列</li></ul></li></ul><h4 id="慢查询">慢查询</h4><p>在Redis执行时耗时超过某个阈值的<strong>命令</strong>，称为慢查询。</p><p>慢查询的危害：由于Redis是单线程的，所以当客户端发出指令后，他们都会进入到redis底层的queue来执行，如果此时有一些慢查询的数据，就会导致大量请求阻塞，从而引起报错。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/1653129590210-2024-12-3010:52:29.png"alt="1653129590210" /><figcaption aria-hidden="true">1653129590210</figcaption></figure><p>慢查询的阈值在redis.conf中设置：</p><p><code>slowlog-log-slower-than</code>：慢查询阈值，单位是微秒。默认是10000，建议1000</p><p>慢查询会被放入慢查询日志中，日志的长度有上限，可以通过配置指定：</p><p><code>slowlog-max-len</code>：慢查询日志（本质是一个队列）的长度。默认是128，建议1000</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230105504516-2024-12-3010:55:05.png"alt="image-20241230105504516" /><figcaption aria-hidden="true">image-20241230105504516</figcaption></figure><p><strong>查看慢查询日志列表</strong></p><ul><li><code>slowlog len</code>：查询慢查询日志长度</li><li><code>slowlog get [n]</code>：读取n条慢查询日志</li><li><code>slowlog reset</code>：清空慢查询列表</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/1653130858066-2024-12-3010:56:01.png"alt="1653130858066" /><figcaption aria-hidden="true">1653130858066</figcaption></figure><p>也可以在图形化客户端中查看</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230105734147-2024-12-3010:57:36.png"alt="image-20241230105734147" /><figcaption aria-hidden="true">image-20241230105734147</figcaption></figure><h4 id="安全配置">安全配置</h4><p>安全可以说是服务器端一个非常重要的话题，如果安全出现了问题，那么一旦这个漏洞被一些坏人知道了之后，并且进行攻击，那么这就会给咱们的系统带来很多的损失，所以我们这节课就来解决这个问题。</p><p>Redis会绑定在0.0.0.0:6379，这样将会将Redis服务暴露到公网上，而Redis如果没有做身份认证，会出现严重的安全漏洞.<ahref="https://cloud.tencent.com/developer/article/1039000">漏洞重现方式</a></p><p>为什么会出现不需要密码也能够登录呢，主要是Redis考虑到每次登录都比较麻烦，所以Redis就有一种ssh免秘钥登录的方式，生成一对公钥和私钥，私钥放在本地，公钥放在redis端，当我们登录时服务器，再登录时候，他会去解析公钥和私钥，如果没有问题，则不需要利用redis的登录也能访问，这种做法本身也很常见，但是这里有一个前提，前提就是公钥必须保存在服务器上，才行，但是Redis的漏洞在于在不登录的情况下，也能把秘钥送到Linux服务器，从而产生漏洞。其核心操作就是连接到Redis服务器，使用<code>config set</code>命令修改Redis持久化文件的名称和保存目录，再执行持久化操作，将秘钥内容写入服务器，完成免密登录。</p><p>漏洞出现的核心的原因有以下几点：</p><ul><li>Redis未设置密码</li><li>利用了Redis的config set命令动态修改Redis配置</li><li>使用了Root账号权限启动Redis</li></ul><p>所以：如何解决呢？我们可以采用如下几种方案</p><p>为了避免这样的漏洞，这里给出一些建议：</p><ul><li><p>Redis一定要设置密码</p></li><li><p>禁止线上使用下面命令：keys、flushall、flushdb、configset等命令。可以在配置文件中利用<code>rename-command</code>给这些命令重命名或禁用。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230111054332-2024-12-3011:11:05.png"alt="image-20241230111054332" /><figcaption aria-hidden="true">image-20241230111054332</figcaption></figure></li><li><p>bind：限制网卡，禁止外网网卡访问</p></li><li><p>开启防火墙</p></li><li><p>不要使用Root账户启动Redis</p></li><li><p>尽量不是有默认的端口</p></li></ul><h4 id="内存配置">内存配置</h4><p>当Redis内存不足时，可能导致Key频繁被删除、响应时间变长、QPS不稳定等问题。当内存使用率达到90%以上时就需要我们警惕，并快速定位到内存占用的原因。</p><p>查看到Redis目前的内存分配状态：</p><ul><li><p><code>info memory</code>：查看内存分配的情况</p></li><li><p><code>memory xxx</code>：查看key的主要占用情况</p><p><code>memory state</code>命令返回结果分析</p><div class="code-wrapper"><pre><code class="hljs bash">1）<span class="hljs-string">&quot;peak.allocated&quot;</span>//Redis进程自启动以来消耗内存的峰值。2）（<span class="hljs-built_in">integer</span>）794923123）<span class="hljs-string">&quot;total.allocated&quot;</span>//Redis使用其分配器分配的总字节数，即当前的总内存使用量。4）（<span class="hljs-built_in">integer</span>）793077765）<span class="hljs-string">&quot;startup.allocated&quot;</span>_//Redis启动时消耗的初始内存量。6）（<span class="hljs-built_in">integer</span>）455825927）<span class="hljs-string">&quot;replication.backlog&quot;</span>//复制积压缓冲区的大小。8）（<span class="hljs-built_in">integer</span>）335544329）<span class="hljs-string">&quot;clients.slaves&quot;</span>//主从复制中所有从节点的读写缓冲区大小。10）（<span class="hljs-built_in">integer</span>）1726611）<span class="hljs-string">&quot;clients.normal&quot;</span>//除从节点外，所有其他客户端的读写缓冲区大小。12）（<span class="hljs-built_in">integer</span>）11910213）<span class="hljs-string">&quot;aof.buffer&quot;</span>//AOF持久化使用的缓存和AOF重写时产生的缓存。14）（<span class="hljs-built_in">integer</span>）015）<span class="hljs-string">&quot;db.0&quot;</span>//业务数据库的数量。16）1）<span class="hljs-string">&quot;overhead.hashtable.main&quot;</span>//当前数据库的<span class="hljs-built_in">hash</span>链表开销内存总和，即元数据内存。        2）（<span class="hljs-built_in">integer</span>）144        3）<span class="hljs-string">&quot;overhead.hashtable.expires&quot;</span>//用于存储key的过期时间所消耗的内存。        4）（<span class="hljs-built_in">integer</span>）e17）<span class="hljs-string">&quot;overhead.total&quot;</span>//数值=startup.allocated+replication.backlog+clients.slaves+clients.normal+aof.buffer+db.X.18）（<span class="hljs-built_in">integer</span>）7927361619）<span class="hljs-string">&quot;keys.count&quot;</span>//当前Redis实例的key总数20）（<span class="hljs-built_in">integer</span>）221）<span class="hljs-string">&quot;keys.bytes-per-key&quot;</span>//当前Redis实例每个key的平均大小，计算公式21）<span class="hljs-string">&quot;keys.bytes-per-key&quot;</span>//当前Redis实例每个key的平均大小，计算公式：（total.allocated-startup.allocated）/keys.count.22）（<span class="hljs-built_in">integer</span>）1686259223）<span class="hljs-string">&quot;dataset.bytes&quot;</span>//纯业务数据占用的内存大小。24）（<span class="hljs-built_in">integer</span>）3416025）<span class="hljs-string">&quot;dataset.percentage&quot;</span>//纯业务数据占用的内存比例，计算公式：dataset.bytes*100/（total.allocated-startup.allocated）.26）<span class="hljs-string">&quot;0.1012892946600914&quot;</span>27）<span class="hljs-string">&quot;peak.percentage&quot;</span>//当前总内存与历史峰值的比例，计算公式：total.allocated*100/peak.allocated.28）<span class="hljs-string">&quot;99.767860412597656&quot;</span>29）<span class="hljs-string">&quot;fragmentation&quot;</span>//内存的碎片率。30）<span class="hljs-string">&quot;0.45836541056632996&quot;</span></code></pre></div></li></ul><p>Redis的内存占用主要划分为以下几个部分：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230132253444-2024-12-3013:23:01.png"alt="Redis内存划分" /><figcaption aria-hidden="true">Redis内存划分</figcaption></figure><p><strong>1、数据内存问题分析</strong>：</p><p>主要是BigKey和内存碎片问题。</p><p>其中BigKey之前已经讲过，应该选择合适的数据结构避免出现BigKey，对已经出现的BigKey的数据进行拆分后删除即可。</p><p>内存碎片的形成主要有以下几个原因：</p><ol type="i"><li><p><strong>内存分配机制</strong>：Redis使用的内存分配器（默认是<code>jemalloc</code>）<strong>会按照固定大小来分配内存，而不是完全按照程序申请的内存大小来进行分配。</strong>这可能导致分配的内存空间大于实际需要的空间，从而产生碎片‌。例如，当前key只需要10个字节，此时分配8肯定不够，那么他就会分配16个字节，多出来的6个字节就不能被使用。内存碎片对Redis的影响主要体现在内存利用率上。虽然内存碎片不会影响Redis的性能，但会降低内存的实际可用空间，从而可能导致Redis需要和外存进行数据交换（Swap），或者根据淘汰策略清理老数据，进而影响整体系统的性能。</p></li><li><p><strong>数据删除与修改</strong>‌：当Redis删除或修改数据时，释放的内存空间并不一定能被立即重新利用。尤其是当这些空闲内存空间大小不一致时，就更可能导致内存碎片的出现‌</p></li></ol><p>为了清理内存碎片，Redis4.0版本后提供了自动内存碎片清理机制‌。此外，也可以通过重启Redis服务来清理内存碎片，但这种方法需要谨慎使用，因为重启期间Redis不可用，且如果未开启持久化机制，数据可能会丢失。</p><p><strong>2、进程内存问题分析：</strong></p><p>Redis进程自身运行所需的内存消耗，这部分内存消耗通常非常小，通常可以忽略不计</p><p><strong>3、缓冲区内存问题分析：</strong></p><p>缓冲区内存占用波动较大，特别是在高并发或大流量场景下，需要重点分析和管理。</p><p>Redis的缓冲区内存主要包括以下几个部分：</p><p>‌<strong>复制缓存（Replication Backlog Buffer）</strong>‌：</p><ul><li>这是一个可重用的固定大小缓冲区（<code>repl_backlog_buf</code>），用于支持主从复制功能。如果太小可能导致频繁的全量复制，影响性能。它存储复制过程中的数据缓冲区，避免全量复制。配置参数为<code>repl-backlog-size</code>，默认值为1M。单个主节点配置一个复制积压缓冲区。</li></ul><p>‌<strong>AOF缓冲区</strong>‌：</p><ul><li>如果启用了AOF（Append-OnlyFile）持久化，则会有一个缓冲区用于存储写操作，以便在后台将其写入磁盘。AOF重写期间增量的写入命令也会保存在这个缓冲区中。此部分缓存占用大小取决于AOF重写时间及增量。</li></ul><p>‌<strong>客户端缓存</strong>‌：</p><p>Redis客户端主要分为<strong>从客户端</strong>、<strong>订阅客户端</strong>和<strong>普通客户端</strong>。从客户端连接主要用于主从复制，订阅客户端用于发布订阅功能，普通客户端则是通常的应用连接。每种类型的客户端都有不同的缓冲配置限制，以避免因缓冲区积压而导致的内存问题。</p><ul><li><p>‌<strong>输入缓冲</strong>‌：TCP连接的输入缓冲占用是不受控制的，最大允许空间为1G。</p></li><li><p>‌<strong>输出缓冲</strong>‌：TCP连接的输出缓冲占用可以通过<code>client-output-buffer-limit</code>参数配置。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241230140922747-2024-12-3014:09:30.png"alt="image-20241230140922747" /><figcaption aria-hidden="true">image-20241230140922747</figcaption></figure><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#默认配置如下：</span><span class="hljs-comment"># Both the hard or the soft limit can be disabled by setting them to zero.</span><span class="hljs-comment">#普通客户端默认不受限制</span><span class="hljs-attr">client-output-buffer-limit</span> <span class="hljs-string">normal 0 0 0 </span><span class="hljs-attr">client-output-buffer-limit</span> <span class="hljs-string">replica 256mb 64mb 60</span><span class="hljs-attr">client-output-buffer-limit</span> <span class="hljs-string">pubsub 32mb 8mb 60</span></code></pre></div></li></ul><p>解决客户端缓冲区过大导致断开Redis连接的方法：</p><p>1、设置一个大小</p><p>2、增加带宽，避免我们出现大量数据从而直接超过了redis的承受能力</p><p>Redis提供的查看客户端详情的命令</p><ul><li><p><code>info clients</code>，返回客户端总览，其中包括最大输入和最大输出缓冲区的大小</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241230142225240-2024-12-3014:23:04.png" alt="image-20241230142225240" style="zoom: 80%;" /></p></li><li><p><code>client list</code>，可以获取当前连接到Redis服务器的所有客户端信息，其中包括客户端的缓冲区使用情况。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241230142726964-2024-12-3014:28:04.png" alt="image-20241230142726964" style="zoom:67%;" /></p><p>在输出结果中，关注与客户端缓冲区相关的字段，这些字段包括：</p><ul><li><code>qbuf</code>：查询缓冲区的长度（字节为单位），表示客户端发送到Redis但尚未被处理的命令所占用的缓冲区大小。如果<code>qbuf</code>很大，而同时<code>qbuf-free</code>（查询缓冲区剩余空间的长度）很小，说明客户端的输入缓冲区已经占用了很多内存，且空闲空间不足。</li><li><code>qbuf-free</code>：查询缓冲区剩余空间的长度（字节为单位），表示客户端输入缓冲区中剩余的可用空间大小。</li><li><code>obl</code>：输出缓冲区的长度（字节为单位），表示Redis为客户端分配的输出缓冲区中，已用于存储命令执行结果的部分所占用的空间大小。</li><li><code>oll</code>：输出列表包含的对象数量，当输出缓冲区没有剩余空间时，命令回复会以字符串对象的形式被入队到这个队列里。</li><li><code>omem</code>：输出缓冲区和输出列表占用的内存总量。</li></ul><p>根据上述字段的值，可以分析客户端的缓冲区使用情况。例如，如果<code>qbuf</code>值很大，说明客户端正在向Redis发送大量命令，而Redis尚未处理完这些命令。如果<code>obl</code>和<code>oll</code>值很大，说明Redis正在为客户端准备大量的命令执行结果，但尚未发送给客户端。如果<code>qbuf-free</code>值很小或接近0，说明客户端的输入缓冲区已经接近满负荷，可能需要考虑优化客户端的命令发送速率或增加Redis的处理能力。</p><p>根据分析结果，采取相应的措施来优化客户端的缓冲区使用情况。例如，如果发现某个客户端的<code>qbuf</code>值持续很高，可以考虑优化该客户端的命令发送逻辑，减少不必要的命令发送；如果发现Redis的输出缓冲区占用过高，可以考虑增加Redis的内存配额、优化数据访问模式或增加Redis实例的数量等。</p><blockquote><p>注意：<code>CLIENT LIST</code>命令输出的缓冲区信息只是瞬时值，要全面了解客户端的缓冲区使用情况，可能需要结合监控工具和日志分析等方法进行综合评估。</p></blockquote></li></ul><h3 id="集群最佳实践---集群-or-主从">3.4、集群最佳实践 - 集群 or主从</h3><p>集群虽然具备高可用特性，能实现自动故障恢复，但是如果使用不当，也会存在一些问题：</p><ul><li><p><strong>集群完整性问题</strong></p><p>在Redis的默认配置中，如果发现任意一个插槽不可用，则整个集群都会停止对外服务：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/1653132740637-2024-12-3013:12:20.png"alt="1653132740637" /><figcaption aria-hidden="true">1653132740637</figcaption></figure><p>在开发中，其实最重要的是可用性，所以需要把如下配置修改成no，即有slot不能使用时，redis集群的其他节点还是可以对外提供服务。</p></li><li><p><strong>集群带宽问题</strong></p><p>集群节点之间会不断的互相Ping来确定集群中其它节点的状态。每次Ping携带的信息至少包括：</p><ul><li>插槽信息</li><li>集群状态信息</li></ul><p>集群中节点越多，集群状态信息数据量也越大，10个节点的相关信息可能达到1kb，此时每次集群互通需要的带宽会非常高，这样会导致集群中大量的带宽都会被ping信息所占用，这是一个非常可怕的问题。</p><p><strong>解决途径：</strong></p><ul><li>避免大集群，集群节点数不要太多，最好少于1000，如果业务庞大，则建立多个集群。</li><li>避免在单个物理机中运行太多Redis实例</li><li>配置合适的cluster-node-timeout值</li></ul></li><li><p><strong>数据倾斜问题</strong></p><p>在出现BigKey或者批处理中使用hash_tag策略时，会产生数据倾斜的问题。</p></li><li><p><strong>客户端性能问题</strong></p></li><li><p><strong>命令的集群兼容性问题</strong></p></li><li><p><strong>lua和事务问题</strong></p><p>lua和事务都是要保证原子性问题，如果你的key不在一个节点，那么是无法保证lua的执行和事务的特性的，所以在集群模式是没有办法执行lua和事务的。</p></li></ul><p><strong>到底是集群还是主从？</strong></p><p>单体Redis（主从Redis）已经能达到万级别的QPS，并且也具备很强的高可用特性。如果主从能满足业务需求的情况下，所以如果不是在万不得已的情况下，尽量不搭建Redis集群</p><h2 id="四补充redis事务">四、补充：Redis事务</h2><p>Redis事务：一组命令的集合。事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。所有事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p><h3 id="使用redis事务">4.1、使用Redis事务</h3><p>Redis 可以通过<strong>MULTI</strong>，<strong>EXEC</strong>，<strong>DISCARD</strong>和 <strong>WATCH</strong> 等命令来实现事务(Transaction)功能。</p><p>操作过程：开启事务(<code>multi</code>) &gt;&gt; 命令入队 &gt;&gt;执行事务(<code>exec</code>)</p><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; multi <span class="hljs-comment"># 开启事务</span>OK127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1 <span class="hljs-comment"># 命令入队</span>QUEUED127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k2 v2 <span class="hljs-comment"># ..</span>QUEUED127.0.0.1:6379&gt; get k1QUEUED127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k3 v3QUEUED127.0.0.1:6379&gt; keys *QUEUED127.0.0.1:6379&gt; <span class="hljs-built_in">exec</span> <span class="hljs-comment"># 事务执行</span>1) OK2) OK3) <span class="hljs-string">&quot;v1&quot;</span>4) OK5) 1) <span class="hljs-string">&quot;k3&quot;</span>   2) <span class="hljs-string">&quot;k2&quot;</span>   3) <span class="hljs-string">&quot;k1&quot;</span></code></pre></div><p>取消事务(<code>discurd</code>)</p><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 v1QUEUED127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k2 v2QUEUED127.0.0.1:6379&gt; DISCARD <span class="hljs-comment"># 放弃事务</span>OK127.0.0.1:6379&gt; EXEC (error) ERR EXEC without MULTI <span class="hljs-comment"># 当前未开启事务</span>127.0.0.1:6379&gt; get k1 <span class="hljs-comment"># 被放弃事务中命令并未执行</span>(nil)</code></pre></div><p>通过<code>WATCH</code> 命令监听指定的 Key，当调用<strong>EXEC</strong> 命令执行事务时，如果一个被 <strong>WATCH</strong>命令监视的 Key 被 其他客户端/Session修改的话，整个事务都不会被执行。</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 客户端 1</span>127.0.0.1:6379&gt; SET PROJECT <span class="hljs-string">&quot;Hello，Redis!&quot;</span>OK127.0.0.1:6379&gt; WATCH PROJECTOK127.0.0.1:6379&gt; MULTIOK127.0.0.1:6379&gt; SET PROJECT <span class="hljs-string">&quot;Hello，Redis!&quot;</span>QUEUED <span class="hljs-comment"># 客户端 2</span><span class="hljs-comment"># 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值</span>127.0.0.1:6379&gt; SET PROJECT <span class="hljs-string">&quot;Hi，Redis!&quot;</span> <span class="hljs-comment"># 客户端 1</span><span class="hljs-comment"># 修改失败，因为 PROJECT 的值被客户端2修改了</span>127.0.0.1:6379&gt; EXEC(nil)127.0.0.1:6379&gt; GET PROJECT<span class="hljs-string">&quot;Hi，Redis!&quot;</span></code></pre></div><h3 id="redis事务特性">4.2、Redis事务特性</h3><p><strong>Redis的单条命令是保证原子性的，但是redis事务不能保证原子性</strong></p><p>对于提交到事务中的命令，若出现代码语法错误（编译时异常）所有的命令都不执行；若是代码逻辑错误(运行时异常) <strong>其他命令可以正常执行</strong>（<u>不保证事务原子性</u>）。并且，Redis 事务是不支持回滚（rollback）操作的。</p><p>Redis 从 2.6 版本开始支持执行 Lua脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis命令，这些 Redis 命令会被提交到 Redis服务器一次性执行完成，大幅减小了网络开销。一段 Lua脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis命令同时执行，保证了操作不会被其他指令插入或打扰。</p><p>不过，如果 Lua脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此，严格来说的话，通过 Lua 脚本来批量执行 Redis命令实际也是不完全满足原子性的。</p><p>如果想要让 Lua脚本中的命令全部执行，必须保证语句语法和命令都是对的。</p><p><ahref="https://blog.csdn.net/Bisikl/article/details/143578263">参考文章</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis持久化</tag>
      
      <tag>Redis主从</tag>
      
      <tag>Redis分片集群</tag>
      
      <tag>多级缓存</tag>
      
      <tag>Redis最佳实践</tag>
      
      <tag>Redis事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis - 实战篇</title>
    <link href="/e0606bbf/"/>
    <url>/e0606bbf/</url>
    
    <content type="html"><![CDATA[<meta name = "referrer", content = "no-referrer"/><p>基于一个springboot项目 黑马点评，用以学习Redis在web中的各种使用方式和场景。</p><p><ahref="https://pan.baidu.com/s/1189u6u4icQYHg_9_7ovWmA?pwd=eh11#list/path=%2Fsharelink3232509500-235828228909890%2F7%E3%80%81Redis%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B%2FRedis-%E7%AC%94%E8%AE%B0%E8%B5%84%E6%96%99%2F02-%E5%AE%9E%E6%88%98%E7%AF%87%2F%E8%B5%84%E6%96%99&amp;parentPath=%2Fsharelink3232509500-235828228909890">项目初始代码</a></p><p><ahref="https://www.bilibili.com/video/BV1cr4y1671t?vd_source=51d78ede0a0127d1839d6abf9204d1ee&amp;spm_id_from=333.788.videopod.episodes&amp;p=25">项目导入参考</a></p><h2 id="一短信登录">一、短信登录</h2><blockquote><p>Redis的共享Session应用</p></blockquote><h3 id="基于session实现登录的流程">1.1、基于Session实现登录的流程</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241211101059066-2024-12-1110:11:15.png"alt="image-20241211101059066" /><figcaption aria-hidden="true">image-20241211101059066</figcaption></figure><p><strong>发送验证码：</strong></p><p>用户在提交手机号后，会校验手机号是否合法，如果不合法，则要求用户重新输入手机号。</p><p>如果手机号合法，后台此时生成对应的验证码，同时将验证码进行保存，然后再通过短信的方式将验证码发送给用户</p><p><strong>短信验证码登录、注册：</strong></p><p>​用户将验证码和手机号进行输入，后台从session中拿到当前验证码，然后和用户输入的验证码进行校验，如果不一致，则无法通过校验，如果一致，则后台根据手机号查询用户，如果用户不存在，则为用户创建账号信息，保存到数据库，无论是否存在，都会将用户信息保存到session中，方便后续获得当前登录信息</p><p><strong>校验登录状态:</strong></p><p>用户在请求时候，会从cookie中携带JsessionId到后台，后台通过JsessionId从session中拿到用户信息，如果没有session信息，则进行拦截，如果有session信息，则将用户信息保存到threadLocal中，并且放行。</p><h4 id="发送验证码">发送验证码</h4><p>页面流程如下，输入手机号后点击发送验证码，会向后端路径为<code>/user/code</code>的接口发起请求</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241211111739244-2024-12-1111:17:41.png"alt="image-20241211111739244" /><figcaption aria-hidden="true">image-20241211111739244</figcaption></figure><p>在对应的service层编写业务逻辑</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;    <span class="hljs-comment">//1. 校验手机号</span>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;        <span class="hljs-comment">//校验失败，返回错误信息</span>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);    &#125;    <span class="hljs-comment">//2.校验成功，生成验证码</span>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);    <span class="hljs-comment">//3.保存验证码</span>    <span class="hljs-comment">//将session的id名称“login_code”设置为常量</span>    session.setAttribute(SystemConstants.User_LOGIN_SESSION_ID,code);    <span class="hljs-comment">//4.发送验证码（模拟，实际调用发送验证码功能模块完成）</span>    log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);    <span class="hljs-keyword">return</span> Result.ok();&#125;</code></pre></div><p>测试结果：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241211112139742-2024-12-1111:21:41.png"alt="image-20241211112139742" /><figcaption aria-hidden="true">image-20241211112139742</figcaption></figure><h4 id="短信验证码登录注册">短信验证码登录、注册</h4><p>填入获得的验证码点击登录后，会向后端接口为<code>/user/login</code>的接口发起登录请求</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241211112401673-2024-12-1111:24:02.png"alt="image-20241211112401673" /><figcaption aria-hidden="true">image-20241211112401673</figcaption></figure><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;    <span class="hljs-comment">//1.校验手机号</span>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;        <span class="hljs-comment">//校验失败，返回错误信息</span>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);    &#125;    <span class="hljs-comment">//2.校验验证码</span>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();    <span class="hljs-type">Object</span> <span class="hljs-variable">cachedCode</span> <span class="hljs-operator">=</span> session.getAttribute(SystemConstants.User_LOGIN_SESSION_ID);    <span class="hljs-keyword">if</span> (code == <span class="hljs-literal">null</span> || !cachedCode.toString().equals(code))&#123;        <span class="hljs-comment">//验证码不一致，返回错误信息</span>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);    &#125;    <span class="hljs-comment">//3.验证码一致，根据手机号查询用户（基于MyBatisPlus）</span>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();     <span class="hljs-comment">//4.用户不存在，创建用户，保存到数据库</span>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;        user = createUserWithPhone(phone);    &#125;    <span class="hljs-comment">//5.保存用户到session中</span>    <span class="hljs-comment">//session中不必保存用户的所有信息，隐藏密码登敏感信息</span>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);    session.setAttribute(SystemConstants.User_INFO_SESSION_ID,userDTO);    <span class="hljs-keyword">return</span> Result.ok();&#125;<span class="hljs-keyword">private</span> User <span class="hljs-title function_">createUserWithPhone</span><span class="hljs-params">(String phone)</span> &#123;    <span class="hljs-comment">//1.创建用户</span>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();    user.setPhone(phone);    user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX+RandomUtil.randomString(<span class="hljs-number">8</span>));    <span class="hljs-comment">//2.保存用户</span>    save(user);    <span class="hljs-keyword">return</span> user;&#125;</code></pre></div><h4 id="校验登录状态">校验登录状态</h4><p>用户在访问接口时需要验证登录信息，这种验证逻辑不能只写在某个一个功能接口中，因为其他的功能接口可能也要进行登录校验。因此，可以将登录校验逻辑写在<strong>拦截器</strong>中，对每个接口的访问都要首先经过拦截器拦截验证，若用户已登录将登录信息保存到此次请求线程的ThreadLocal中，每个线程操作自己的一份数据。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241211120555985-2024-12-1112:05:57.png"alt="image-20241211120555985" /><figcaption aria-hidden="true">image-20241211120555985</figcaption></figure><p>创建拦截器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">//1.获取session</span>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();        <span class="hljs-comment">//2.获取session中的用户</span>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> (UserDTO)session.getAttribute(USER_INFO_SESSION_ID);        <span class="hljs-comment">//3.判断用户是否存在</span>        <span class="hljs-keyword">if</span> (userDTO == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//不存在，拦截请求，返回未授权状态码401</span>            response.setStatus(<span class="hljs-number">401</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">//4.存在将用户信息保存到ThreadLocal中</span>        <span class="hljs-comment">//此处使用自定义的ThreadLocal工具类完成</span>        log.info(<span class="hljs-string">&quot;请求路径：&#123;&#125;，拦截器验证通过，从session中取出的UserDTO为:&#123;&#125;&quot;</span>,request.getRequestURL(),userDTO);        UserHolder.saveUser(userDTO);        <span class="hljs-comment">//5.放行</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">//移除用户</span>        UserHolder.removeUser();    &#125;&#125;</code></pre></div><p>配置拦截器使之生效</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@RequiredArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LoginInterceptor loginInterceptor;    <span class="hljs-comment">//添加拦截器</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;        registry.addInterceptor(loginInterceptor)                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)                .excludePathPatterns(                        <span class="hljs-string">&quot;/shop/**&quot;</span>,                        <span class="hljs-string">&quot;/voucher/**&quot;</span>,                        <span class="hljs-string">&quot;/shop-type/**&quot;</span>,                        <span class="hljs-string">&quot;/upload/**&quot;</span>,                        <span class="hljs-string">&quot;/blog/hot&quot;</span>,                        <span class="hljs-string">&quot;/user/code&quot;</span>,                        <span class="hljs-string">&quot;/user/login&quot;</span>                );    &#125;&#125;</code></pre></div><blockquote><p>补充：</p><p>当用户发起请求时，会访问我们向tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket相互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应</p><p>通过以上讲解，我们可以得知每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的，使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据</p></blockquote><h3 id="集群的session共享问题">1.2、集群的Session共享问题</h3><p>session共享问题：多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题。</p><p>​每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时整个登录拦截功能就会出现问题。早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了</p><p>但是这种方案具有两个大问题</p><p>1、每台服务器中都有完整的一份session数据，服务器压力过大。</p><p>2、session拷贝数据时，可能会出现延迟</p><p>session的替代方案应该满足：数据共享、内存存储，key、value结构。基于以上特性可以选择使用<strong>Redis</strong>代替Session。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241211161446154-2024-12-1116:15:45.png" alt="image-20241211161446154" style="zoom:80%;" /></p><h3id="基于reids实现共享session的登录">1.3、基于Reids实现共享Session的登录</h3><p>整体访问流程：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241211171313432-2024-12-1117:13:17.png" alt="image-20241211171313432" style="zoom:80%;" /></p><p>细节：</p><p>1、本项目中使用<code>StringRedisTemplate</code>进行序列化，其要求存入的key和value都是String类型。当用户成功登录或注册后，需要存入Redis的UserDTO的id为Long类型，通过Bean转化得到的HashMap无法直接存入Redis。</p><p>方案一：在利用BeanUtil工具将UserDTO转化为HashMap时指定转换规则，将value都转化为String类型。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO,        <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),        CopyOptions.create()                .setIgnoreNullValue(<span class="hljs-literal">true</span>) <span class="hljs-comment">//忽略其中为null的属性</span>                .setFieldValueEditor(    <span class="hljs-comment">//设置属性编辑器</span>                    (filedName, filedValue) -&gt; filedValue.toString()));</code></pre></div><p>方案二：利用Steam流对所转化的HashMap做进一步处理，将value都转化为String类型</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO);Map&lt;String,String&gt; convertUserMap = userMap.entrySet()        .stream()        .collect(Collectors.toMap(                Map.Entry::getKey,                e-&gt; String.valueOf(e.getValue())        ));</code></pre></div><p>2、在创建token时指定了其过期时间为30分钟，为了保证用户在使用过程中token不过期，在拦截器中添加了刷新过期时间的逻辑。但这种方式只能保证用户在访问被拦截的路径时会刷新，而对于访问首页，商品页等不需要拦截的页面超过30分钟后token还是会失效，需要重新登陆。</p><p>为此，再添加一个拦截器<code>RefreshTokenInterceptor</code>，拦截所有路径的请求，在其中获取token，刷新token过期时间，使用token从Redis中查询用户数据，将其保存保存在ThreadLocal中，但不做拦截，一律放行到原来的拦截器。在原来的拦截器中通过判断ThreadLocal中是否存入了用户数据来决定是否放行。</p><blockquote><p>具体代码如下：</p></blockquote><p>1、发送验证码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;    <span class="hljs-comment">//1. 校验手机号</span>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;        <span class="hljs-comment">//校验失败，返回错误信息</span>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);    &#125;    <span class="hljs-comment">//2.校验成功，生成验证码</span>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);    <span class="hljs-comment">//3.保存验证码到Redis，并设置验证码有效期为2min</span>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> LOGIN_CODE_KEY + phone;    stringRedisTemplate        .opsForValue()        .set(key,code,LOGIN_CODE_TTL, TimeUnit.MINUTES);        <span class="hljs-comment">//4.发送验证码（模拟，实际调用发送验证码功能模块完成）</span>    log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);    <span class="hljs-keyword">return</span> Result.ok();&#125;</code></pre></div><p>2、短信验证码登录、注册</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;    <span class="hljs-comment">//1.校验手机号</span>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;        <span class="hljs-comment">//校验失败，返回错误信息</span>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);    &#125;    <span class="hljs-comment">//2.从Redis获取验证码进行校验</span>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> LOGIN_CODE_KEY + phone;    <span class="hljs-type">String</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);    <span class="hljs-keyword">if</span> (cacheCode == <span class="hljs-literal">null</span> || !cacheCode.equals(code))&#123;        <span class="hljs-comment">//验证码不一致，返回错误信息</span>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);    &#125;    <span class="hljs-comment">//3.验证码一致，根据手机号查询用户</span>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();    <span class="hljs-comment">//4.用户不存在，创建用户，保存到数据库</span>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;        user = createUserWithPhone(phone);    &#125;    <span class="hljs-comment">//5.保存用户到red中</span>    <span class="hljs-comment">//5.1 生成随机token</span>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>);    <span class="hljs-comment">//5.2 将UserDTO对象转为HashMap存储</span>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);    <span class="hljs-comment">//注：stringRedisTemplate的键和值都是String类型，而UserDTO的id是Long类型，无法直接存入</span>    Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO,            <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),            CopyOptions.create()                    .setIgnoreNullValue(<span class="hljs-literal">true</span>)                    <span class="hljs-comment">//设置属性转化，将value都转化为String类型</span>                    .setFieldValueEditor(                        (filedName, filedValue) -&gt; filedValue.toString()));    <span class="hljs-comment">//5.3 存入Redis</span>    <span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;    stringRedisTemplate.opsForHash().putAll(tokenKey,userMap);    <span class="hljs-comment">//5.4、设置token有效期</span>    stringRedisTemplate.expire(tokenKey,LOGIN_USER_TTL,TimeUnit.MINUTES);    <span class="hljs-comment">//6. 将token返回</span>    <span class="hljs-keyword">return</span> Result.ok(token);&#125;<span class="hljs-keyword">private</span> User <span class="hljs-title function_">createUserWithPhone</span><span class="hljs-params">(String phone)</span> &#123;    <span class="hljs-comment">//1.创建用户</span>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();    user.setPhone(phone);    user.setNickName(USER_NICK_NAME_PREFIX+RandomUtil.randomString(<span class="hljs-number">8</span>));    <span class="hljs-comment">//2.保存用户</span>    save(user);    <span class="hljs-keyword">return</span> user;&#125;</code></pre></div><p>3、拦截器配置</p><p>token刷新拦截器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@RequiredArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefreshTokenInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, </span><span class="hljs-params">                             HttpServletResponse response, </span><span class="hljs-params">                             Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">//1.从请求头中获取token</span>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);        log.info(<span class="hljs-string">&quot;请求路径：&#123;&#125;，token:&#123;&#125;&quot;</span>,request.getRequestURL(),token);        <span class="hljs-keyword">if</span> (StrUtil.isBlank(token)) &#123;            <span class="hljs-comment">//token不存在，放行到登录拦截器</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-comment">//2.从Redis获取用户数据</span>        <span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;        Map&lt;Object, Object&gt; userMap = stringRedisTemplate            .opsForHash()            .entries(tokenKey);                <span class="hljs-keyword">if</span> (userMap.isEmpty()) &#123;            <span class="hljs-comment">//用户数据不存在，放行到登录拦截器</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-comment">//3.将查询到的Hash数据转化为UserDTO对象</span>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);        <span class="hljs-comment">//4.存在将用户信息保存到ThreadLocal中</span>        <span class="hljs-comment">//此处使用自定义的ThreadLocal工具类完成(创建ThreadLocal对象，添加UserDTO)</span>        UserHolder.saveUser(userDTO);        <span class="hljs-comment">//5.刷新token时间</span>        stringRedisTemplate.expire(tokenKey,LOGIN_USER_TTL, TimeUnit.MINUTES);        <span class="hljs-comment">//6.放行</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, </span><span class="hljs-params">                                HttpServletResponse response, </span><span class="hljs-params">                                Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">//移除用户</span>        UserHolder.removeUser();    &#125;&#125;</code></pre></div><p>登录拦截器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">//1. 判断是否需要拦截（ThreadLocal中是否有用户）</span>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//2. 没有，需要拦截</span>            response.setStatus(<span class="hljs-number">401</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">//3.有用户，放行</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;&#125;</code></pre></div><p>拦截器注册</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@RequiredArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LoginInterceptor loginInterceptor;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RefreshTokenInterceptor refreshTokenInterceptor;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;        <span class="hljs-comment">//添加登录拦截器</span>        registry.addInterceptor(loginInterceptor)                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)                .excludePathPatterns(                        <span class="hljs-string">&quot;/shop/**&quot;</span>,                        <span class="hljs-string">&quot;/voucher/**&quot;</span>,                        <span class="hljs-string">&quot;/shop-type/**&quot;</span>,                        <span class="hljs-string">&quot;/upload/**&quot;</span>,                        <span class="hljs-string">&quot;/blog/hot&quot;</span>,                        <span class="hljs-string">&quot;/user/code&quot;</span>,                        <span class="hljs-string">&quot;/user/login&quot;</span>                ).order(<span class="hljs-number">1</span>);                <span class="hljs-comment">//添加token刷新拦截器</span>        registry.addInterceptor(refreshTokenInterceptor)            .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)            .order(<span class="hljs-number">0</span>); <span class="hljs-comment">//先执行</span>    &#125;&#125;</code></pre></div><h2 id="二商户查询缓存">二、商户查询缓存</h2><blockquote><p>企业的缓存使用技巧，缓存穿透雪崩等问题的解决</p></blockquote><h3 id="缓存">2.1、缓存</h3><p>缓存就是数据交换的缓冲区（cache），是存贮数据的临时地方，一般<strong>读写性能较高</strong>。</p><p>缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低<strong>用户访问并发量带来的</strong>服务器读写压力，降低响应时间</p><p>实际开发中,会构筑<strong>多级缓存</strong>来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241212101231710-2024-12-1210:13:03.png"alt="image-20241212101231710" /><figcaption aria-hidden="true">image-20241212101231710</figcaption></figure><p>缓存的成本：</p><ul><li>数据一致性成本（需要保证缓存与数据库中数据的一致性）</li><li>代码维护成本</li><li>运维成本（为保证缓存高可用，需要搭建缓存集群，增加运维成本）</li></ul><h3 id="添加redis缓存">2.2、添加Redis缓存</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241212104712006-2024-12-1210:47:19.png"alt="image-20241212104712006" /><figcaption aria-hidden="true">image-20241212104712006</figcaption></figure><p>操作思路：查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis并将数据返回。</p><p>此处使用String类型存储店铺信息，key设计为“固定前缀+商铺id”的形式。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopById</span><span class="hljs-params">(Long id)</span> &#123;    <span class="hljs-comment">//1、从redis中根据id查询商铺</span>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;    <span class="hljs-type">String</span> <span class="hljs-variable">cachedShop</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);    <span class="hljs-comment">//2、判断是否存在记录</span>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(cachedShop)) &#123;        <span class="hljs-comment">//3、存在，返回数据     </span>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(cachedShop, Shop.class);        <span class="hljs-keyword">return</span> Result.ok(shop);    &#125;    <span class="hljs-comment">//4、不存在，查询数据库</span>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getById(id);    <span class="hljs-comment">//5、数据库是存在记录</span>    <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">//6、不存在，返回错误信息</span>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);    &#125;    <span class="hljs-comment">//7、存在，保存数据到redis，返回数据</span>    stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop));    <span class="hljs-keyword">return</span> Result.ok(shop);&#125;</code></pre></div><p>练习：给店铺类型查询业务添加缓存</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241212111434376-2024-12-1211:14:36.png"alt="image-20241212111434376" /><figcaption aria-hidden="true">image-20241212111434376</figcaption></figure><p>此处将店铺类型数据使用List类型存储到Redis中，key设计为<code>shop:type</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryTypeList</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//1、从Redis中查询商铺类型</span>    List&lt;String&gt; shopType = stringRedisTemplate        .opsForList()        .range(SHOP_TYPE, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);    <span class="hljs-comment">//2、是否存在记录</span>    <span class="hljs-keyword">if</span> (CollectionUtil.isNotEmpty(shopType)) &#123;        <span class="hljs-comment">//3、存在，返回数据</span>        List&lt;ShopType&gt; collect = shopType                .stream()                .map(str -&gt; JSONUtil.toBean(str,ShopType.class))                .collect(Collectors.toList());        <span class="hljs-keyword">return</span> Result.ok(collect);    &#125;    <span class="hljs-comment">//4、不存在，从数据库中查询</span>    List&lt;ShopType&gt; typeList = query().orderByAsc(<span class="hljs-string">&quot;sort&quot;</span>).list();    <span class="hljs-comment">//5、添加结果到Redis，返回数据</span>    <span class="hljs-comment">//List中的是String类型，进行类型转化</span>    List&lt;String&gt; shopTypeStr = typeList.stream()        .map(shopType1 -&gt; JSONUtil.toJsonStr(shopType1))        .collect(Collectors.toList());    stringRedisTemplate.opsForList().rightPushAll(SHOP_TYPE,shopTypeStr);    <span class="hljs-keyword">return</span> Result.ok(typeList);&#125;</code></pre></div><h3 id="缓存更新策略">2.3、缓存更新策略</h3><p><strong>缓存更新策略</strong>主要有三种更新策略：<strong>内存淘汰</strong>、<strong>超时剔除</strong>和<strong>主动更新</strong></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241212140122680-2024-12-1214:01:25.png"alt="image-20241212140122680" /><figcaption aria-hidden="true">image-20241212140122680</figcaption></figure><p>可以根据业务场景选择更新策略：</p><ul><li>低一致性需求：使用内存淘汰机制。如店铺类型的查询缓存</li><li>高一致性需求：主动更新，并以超时剔除为兜底方案。如店铺详情查询的缓存。</li></ul><p><strong>主动更新策略</strong>主要有三种：<code>Cache Aside</code>模式、<code>Read/Write Through</code>模式、<code>Write Behind Cahing</code>模式。</p><ul><li>CacheAside：由缓存调用者，在更新数据库的同时更新缓存。（代码复杂，但可人为控制）</li><li>Read/WriteThrough：缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题。（维护服务复杂，无现成服务）</li><li>Write BehindCaching：调用者只操作缓存，由其它线程异步的将缓存数据持久化到数据库，保证<strong>最终一致</strong>。（维护异步任务复杂，在异步进程修改数据库前，难以保证一致性若，服务器宕机，内存中的Redis数据将丢失）</li></ul><p>综合考虑，在企业中使用最多的策略是：<strong>CacheAside</strong>。由调用者自己更新缓存需要解决几个问题：</p><ol type="1"><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都要更新缓存，无效的写操作多。</li><li><u>删除缓存</u>：更新数据库时让缓存失效，查询时再更新缓存。</li></ul></li><li><p>如何保证缓存与数据库的操作的同时成功或失败？</p><ul><li>单体系统：将缓存和数据库操作放在一个事务中。</li><li>分布式系统：利用TCC等分布式事务方案（如：使用MQ通知其他服务进行数据同步）。</li></ul></li><li><p>先操作缓存还是先操作数据库（线程安全问题）？</p><p>先删除缓存，再操作数据库。在多线程下可能会出现如下情况，线程1删完缓存，准备更新数据库，此时线程2查询缓存，缓存未命中，查询数据库，并将查询结果写回缓存。<strong>由于数据库的写操作耗时较长</strong>，线程2从数据库中查询到的还是原来的旧数据的数据，写入缓存的也是旧数据。最终结果是数据库中的是新数据，而缓存中的是旧数据，造成数据的不一致。并且写数据库的耗时较长，<strong>很可能发生</strong>如下情况。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241212142243185-2024-12-1214:22:52.png" alt="image-20241212142243185" style="zoom:67%;" /></p><p><u>先操作数据库，再删除缓存</u>。此时可能出现线程安全的情况如下：在线程1查询缓存，若命中则返回数据，此时未命中，需要查询数据库，将数据v = 10写入缓存。线程2<strong>在线程1查询完数据库，将数据写入缓存期间</strong>到来，更新数据库v =20，再删除缓存（此时缓存啥也没有）,之后线程1才完成向缓存中写入查询结果 v= 10。此时数据库中的最新数据为v=20，但缓存中为v =10，发生数据不一致。但是写入Redis缓存的用时很短，不太可能在此期间完成更新数据库和删除缓存的可能，发生数据不一致的可能很小。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241212143501915-2024-12-1214:35:03.png" alt="image-20241212143501915" style="zoom:67%;" /></p></li></ol><p>综上可得缓存更新策略的最佳实践方案</p><p>1、低一致性需求：使用Redis自带的内存淘汰机制</p><p>2、高一致性需求：主动更新（CacheAside），并以超时剔除作为兜底方案</p><ul><li><p>读操作：</p><ul><li><p>缓存命中则直接返回</p></li><li><p>缓存未命中则查询数据库，并写入缓存，设定超时时间</p></li></ul></li><li><p>写操作：</p><ul><li>先写数据库，然后再删除缓存</li><li>要确保数据库与缓存操作的原子性</li></ul></li></ul><p>作业：给查询商铺的缓存添加超时剔除和主动更新的策略</p><p>MySQL查询到的数据写入Reids时添加过期时间</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//7、保存数据到redis，返回数据</span>stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop));<span class="hljs-comment">//设置店铺数据过期时间 CACHE_SHOP_TTL = 30L</span>stringRedisTemplate.expire(key,CACHE_SHOP_TTL, TimeUnit.MINUTES);</code></pre></div><p>在更新商铺信息时，先操作数据库再删除缓存，同时将这两个操作放在一个事务中执行。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">updateShop</span><span class="hljs-params">(Shop shop)</span> &#123;    <span class="hljs-comment">//1、验证数据有效性</span>    <span class="hljs-keyword">if</span> (shop.getId() == <span class="hljs-literal">null</span>)        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺ID不能为空&quot;</span>);    <span class="hljs-comment">//2、更新数据库</span>    updateById(shop);    <span class="hljs-comment">//3、删除店铺缓存</span>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + shop.getId();    stringRedisTemplate.delete(key);    <span class="hljs-keyword">return</span> Result.ok();&#125;</code></pre></div><h3 id="缓存穿透">2.4、缓存穿透</h3><p><strong>缓存穿透</strong>：指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见解决方案：</p><ol type="1"><li><p>缓存空值</p><p>当我们发现请求的数据即不存在于缓存，也不存于与数据库时，<strong>将空值缓存到Redis，并设置过期时间，</strong>避免频繁查询数据库。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240827092524186-2024-8-2709:25:33.png" alt="image-20240827092524186" style="zoom:80%;" /></p><p>优点：</p><p>• 实现简单，维护⽅便</p><p>缺点：</p><p>•额外的内存消耗，可能发生不一致问题（在TTL内真的有对应数据存入数据库中）</p></li><li><p>布隆过滤器</p><p>布隆过滤是⼀种数据统计的算法，<strong>⽤于检索⼀个元素是否存在⼀个集合中</strong>。</p><p>布隆过滤器基于<strong>bitmap</strong>实现（⼀个很⻓的bit数组），默认数组中每⼀位都是0。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240827092937090-2024-8-2709:29:37.png"alt="image-20240827092937090" /><figcaption aria-hidden="true">image-20240827092937090</figcaption></figure><p>然后还需要 <strong>K 个 hash函数</strong>，将元素基于这些hash函数做运算的结果映射到bit数组的不同位置，并将这些位置置为1。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240827093001045-2024-8-2709:30:01.png"alt="image-20240827093001045" /><figcaption aria-hidden="true">image-20240827093001045</figcaption></figure></li></ol><p>此时，我们要判断元素是否存在，只需要再次基于 K 个 hash 函数做运算，得到 K 个⻆标，判断每</p><p>个⻆标的位置是不是1。由于存在<strong>hash碰撞</strong>的可能性，这就会出现某个元素计算出的⻆标已经被其</p><p>元素置为1的情况。那么这个元素也会被误判为已经存在。<u>当 bit数组越大、 Hash 函数 K 越复</u></p><p><u>杂， K越大时，这个误判的概率也就越低。</u></p><p>因此，<strong>布隆过滤器的判断存在误差</strong>：</p><ul><li>当布隆过滤器认为元素不存在时，它<strong>肯定不存在</strong></li><li>当布隆过滤器认为元素存在时，它<strong>可能存在，也可能不存在</strong></li></ul><p>在缓存预热时，把数据库中的数据利用布隆过滤器标记出来，当用户发起请求时，先基于布隆过滤器判断。如果不存在则直接拒绝请求，如果存在则去查询缓存和数据库。尽管布隆过滤存在误差，但⼀般都在0.01%左右，可以⼤⼤减少数据库压⼒。</p><p>其他解决方案：</p><ul><li>增加参数的复杂度，设置为一定的复杂格式，进而对参数格式进行校验，拒绝非法参数</li><li>对热点参数进行限流</li><li>加强用户权限校验</li></ul><p>练习：解决商铺查询的缓存穿透问题。</p><p>采用缓存空值并添加过期时间的方式解决缓存穿透问题。原来查询到不存在的数据时，返回404。此时应修改为添加空值到redis，并且Redis中保存了空值，在下一次查询时需要判断获得的是否是空值。不是空值，则返回数据给前端；是空值，返回错误信息。具体流程如下</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241212154600399-2024-12-1215:46:02.png"alt="image-20241212154600399" /><figcaption aria-hidden="true">image-20241212154600399</figcaption></figure><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopById</span><span class="hljs-params">(Long id)</span> &#123;    <span class="hljs-comment">//1、从redis中根据id查询商铺</span>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;    <span class="hljs-type">String</span> <span class="hljs-variable">cachedShop</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);    <span class="hljs-comment">//2、判断是否存在记录</span>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(cachedShop)) &#123; <span class="hljs-comment">//isNotBlank有值时返回true，为空值或null时返回false</span>        <span class="hljs-comment">//存在，返回数据</span>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(cachedShop, Shop.class);        <span class="hljs-keyword">return</span> Result.ok(shop);    &#125;    <span class="hljs-comment">//3、判断记录是否为空值************************</span>    <span class="hljs-keyword">if</span> (cachedShop != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);    &#125;    <span class="hljs-comment">//4、查询数据库</span>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getById(id);    <span class="hljs-comment">//5、数据库是否存在记录</span>    <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">//6、不存在，将空值写入redis,并设置过期时间************************</span>       stringRedisTemplate.opsForValue().set(key,<span class="hljs-string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);    &#125;    <span class="hljs-comment">//7、存在，保存数据到redis，返回数据</span>    stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop));    <span class="hljs-comment">//设置店铺数据过期时间</span>    stringRedisTemplate.expire(key,CACHE_SHOP_TTL, TimeUnit.MINUTES);    <span class="hljs-keyword">return</span> Result.ok(shop);&#125;</code></pre></div><h3 id="缓存雪崩">2.5、缓存雪崩</h3><p><strong>缓存雪崩</strong>是指在同⼀时段<strong>⼤量的缓存key同时失效</strong>或者<strong>Redis服务宕机</strong>，导致⼤量请求到达数据库，带来巨⼤压⼒。与缓存击穿的区别：雪崩是很多key，击穿是某一个key缓存。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240827110108636-2024-8-2711:01:29.png" alt="image-20240827110108636" style="zoom:80%;" /></p><p>常⻅的解决⽅案有：</p><p>•由于设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效。因此给不同的Key在<strong>原本TTL的基础上添加随机值</strong>，这样KEY的过期时间不同，不会⼤量KEY同时过期</p><p>• 利⽤Redis集群提⾼服务的可⽤性，避免缓存服务宕机</p><p>• 给缓存业务添加降级限流策略（服务降级、快速失败等）</p><p>•给业务添加多级缓存，⽐如先查询本地缓存，本地缓存未命中再查询Redis，Redis未命中再查询数</p><p>​ 据库。</p><h3 id="缓存击穿">2.6、缓存击穿</h3><p><strong>缓存击穿问题</strong>也叫<strong>热点Key问题</strong>，就是⼀个被<strong>⾼并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效</p><p>了，⽆数的请求访问会在瞬间给数据库带来巨⼤的冲击。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241212162120403-2024-12-1216:21:57.png" alt="image-20241212162120403" style="zoom: 80%;" /></p><p>解决方案：</p><ul><li><p>互斥锁：给重建缓存逻辑加锁，避免多线程同时进行</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240827094838259-2024-8-2709:48:46.png" alt="image-20240827094838259" style="zoom:80%;" /></p></li></ul><p>当线程1发现缓存过期并尝试重建缓存时，首先获取互斥锁，再查询数据库并写入缓存，之后释放锁。在重建过程中，有其他线程也发现缓存过期并尝试重建时，会获取互斥锁失败，休眠一会再尝试查询缓存和获取锁的操作，直到查询到新的缓存数据时直接返回。</p><p>•逻辑过期：热点key不要设置过期时间，通过逻辑过期字段标识是否过期。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240827095123684-2024-8-2709:51:46.png" alt="image-20240827095123684" style="zoom:80%;" /></p><p>当一个线程发现缓存已经过期时，获取互斥锁进行缓存重建，与前一种方案不同的时，缓存重建时会创建新的线程去完成，重建完成后释放互斥锁，自己直接返回过期数据。在重建缓存过程中，有新线程发现缓存过期并尝试重建时，会获取锁失败，此时直接返回过期数据。</p><p><strong>对比：互斥锁能够保证数据的强一致性，但由于锁的存在会降低并发性能；逻辑过期的方式优先保障高可用，性能好，但存在数据不一致情况。</strong>根据项目的实际需要选择合适的解决方案</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241212162302115-2024-12-1216:23:03.png" alt="image-20241212162302115" style="zoom:80%;" /></p><h4id="利用互斥锁解决店铺详情查询的缓存击穿问题">利用互斥锁解决店铺详情查询的缓存击穿问题</h4><p>整体思路：相较于原来从缓存中查询不到数据后直接查询数据库而言，现在的方案是：</p><p>进行查询之后，如果从缓存没有查询到数据，则进行互斥锁的获取</p><ol type="1"><li><p>若获取成功，则<strong>再次检测redis缓存是否存在</strong>，做DoubleCheck，如果存在则无需重建缓存，如果不存在则查询数据库重建缓存。</p><blockquote><ol type="i"><li><p>对于第一次获取就得到互斥锁的线程而言，再次检测redis缓存，结果还是不存在，然后重建缓存。</p></li><li><p>对于上次获得锁失败的线程而言，本次获取锁成功，说明已经有线程完成缓存重建，再次查询缓存即可获得数据，不用再执行重建缓存操作。</p></li></ol></blockquote></li><li><p>若没有获取到互斥锁，则自旋等待一段时间后再次尝试获取锁，获取成功则回到1.</p></li></ol><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241212230730969-2024-12-1223:08:02.png"alt="image-20241212230730969" /><figcaption aria-hidden="true">image-20241212230730969</figcaption></figure><p>互斥锁的实现思路：</p><p>核心思想是利用redis的<strong>setnx</strong>方法来表示获取锁，该方法执行时，若没有指定的key则添加，并返回1（在stringRedisTemplate中返回true），若存在该key，则添加失败返回0（在stringRedisTemplate返回false），可以通过true，或者是false，来表示是否有线程成功插入key，成功插入的key的线程认为它就是获得到锁的线程。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopById</span><span class="hljs-params">(Long id)</span> &#123;    <span class="hljs-comment">//互斥锁解决缓存击穿</span>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> queryWithMutex(id);    <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> Result.ok(shop);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取互斥锁，利用 setnx设置互斥锁，并设置锁的过期时间</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span> &#123;    <span class="hljs-type">Boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()        .setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);    <span class="hljs-keyword">return</span> BooleanUtil.isTrue(isLock);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 释放互斥锁</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span> &#123;    stringRedisTemplate.delete(key);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 互斥锁解决缓存击穿问题 (在解决了缓存穿透的基础上)</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithMutex</span><span class="hljs-params">(Long id)</span> &#123;    <span class="hljs-comment">//1、从redis中根据id查询商铺</span>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;    <span class="hljs-type">String</span> <span class="hljs-variable">cachedShop</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);    <span class="hljs-comment">//2、判断是否存在记录</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">    StrUtil.isNotBlank</span><span class="hljs-comment">        形参为null false</span><span class="hljs-comment">        形参为&quot;&quot; false</span><span class="hljs-comment">        形参为&quot;\t\n&quot; false</span><span class="hljs-comment">        形参为&quot;abc&quot; true</span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(cachedShop)) &#123;        <span class="hljs-comment">//存在，返回数据</span>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(cachedShop, Shop.class);        <span class="hljs-keyword">return</span> shop;    &#125;    <span class="hljs-comment">//3、判断记录是否为空值</span>    <span class="hljs-keyword">if</span> (cachedShop != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">//4、redis 查询结果为null缓存失效，尝试重建缓存</span>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:shop:&quot;</span> + id;    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">//自旋等待，尝试获取互斥锁</span>        <span class="hljs-keyword">while</span>( !tryLock(lockKey)) &#123;            Thread.sleep(<span class="hljs-number">50</span>);        &#125;        <span class="hljs-comment">//4.2、获取锁成功,再次查询缓存</span>        <span class="hljs-type">String</span> <span class="hljs-variable">dcShop</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);        <span class="hljs-comment">//缓存有效，直接返回</span>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(dcShop)) &#123;            <span class="hljs-comment">//存在，返回数据</span>            <span class="hljs-keyword">return</span> JSONUtil.toBean(cachedShop, Shop.class);        &#125;        <span class="hljs-comment">//4.3、缓存无效，查询数据库重建缓存</span>        <span class="hljs-comment">//模拟缓存重建延时</span>        Thread.sleep(<span class="hljs-number">200</span>);                shop = getById(id);        <span class="hljs-comment">//数据库是否存在记录</span>        <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//不存在，将空值写入redis</span>            stringRedisTemplate.opsForValue()                .set(key,<span class="hljs-string">&quot;&quot;</span>,CACHE_NULL_TTL,TimeUnit.MINUTES);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-comment">//存在，保存数据到redis，返回数据</span>        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop));        <span class="hljs-comment">//设置店铺数据过期时间</span>        stringRedisTemplate.expire(key,CACHE_SHOP_TTL, TimeUnit.MINUTES);    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">//5、释放锁</span>        unlock(lockKey);    &#125;    <span class="hljs-comment">//返回数据</span>    <span class="hljs-keyword">return</span> shop;&#125;</code></pre></div><h4id="基于逻辑过期方式解决店铺详情查询的缓存击穿问题">基于逻辑过期方式解决店铺详情查询的缓存击穿问题</h4><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241212231031526-2024-12-1223:11:02.png"alt="image-20241212231031526" /><figcaption aria-hidden="true">image-20241212231031526</figcaption></figure><p>对于热点key会提前添加到Redis缓存，不设置过期时间，而是设置逻辑过期时间，再次进行查询缓存时，一定会命中的。若未命中，则说明不是热点key，直接返回空值即可。</p><p>整体思路：用户开始查询商铺，查询Redis判断是否命中，未命中直接返回空值即可。若命中，再通过逻辑过期时间判断数据是否过期，若未过期，直接返回Redis中的数据；若过期，则尝试获取互斥锁进行缓存重建。</p><ul><li><p>若互斥锁获取成功，再次检查Redis中的数据是否过期，做DoubleCheck。若未过期（已经有人重建完成），返回本次查询到的商铺数据；若仍过期（还没有人重建缓存），开启独立线程查询数据库进行缓存重建，自己返回过期数据。</p><blockquote><p>获取锁成功后是需要进行二次检查的，避免重复重建。如线程B来访问，得到的是过期数据，此时线程A完成缓存重建释放了锁，线程B就会获得锁成功，会再次进行重建。</p></blockquote></li><li><p>若获取互斥锁失败，返回过期数据即可。</p></li></ul><p>现在redis中存储的数据的value需要带上过期时间，故重建一个实体类，避免对原来代码的修改</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisData</span> &#123;    <span class="hljs-keyword">private</span> LocalDateTime expireTime;    <span class="hljs-keyword">private</span> Object data;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//创建拥有十个线程的线程池，用来重建缓存，避免经常创建销毁线程</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopById</span><span class="hljs-params">(Long id)</span> &#123;    <span class="hljs-comment">//逻辑过期解决缓存击穿</span>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> queryWithLogicalExpire(id);        <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> Result.ok(shop);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 进行缓存重建：将原始店铺信息封装上过期时间，存储到Redis中</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> expireSeconds</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InterruptedException</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveShop2Redis</span><span class="hljs-params">(Long id, Long expireSeconds)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;    <span class="hljs-comment">//模拟缓存重建延时</span>    Thread.sleep(<span class="hljs-number">200</span>);    <span class="hljs-comment">//1、获取店铺信息</span>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getById(id);    <span class="hljs-comment">//2、封装逻辑过期时间</span>    <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisData</span>();    redisData.setData(shop);    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));    <span class="hljs-comment">//3、存入redis</span>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;    stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(redisData));&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取互斥锁，利用 setnx设置互斥锁，并设置锁的过期时间</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span> &#123;    <span class="hljs-type">Boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);    <span class="hljs-keyword">return</span> BooleanUtil.isTrue(isLock);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 释放互斥锁</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span> &#123;    stringRedisTemplate.delete(key);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 利用逻辑过期解决缓存击穿</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">(Long id)</span> &#123;    <span class="hljs-comment">//1、从redis中根据id查询商铺</span>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> CACHE_SHOP_KEY + id;    <span class="hljs-type">String</span> <span class="hljs-variable">cacheDataJSON</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);    <span class="hljs-comment">//2、缓存未命中，返回空数据</span>    <span class="hljs-keyword">if</span> (StrUtil.isBlank(cacheDataJSON)) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">//3、缓存命中</span>    <span class="hljs-type">RedisData</span> <span class="hljs-variable">cacheData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(cacheDataJSON, RedisData.class);    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> cacheData.getExpireTime();    <span class="hljs-comment">//从RedisData中获取的Data，不是Shop类型，需要进行转化</span>    <span class="hljs-type">JSONObject</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (JSONObject) cacheData.getData();    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(data, Shop.class);    <span class="hljs-comment">//3.1、判断缓存是否过期</span>    <span class="hljs-keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;        <span class="hljs-comment">//3.2、缓存未过期，直接返回数据</span>        <span class="hljs-keyword">return</span> shop;    &#125;    <span class="hljs-comment">//4、缓存过期，需要进行缓存重建</span>    <span class="hljs-comment">//4.1、尝试获取互斥锁</span>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);    <span class="hljs-comment">//4.2、互斥锁获取成功</span>    <span class="hljs-keyword">if</span> (isLock) &#123;        <span class="hljs-comment">//4.3、再次检测redis缓存是否过期，做DoubleCheck</span>        <span class="hljs-type">String</span> <span class="hljs-variable">doubleCheckCacheStr</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);        <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(doubleCheckCacheStr, RedisData.class);        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">newExpireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();        <span class="hljs-type">Shop</span> <span class="hljs-variable">newShop</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);        <span class="hljs-comment">//4.3、缓存未过期（已经有线程重建完成了），则返回数据</span>        <span class="hljs-keyword">if</span> (newExpireTime.isAfter(LocalDateTime.now())) &#123;            <span class="hljs-keyword">return</span> newShop;        &#125;        <span class="hljs-comment">//4.4 缓存仍过期 （还没有其他的线程重建缓存），创建独立线程，重建缓存</span>        <span class="hljs-comment">//将重建工作交给线程池完成</span>        CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//查询数据库，重建缓存</span>                saveShop2Redis(id,<span class="hljs-number">20L</span>);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-comment">//4.5释放锁</span>                unlock(lockKey);            &#125;        &#125;);    &#125;    <span class="hljs-comment">//5、返回过期的商铺信息</span>    <span class="hljs-keyword">return</span> shop;&#125;</code></pre></div><h3 id="缓存工具封装">2.7、缓存工具封装</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p><ul><li>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</li><li>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓</li></ul><p>存击穿问题</p><ul><li><p>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</p></li><li><p>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</p></li><li><p>方法5：根据指定的key查询缓存，并反序列化为指定类型，需要利用互斥锁解决缓存击穿问题</p></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hmdp.utils;<span class="hljs-keyword">import</span> cn.hutool.core.util.BooleanUtil;<span class="hljs-keyword">import</span> cn.hutool.core.util.StrUtil;<span class="hljs-keyword">import</span> cn.hutool.json.JSONObject;<span class="hljs-keyword">import</span> cn.hutool.json.JSONUtil;<span class="hljs-keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> java.time.LocalDateTime;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">import</span> java.util.function.Function;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> CacheClient</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>  缓存工具类</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> 猫爪在上</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/12/12 23:40</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheClient</span> &#123;    <span class="hljs-comment">//存入Reids中的空值的过期时间</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Long</span> <span class="hljs-variable">CACHE_NULL_TTL</span> <span class="hljs-operator">=</span> <span class="hljs-number">2L</span>;    <span class="hljs-comment">//存入Reids中的空值的过期时间的时间类型</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">TimeUnit</span> <span class="hljs-variable">CACHE_NULL_TIME_UNIT</span> <span class="hljs-operator">=</span> TimeUnit.MINUTES;    <span class="hljs-comment">//互斥锁对应的key</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOCK_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;    <span class="hljs-comment">//获取互斥锁失败后的等待时间（单位毫秒）</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Long</span> <span class="hljs-variable">SPIN_WAIT_MILLISECOND</span> <span class="hljs-operator">=</span> <span class="hljs-number">50L</span>;    <span class="hljs-comment">//使用构造函数注入StringRedisTemplate</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CacheClient</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;    &#125;    <span class="hljs-comment">//创建拥有十个线程的线程池，用来重建缓存，避免经常创建销毁线程</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key String类型的Key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 任意类型的对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time 过期时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeUnit  时间单位</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit timeUnit)</span> &#123;        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value),time,timeUnit);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key   String类型的Key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 任意类型的对象</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time 逻辑过期时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeUnit 时间单位</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWithLogicalExpire</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit timeUnit)</span> &#123;        <span class="hljs-comment">//设置逻辑过期时间</span>        <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisData</span>();        redisData.setData(value);        redisData.setExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(time)));        <span class="hljs-comment">//写入Redis</span>        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(redisData));    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> keyPrefix key的前缀</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id  id</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type  需要返回的对象的Class类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dbFallback  根据id进行数据库查询的函数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  过期时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeUnit 时间单位</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;R&gt; 需要返回的对象类型的泛型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;ID&gt; id的泛型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> &lt;R,ID&gt; R <span class="hljs-title function_">queryWithPassThrough</span><span class="hljs-params">(String keyPrefix,</span><span class="hljs-params">                                         ID id,</span><span class="hljs-params">                                         Class&lt;R&gt; type,</span><span class="hljs-params">                                         Function&lt;ID,R&gt; dbFallback,</span><span class="hljs-params">                                         Long time,</span><span class="hljs-params">                                         TimeUnit timeUnit)</span> &#123;        <span class="hljs-comment">//1、从redis中根据id查询商铺</span>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);        <span class="hljs-comment">//2、判断是否存在记录</span>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(json)) &#123;            <span class="hljs-comment">//存在，返回数据</span>            <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, type);            <span class="hljs-keyword">return</span> r;        &#125;        <span class="hljs-comment">//3、判断记录是否为空值</span>        <span class="hljs-keyword">if</span> (json != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-comment">//4、查询数据库</span>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dbFallback.apply(id);        <span class="hljs-comment">//5、数据库是否存在记录</span>        <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//6、不存在，将空值写入redis</span>            stringRedisTemplate.opsForValue().set(key,<span class="hljs-string">&quot;&quot;</span>,CACHE_NULL_TTL,CACHE_NULL_TIME_UNIT);            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-comment">//7、存在，保存数据到redis，返回数据</span>        <span class="hljs-built_in">this</span>.set(key,r,time,timeUnit);        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> keyPrefix key的前缀</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id    id</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type  需要返回对象的Class类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dbFallback  根据id查询数据库</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  逻辑过期时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeUnit    时间单位</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;R&gt; 需要返回的对象类型的泛型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;ID&gt; id的泛型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> &lt;R,ID&gt; R <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">(String keyPrefix,</span><span class="hljs-params">                                           ID id,</span><span class="hljs-params">                                           Class&lt;R&gt; type,</span><span class="hljs-params">                                           Function&lt;ID,R&gt; dbFallback,</span><span class="hljs-params">                                           Long time,</span><span class="hljs-params">                                           TimeUnit timeUnit)</span> &#123;        <span class="hljs-comment">//1、从redis中根据id查询商铺</span>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);        <span class="hljs-comment">//2、缓存未命中，返回空数据</span>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(json)) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-comment">//3、缓存命中</span>        <span class="hljs-type">RedisData</span> <span class="hljs-variable">cacheData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, RedisData.class);        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> cacheData.getExpireTime();        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) cacheData.getData(), type);        <span class="hljs-comment">//3.1、判断缓存是否过期</span>        <span class="hljs-keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;            <span class="hljs-comment">//3.2、缓存未过期，直接返回数据</span>            <span class="hljs-keyword">return</span> r;        &#125;        <span class="hljs-comment">//4、缓存过期，需要进行缓存重建</span>        <span class="hljs-comment">//4.1、尝试获取互斥锁</span>        <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_KEY + id;        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);        <span class="hljs-comment">//4.2、互斥锁获取成功</span>        <span class="hljs-keyword">if</span> (isLock) &#123;            <span class="hljs-comment">//4.3、再次检测redis缓存是否过期，做DoubleCheck</span>            <span class="hljs-type">String</span> <span class="hljs-variable">doubleCheckCacheStr</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);            <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(doubleCheckCacheStr, RedisData.class);            <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">newExpireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();            <span class="hljs-type">R</span> <span class="hljs-variable">newR</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);            <span class="hljs-comment">//4.3、缓存未过期（已经有线程重建完成了），则返回数据</span>            <span class="hljs-keyword">if</span> (newExpireTime.isAfter(LocalDateTime.now())) &#123;                <span class="hljs-keyword">return</span> newR;            &#125;            <span class="hljs-comment">//4.4 缓存仍过期 （还没有其他的线程重建缓存），创建独立线程，重建缓存</span>            <span class="hljs-comment">//将重建工作交给线程池完成</span>            CACHE_REBUILD_EXECUTOR.submit(()-&gt;&#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//查询数据库</span>                    <span class="hljs-type">R</span> <span class="hljs-variable">dbR</span> <span class="hljs-operator">=</span> dbFallback.apply(id);                    <span class="hljs-comment">//重建缓存</span>                    <span class="hljs-built_in">this</span>.setWithLogicalExpire(key,dbR,time,timeUnit);                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);                &#125; <span class="hljs-keyword">finally</span> &#123;                    <span class="hljs-comment">//4.5释放锁</span>                    unlock(lockKey);                &#125;            &#125;);        &#125;        <span class="hljs-comment">//5、返回过期的商铺信息</span>        <span class="hljs-keyword">return</span> r;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据指定的key查询缓存，并反序列化为指定类型，利用互斥锁解决缓存击穿问题</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> keyPrefix key的前缀</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id    id</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type  需要返回对象的Class类型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dbFallback  根据id查询数据库</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time  过期时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeUnit    时间单位</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;R&gt; 需要返回的对象类型的泛型</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;ID&gt; id的泛型</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> &lt;R,ID&gt; R <span class="hljs-title function_">queryWithMutex</span><span class="hljs-params">(String keyPrefix,</span><span class="hljs-params">                                   ID id,</span><span class="hljs-params">                                   Class&lt;R&gt; type,</span><span class="hljs-params">                                   Function&lt;ID,R&gt; dbFallback,</span><span class="hljs-params">                                   Long time,</span><span class="hljs-params">                                   TimeUnit timeUnit)</span> &#123;        <span class="hljs-comment">//1、从redis中根据id查询商铺</span>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);        <span class="hljs-comment">//2、判断是否存在记录</span>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(json)) &#123;            <span class="hljs-comment">//存在，返回数据</span>            <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, type);            <span class="hljs-keyword">return</span> r;        &#125;        <span class="hljs-comment">//3、判断记录是否为空值</span>        <span class="hljs-keyword">if</span> (json != <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125;        <span class="hljs-comment">//4、redis 查询结果为null缓存失效，尝试重建缓存</span>        <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_KEY + id;        <span class="hljs-type">R</span> <span class="hljs-variable">dbR</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//自旋等待，尝试获取互斥锁</span>            <span class="hljs-keyword">while</span>( !tryLock(lockKey)) &#123;                Thread.sleep(SPIN_WAIT_MILLISECOND);            &#125;            <span class="hljs-comment">//4.2、获取锁成功,再次查询缓存</span>            <span class="hljs-type">String</span> <span class="hljs-variable">newJson</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(key);            <span class="hljs-comment">//缓存有效，直接返回</span>            <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(newJson)) &#123;                <span class="hljs-comment">//存在，返回数据</span>                <span class="hljs-keyword">return</span> JSONUtil.toBean(newJson, type);            &#125;            <span class="hljs-comment">//4.3、缓存无效，查询数据库重建缓存</span>            dbR = dbFallback.apply(id);            <span class="hljs-comment">//数据库是否存在记录</span>            <span class="hljs-keyword">if</span> (dbR == <span class="hljs-literal">null</span>) &#123;                <span class="hljs-comment">//不存在，将空值写入redis</span>                stringRedisTemplate.opsForValue().set(key,<span class="hljs-string">&quot;&quot;</span>,CACHE_NULL_TTL,CACHE_NULL_TIME_UNIT);                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;            &#125;            <span class="hljs-comment">//存在，保存数据到redis，返回数据</span>            <span class="hljs-built_in">this</span>.set(key,dbR,time,timeUnit);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//5、释放锁</span>            unlock(lockKey);        &#125;        <span class="hljs-comment">//返回数据</span>        <span class="hljs-keyword">return</span> dbR;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取互斥锁，利用 setnx设置互斥锁，并设置锁的过期时间</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span> &#123;        <span class="hljs-type">Boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);        <span class="hljs-keyword">return</span> BooleanUtil.isTrue(isLock);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 释放互斥锁</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span> &#123;        stringRedisTemplate.delete(key);    &#125;&#125;</code></pre></div><p>使用工具类优化解决之前店铺详情查询的缓存击穿和缓存穿透问题的代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopById</span><span class="hljs-params">(Long id)</span> &#123;        <span class="hljs-comment">//通过缓存空值，缓存穿透</span><span class="hljs-comment">//        Shop shop = cacheClient.queryWithPassThrough(CACHE_SHOP_KEY,</span><span class="hljs-comment">//                id, Shop.class,  this::getById, CACHE_SHOP_TTL,TimeUnit.MINUTES);</span>        <span class="hljs-comment">//互斥锁解决缓存击穿</span><span class="hljs-comment">//        Shop shop = cacheClient.queryWithMutex(CACHE_SHOP_KEY,id,Shop.class,</span><span class="hljs-comment">//                this::getById,CACHE_SHOP_TTL,TimeUnit.MINUTES);</span>        <span class="hljs-comment">//逻辑过期解决缓存击穿</span>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> cacheClient.queryWithLogicalExpire(CACHE_SHOP_KEY,id,Shop.class,                <span class="hljs-built_in">this</span>::getById,<span class="hljs-number">10L</span>,TimeUnit.SECONDS);        <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在&quot;</span>);        &#125;        <span class="hljs-keyword">return</span> Result.ok(shop);    &#125;</code></pre></div><h2 id="三优惠券秒杀">三、优惠券秒杀</h2><blockquote><p>Redis的计数器、Lua脚本Redis、分布式锁、Redis的三种消息队列</p></blockquote><h3 id="全局唯一id">3.1、全局唯一ID</h3><p>对于使用MySQL数据库的ID自增存在的问题：</p><ul><li><p>ID规律太过明显，可能泄露数据</p></li><li><p>受单表数据量的限制，数量过大后需要进行分库分表，但分表后各自的ID会从1开始递增，会出现ID重复的情况，无法保证同类数据ID的唯一性。</p></li></ul><p>全局ID生成器：是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足一下特性：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241213144741306-2024-12-1314:48:03.png" alt="image-20241213144741306" style="zoom:67%;" /></p><p>综合分析，使用Redis中<strong>String类型</strong>的数值自增，并且拼接一些其它信息保证ID的安全性，生成<code>long</code>类型的ID</p><p>ID的组成部分：</p><ul><li><p>符号位：1bit，为0</p></li><li><p>时间戳：31bit，以秒为单位，可以使用69年</p></li><li><p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p></li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241213145113498-2024-12-1314:51:14.png" alt="image-20241213145113498" style="zoom:80%;" /></p><p>对应的key设计为</p><p>代码实现：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@RequiredArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdWorker</span> &#123;    <span class="hljs-comment">//开始时间戳(2017.9.1 00:00:00)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_TIMESTAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1504224000L</span>;    <span class="hljs-comment">//序列号的位数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 生成全局唯一ID</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> keyPrefix 相关业务的ID前缀</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span> &#123;        <span class="hljs-comment">//1、生成时间戳</span>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();        <span class="hljs-type">long</span> <span class="hljs-variable">nowSeconds</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);        <span class="hljs-type">long</span> <span class="hljs-variable">timStamp</span> <span class="hljs-operator">=</span> nowSeconds - BEGIN_TIMESTAMP;        <span class="hljs-comment">//2、生成序列号</span>        <span class="hljs-comment">//2.1、获取当前日期，精确到天</span>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));        <span class="hljs-comment">//2.2、自增长</span>        <span class="hljs-comment">//对不存在的key做自增长时，在执行前会将其值设置为0</span>        <span class="hljs-type">Long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringRedisTemplate            .opsForValue()            .increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);        <span class="hljs-comment">//3、拼接返回</span>        <span class="hljs-keyword">return</span> timStamp &lt;&lt; COUNT_BITS | count;    &#125;&#125;</code></pre></div><p>测试：创建含有300个线程的线程池，每个线程使用Reids的id生成器生成100个id，统计用时。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">HmDianPingApplicationTests</span> &#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RedisIdWorker idWorker;    <span class="hljs-keyword">private</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">es</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">300</span>);    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testIdWorker</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">300</span>);        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;                <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> idWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);                System.out.println(<span class="hljs-string">&quot;id = &quot;</span> + id);            &#125;            latch.countDown();        &#125;;                <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">300</span>; i++) &#123;            es.submit(task);        &#125;        latch.await();        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        System.out.println(<span class="hljs-string">&quot;time = &quot;</span> + (end - begin));    &#125;&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241215101723975-2024-12-1510:17:38.png"alt="image-20241215101723975" /><figcaption aria-hidden="true">image-20241215101723975</figcaption></figure><blockquote><p>补充：关于countdownlatch</p><p><code>CountDownLatch</code> 是 Java 并发包<code>java.util.concurrent</code>中的一个同步辅助类，<strong>它允许一个或多个线程等待一系列指定操作的完成。</strong><code>CountDownLatch</code>通过一个计数器来实现，计数器的初始值表示需要等待的操作数量。每当一个操作完成时，计数器的值就会减一；当计数器的值达到零时，所有等待的线程都会被释放，继续执行。</p><p><code>CountDownLatch</code> 的关键方法和构造函数</p><ul><li>‌<strong>构造函数</strong>‌：<code>CountDownLatch(int count)</code>，其中<code>count</code> 是计数器的初始值。</li><li>‌<strong>主要方法</strong>‌<ul><li><code>void countDown()</code>：将计数器的值减一。如果计数器的值到达零，则所有等待的线程都会被释放。</li><li><code>void await()</code>：使当前线程等待，直到计数器的值到达零。</li><li><code>boolean await(long timeout, TimeUnit unit)</code>：与<code>await()</code>类似，但可以指定等待的超时时间。如果在指定的时间内计数器的值没有到达零，则当前线程继续执行。</li><li><code>long getCount()</code>：返回当前计数器的值。</li></ul></li></ul><p><code>CountDownLatch</code> 的使用场景</p><ol type="1"><li>‌<strong>等待多个线程完成某个操作</strong>‌：主线程可以启动多个工作线程来并行处理任务，并使用<code>CountDownLatch</code> 来等待所有工作线程完成。</li><li>‌<strong>协调多个线程的执行顺序</strong>‌：在某些情况下，你可能希望一组线程等待另一个线程或一组线程完成某个操作后再继续执行。</li></ol><p>如果没有CountDownLatch，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到CountDownLatch。</p></blockquote><h3 id="实现优惠券秒杀下单">3.2、实现优惠券秒杀下单</h3><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241215105950869-2024-12-1511:00:13.png"alt="image-20241215105950869" /><figcaption aria-hidden="true">image-20241215105950869</figcaption></figure><p>相关表的信息：</p><p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。</p><p>秒杀券属于优惠券，关联了优惠券的id。秒杀券除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段。新建秒杀券时，既要在优惠券表中添加记录并将type类型设置为1，并且要在秒杀券表中添加秒杀相关信息。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241215110440776-2024-12-1511:04:42.png"alt="image-20241215110440776" /><figcaption aria-hidden="true">image-20241215110440776</figcaption></figure><h4 id="添加优惠券">添加优惠券</h4><p><strong>VoucherController</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">*新增普通卷代码</span><span class="hljs-comment">*/</span><span class="hljs-meta">@PostMapping</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">addVoucher</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Voucher voucher)</span> &#123;    voucherService.save(voucher);    <span class="hljs-keyword">return</span> Result.ok(voucher.getId());&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">*新增秒杀券代码</span><span class="hljs-comment">*/</span><span class="hljs-meta">@PostMapping(&quot;seckill&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">addSeckillVoucher</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Voucher voucher)</span> &#123;    voucherService.addSeckillVoucher(voucher);    <span class="hljs-keyword">return</span> Result.ok(voucher.getId());&#125;</code></pre></div><p><strong>VoucherServiceImpl</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-meta">@Transactional</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSeckillVoucher</span><span class="hljs-params">(Voucher voucher)</span> &#123;    <span class="hljs-comment">// 保存优惠券</span>    save(voucher);    <span class="hljs-comment">// 保存秒杀信息</span>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeckillVoucher</span>();    seckillVoucher.setVoucherId(voucher.getId());    seckillVoucher.setStock(voucher.getStock());    seckillVoucher.setBeginTime(voucher.getBeginTime());    seckillVoucher.setEndTime(voucher.getEndTime());    seckillVoucherService.save(seckillVoucher);    <span class="hljs-comment">// 保存秒杀库存到Redis中</span>    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());&#125;</code></pre></div><p>添加秒杀券后，可在店铺详情页看到</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241215111327886-2024-12-1511:13:29.png"alt="image-20241215111327886" /><figcaption aria-hidden="true">image-20241215111327886</figcaption></figure><h4 id="秒杀券下单">秒杀券下单</h4><p>秒杀券下单时需要判断两点：</p><ul><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li><li>库存是否充足，不足则无法下单</li></ul><p>具体流程如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241215153900724-2024-12-1515:39:02.png" alt="image-20241215153900724" style="zoom:80%;" /></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-meta">@RequiredArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoucherOrderService</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SeckillVoucherServiceImpl seckillVoucherService;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RedisIdWorker redisIdWorker;        <span class="hljs-comment">/**</span><span class="hljs-comment">     *  秒杀券下单</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> voucherId 秒杀券id</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;        <span class="hljs-comment">//1、查询优惠券</span>        <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);        <span class="hljs-comment">//2、判断秒杀是否开始</span>        <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now()))&#123;            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀活动尚未开始&quot;</span>);        &#125;        <span class="hljs-comment">//3、判断秒杀是否结束</span>        <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀活动已经结束&quot;</span>);        &#125;        <span class="hljs-comment">//4、判断库存是否充足</span>        <span class="hljs-type">Integer</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> voucher.getStock();        <span class="hljs-keyword">if</span> (stock &lt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);        &#125;        <span class="hljs-comment">//5、扣减库存</span>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> seckillVoucherService.update()                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).update();        <span class="hljs-keyword">if</span> (!isSuccess) &#123;            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);        &#125;                <span class="hljs-comment">//6、创建订单</span>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();        <span class="hljs-comment">//6.1、设置订单id，使用Reids的id生成器</span>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;voucherOrder&quot;</span>);        voucherOrder.setId(orderId);        <span class="hljs-comment">//6.2、设置优惠券id</span>        voucherOrder.setVoucherId(voucherId);        <span class="hljs-comment">//6.3、设置用户id</span>        <span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();        voucherOrder.setUserId(userId);        save(voucherOrder);                <span class="hljs-comment">//7、返回订单id</span>        <span class="hljs-keyword">return</span> Result.ok(orderId);    &#125;&#125;</code></pre></div><h3 id="超卖问题">3.3、超卖问题</h3><h4 id="问题分析">问题分析</h4><p>使用Jmeter模拟多用户购买的情况，在JMeter中设置200个线程，秒杀券库存设置为100，并发进行秒杀券购买。若正确执行，会有100个线程购买失败，库存减为0，共生成100条秒杀券订单。执行结果如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241215161417918-2024-12-1516:14:37.png"alt="Jmeter执行结果" /><figcaption aria-hidden="true">Jmeter执行结果</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241215161527843-2024-12-1516:15:37.png"alt="优惠券订单表信息" /><figcaption aria-hidden="true">优惠券订单表信息</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241215161652806-2024-12-1516:17:37.png"alt="秒杀券信息" /><figcaption aria-hidden="true">秒杀券信息</figcaption></figure><p>错误分析：</p><p>​假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241215162417172-2024-12-1516:24:37.png" alt="多线程执行库存扣减出错情况" style="zoom:80%;" /></p><h4 id="乐观锁和悲观锁">乐观锁和悲观锁</h4><p>超卖问题是典型的<strong>多线程安全问题</strong>，针对这一问题的常见解决方案就是加锁：（<strong>悲观锁</strong>or <strong>乐观锁</strong>）</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241215162704888-2024-12-1516:27:24.png" alt="悲观锁和乐观锁" style="zoom:80%;" /></p><p>乐观锁的关键是判断之前查询得到的数据是否有被修改过，常见的方式有两种：</p><p>1、版本号法</p><p>给数据添加一个版本<code>version</code>字段，当数据修改时version加一，基于<code>version</code>字段判断有没有被修改过。</p><p><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241215164638341-2024-12-1516:46:39.png" /></p><p>2、CAS法</p><p>用<strong>数据本身是否发生变化</strong>判断线程是否安全</p><p><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241215165157862-2024-12-1516:51:58.png" /></p><h4 id="使用乐观锁解决超卖问题">使用乐观锁解决超卖问题</h4><p>修改扣减库存操作，在执行update语句时添加判断，判断当前库存与之前查询出来的库存是否相等，若相等，则说明没有人在中间修改过库存，那么此时就是安全的。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//5、扣减库存</span><span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> seckillVoucherService.update()        .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)        .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)        .eq(<span class="hljs-string">&quot;stock&quot;</span>,voucher.getStock()) <span class="hljs-comment">//where id = ? and stock = ?</span>        .update();</code></pre></div><p>将秒杀券库存重置为100，使用JMeter创建200个线程并发进行秒杀。结果如下，200个线程只有24个完成下单操作，以上这种方式通过测试发现会有很多失败的情况，失败的原因在于：在使用乐观锁过程中，假设100个线程同时都拿到了100的库存，然后大家一起去进行扣减，但是100个人中只有1个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241215171210639-2024-12-1517:12:11.png"alt="image-20241215171210639" /><figcaption aria-hidden="true">image-20241215171210639</figcaption></figure><p>乐观锁优化：执行update语句时，只需判断当前库存大于0即可。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//5、扣减库存</span><span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> seckillVoucherService.update()        .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)        .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)        .gt(<span class="hljs-string">&quot;stock&quot;</span>,<span class="hljs-number">0</span>) <span class="hljs-comment">//where id = ? and stock &gt; 0</span>        .update();</code></pre></div><p>再次使用JMeter进行测试，秒杀券库存成功减为零，优惠券订单新增100条</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241215182459350-2024-12-1518:25:01.png"alt="image-20241215182459350" /><figcaption aria-hidden="true">image-20241215182459350</figcaption></figure><h4 id="longadder">LongAdder</h4><p>针对CAS（Compare-And-Swap）操作中的自旋压力过大问题，<code>LongAdder</code>是一个有效的解决方案。在高并发环境下，多个线程可能会频繁地尝试更新同一个原子变量，导致大量的CAS自旋重试，这会消耗大量的CPU资源并降低性能。</p><p><code>LongAdder</code>通过其内部的设计，将热点数据分散到多个槽（Cell）中，每个槽都可以独立地进行CAS操作。这样，不同线程在更新计数时，会尽量分布到不同的槽上，从而减少了CAS冲突和自旋重试的次数。这种设计使得<code>LongAdder</code>在高并发场景下具有更好的性能表现。</p><p>具体来说，LongAdder的底层实现包括以下几个重要部分：</p><ul><li>‌<strong>base变量</strong>‌：类似于AtomicLong中的全局value值，在没有竞争的情况下，数据直接累加到base上‌25。</li><li>‌<strong>cells数组</strong>‌：当检测到有线程竞争时，LongAdder会尝试将数据累加到cells数组中的某个元素上。cells数组中的每个元素都是一个Cell对象，Cell对象内部存储了一个long类型的值，并且这个值是通过CAS操作进行更新的。这样，不同线程在更新计数时，会尽量分布到不同的Cell上，从而实现了热点的分散。</li><li><strong>分散热点的原理</strong>‌：LongAdder通过线程id获取probe值，然后利用probe值与cells数组的长度进行位与操作，找到所属cells的位置。这样，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，从而降低了冲突概率‌</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241215182944517-2024-12-1518:29:45.png"alt="image-20241215182944517" /><figcaption aria-hidden="true">image-20241215182944517</figcaption></figure><h3 id="一人一单">3.4、一人一单</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p><p>具体逻辑如下：首先查询优惠券，判断当前时间是否处于秒杀阶段，再进一步判断库存是否足够，然后再<strong>根据优惠卷id和用户id查询是否已经下过这个订单</strong>，如果下过这个订单，则不再下单，否则进行下单。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//5、一人一单：根据当前用户id和优惠券id判断是否已经下过单</span><span class="hljs-type">long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);&#125;<span class="hljs-comment">//6、扣减库存</span>...</code></pre></div><p>在JMeter多线程环境下测试，同样会出现线程安全的问题，多个线程第一次下单时，同时查询到当前不存在订单，然后各自去下单，还是会出现一个用户下了多个订单的情况。</p><p><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241215205025455-2024-12-1520:50:27.png" /></p><p>为了解决多线程安全问题，还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用<strong>悲观锁</strong>操作。</p><p>需要注意的问题：</p><h4 id="加锁的粒度">加锁的粒度</h4><p>​ 首先把从验证一人一单 到添加优惠券订单的逻辑抽取到一个方法<code>createVoucherOrder</code>中，在这个方法中进行查询订单、扣减库存并完成订单添加。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();    <span class="hljs-comment">// 5.1.查询订单</span>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();    <span class="hljs-comment">// 5.2.判断是否存在</span>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 用户已经购买过了</span>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);    &#125;    <span class="hljs-comment">// 6.扣减库存</span>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()            .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>) <span class="hljs-comment">// set stock = stock - 1</span>            .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// where id = ? and stock &gt; 0</span>            .update();    <span class="hljs-keyword">if</span> (!success) &#123;        <span class="hljs-comment">// 扣减失败</span>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);    &#125;    <span class="hljs-comment">// 7.创建订单</span>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();    <span class="hljs-comment">// 7.1.订单id</span>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);    voucherOrder.setId(orderId);    <span class="hljs-comment">// 7.2.用户id</span>    voucherOrder.setUserId(userId);    <span class="hljs-comment">// 7.3.代金券id</span>    voucherOrder.setVoucherId(voucherId);    save(voucherOrder);    <span class="hljs-comment">// 7.返回订单id</span>    <span class="hljs-keyword">return</span> Result.ok(orderId);&#125;</code></pre></div><p>如果在这个方法上加锁，在同一时刻只有一个线程可以执行该方法，每个线程对这个方法的访问变成了串行方式，性能降低。加锁的初衷是为了解决同一个用户的线程安全问题，而不同用户应该互不受影响。因此需要降低锁的粒度，同一个用户加一把锁，不同用户加不同的锁，故可以对<strong>用户的id</strong>加锁。</p><p>注意：<code>toString</code>方法底层是new一个String对象，即使是同一个用户的<code>userId</code>经过<code>toString</code>方法每次返回的都不是同一个对象，无法做到一个用户一把锁。因此需要使用String的<code>intern()</code>方法返回其在JVM常量池中的唯一实例，确保一个用户通过id获取到的是同一把锁。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><span class="hljs-keyword">public</span>  Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();    <span class="hljs-keyword">synchronized</span>(userId.toString().intern())&#123;        <span class="hljs-comment">// 5.1.查询订单</span>      ...        <span class="hljs-comment">// 5.2.判断是否存在</span>...        <span class="hljs-comment">// 6.扣减库存</span>...        <span class="hljs-comment">// 7.创建订单</span>      ...        <span class="hljs-comment">// 7.返回订单id</span>        <span class="hljs-keyword">return</span> Result.ok(orderId);            &#125; <span class="hljs-comment">//同步代码块结束</span>&#125; <span class="hljs-comment">//方法执行完，事务才会提交</span></code></pre></div><blockquote><p>补充：<code>intern()</code>方法是<code>String</code>类的一个方法，其设计初衷是为了优化内存使用和提升字符串操作的效率。在JDK1.8中，当你调用一个字符串的<code>intern()</code>方法时，Java会首先检查字符串常量池中是否已存在与该字符串内容相同的实例。如果存在，则返回该实例的引用；如果不存在，则将该字符串添加到常量池中，并返回这个实例引用。</p></blockquote><h4 id="事务生效">事务生效</h4><p>当前方法被spring的事务控制，只有方法结束才会进行事务提交。在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放的情况，此时同一个用户的其他线程再来下单时，会获取锁成功，可能导致重复下单。因此需要对整个方法的调用针对用户id加锁，保证事务提交后再释放锁。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;    <span class="hljs-comment">//1、查询优惠券</span>     ...    <span class="hljs-comment">//2、判断秒杀是否开始</span>     ...    <span class="hljs-comment">//3、判断秒杀是否结束</span>    ...    <span class="hljs-comment">//4、判断库存是否充足</span>    ...    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();    <span class="hljs-comment">//在函数调用处加锁，保证事务提交后再释放锁</span>    <span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;        <span class="hljs-keyword">return</span> createVoucherOrder(voucherId); <span class="hljs-comment">//其实是以 this.xxxx方方式调用</span>    &#125;&#125;<span class="hljs-meta">@Transactional</span><span class="hljs-keyword">public</span>  Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;    .....&#125; <span class="hljs-comment">//方法执行完，事务才会提交</span></code></pre></div><p>spring的事务功能是通过动态代理获得当前类的代理对象，用代理对象做事务处理。而此处直接调用<code>createVoucherOrder(xxx)</code>方法，实际上是以<code>this.createVoucherOrder(xxx)</code>方式调用的，而通过this得到的是非代理对象，不具备事务功能。</p><p>因此，此处需要获得当前接口的代理对象，通过代理对象来调用该方法。</p><p>首先将<code>createVoucherOrder(xxx)</code>方法添加为<code>IVoucherOrderService</code>接口的方法，之后才能基于接口的代理对象调用方法</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IVoucherOrderService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">IService</span>&lt;VoucherOrder&gt; &#123;    Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span>;<span class="hljs-comment">//在接口中添加方法</span>    Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span>;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;    <span class="hljs-comment">//1、查询优惠券</span>     ...    <span class="hljs-comment">//2、判断秒杀是否开始</span>     ...    <span class="hljs-comment">//3、判断秒杀是否结束</span>    ...    <span class="hljs-comment">//4、判断库存是否充足</span>    ...    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();    <span class="hljs-comment">//在函数调用处加锁，保证事务提交后再释放锁</span>    <span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;        <span class="hljs-comment">//获得当前接口的代理对象</span>        <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();        <span class="hljs-comment">//使用代理对象调用方法</span><span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);    &#125;&#125;<span class="hljs-meta">@Transactional</span><span class="hljs-keyword">public</span>  Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;    .....&#125; <span class="hljs-comment">//方法执行完，事务才会提交</span></code></pre></div><p>为了使代理对象生效还需要做两件事：</p><ul><li><p>添加必要依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.8.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>在启动类上添加注解，暴漏代理对象</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableAspectJAutoProxy(exposeProxy = true)</span></code></pre></div></li></ul><p>Jmeter200个线程测试结果：同一个用户只扣减了一次库存，订单表中只有一条记录。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241215222017340-2024-12-1522:20:19.png"alt="image-20241215222017340" /><figcaption aria-hidden="true">image-20241215222017340</figcaption></figure><blockquote><p>补充：</p><ol type="1"><li>‌<strong>接口代理（JDK动态代理）</strong>‌：若Spring采用的是JDK动态代理方式，那么<code>AopContext.currentProxy()</code>将返回一个实现了相关接口的代理类实例。此时，该代理对象的类型可以被视为接口类型（或者说，它至少实现了那些接口）。但值得注意的是，这个代理对象并非接口本身，而是一个实现了这些接口的代理类的新实例。</li><li>‌<strong>类代理（CGLIB代理）</strong>‌：若Spring选择使用CGLIB代理（通常是在无法采用接口代理，例如目标类没有实现任何接口时），<code>AopContext.currentProxy()</code>则会返回一个目标类的子类的代理实例。在这种情况下，代理对象的类型可以被看作是目标实现类的类型（或其子类型）。</li><li><code>@EnableAspectJAutoProxy(exposeProxy = true)</code>：在默认情况下，SpringAOP创建的<strong>代理对象并不直接暴露给被代理的Bean</strong>。然而，通过设置<code>exposeProxy = true</code>，我们可以让Spring在代理创建过程中将代理对象公开为Springbean，从而允许开发者在需要时直接访问代理对象。当<code>exposeProxy = true</code>时，开发者可以通过<code>AopContext.currentProxy()</code>方法在AOP切面中获取当前的代理对象。</li></ol></blockquote><h4 id="存在的问题">存在的问题</h4><p>通过加锁可以解决在<strong>单机</strong>情况下的一人一单安全问题，但是在<strong>集群模式</strong>下就不行了。</p><p>模拟集群环境：</p><figure><imgsrc="C:%5CUsers%5C86152%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241216201615254.png"alt="模拟集群环境" /><figcaption aria-hidden="true">模拟集群环境</figcaption></figure><p>启动两端口的服务，使用同一个用户下两次单，在锁内部打上断点，debug结果如下：同一个用户在不同端口的服务上都成功获取到了锁，都可以进行下单操作。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241216204659057-2024-12-1620:47:54.png"alt="同一用户在不同端口的服务上都成功获取到互斥锁" /><figcaptionaria-hidden="true">同一用户在不同端口的服务上都成功获取到互斥锁</figcaption></figure><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241216205036529-2024-12-1620:50:37.png" alt="数据库数据更改情况" style="zoom:80%;" /></p><p><code>synchronized</code>是基于JVM置锁实现的，具体通过<strong>内部对象Monitor</strong>（监视器锁）来实现。每个Java对象都有一个与之关联的Monitor。</p><ul><li>当一个线程想要访问某个对象的<code>synchronized</code>代码块时，首先需要获取该对象的Monitor。</li><li>如果Monitor已经被其他线程持有，则当前线程将会被阻塞，直至Monitor变为可用状态。</li><li>当线程完成<code>synchronized</code>块的代码执行后，它会释放Monitor，并把Monitor返还给对象池，这样其他线程才能获取Monitor并进入<code>synchronized</code>代码块。</li></ul><p>在一个JVM内部可以保证多个线程要获取的监视器对象是唯一的，是可以实现多线程互斥的。由于现在我们部署了多个tomcat，每个tomcat都有一个属于自己的jvm。在每个JVM内部都会有一个线程成功获取锁，发生线程安全问题。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241216205958398-2024-12-1621:00:33.png"alt="image-20241216205958398" /><figcaption aria-hidden="true">image-20241216205958398</figcaption></figure><h3 id="分布式锁">3.5、分布式锁</h3><p>分布式锁：满足分布式系统或集群模式下<strong>多进程可见</strong>并且<strong>互斥</strong>的锁。其核心思想是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，让程序串行执行。</p><p>分布式锁需满足的特性：</p><ul><li><p><strong>可见性</strong>：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</p></li><li><p><strong>互斥</strong>：互斥是分布式锁的最基本的条件，使得程序串行执行</p></li><li><p><strong>高可用</strong>：程序不易崩溃，时时刻刻都保证较高的可用性</p></li><li><p><strong>高性能</strong>：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</p></li><li><p><strong>安全性</strong>：安全也是程序中必不可少的一环</p></li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241216224912910-2024-12-1622:49:15.png" alt="image-20241216224912910" style="zoom:80%;" /></p><h4 id="分布式锁的实现方案">分布式锁的实现方案</h4><p>分布式锁的核心是实现多进程之间互斥，而满足这一点的方式有很多，常见的有三种：</p><ol type="1"><li>MySQL：MySQL本身就带有锁机制，可以搭建主从集群能够保证高可用，使用事务机制获得的锁，当出现异常连接断开时会锁自动释放，数据也会回滚。但是由于MySQL性能本身一般，所以采用分布式锁的情况下，其实使用MySQL作为分布式锁比较少见。</li><li><strong>Redis</strong>：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁。利用<code>setnx</code>命令实现互斥，如果有线程插入key成功，则表示获得到了锁，其他线程再插入时会失败，表示获得锁失败；释放锁时只需删除删除该key即可，为了在服务出现故障后仍能自动释放锁，需要在添加key的时候设置<strong>过期时间</strong>。</li><li>ZooKeeper：应用程序通过ZooKeeper客户端创建一个指定的持久节点作为锁的<strong>根节点</strong>。，节点在ZooKeeper服务器上会一直存在，直到手动删除。当应用程序想要获取锁时，它会在根节点下创建一个<strong>临时顺序节点</strong>，这个节点在ZooKeeper客户端会话结束时会自动删除。<strong>应用程序通过获取所有子节点，并根据节点的顺序进行排序。如果当前节点是所有子节点中最小的（即序号最小），则表示应用程序成功获取了锁。</strong>如果当前节点不是最小的，则应用程序监听前一个节点，等待前一个节点被删除。当前一个节点被删除后，应用程序重新尝试获取锁。当应用程序完成任务并需要释放锁时，它只需删除自己创建的临时顺序节点。如果其他客户端正在监听这个节点，它们会收到通知并重新尝试获取锁。</li></ol><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241216225412480-2024-12-1622:54:13.png"alt="image-20241216225412480" /><figcaption aria-hidden="true">image-20241216225412480</figcaption></figure><h4 id="利用redis实现分布式锁">利用Redis实现分布式锁</h4><p>基本流程：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241216233005105-2024-12-1623:30:06.png" alt="image-20241216233005105" style="zoom: 80%;" /></p><p>实现分布式锁时需要实现的两个基本方法：<strong>获取锁</strong>和<strong>释放锁</strong></p><p><strong>获取锁</strong></p><ul><li>互斥：确保只能有一个线程获取锁</li><li>非阻塞：尝试一次，成功返回true，失败返回false</li></ul><p>为了保证设置key和设置过期时间这两个操作的原子性，需要使用<code>set</code>在一个命令中完成设置</p><div class="code-wrapper"><pre><code class="hljs bash">//添加锁，NX是互斥，EX时是指过期时间SET lock thread1 NX EX 10</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241216232512456-2024-12-1623:25:14.png"alt="image-20241216232512456" /><figcaption aria-hidden="true">image-20241216232512456</figcaption></figure><p>此处的<code>key</code>和<code>value</code>该设置成什么？</p><p>key：<code>KEY_PREFIX + name</code>，key的前缀<code>KEY_PREFIX = "lock:"</code>，再根据当前的业务名称传入<code>name</code>，二者拼接起来作为key，让不同的业务获取不同的锁。</p><p>value：应设置成当前线程的<strong>唯一标识</strong>，防止因线程阻塞导致锁自动释放后再去执行释放锁操作，将别的线程锁设置的锁误删。此处的唯一标识设置为<strong>UUID+线程id</strong>的形式，当要主动释放锁时，先获取对应的value值，判断与自己的唯一标识是否相同，相同则删除该key释放锁，否则不用处理。</p><blockquote><p>当前线程的id不能作为线程的唯一标识。每个JVM实例都会为在其内部创建的每个线程分配一个唯一的标识符（通常是一个递增的长整型数字）。当有多个JVM实例运行时，每个JVM实例的线程标识符空间是独立的，所以不同JVM实例中的线程可能会有相同的标识符。</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241216234347762-2024-12-1623:43:49.png"alt="image-20241216234347762" /><figcaption aria-hidden="true">image-20241216234347762</figcaption></figure><p><strong>释放锁</strong></p><ul><li><p>超时释放：获取锁时添加一个超时时间</p></li><li><p>手动释放</p></li></ul><p>手动释放时先获取对应的value值，判断与自己的唯一标识是否相同，相同则删除该key释放锁，否则不用处理。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//获取线程唯一标识</span><span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> VALUE_PREFIX + Thread.currentThread().getId();<span class="hljs-comment">//获取锁中的标识</span><span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);<span class="hljs-comment">//判断标识是否一致</span><span class="hljs-keyword">if</span> (id.equals(threadId)) &#123;    <span class="hljs-comment">//一致，释放锁</span>    stringRedisTemplate.delete(KEY_PREFIX + name);&#125;</code></pre></div><p>由于<strong>判断标识是否一致</strong>和<strong>释放锁</strong>是两个操作，可能会在判断标识一致后发生线程阻塞并且阻塞时间过长导致锁自动释放，其他线程就会获取锁成功。而当阻塞完成时会直接去释放锁（之前已经判断过是一致的），此时就会释放其他线程的锁，从而可能引发线程安全问题。因此需要一种机制保证这两个Redis操作的原子性--- <strong>Redis的Lua脚本</strong></p><blockquote><p>‌<strong>JVM的垃圾回收机制在某些情况下会暂时阻塞所有线程</strong>‌，这一现象被称为“StoptheWorld”（STW）。在JVM中，垃圾回收器负责回收不再被引用的内存对象，并释放它们的内存空间。由于垃圾回收过程中需要扫描整个堆内存，并且为了保证数据一致性，需要暂停所有应用程序线程，这就是StoptheWorld现象发生的原因‌。在此期间，应用程序不能继续执行，所有线程都会被暂停，CPU时间片和系统资源都被垃圾回收器所占用。</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241217001630707-2024-12-1700:16:32.png"alt="image-20241217001630707" /><figcaption aria-hidden="true">image-20241217001630707</figcaption></figure><h5 id="redis调用lua脚本">Redis调用Lua脚本</h5><p>Lua 脚本在 Redis 中是一种非常强大的功能，它允许你将多个 Redis命令打包成一个原子操作来执行，这样可以确保数据的一致性和完整性。Lua是一种编程语言,<ahref="https://catpaws.top/29be09bb/#lua入门">基本语法参考</a></p><p>在 Lua 脚本中，你可以通过 <code>redis.call</code> 方法来调用任何Redis 命令。这个方法的第一个参数是 Redis命令的名字，随后的参数是这个命令所需要的任何参数。</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 执行Redis命令</span>redis.call(<span class="hljs-string">&quot;命令名称&quot;</span>,<span class="hljs-string">&quot;key&quot;</span>,<span class="hljs-string">&quot;其他参数&quot;</span>,....)</code></pre></div><p>例如：先执行set name Rose，再执行get name</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 先执行 set name Rose</span>redis.call(<span class="hljs-string">&quot;set&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;Rose&quot;</span>)<span class="hljs-comment">--再执行 get name</span><span class="hljs-keyword">local</span> name = redis.call(<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>)<span class="hljs-comment">--返回结果</span><span class="hljs-keyword">return</span>  name</code></pre></div><p>写好脚本以后，需要用Redis的<code>EVAL</code>命令来调用脚本。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241217003208606-2024-12-1700:32:09.png"alt="image-20241217003208606" /><figcaption aria-hidden="true">image-20241217003208606</figcaption></figure><p>例如：要执行 redis.call('set', 'name', 'jack') 这个脚本，语法如下</p><div class="code-wrapper"><pre><code class="hljs bash">EVAL <span class="hljs-string">&quot;return redis.call(&#x27;set&#x27;,&#x27;name&#x27;,&#x27;jcak&#x27;)&quot;</span> 0</code></pre></div><p>如果脚本中的key、value不想写死，可以作为参数传递。Redis中的参数分为两个：<strong>KEY类型参数</strong>和<strong>其他类型参数</strong>。通过numkeys指定KEY类型参数的个数，其后面的就是其他类型的参数。key类型参数会放入<strong>KEYS</strong>数组，其它参数会放入<strong>ARGV</strong>数组，在脚本中可以从KEYS和ARGV数组获取这些参数。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241217004126786-2024-12-1700:41:27.png"alt="image-20241217004126786" /><figcaption aria-hidden="true">image-20241217004126786</figcaption></figure><blockquote><p>注：Lua语言中数组的下标从1开始</p></blockquote><p>使用Lua脚本编写释放锁的逻辑：</p><ol type="1"><li>获取锁中的线程标示</li><li>判断是否与指定的标示（当前线程标示）</li><li>如果一致则释放锁（删除）</li><li>如果不一致则什么都不做</li></ol><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 获取锁中的线程标识</span><span class="hljs-keyword">local</span> id = reids.call(<span class="hljs-string">&#x27;get&#x27;</span>,KEYS[<span class="hljs-number">1</span>])<span class="hljs-comment">--判断线程标识与锁中标识是否一致</span><span class="hljs-keyword">if</span> (id == ARGV[<span class="hljs-number">1</span>]) <span class="hljs-keyword">then</span>    <span class="hljs-comment">-- 一致，释放锁</span><span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>,KEYS[<span class="hljs-number">1</span>])<span class="hljs-keyword">end</span><span class="hljs-comment">-- 不一致，返回结果</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span></code></pre></div><h5 id="java调用lua脚本">Java调用Lua脚本</h5><p>使用Lua脚本编写释放锁的逻辑：</p><ol type="1"><li>获取锁中的线程标示</li><li>判断是否与当前线程标示一致</li><li>如果一致则释放锁（删除）</li><li>如果不一致则什么都不做</li></ol><p>在Resource目录下新建Lua脚本文件 <strong>unlock.lua</strong></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241217005925509-2024-12-1700:59:27.png"alt="image-20241217005925509" /><figcaption aria-hidden="true">image-20241217005925509</figcaption></figure><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 获取锁中的线程标识</span><span class="hljs-keyword">local</span> id = reids.call(<span class="hljs-string">&#x27;get&#x27;</span>,KEYS[<span class="hljs-number">1</span>])<span class="hljs-comment">--判断线程标识与锁中标识是否一致</span><span class="hljs-keyword">if</span> (id == ARGV[<span class="hljs-number">1</span>]) <span class="hljs-keyword">then</span>    <span class="hljs-comment">-- 一致，释放锁</span><span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>,KEYS[<span class="hljs-number">1</span>])<span class="hljs-keyword">end</span><span class="hljs-comment">-- 不一致，返回结果</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span></code></pre></div><p>RedisTemplate调用Lua脚本的API如下：</p><p>其中，将KEY类型参数放在了一个List中，通过该List可以知道传入的KEY类型参数的个数，就不用原指令中的numkeys参数了。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241217005036808-2024-12-1700:50:38.png"alt="image-20241217005036808" /><figcaption aria-hidden="true">image-20241217005036808</figcaption></figure><p>​</p><p>调用Lua脚本完成释放锁的操作</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//将脚本的加载放在静态代码块中，在类加载时就会完成，省去了释放锁时加载脚本的IO时间</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<span class="hljs-keyword">static</span> &#123;    UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();    UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>));    UNLOCK_SCRIPT.setResultType(Long.class);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//调用lua脚本</span>    stringRedisTemplate.execute(            UNLOCK_SCRIPT,            Collections.singletonList(KEY_PREFIX + name),            VALUE_PREFIX + Thread.currentThread().getId()            );&#125;</code></pre></div><p>整体代码：</p><p><strong>锁的基本接口</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILock</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *尝试获取锁</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout 锁持有的超时时间，过期后自动释放</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true代表获取锁成功；false代表获取锁失败</span><span class="hljs-comment">     */</span>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 释放锁</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;&#125;</code></pre></div><p><strong>SimpleRedisLock</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span>&#123;    <span class="hljs-keyword">private</span> String name; <span class="hljs-comment">//业务相关名称</span>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">VALUE_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>)+<span class="hljs-string">&quot;-&quot;</span>;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;    <span class="hljs-keyword">static</span> &#123;        UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();        UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>));        UNLOCK_SCRIPT.setResultType(Long.class);    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate stringRedisTemplate)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> KEY_PREFIX + name;        <span class="hljs-comment">//获取线程唯一标识</span>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> VALUE_PREFIX + Thread.currentThread().getId();        <span class="hljs-comment">//尝试获取锁</span>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue()            .setIfAbsent(key, value, timeout, TimeUnit.SECONDS);        <span class="hljs-keyword">return</span> BooleanUtil.isTrue(isSuccess);    &#125;        <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//调用lua脚本</span>        stringRedisTemplate.execute(                UNLOCK_SCRIPT,                Collections.singletonList(KEY_PREFIX + name),                VALUE_PREFIX + Thread.currentThread().getId()                );    &#125;&#125;</code></pre></div><p><strong>VoucherOrderServiceImpl</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;    <span class="hljs-comment">//1、查询优惠券</span>     ...    <span class="hljs-comment">//2、判断秒杀是否开始</span>     ...    <span class="hljs-comment">//3、判断秒杀是否结束</span>    ...    <span class="hljs-comment">//4、判断库存是否充足</span>    ...         <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<span class="hljs-comment">//创建锁对象</span><span class="hljs-type">SimpleRedisLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRedisLock</span>(<span class="hljs-string">&quot;voucher-order&quot;</span> + userId, stringRedisTemplate);<span class="hljs-comment">//获取锁</span><span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">500</span>); <span class="hljs-comment">//设置过期时间为500ms</span><span class="hljs-keyword">if</span> (! isSuccess) &#123;    <span class="hljs-comment">//获取锁失败，返回错误信息</span>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单！&quot;</span>);&#125;    <span class="hljs-comment">//获取锁成功，执行业务，创建订单</span><span class="hljs-keyword">try</span> &#123;    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);&#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">//释放锁</span>    lock.unlock();&#125;&#125;<span class="hljs-meta">@Transactional</span><span class="hljs-keyword">public</span>  Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;    .....&#125; <span class="hljs-comment">//方法执行完，事务才会提交</span></code></pre></div><h4 id="redisson">Redisson</h4><p>基于setnx实现的分布式锁存在下面的问题：</p><ul><li><p><strong>重入问题</strong>：重入问题是指<strong>获得锁的线程可以再次进入到相同的锁的代码块中</strong>，可重入锁的意义在于防止死锁。例如，如果一个线程在方法A中获取了锁，并调用方法B，而方法B也需要获取同一把锁，那么由于锁不可重入，方法B将无法获取到锁，这可能导致死锁的情况‌。</p></li><li><p><strong>不可重试</strong>：获取锁只尝试一次，如果失败就立即返回false，没有重试机制。这可能导致在高并发场景下，线程获取锁的成功率降低‌。合理的情况是：当线程在获得锁失败后，它应该能再次尝试获得锁。</p></li><li><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，虽然这可以避免死锁，但如果业务执行时间较长，锁可能会在业务完成之前释放，从而引发安全隐患。</p></li><li><p><strong>主从一致性：</strong>在Redis的主从集群中，<strong>主从数据同步存在延迟</strong>。如果线程在主节点获取了锁，但尚未同步给从节点时主节点宕机，此时会选一个从节点作为新的主节点。由于这个从节点可能没有同步到锁的标识，其他线程可以获取到锁，导致多个线程同时持有锁，出现安全问题‌。</p></li><li><p>锁的误删问题‌：已通过Lua脚本解决。在释放锁时，判断当前的锁中的线程唯一标识与自己的标识是否相同，相同时再释放，并且将这两个操作使用Lua脚本完成，保证操作的原子性。</p></li></ul><p>Redisson是一个高级的分布式协调Redis客户端，与Jedis、Lettuce等Redis客户端相比，Redisson的API更侧重于<strong>分布式开发</strong>，提供了多种分布式Java对象和服务，如<strong>分布式锁</strong>、分布式集合、分布式对象、分布式限流器等‌。</p><figure><imgsrc="C:%5CUsers%5C86152%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20241217170920486.png"alt="image-20241217170920486" /><figcaption aria-hidden="true">image-20241217170920486</figcaption></figure><p>参考文档：</p><p><a href="https://redisson.org/docs/">官方文档</a></p><p><ahref="https://blog.csdn.net/A_art_xiang/article/details/125525864">redisson使用全解（上篇）</a></p><p><ahref="https://blog.csdn.net/A_art_xiang/article/details/125536050">redisson使用全解（中篇）</a></p><p><ahref="https://blog.csdn.net/A_art_xiang/article/details/125538972">redisson使用全解（下篇）</a></p><h5 id="redisson快速入门">Redisson快速入门</h5><p>1、添加依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2、添加Redis配置信息类，读取Reids的配置信息（可选）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Data</span><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;spring.redis&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisProperties</span> &#123;    <span class="hljs-keyword">private</span> String host;    <span class="hljs-keyword">private</span> String port;    <span class="hljs-keyword">private</span> String password;&#125;</code></pre></div><p>3、配置Redisson客户端</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> RedisProperties redisProperties;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//配置</span>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>(); <span class="hljs-comment">//注意要引入Redisson的Config类型</span>        <span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;redis://&quot;</span> + redisProperties.getHost()+<span class="hljs-string">&quot;:&quot;</span>+ redisProperties.getPort();        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> redisProperties.getPassword();        config.useSingleServer().setAddress(address).setPassword(password);        <span class="hljs-comment">//创建RedissonClient对象</span>        <span class="hljs-keyword">return</span> Redisson.create(config);    &#125;&#125;</code></pre></div><p>4、测试</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><span class="hljs-keyword">private</span> RedissionClient redissonClient;<span class="hljs-meta">@Test</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">testRedisson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;    <span class="hljs-comment">//创建锁对象(可重入)，指定锁的名称</span>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;anyLock&quot;</span>);    <span class="hljs-comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,TimeUnit.SECONDS);    <span class="hljs-comment">//判断获取锁成功</span>    <span class="hljs-keyword">if</span>(isLock)&#123;        <span class="hljs-keyword">try</span>&#123;            System.out.println(<span class="hljs-string">&quot;执行业务&quot;</span>);                  &#125;<span class="hljs-keyword">finally</span>&#123;            <span class="hljs-comment">//释放锁</span>            lock.unlock();        &#125;            &#125; &#125;</code></pre></div><p>5、改造业务</p><p><strong>VoucherOrderServiceImpl</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;    <span class="hljs-comment">//1、查询优惠券</span>     ...    <span class="hljs-comment">//2、判断秒杀是否开始</span>     ...    <span class="hljs-comment">//3、判断秒杀是否结束</span>    ...    <span class="hljs-comment">//4、判断库存是否充足</span>    ...         <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();    <span class="hljs-comment">//使用Redisson的分布式锁</span>    <span class="hljs-comment">//创建锁对象</span>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);    <span class="hljs-comment">//尝试获取锁</span>    <span class="hljs-comment">//无参形式下：waitTime默认为-1，失败后不等待；leaseTime默认为30s</span>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<span class="hljs-keyword">if</span> (! isSuccess) &#123;    <span class="hljs-comment">//获取锁失败，返回错误信息</span>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单！&quot;</span>);&#125;    <span class="hljs-comment">//获取锁成功，执行业务，创建订单</span><span class="hljs-keyword">try</span> &#123;    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);&#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">//释放锁</span>    lock.unlock();&#125;&#125;<span class="hljs-meta">@Transactional</span><span class="hljs-keyword">public</span>  Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;    .....&#125; <span class="hljs-comment">//方法执行完，事务才会提交</span></code></pre></div><p>6、JMeter测试用100个线程给同一个用户下单</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241217181414151-2024-12-1718:14:17.png"alt="image-20241217181414151" /><figcaption aria-hidden="true">image-20241217181414151</figcaption></figure><h5 id="redisson可重入锁原理">Redisson可重入锁原理</h5><p>核心：<strong>利用Hash结构记录线程ID和重入次数‌，使用计数器维护锁状态</strong></p><p>Redisson在Redis中使用Hset命令和<strong>Hash数据结构</strong>来实现可重入锁。</p><p>当同一个线程第一次获取锁时，Redis会记录下这个线程的ID，并将锁的持有次数设置为1。如果这个线程再次请求锁（即可重入操作），Redisson会检测到当前持有锁的线程ID与当前线程相同，于是不会重新设置锁，而是简单地<strong>增加计数器</strong>，表示这个线程再次持有了锁‌。</p><p>同一线程可以多次获取同一个锁，且只有当所有锁释放操作都完成后，锁才会真正释放。Redisson通过维护一个<strong>计数器</strong>来实现这一特性。每次释放锁时，Redisson会减少计数器，<strong>只有当计数器减为0时，锁才会真正释放‌。</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241217195721010-2024-12-1719:57:23.png" alt="image-20241217195721010" style="zoom:80%;" /></p><p>获取锁的Lua脚本</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>];  <span class="hljs-comment">-- 锁的key</span><span class="hljs-keyword">local</span> threadId = ARGV[<span class="hljs-number">1</span>];  <span class="hljs-comment">-- 线程的唯一标识</span><span class="hljs-keyword">local</span> releaseTime = ARGV[<span class="hljs-number">2</span>]; <span class="hljs-comment">-- 锁的自动释放时间</span><span class="hljs-comment">-- 判断锁是否存在</span><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>,key) == <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>    <span class="hljs-comment">-- 锁不存在，获取锁</span>    redis.call(<span class="hljs-string">&#x27;hset&#x27;</span>, key, threadId, <span class="hljs-number">1</span>);    <span class="hljs-comment">--设置有效期</span>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, key, releaseTime);    <span class="hljs-comment">-- 返回结果</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">end</span><span class="hljs-comment">--锁已存在，判断锁是否是自己的</span><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>,key,threadId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span>    <span class="hljs-comment">--锁是自己的，重置过期时间，计数器加一</span>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>,key,threadId,<span class="hljs-number">1</span>);    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>,key,releaseTime);    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">end</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">-- 锁不是自己的，获取锁失败</span></code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241217203811863-2024-12-1720:38:17.png"alt="Redisson源码中获取锁的脚本" /><figcaption aria-hidden="true">Redisson源码中获取锁的脚本</figcaption></figure><p>释放锁的Lua脚本</p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>];  <span class="hljs-comment">-- 锁的key</span><span class="hljs-keyword">local</span> threadId = ARGV[<span class="hljs-number">1</span>];  <span class="hljs-comment">-- 线程的唯一标识</span><span class="hljs-keyword">local</span> releaseTime = ARGV[<span class="hljs-number">2</span>]; <span class="hljs-comment">-- 锁的自动释放时间</span><span class="hljs-comment">-- 判断锁是否是自己的</span><span class="hljs-keyword">if</span> (redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>,key,threadId) == <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>    <span class="hljs-comment">--锁不是自己的，直接返回</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<span class="hljs-keyword">end</span><span class="hljs-comment">-- 是自己的锁，则重入次数减一</span><span class="hljs-keyword">local</span> count = redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>,key,threadId,<span class="hljs-number">-1</span>);<span class="hljs-comment">-- 判断计数器是否已减为0</span><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>    <span class="hljs-comment">-- 计数器不为0，不能释放锁，重置锁有效期后返回</span>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>,key,releaseTime);    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<span class="hljs-keyword">else</span>    <span class="hljs-comment">-- 计数器减为零，释放锁</span>    redis.call(<span class="hljs-string">&#x27;del&#x27;</span>,key);    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<span class="hljs-keyword">end</span></code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241217204305605-2024-12-1720:43:17.png"alt="Redisson源码中释放锁的脚本" /><figcaption aria-hidden="true">Redisson源码中释放锁的脚本</figcaption></figure><h5 id="redisson锁重试和watchdog机制">Redisson锁重试和WatchDog机制</h5><p><strong>Redisson的锁重试机制</strong>‌：</p><p>当线程尝试获取锁失败时，Redisson会在指定的等待时间（waitTime）内不断尝试重新获取锁。这一过程中，Redisson会动态调整等待时间以提高获取锁的效率。如果最终仍然无法获取锁，则会返回失败‌。锁重试的实现依赖于<code>tryLock</code>方法，该方法会接受等待时间、超时时间和时间单位三个参数。在尝试获取锁的过程中，如果锁已被其他线程持有，则当前线程会进入一个自旋循环，不断尝试获取锁，直到超时或者成功获取锁为止‌。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/锁的重试机制-2024-12-1723:58:28.png" alt="锁的重试机制源码分析" style="zoom:25%;" /></p><p><strong>Redisson的WatchDog机制</strong>‌：</p><p>WatchDog机制，也称为看门狗机制，通过动态续约锁的过期时间，确保了分布式锁在持有者未主动释放之前不会被其他线程获取，从而有效防止了因锁超时而导致的数据一致性问题。</p><p>分布式锁通常带有一个过期时间(TTL)来防止因锁未释放而导致的死锁问题。然而，业务逻辑执行时间可能超过锁的默认过期时间，如果没有扩展锁的时间，锁会自动过期并释放，导致其他线程获得锁，进而引发数据一致性问题。WatchDog机制的作用就是<strong>动态续约锁的过期时间</strong>，确保锁在持有者未主动释放之前不会被其他线程获取‌。</p><p>若获取锁时<strong>没有指定锁的自动释放时间</strong>，<code>leaseTime</code>参数默认为-1，在异步获取锁时会将锁的自动释放时间设置为<code>WatchdogTimeout</code>，默认为30s。一旦锁被获取，Redisson会启动一个WatchDog定时任务。这个定时任务每隔一段时间（通常是10秒）会检查锁的状态，如果锁仍然有效，它会自动j将锁的持有时间再延长30秒。这样，即使业务逻辑执行时间超过了锁的初始过期时间，锁也不会被自动释放‌。</p><p>当客户端完成需要锁定的操作后，会手动释放锁，并删除定时任务。如果客户端在操作过程中发生异常或崩溃，WatchDog也会在锁的持有时间结束后自动释放锁，以避免死锁的发生‌。</p><h5 id="redisson锁的multilock原理">Redisson锁的MultiLock原理</h5><p>Redisson分布式锁主从一致性问题：</p><p>​Redisson分布式锁主从一致性问题主要是由于<strong>主从同步延迟导致的锁失效问题</strong>‌。当Java应用向Redis主节点发送获取锁的请求，主节点接收请求后存储锁信息，但在主从同步完成之前，如果主节点宕机，Redis的哨兵机制会选择一个新的从节点作为主节点。然而，这个新的主节点上并没有之前的锁信息，导致锁失效。这样，当新的线程发来请求时，又可以获取到锁，从而可能出现两个线程并发访问资源的情况‌。</p><p>​为了解决这个问题，Redisson提出了‌<strong>MultiLock</strong>‌锁（联锁）。MultiLock锁不使用主从关系，而是将每个Redis节点都视为独立的，都可以进行读写操作。在获取锁时，需要在所有的Redis服务器上都要获取锁，<strong>只有所有的服务器都写入成功，才算是加锁成功</strong>。这样，即使某个节点宕机，由于其他节点上仍然保留有锁的标识，因此新的线程无法在所有节点上都获取到锁，从而保证了锁的一致性和安全性‌。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241218100800973-2024-12-1810:08:27.png"alt="image-20241218100800973" /><figcaption aria-hidden="true">image-20241218100800973</figcaption></figure><p>源码分析：</p><p>将独立的多个锁组合成联锁：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/联锁的源码分析-2024-12-1811:26:23.jpg" alt="组成联锁" style="zoom:80%;" /></p><p>获取联锁：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/获取联锁的源码分析-2024-12-1811:26:34.png" alt="获取联锁的源码分析" style="zoom:50%;" /></p><h4 id="总结">总结</h4><p>以上通过Redis实现分布式锁的方案：</p><p><strong>不可重入Redis分布式锁</strong>：</p><ul><li>原理：利用setnx的互斥性；利用ex避免死锁；释放锁时判断线程标示</li><li>缺陷：不可重入、无法重试、锁超时失效</li></ul><p><strong>可重入的Redis分布式锁</strong>：</p><ul><li>原理：利用hash结构，记录线程标示和重入次数；利用watchDog延续锁时间；利用信号量控制锁重试等待</li><li>缺陷：redis宕机引起锁失效问题</li></ul><p><strong>Redisson的multiLock</strong>：</p><ul><li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li><li>缺陷：运维成本高、实现复杂</li></ul><h3 id="redis消息队列">3.6、Redis消息队列</h3><p>消息队列（MessageQueue，简称MQ）是一种应用间的通信方式，它允许消息发送者将消息发送到队列中，而消息接收者可以从队列中异步地接收消息。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241218203219010-2024-12-1820:32:55.png"alt="image-20241218203219010" /><figcaption aria-hidden="true">image-20241218203219010</figcaption></figure><p>Redis提供了三种不同的方式来实现消息队列：</p><ul><li>list结构：基于List结构模拟消息队列</li><li>PubSub：基本的点对点消息模型</li><li>Stream：比较完善的消息队列模型</li></ul><h4 id="基于list结构模拟消息队列">基于List结构模拟消息队列</h4><p>​ Redis的list数据结构是一个双向链表，很容易模拟出队列效果。可以利用LPUSH结合RPOP、或者RPUSH结合LPOP来实现。但是当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。<strong>因此这里应该使用<code>BRPOP</code>或者<code>BLPOP</code>来实现阻塞效果。</strong></p><p>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失，当取出消息执行时出现异常仍会导致数据丢失。</li><li>只支持单消费者，一个消费者取出消息后会将消息从队列中删除，其他消费者无法再获取到。</li></ul><h4 id="pubsub实现消息队列">PubSub实现消息队列</h4><p>‌Redis的PubSub（发布/订阅）是一种消息通信模式，它允许发送者（发布者）将消息发送到指定的<strong>频道</strong>，而接收者（订阅者）可以订阅这些频道以接收消息。订阅者可以订阅一个或多个频道。</p><p>Redis的PubSub模式的主要组件包括：</p><ul><li>‌<strong>发布者（Publisher）</strong>‌：产生并发布消息的实体，将消息发送到指定的频道‌。</li><li>‌<strong>订阅者（Subscriber）</strong>‌：接收并处理消息的实体，可以订阅一个或多个频道以接收消息‌。</li><li>‌<strong>频道（Channel）</strong>‌：发布者和订阅者之间的通信渠道，发布者将消息发送到频道，而订阅者从频道接收消息‌。</li></ul><p>相关命令：</p><ul><li><p>SUBSCRIBE channel[channel]：订阅一个或多个频道，<strong>阻塞式等待</strong>直至新消息到达</p></li><li><p>PUBLISH channel msg：向一个频道发送消息</p></li><li><p>PSUBSCRIBE pattern [pattern]：订阅与pattern格式匹配的所有频道</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241218205604310-2024-12-1820:56:23.png"alt="所支持的通配符示例" /><figcaption aria-hidden="true">所支持的通配符示例</figcaption></figure></li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241218205932568-2024-12-1820:59:35.png"alt="image-20241218205932568" /><figcaption aria-hidden="true">image-20241218205932568</figcaption></figure><p>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li><strong>不支持数据持久化</strong></li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失（消费者缓冲区大小有限，缓冲区满时新出现的消息会丢失）</li></ul><h4 id="stream实现消息队列">Stream实现消息队列</h4><p>Redis Stream 是 Redis 5.0版本新增加的<strong>数据结构</strong>，主要用于实现消息队列（MQ，MessageQueue）。与 Redis 之前的发布订阅（Pub/Sub）模式相比，Redis Stream提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据。</p><p><ahref="https://redis.io/docs/latest/commands/?group=stream">Stream数据结构的相关命令参考</a></p><p>Stream本身就是一种数据结构，其中保存的消息可以被持久化存储到磁盘上，确保数据不会丢失，即使在Redis 服务器重启后也能恢复消息。</p><p>Stream中的消息可以重复读取，消费者处理完消息后需要确认（ACK），确保消息不会丢失。未确认的消息会被记录在待处理消息列表（PendingEntry List, PEL）中，直到被确认或超时。</p><p>发消息的命令<code>XADD</code></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241218210630161-2024-12-1821:06:37.png"alt="image-20241218210630161" /><figcaption aria-hidden="true">image-20241218210630161</figcaption></figure><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">##创建名为users的队列，并向其中发送一个消息，内容是：&#123;name=jack，age=21&#125;，让Redis自动生成ID</span>127.0.0.1:6379&gt; XADD <span class="hljs-built_in">users</span> * name jack age 21<span class="hljs-string">&quot;1734527266902-0&quot;</span>    <span class="hljs-comment">#命令执行结果返回消息的id</span></code></pre></div><p>读取消息的命令</p><p><code>XREAD</code>：消费者可以选择阻塞读取模式，当没有新消息时，会等待指定时间再返回结果</p><p>当我们指定起始ID为<code>$</code>时，代表读取最新的消息，如果我们处理一条消息的过程中，又有<strong>超过1条以上</strong>的消息到达队列，则下次获取时也只能获取到最新的一条，会出现<strong><u>漏读消息</u></strong>的问题。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241218211301988-2024-12-1821:13:04.png"alt="image-20241218211301988" /><figcaption aria-hidden="true">image-20241218211301988</figcaption></figure><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; XREAD COUNT 1 STREAMS <span class="hljs-built_in">users</span> 01) 1) <span class="hljs-string">&quot;users&quot;</span>   2) 1) 1) <span class="hljs-string">&quot;1734527266902-0&quot;</span>         2) 1) <span class="hljs-string">&quot;name&quot;</span>            2) <span class="hljs-string">&quot;jack&quot;</span>            3) <span class="hljs-string">&quot;age&quot;</span>            4) <span class="hljs-string">&quot;21&quot;</span></code></pre></div><p><strong>Stream的多消费者模式</strong></p><p>Redis Stream 的<strong>消费者组</strong>（Consumer Group）是 Redis5.0引入的一种机制，<strong>将多个消费者划分到一个组中，监听同一个消息队列</strong>，实现<strong>多个消费者并行消费Stream 中的消息</strong>，从而实现消息的负载均衡。其具有以下特点：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241218213059980-2024-12-1821:31:02.png"alt="image-20241218213059980" /><figcaption aria-hidden="true">image-20241218213059980</figcaption></figure><p>1、创建消费者组：<code>XGROUP CREATE</code></p><div class="code-wrapper"><pre><code class="hljs bash">XGROUP CREATE key groupName ID [MKSTREAM]</code></pre></div><ul><li>key：消息队列名称</li><li>groupName：消费者组名称</li><li>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息</li><li>MKSTREAM：队列不存在时自动创建队列</li></ul><p>例：为消息队列 <code>users</code>创建消费者组 g1</p><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; XGROUP CREATE <span class="hljs-built_in">users</span> g1 0OK</code></pre></div><blockquote><p>消费者组中的消费者不用手动去创建。当指定消费者组中某个消费者监听消息时，若该消费者不存在，Reids会自动创建该消费者</p></blockquote><p>其他相关命令</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#删除指定的消费者组</span>XGROUP DESTORY key groupName<span class="hljs-comment">#给指定的消费者组添加消费者</span>XGROUP CREATECONSUMER key groupname consumername<span class="hljs-comment">#删除消费者组中的指定消费者</span>XGROUP DELCONSUMER key groupname consumername</code></pre></div><p>2、从消费者组读取消息 <code>XREADGROUP GROUP</code></p><div class="code-wrapper"><pre><code class="hljs bash">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds]  [NOACK] STREAMS key [key ...] <span class="hljs-built_in">id</span> [<span class="hljs-built_in">id</span> ...]</code></pre></div><ul><li>group：消费组名称</li><li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者者</li><li>count：本次查询的最大数量</li><li>BLOCK milliseconds：当没有消息时最长等待时间</li><li>NOACK：无需手动ACK，获取到消息后自动确认</li><li>STREAMS key：指定队列名称</li><li>ID：获取消息的起始ID<ul><li><code>&gt;</code>：从下一个未消费的消息开始 （正常情况使用<code>&gt;</code>）</li><li>其它：<u>根据指定id从<strong>pending-list</strong>中获取<strong>已消费但未确认</strong>的消息</u>，例如0，是从pending-list中的第一个消息开始。（消息处理出现异常时，每次ID使用<code>0</code>即可依次处理pending-list中的消息）</li></ul></li></ul><p>例：使用消费者组g1中的消费者c2阻塞式读取消息队列users中的最新两条信息，阻塞等待时间为2s</p><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; XREADGROUP GROUP g1 c2  COUNT 2  BLOCK 2000 STREAMS <span class="hljs-built_in">users</span> &gt;1) 1) <span class="hljs-string">&quot;users&quot;</span>   2) 1) 1) <span class="hljs-string">&quot;1734529962652-0&quot;</span>         2) 1) <span class="hljs-string">&quot;k1&quot;</span>            2) <span class="hljs-string">&quot;v1&quot;</span>      2) 1) <span class="hljs-string">&quot;1734529969264-0&quot;</span>         2) 1) <span class="hljs-string">&quot;k2&quot;</span>            2) <span class="hljs-string">&quot;v2&quot;</span></code></pre></div><p>3、确认消息 <code>XACK</code></p><div class="code-wrapper"><pre><code class="hljs bash">XACK key groupName <span class="hljs-built_in">id</span> [<span class="hljs-built_in">id</span> ...]</code></pre></div><p>例：确认使用消费者组g1从消息队列users中读取到id分别为<code>1734529962652-0</code>和<code>1734529969264-0</code>的两条消息</p><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; XACK <span class="hljs-built_in">users</span> g1 1734529962652-0 1734529969264-0(<span class="hljs-built_in">integer</span>) 2</code></pre></div><p>Redis三种消息队列对比：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241218220844769-2024-12-1822:08:47.png"alt="Redis三种消息队列" /><figcaption aria-hidden="true">Redis三种消息队列</figcaption></figure><h3 id="redis优化秒杀">3.7、Redis优化秒杀</h3><p>原来秒杀下单的流程如下，处理逻辑<strong>由单个线程串行执行</strong>，并且其中还包括对数据库的修改操作，耗时较长。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241218150543198-2024-12-1815:05:54.png"alt="image-20241218150543198" /><figcaption aria-hidden="true">image-20241218150543198</figcaption></figure><p>优化方案：</p><p>将耗时比较短的查询操作和逻辑判断放入到redis中，并通过Lua脚本保证其原子性。比如是否库存足够和是否一人一单。因此需要新增秒杀优惠券的同时，将优惠券信息保存到Redis中。</p><ul><li>判断库存是否充足，使用Redis中的String类型存储判断即可；</li><li>判断一人一单，可使用Redis的set数据结构判断，其值具有不重复的特点。key为优惠券的id，值为下过单的用户。用户再次下单时，对应优惠券的value中已经存在该用户，判断为重复下单。</li></ul><p>执行Lua脚本，根据返回结果判断用户是否能够下单，若用户不满足下单要求，则直接返回错误信息；若能够下单，则将下单操作放入阻塞队列交给其他异步线程完成，当前线程只需给用户返回订单id即可。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241218152900942-2024-12-1815:29:55.png"alt="异步秒杀流程" /><figcaption aria-hidden="true">异步秒杀流程</figcaption></figure><p>如果阻塞队列采用Java 的BlockingQueue能够做到持续监听队列中的订单信息，当有订单加入时能够及时取出完成下单操作。但该方法主要有一下两个缺陷：</p><ul><li><p>内存限制问题</p><p>该阻塞队列使用的是JVM的内存，在高并发环境下会出现内存溢出问题。</p></li><li><p>数据安全问题</p><p>该阻塞队列基于内存保存订单信息，若服务宕机或者将订单信息取出后执行时发生异常，会导致数据丢失。</p></li></ul><p>可以使用<strong>消息队列</strong>完成订单信息的发送和接收，通常会采用消息中间件完成，如RabbitMQ等。</p><p>消息队列允许系统中的组件进行异步消息传递，发送者不需要等待接收者处理完毕，即可继续执行其他任务，因此可以使用消息队列代替阻塞队列完成异步生成订单；消息队列是独立于JVM之外的，解决了内存限制问题；同时消息队列通过持久化、确认机制等方式，确保消息的可靠传输。防止消息在传递过程中丢失，从而保证系统的稳定性和数据的完整性‌。</p><p>此处使用Reids提供的消息队列功能完成异步下单。</p><p>创建一个Stream类型的消息队列，名为<code>stream.orders</code>，并为其添加消费者组<code>g1</code></p><div class="code-wrapper"><pre><code class="hljs bash">xgroup create stream.orders g1 0 MKSTREAM</code></pre></div><p>在Lua脚本中，判断库存是否充足和用户是否重复下单。确定用户有抢购资格后，扣减库存，添加用户购买记录，向消息队列stream.orders中添加订单消息，内容包含voucherId、userId、orderId</p><p>在<code>VoucherOrderServiceImpl</code>初始化完成后，开启一个线程任务，尝试获取stream.orders中的消息，完成下单并确认消息。</p><p>VoucherServiceImpl，添加秒杀券时将库存信息存入Redis</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-meta">@Transactional</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSeckillVoucher</span><span class="hljs-params">(Voucher voucher)</span> &#123;    <span class="hljs-comment">// 保存优惠券</span>    save(voucher);    <span class="hljs-comment">// 保存秒杀信息</span>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeckillVoucher</span>();    seckillVoucher.setVoucherId(voucher.getId());    seckillVoucher.setStock(voucher.getStock());    seckillVoucher.setBeginTime(voucher.getBeginTime());    seckillVoucher.setEndTime(voucher.getEndTime());    seckillVoucherService.save(seckillVoucher);        <span class="hljs-comment">// 保存秒杀库存到Redis中，并设置过期时间</span>    <span class="hljs-comment">//根据秒杀券的开始时间和结束时间获得秒杀券的TTL</span>    <span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">startZonedDateTime</span> <span class="hljs-operator">=</span> voucher.getBeginTime().atZone(ZoneOffset.UTC);    <span class="hljs-type">ZonedDateTime</span> <span class="hljs-variable">endZonedDateTime</span> <span class="hljs-operator">=</span> voucher.getEndTime().atZone(ZoneOffset.UTC);    <span class="hljs-type">Duration</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> Duration.between(startZonedDateTime, endZonedDateTime);    <span class="hljs-type">long</span> <span class="hljs-variable">seconds</span> <span class="hljs-operator">=</span> duration.getSeconds();        stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(),voucher.getStock().toString(),seconds, TimeUnit.SECONDS);&#125;</code></pre></div><p>Lua脚本 <code>seckill</code></p><div class="code-wrapper"><pre><code class="hljs lua"><span class="hljs-comment">-- 1.参数列表</span><span class="hljs-comment">-- 1.1.优惠券id</span><span class="hljs-keyword">local</span> voucherId = ARGV[<span class="hljs-number">1</span>]<span class="hljs-comment">-- 1.2.用户id</span><span class="hljs-keyword">local</span> userId = ARGV[<span class="hljs-number">2</span>]<span class="hljs-comment">-- 1.3.订单id</span><span class="hljs-keyword">local</span> orderId = ARGV[<span class="hljs-number">3</span>]<span class="hljs-comment">-- 2.数据key</span><span class="hljs-comment">-- 2.1.库存key（Lua中字符串拼接使用 ..）</span><span class="hljs-keyword">local</span> stockKey = <span class="hljs-string">&#x27;seckill:stock:&#x27;</span> .. voucherId<span class="hljs-comment">-- 2.2.订单key</span><span class="hljs-keyword">local</span> orderKey = <span class="hljs-string">&#x27;seckill:order:&#x27;</span> .. voucherId<span class="hljs-comment">-- 3.脚本业务</span><span class="hljs-comment">-- 3.1.判断库存是否充足 get stockKey</span><span class="hljs-keyword">if</span>(<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>    <span class="hljs-comment">-- 3.2.库存不足，返回1</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><span class="hljs-keyword">end</span><span class="hljs-comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span>    <span class="hljs-comment">-- 3.3.存在，说明是重复下单，返回2</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><span class="hljs-keyword">end</span><span class="hljs-comment">-- 3.4.扣库存 incrby stockKey -1</span>redis.call(<span class="hljs-string">&#x27;incrby&#x27;</span>, stockKey, <span class="hljs-number">-1</span>)<span class="hljs-comment">-- 3.5.下单（保存用户）sadd orderKey userId</span>redis.call(<span class="hljs-string">&#x27;sadd&#x27;</span>, orderKey, userId)<span class="hljs-comment">-- 3.6.发送消息到队列中， XADD stream.orders * k1 v1 k2 v2 ...</span>redis.call(<span class="hljs-string">&#x27;xadd&#x27;</span>, <span class="hljs-string">&#x27;stream.orders&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;userId&#x27;</span>, userId, <span class="hljs-string">&#x27;voucherId&#x27;</span>, voucherId, <span class="hljs-string">&#x27;id&#x27;</span>, orderId)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span></code></pre></div><p>VoucherOrderServiceImpl</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-meta">@RequiredArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IVoucherOrderService</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SeckillVoucherServiceImpl seckillVoucherService;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RedisIdWorker redisIdWorker;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RedissonClient redissonClient;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">SECKILL_ORDER_SERVICE</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">50</span>);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;    <span class="hljs-comment">//执行创建订单的动作是在子线程中进行的，获取不到当前主线程的代理类，需要将其设置为属性，以便在子线程中获取</span>    <span class="hljs-keyword">private</span> IVoucherOrderService proxy;    <span class="hljs-comment">//加载Lua脚本</span>    <span class="hljs-keyword">static</span> &#123;        SECKILL_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();        SECKILL_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;seckill.lua&quot;</span>));        SECKILL_SCRIPT.setResultType(Long.class);    &#125;    <span class="hljs-comment">//在类加载完成后，提交任务到线程池，执行其中的run方法</span>    <span class="hljs-meta">@PostConstruct</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;        SECKILL_ORDER_SERVICE.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrderHandler</span>());    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;        <span class="hljs-type">String</span> <span class="hljs-variable">queueName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;stream.orders&quot;</span>;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//1、获取消息队列中的订单信息</span>                    <span class="hljs-comment">// XREADGROUP GROUP g1 c2  COUNT 2  BLOCK 2000 STREAMS users &gt;</span>                    <span class="hljs-comment">//需要提前在redis中执行xgroup create stream.orders g1 0 MKSTREAM，创建消息队列和消费组</span>                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(                            Consumer.from(<span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>),                            StreamReadOptions.empty().count(<span class="hljs-number">1</span>).block(Duration.ofSeconds(<span class="hljs-number">2</span>)),                            StreamOffset.create(queueName, ReadOffset.lastConsumed())                    );                    <span class="hljs-comment">//2、判断消息是否获取成功</span>                    <span class="hljs-comment">//2.1、获取失败，即当前还没有新的订单要处理，继续进行下次循环</span>                    <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span> || list.isEmpty())&#123;                        <span class="hljs-keyword">continue</span>;                    &#125;                    <span class="hljs-comment">//2.2 获取成功，解析消息</span>                    MapRecord&lt;String, Object, Object&gt; entries = list.get(<span class="hljs-number">0</span>);                    Map&lt;Object, Object&gt; value = entries.getValue();                    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>(), <span class="hljs-literal">true</span>);                    <span class="hljs-comment">//2.3 下单</span>                    handleVoucherOrder(voucherOrder);                    <span class="hljs-comment">//3、ACK确认消息</span>                    stringRedisTemplate.opsForStream().acknowledge(queueName,<span class="hljs-string">&quot;g1&quot;</span>,entries.getId());                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    log.error(<span class="hljs-string">&quot;处理订单异常&quot;</span>, e);                    <span class="hljs-comment">//消息处理异常未确认会存入pending-list,处理pending-list中的消息</span>                    handlePendingList();                &#125;            &#125;        &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handlePendingList</span><span class="hljs-params">()</span> &#123;            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">//1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0</span>                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(                            Consumer.from(<span class="hljs-string">&quot;g1&quot;</span>, <span class="hljs-string">&quot;c1&quot;</span>),                            StreamReadOptions.empty().count(<span class="hljs-number">1</span>),                            StreamOffset.create(queueName, ReadOffset.from(<span class="hljs-string">&quot;0&quot;</span>))                    );                    <span class="hljs-comment">//2、判断消息是否获取成功</span>                    <span class="hljs-comment">//2.1 如果为null，说明pending-list中没有异常消息，结束循环</span>                    <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span> || list.isEmpty())&#123;                        <span class="hljs-keyword">break</span>;                    &#125;                    <span class="hljs-comment">//2.2 获取成功，解析消息</span>                    MapRecord&lt;String, Object, Object&gt; entries = list.get(<span class="hljs-number">0</span>);                    Map&lt;Object, Object&gt; value = entries.getValue();                    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(value, <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>(), <span class="hljs-literal">true</span>);                    <span class="hljs-comment">//2.3 下单</span>                    handleVoucherOrder(voucherOrder);                    <span class="hljs-comment">//3、ACK确认消息</span>                    stringRedisTemplate.opsForStream().acknowledge(queueName,<span class="hljs-string">&quot;g1&quot;</span>,entries.getId());                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    log.error(<span class="hljs-string">&quot;处理pending-list订单异常&quot;</span>, e);                &#125;            &#125;        &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleVoucherOrder</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;            <span class="hljs-comment">/**</span><span class="hljs-comment">             * 由于在redis中做了一人一单的判断，同一个用户的多个线程下单时在Lua脚本中会返回1，从而直接返回不能重复下单的提醒</span><span class="hljs-comment">             * 此处加锁是为了防止Redis中出错（尽管不太可能）后兜底</span><span class="hljs-comment">             */</span>            <span class="hljs-comment">//1.获取用户</span>            <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();            <span class="hljs-comment">//使用Redisson的分布式锁</span>            <span class="hljs-comment">// 2.创建锁对象</span>            <span class="hljs-type">RLock</span> <span class="hljs-variable">redisLock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);            <span class="hljs-comment">// 3.尝试获取锁</span>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> redisLock.tryLock();            <span class="hljs-comment">// 4.判断是否获得锁成功</span>            <span class="hljs-keyword">if</span> (!isLock) &#123;                <span class="hljs-comment">// 获取锁失败，直接返回失败或者重试</span>                log.error(<span class="hljs-string">&quot;不允许重复下单！&quot;</span>);                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//注意：由于是spring的事务是放在threadLocal中，此时的是多线程，事务会失效</span>                proxy.createVoucherOrder(voucherOrder);            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-comment">// 释放锁</span>                redisLock.unlock();            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *  秒杀券下单</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> voucherId 秒杀券id</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;        <span class="hljs-comment">//获取用户id</span>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();        <span class="hljs-comment">//生成订单id</span>        <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);        <span class="hljs-comment">//1、执行Lua脚本</span>        <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stringRedisTemplate.execute(                SECKILL_SCRIPT,                Collections.emptyList(),                voucherId.toString(),                userId.toString(),                String.valueOf(orderId)        );        <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> result.intValue();        <span class="hljs-comment">//2、判断结果Lua脚本返回值是否为0</span>        <span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> Result.fail(r == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;库存步骤&quot;</span>:<span class="hljs-string">&quot;不允许重复下单&quot;</span>);        &#125;        <span class="hljs-comment">//3、创建代理对象</span>        proxy =(IVoucherOrderService) AopContext.currentProxy();        <span class="hljs-comment">//4、返回订单id</span>        <span class="hljs-keyword">return</span> Result.ok(orderId);    &#125;    <span class="hljs-meta">@Transactional</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;        <span class="hljs-comment">//1、扣减库存</span>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()                .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>) <span class="hljs-comment">// set stock = stock - 1</span>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// where id = ? and stock &gt; 0</span>                .update();        <span class="hljs-keyword">if</span> (!success) &#123;            <span class="hljs-comment">// 扣减失败</span>            log.error(<span class="hljs-string">&quot;库存不足！&quot;</span>);        &#125;        <span class="hljs-comment">//2、保存订单</span>        save(voucherOrder);    &#125;&#125;</code></pre></div><h2 id="四达人探店">四、达人探店</h2><blockquote><p>基于List的点赞列表、基于SortedSet的点赞排行榜</p></blockquote><h3 id="发布探店笔记">4.1、发布探店笔记</h3><p>探店笔记类似点评网站的评价，往往是图文结合。对应的表有两个：</p><p>tb_blog：探店笔记表，包含笔记中的标题、文字、图片等tb_blog_comments：其他用户对探店笔记的评价</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241220094532686-2024-12-2009:45:33.png"alt="image-20241220094532686" /><figcaption aria-hidden="true">image-20241220094532686</figcaption></figure><p>具体的发布流程如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/1653578992639-2024-12-2009:46:08.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>上传图片接口<code>/upload/blog</code>，此处只是简单将文件保存到指定的本地目录<code>SystemConstants.IMAGE_UPLOAD_DIR</code>中，实际业务中都是上传到对象存储服务器上的。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;upload&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadController</span> &#123;    <span class="hljs-meta">@PostMapping(&quot;blog&quot;)</span>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">uploadImage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 获取原始文件名称</span>            <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> image.getOriginalFilename();            <span class="hljs-comment">// 生成新文件名</span>            <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> createNewFileName(originalFilename);            <span class="hljs-comment">// 保存文件</span>            image.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));            <span class="hljs-comment">// 返回结果</span>            log.debug(<span class="hljs-string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);            <span class="hljs-keyword">return</span> Result.ok(fileName);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;文件上传失败&quot;</span>, e);        &#125;    &#125;&#125;</code></pre></div><p>发布笔记接口<code>/blog</code>，其中Blog实体类对应的表中没有发布博客用户的姓名、用户头像以及用户是否点赞过了等字段，为了方便数据处理，在实体类中添加这三个属性，并使用<code>@TableField(exist = false)</code>修饰，表示该字段不属于当前实体类，需自己维护。</p><p>Blog实体类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@EqualsAndHashCode(callSuper = false)</span><span class="hljs-meta">@Accessors(chain = true)</span><span class="hljs-meta">@TableName(&quot;tb_blog&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 主键</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@TableId(value = &quot;id&quot;, type = IdType.AUTO)</span>    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 商户id</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Long shopId;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 用户id</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Long userId;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 用户图标  <span class="hljs-doctag">@TableField</span>(exist = false) 表示该字段不属于当前实体类，需自己维护</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@TableField(exist = false)</span>    <span class="hljs-keyword">private</span> String icon;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 用户姓名</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@TableField(exist = false)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 是否点赞过了</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@TableField(exist = false)</span>    <span class="hljs-keyword">private</span> Boolean isLike;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 标题</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String title;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 探店的照片，最多9张，多张以&quot;,&quot;隔开</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String images;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 探店的文字描述</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> String content;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 点赞数量</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Integer liked;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 评论数量</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> Integer comments;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建时间</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> LocalDateTime createTime;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 更新时间</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> LocalDateTime updateTime;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/blog&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogController</span> &#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> IBlogService blogService;    <span class="hljs-meta">@PostMapping</span>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">saveBlog</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Blog blog)</span> &#123;        <span class="hljs-comment">//获取登录用户</span>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();        blog.setUserId(user.getId());        <span class="hljs-comment">//保存探店博文</span>        blogService.saveBlog(blog);        <span class="hljs-comment">//返回id</span>        <span class="hljs-keyword">return</span> Result.ok(blog.getId());    &#125;&#125;</code></pre></div><h3 id="查看探店笔记">4.2、查看探店笔记</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/1653579931626-2024-12-2009:58:16.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>实现代码：</p><p>BlogController</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/blog&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogController</span> &#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> IBlogService blogService;        <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-type">long</span> id)</span> &#123;        <span class="hljs-keyword">return</span> blogService.queryBlogById(id);    &#125;&#125;</code></pre></div><p>BlogServiceImpl</p><div class="code-wrapper"><pre><code class="hljs java"> <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogById</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;     <span class="hljs-comment">//1、查询博客</span>     <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> getById(id);     <span class="hljs-comment">//2、查询博客相关用户</span>     queryBlogUser(blog);     <span class="hljs-keyword">return</span> Result.ok(blog); &#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryBlogUser</span><span class="hljs-params">(Blog blog)</span> &#123;    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> blog.getUserId();    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getById(userId);    blog.setName(user.getNickName());    blog.setIcon(user.getIcon());&#125;</code></pre></div><h3 id="点赞功能">4.3、点赞功能</h3><p>初始点赞功能实现代码如下，一个用户可以给一个博客点多次赞，不符合业务逻辑。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;    <span class="hljs-comment">//修改点赞数量</span>    blogService.update().setSql(<span class="hljs-string">&quot;liked = liked +1 &quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>,id).update();    <span class="hljs-keyword">return</span> Result.ok();&#125;</code></pre></div><p>需求：</p><ul><li>同一个用户只能点赞一次，再次点击则取消点赞</li><li>如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段Blog类的isLike属性）</li></ul><p>实现步骤：</p><ul><li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li><li>修改点赞功能，利用Redis的<strong>set集合</strong>判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1</li><li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li><li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li></ul><p>1、在Blog 添加一个字段</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@TableField(exist = false)</span><span class="hljs-keyword">private</span> Boolean isLike;</code></pre></div><p>2、修改代码</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>   <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span>&#123;       <span class="hljs-comment">// 1.获取登录用户</span>       <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();       <span class="hljs-comment">// 2.判断当前登录用户是否已经点赞</span>       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;       <span class="hljs-type">Boolean</span> <span class="hljs-variable">isMember</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForSet().isMember(key, userId.toString());       <span class="hljs-keyword">if</span>(BooleanUtil.isFalse(isMember))&#123;            <span class="hljs-comment">//3.如果未点赞，可以点赞</span>           <span class="hljs-comment">//3.1 数据库点赞数+1</span>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();           <span class="hljs-comment">//3.2 保存用户到Redis的set集合</span>           <span class="hljs-keyword">if</span>(isSuccess)&#123;               stringRedisTemplate.opsForSet().add(key,userId.toString());           &#125;       &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//4.如果已点赞，取消点赞</span>           <span class="hljs-comment">//4.1 数据库点赞数-1</span>           <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();           <span class="hljs-comment">//4.2 把用户从Redis的set集合移除</span>           <span class="hljs-keyword">if</span>(isSuccess)&#123;               stringRedisTemplate.opsForSet().remove(key,userId.toString());           &#125;       &#125;</code></pre></div><h3 id="点赞排行榜">4.4、点赞排行榜</h3><p>在探店笔记的详情页面，应该把给该笔记点赞的人显示出来，此处按照时间顺序显示最先点赞的五人。由于涉及到排序，因此可以<u>使用Redis的<code>SortedSet</code>集合，其中的score字段存储点赞时的<strong>时间戳</strong>，显示时按照时间戳从小到大排序，返回前五个。</u></p><p>也要将之前点赞功能中使用的<code>Set</code>换成<code>SortedSet</code>。由于SortedSet没有<code>isMember</code>方法，在判断用户是否点过赞时，可以使用<code>score</code>方法返回当前用户点赞时的时间戳，若没点过赞则返回null，以此来判断。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ServiceImpl</span>&lt;BlogMapper, Blog&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IBlogService</span> &#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> IUserService userService;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 对所有博客按照点赞数排序后分页返回数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> current</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryHotBlog</span><span class="hljs-params">(Integer current)</span> &#123;        <span class="hljs-comment">// 根据用户查询</span>        Page&lt;Blog&gt; page = query()                .orderByDesc(<span class="hljs-string">&quot;liked&quot;</span>)                .page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));        <span class="hljs-comment">// 获取当前页数据</span>        List&lt;Blog&gt; records = page.getRecords();        <span class="hljs-comment">// 查询用户</span>        records.forEach(blog -&gt;&#123;            queryBlogUser(blog);            queryBlogIsLiked(blog);        &#125;);        <span class="hljs-keyword">return</span> Result.ok(records);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 博客点赞</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id 博客id</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;        <span class="hljs-comment">//1、获取当前用户ID</span>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();        <span class="hljs-comment">//2、查询用户的点赞信息</span>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;        <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());        <span class="hljs-keyword">if</span> (score == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//3、若没点过赞</span>            <span class="hljs-comment">//3.1、博客点赞数加一</span>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();            <span class="hljs-keyword">if</span> (isSuccess) &#123;                <span class="hljs-comment">//3.2 将用户信息保存到Reids的set集合中</span>                stringRedisTemplate.opsForZSet().add(key,userId.toString(),System.currentTimeMillis());            &#125;        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//4、若点过赞了</span>            <span class="hljs-comment">//3.2、博客点赞数减一</span>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();            <span class="hljs-comment">//3.3 将用户从Reids的set集合中移除</span>            <span class="hljs-keyword">if</span> (isSuccess) &#123;                stringRedisTemplate.opsForZSet().remove(key,userId.toString());            &#125;        &#125;        <span class="hljs-keyword">return</span> Result.ok();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 返回当前博客已点赞的按时间先后的前五人</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;        <span class="hljs-comment">//1、返回top5</span>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;        Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);        <span class="hljs-keyword">if</span> (top5 == <span class="hljs-literal">null</span> || top5.isEmpty()) &#123;            <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());        &#125;        List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());        <span class="hljs-type">String</span> <span class="hljs-variable">idStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);        <span class="hljs-comment">//2、解析用户ID，查询用户信息</span>        List&lt;UserDTO&gt; userDTOList = userService.query()                .in(<span class="hljs-string">&quot;id&quot;</span>,ids).last(<span class="hljs-string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="hljs-string">&quot;)&quot;</span>).list()                .stream()                .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))                .collect(Collectors.toList());        <span class="hljs-comment">//3、封装用户信息并返回</span>        <span class="hljs-keyword">return</span> Result.ok(userDTOList);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogById</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;        <span class="hljs-comment">//1、查询博客</span>        <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> getById(id);        <span class="hljs-comment">//2、查询博客相关用户</span>        queryBlogUser(blog);        queryBlogIsLiked(blog);        <span class="hljs-keyword">return</span> Result.ok(blog);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询用户是否对某博客点过赞，设置isLiked字段</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> blog</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryBlogIsLiked</span><span class="hljs-params">(Blog blog)</span> &#123;        <span class="hljs-comment">//1、获取当前用户ID</span><span class="hljs-comment">//        Long userId = UserHolder.getUser().getId();</span>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-comment">//用户尚未登录</span>            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> user.getId();        <span class="hljs-comment">//2、查询用户的点赞信息</span>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + blog.getId();        <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());        <span class="hljs-comment">//设置isLike字段</span>        blog.setIsLike(score != <span class="hljs-literal">null</span>);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 设置博客中用户相关信息</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> blog</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryBlogUser</span><span class="hljs-params">(Blog blog)</span> &#123;        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> blog.getUserId();        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getById(userId);        blog.setName(user.getNickName());        blog.setIcon(user.getIcon());    &#125;&#125;</code></pre></div><h2 id="五好友关注">五、好友关注</h2><h3 id="关注和取关">5.1、关注和取关</h3><p>在探店图文的详情页面中，可以关注发布笔记的作者：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241220113107813-2024-12-2011:31:16.png"alt="image-20241220113107813" /><figcaption aria-hidden="true">image-20241220113107813</figcaption></figure><p>用户之间的关注是一个多对多关系，需要在数据库中新建一张表来记录</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241220113315168-2024-12-2011:33:16.png"alt="tb_follow" /><figcaption aria-hidden="true">tb_follow</figcaption></figure><p>基于该表数据结构，实现两个接口：</p><ul><li>关注和取关接口</li><li>判断是否关注的接口</li></ul><p>在用户执行关注操作时，将当前用户id和被关注用的id写入<code>tb_follow</code>，取关则删除该记录即可。</p><p>为了实现共同关注功能，即求两个用户所关注的交集，可以采用Reids的<strong>set集合</strong>存储各自关注用户的id，故在关注/取关进行数据库的新增/删除时同步在Reids的Set集合中做添加/删除操作。</p><p>FollowController</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/follow&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FollowController</span> &#123;    <span class="hljs-meta">@Resource</span>    <span class="hljs-keyword">private</span> IFollowService followService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 关注/取关</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> followUserId 要关注/取关的博主的id</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isFollow  true为关注，false为取关</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-type">long</span> followUserId, <span class="hljs-meta">@PathVariable(&quot;isFollow&quot;)</span> Boolean isFollow)</span> &#123;       <span class="hljs-keyword">return</span> followService.follow(followUserId,isFollow);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断是否关注了某人</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> followUserId </span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> <span class="hljs-type">long</span> followUserId)</span> &#123;        <span class="hljs-keyword">return</span> followService.isFollow(followUserId);    &#125;&#125;</code></pre></div><p>FollowServiceImpl</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(<span class="hljs-type">long</span> followUserId)</span> &#123;    <span class="hljs-comment">//1、获得当前用户id</span>    <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();    <span class="hljs-comment">//2、查询数据库 select count(*) from tb_follow where user_id = ? and follow_user_id = ?</span>    <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, id).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId).count();    <span class="hljs-keyword">return</span> Result.ok(count &gt; <span class="hljs-number">0</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(<span class="hljs-type">long</span> followUserId, Boolean isFollow)</span> &#123;    <span class="hljs-comment">//1、获得当前用户id</span>    <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();    <span class="hljs-comment">//2、判断是关注还是取关</span>    <span class="hljs-keyword">if</span> (isFollow) &#123;        <span class="hljs-comment">//关注，新增数据</span>        <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();        follow.setUserId(id);        follow.setFollowUserId(followUserId);        save(follow);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">//取关，删除数据 delete from tb_follow where user_id = ? and follow_user_id = ?</span>        remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;()                .eq(<span class="hljs-string">&quot;user_id&quot;</span>, id).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId));    &#125;    <span class="hljs-keyword">return</span> Result.ok();&#125;</code></pre></div><h3 id="共同关注">5.2、共同关注</h3><p>由于之前将每个用户关注的用户id存入Redis的set集合中，故可以使用Set的<code>SINTER</code>命令求两个的集合的交集，查询相关用户信息并返回即可。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/共同好友-2024-12-2015:19:16.png" alt="共同好友" style="zoom:67%;" /></p><p>FollowController</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取当前用户和指定用户的共同好友</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@GetMapping(&quot;/common/&#123;id&#125;&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">followCommons</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;    <span class="hljs-keyword">return</span> followService.followCommons(id);&#125;</code></pre></div><p>FollowServiceImpl</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">followCommons</span><span class="hljs-params">(Long id)</span> &#123;    <span class="hljs-comment">//1、获取当前用户id</span>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();    <span class="hljs-comment">//2、求交集</span>    <span class="hljs-type">String</span> <span class="hljs-variable">key1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + userId;    <span class="hljs-type">String</span> <span class="hljs-variable">key2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + id;    Set&lt;String&gt; commonUserSet = stringRedisTemplate.opsForSet().intersect(key1, key2);    <span class="hljs-keyword">if</span> (commonUserSet == <span class="hljs-literal">null</span> || commonUserSet.isEmpty()) &#123;        <span class="hljs-comment">// 无交集,五共同好友</span>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());    &#125;    <span class="hljs-comment">//4、解析id集合</span>    List&lt;Long&gt; idList = commonUserSet.stream()            .map(Long::valueOf)            .collect(Collectors.toList());    <span class="hljs-comment">//3、查询相关用户，返回结果</span>    List&lt;UserDTO&gt; users = userService.listByIds(idList).stream()            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))            .collect(Collectors.toList());    <span class="hljs-keyword">return</span> Result.ok(users);&#125;</code></pre></div><h3 id="关注推送">5.3、关注推送</h3><p>实现效果如下，在个人主页查看所关注用户发布的文章。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241220154737283-2024-12-2015:47:44.png" alt="image-20241220154737283" style="zoom:67%;" /></p><h4 id="feed流">Feed流</h4><p>关注推送也叫做<strong>Feed流</strong>，直译为投喂。为用户持续的提供“沉浸式”的体验，通过无限下拉刷新获取新的信息。</p><p>Feed流产品有两种常见模式：</p><ul><li><strong>Timeline</strong>：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。例如朋友圈<ul><li>优点：信息全面，不会有缺失。并且实现也相对简单</li><li>缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低</li></ul></li><li><strong>智能排序</strong>：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。推送用户感兴趣信息来吸引用<ul><li>优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷</li><li>缺点：如果算法不精准，可能起到反作用</li></ul></li></ul><p>本例中的个人页面，是基于关注的好友来做Feed流，因此采用<strong>Timeline</strong>的模式。该模式的实现方案有三种：<strong>拉模式</strong>、<strong>推模式</strong>、<strong>推拉结合</strong></p><ul><li><p>拉模式</p><p>拉模式也叫做读扩散。消息的发布者将消息发布到各自的发件箱，已关注者查看最新消息时从对应的发件箱拉取。</p><p>优点：节省内存空间，消息读完后可直接丢弃，需要时再次拉取。</p><p>缺点：延时较高，由于读取时都要重写拉取排序，写操作耗时较长。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241220154931662-2024-12-2015:49:32.png"alt="image-20241220154931662" /><figcaption aria-hidden="true">image-20241220154931662</figcaption></figure></li><li><p>推模式</p><p>推模式也叫做写扩散。消息发布者会将最新消息直接推送到所有粉丝的收件箱中。</p><p>优点：时效快，不用临时拉取</p><p>缺点：内存压力大。需要将消息写到每个粉丝的收件箱。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241220155249206-2024-12-2015:52:50.png"alt="image-20241220155249206" /><figcaption aria-hidden="true">image-20241220155249206</figcaption></figure></li><li><p>推拉结合</p><p>推拉结合模式：也叫做读写混合，兼具推和拉两种模式的优点。</p><p>这种方式需要根据活跃程度对用户进行划分。对于活跃粉丝，使用推模式直接将消息写到其收件箱中，保证频繁读取时的速度；对于普通粉丝，使用拉模式，将消息存储在发件箱中，用户主动查看时再进行拉取。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241220160134799-2024-12-2016:01:36.png"alt="image-20241220160134799" /><figcaption aria-hidden="true">image-20241220160134799</figcaption></figure></li></ul><p>三种方案对比之下，采用<u>推模式</u>实现本项目的消息推送。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241220160527989-2024-12-2016:05:29.png"alt="image-20241220160527989" /><figcaption aria-hidden="true">image-20241220160527989</figcaption></figure><h4 id="功能实现">功能实现</h4><p>需求：</p><ul><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱满足可以根据时间戳排序，必须用Redis的数据结构实现</li><li>查询收件箱数据时，可以实现分页查询</li></ul><p>由于博客内容已在MySQL中保存，只需将博客的id存入Reids。</p><p>Redis的<code>List</code>和<code>SortedSet</code>都具有排序的功能，但是要实现Feed流的分页查询只能使用<code>SortedSet</code>。</p><p>Feed流中的数据会不断更新，所以数据的角标也在变化，若使用<code>List</code>结果作为收件箱，当新消息到来，旧消息的角标会发生变化，出现重复读取消息的情况。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241220161718259-2024-12-2016:17:19.png"alt="image-20241220161718259" /><figcaption aria-hidden="true">image-20241220161718259</figcaption></figure><p>因此不能采用传统的分页模式，而要采用滚动分页模式。<strong>滚动分页查询</strong>‌：通过维护一个滚动上下文（ScrollContext）来记录当前读取的数据位置（最后一条消息的id），下一页读取时从指定id后继续读取即可。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241220162312526-2024-12-2016:23:14.png"alt="image-20241220162312526" /><figcaption aria-hidden="true">image-20241220162312526</figcaption></figure><p>综上应使用<code>SortedSet</code>结构作为收件箱，score值为博客文章发布时的时间戳，消息按时间戳排序，时间戳越大，表示当前消息越新。读取每一页时，使用<code>ZREVRANGEBYSCORE</code>命令，按score降序排序后，在指定的<code>score</code>范围内，读取count个元素，可以通过<code>offset</code>字段指定在该范围内读取的起始位置。对应的Redis命令如下：</p><div class="code-wrapper"><pre><code class="hljs bash">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241220191847306-2024-12-2019:18:48.png"alt="image-20241220191847306" /><figcaption aria-hidden="true">image-20241220191847306</figcaption></figure><p>其中</p><ul><li>max：第一次读取时设置为当前时间戳，之后为<strong>上一次查询的最小时间戳</strong></li><li>min：取0即可</li><li>offset：第一次读取设置为0，之后设置为<strong>与上次最小时间戳相等的元素个数</strong>（跳过重复数据）</li><li>count：一页包含的记录数</li></ul><p>此方案每次读取下一页都是从上次最后一条记录后读取，不受角标的影响。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241220222418873-2024-12-2022:24:56.png"alt="image-20241220222418873" /><figcaption aria-hidden="true">image-20241220222418873</figcaption></figure><p>代码实现：</p><p>1、修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</p><p>BlogServiceImpl</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">saveBlog</span><span class="hljs-params">(Blog blog)</span> &#123;    <span class="hljs-comment">//1、 获取登录用户</span>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();    blog.setUserId(user.getId());    <span class="hljs-comment">//2、 保存探店博文</span>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> save(blog);    <span class="hljs-keyword">if</span> (!isSuccess) &#123;        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;新增笔记失败！&quot;</span>);    &#125;    <span class="hljs-comment">//3、获取粉丝列表,follow_user_id 等于当前用户id的都是粉丝</span>    List&lt;Follow&gt; followList = followService.query().eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, user.getId()).list();    <span class="hljs-comment">//4、推送笔记id给所有粉丝</span>    <span class="hljs-keyword">for</span> (Follow follow : followList) &#123;        <span class="hljs-comment">//获取粉丝id</span>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> follow.getUserId();        <span class="hljs-comment">//保存到SortedSet key为 feed:用户id，value为博客id，score为当前时间戳</span>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> FEED_KEY + userId;        stringRedisTemplate.opsForZSet()                .add(key,blog.getId().toString(),System.currentTimeMillis());    &#125;    <span class="hljs-comment">// 5.返回id</span>    <span class="hljs-keyword">return</span> Result.ok(blog.getId());&#125;</code></pre></div><p>2、笔记分页查询结果的实体类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScrollResult</span> &#123;    <span class="hljs-keyword">private</span> List&lt;?&gt; list;    <span class="hljs-keyword">private</span> Long minTime;    <span class="hljs-keyword">private</span> Integer offset;&#125;</code></pre></div><p>4、新增分页查询笔记列表接口</p><p>BlogController</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 分页查询笔记</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> max</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> offset</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@GetMapping(&quot;/of/follow&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogOfFollow</span><span class="hljs-params">(</span><span class="hljs-params">        <span class="hljs-meta">@RequestParam(&quot;lastId&quot;)</span> Long max,</span><span class="hljs-params">        <span class="hljs-meta">@RequestParam(value = &quot;offset&quot;,defaultValue = &quot;0&quot;)</span> Integer offset</span><span class="hljs-params">)</span> &#123;    <span class="hljs-keyword">return</span> blogService.queryBlogOfFollow(max,offset);&#125;</code></pre></div><p>3、采用滚动式分页查询返回笔记列表</p><p>BlogServiceImpl</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogOfFollow</span><span class="hljs-params">(Long max, Integer offset)</span> &#123;    <span class="hljs-comment">//1、获取当前用户</span>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();    <span class="hljs-comment">//2、查询收件箱 ZREVRANGEBYSCORE key Max Min LIMIT offset count</span>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> FEED_KEY + userId;    <span class="hljs-comment">//TypeTuple对应Set集合的元素，其中保存着value和score</span>    Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate            .opsForZSet()            .reverseRangeByScoreWithScores(key, <span class="hljs-number">0</span>, max, offset, <span class="hljs-number">2</span>);    <span class="hljs-keyword">if</span> (typedTuples == <span class="hljs-literal">null</span> || typedTuples.isEmpty()) &#123;        <span class="hljs-keyword">return</span> Result.ok();    &#125;    <span class="hljs-comment">// 4.解析数据：blogId、minTime（时间戳）、offset</span>    List&lt;Long&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(typedTuples.size());    <span class="hljs-type">long</span> <span class="hljs-variable">minTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; tuple : typedTuples) &#123;        <span class="hljs-comment">// 4.1.获取id</span>        ids.add(Long.valueOf(tuple.getValue()));        <span class="hljs-comment">// 4.2.获取分数(时间戳）</span>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> tuple.getScore().longValue();        <span class="hljs-keyword">if</span>(time == minTime)&#123;            os++; <span class="hljs-comment">//score值与最小时间戳相同的元素个数，最后跳过这些重复元素</span>        &#125;<span class="hljs-keyword">else</span>&#123;            minTime = time;            os = <span class="hljs-number">1</span>;        &#125;    &#125;    os = minTime == max ? os : os + offset;    <span class="hljs-comment">//4、查询Blog</span>    <span class="hljs-type">String</span> <span class="hljs-variable">idStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);    List&lt;Blog&gt; blogList = query().in(<span class="hljs-string">&quot;id&quot;</span>, ids).last(<span class="hljs-string">&quot;ORDER BY FIELD(id,&quot;</span> + idStr + <span class="hljs-string">&quot;)&quot;</span>).list();    <span class="hljs-keyword">for</span> (Blog blog : blogList) &#123;        <span class="hljs-comment">// 4.1.查询blog有关的用户</span>        queryBlogUser(blog);        <span class="hljs-comment">// 4.2.查询blog是否被点赞</span>        queryBlogIsLiked(blog);    &#125;    <span class="hljs-comment">//5、封装数据并返回</span>    <span class="hljs-type">ScrollResult</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScrollResult</span>();    r.setList(blogList);    r.setOffset(os);    r.setMinTime(minTime);    <span class="hljs-keyword">return</span> Result.ok(r);&#125;</code></pre></div><h2 id="六附近的商户">六、附近的商户</h2><blockquote><p>Redis的GeoHash的应用</p></blockquote><h3 id="redis-geo">6.1、Redis GEO</h3><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，帮助我们根据经纬度来检索数据。常见的命令有：</p><ul><li><p><code>GEOADD</code>：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241222140220121-2024-12-2214:02:48.png"alt="GEOADD" /><figcaption aria-hidden="true">GEOADD</figcaption></figure></li><li><p><code>GEODIST</code>：计算指定的两个点之间的距离并返回</p></li><li><p><code>GEOHASH</code>：将指定member坐标转为hash字符串形式并返回</p></li><li><p><code>GEOPOS</code>：返回指定member的坐标</p></li><li><p><code>GEORADIUS</code>：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。6.2以后已废弃</p></li><li><p><code>GEOSEARCH</code>：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。6.2.新功能</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241222135219824-2024-12-2213:52:38.png"alt="GEOSEARCH" /><figcaption aria-hidden="true">GEOSEARCH</figcaption></figure></li><li><p><code>GEOSEARCHSTORE</code>：与GEOSEARCH功能一致，不过可以把结果存储到一个指定的key。6.2.新功能</p></li></ul><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#练习：</span><span class="hljs-comment"># 1.添加下面几条数据：</span><span class="hljs-comment">#北京站（116.42803 39.903738）</span><span class="hljs-comment">#北京南站（116.378248 39.865275）</span><span class="hljs-comment">#北京西站（116.322287 39.893729）</span><span class="hljs-comment">#2.计算北京西站到北京站的距离</span><span class="hljs-comment">#3，搜索天安门（116.397904 39.909005）附近10km内的所有火车站，并按照距离升序排序</span>127.0.0.1:6379&gt; GEOADD g1  116.42803 39.903738 bjz  116.378248 39.865275 bjn 116.322287 39.893729 bjx  (<span class="hljs-built_in">integer</span>) 3127.0.0.1:6379&gt; GEODIST g1 bjx bjz  <span class="hljs-comment">#距离默认以m为单位</span><span class="hljs-string">&quot;9091.5648&quot;</span>127.0.0.1:6379&gt; GEODIST g1 bjx bjz km  <span class="hljs-string">&quot;9.0916&quot;</span>127.0.0.1:6379&gt; GEOSEARCH g1 FROMLONLAT 116.397904 39.909005 BYRADIUS 10 km  ASC WITHDIST1) 1) <span class="hljs-string">&quot;bjz&quot;</span>   2) <span class="hljs-string">&quot;2.6361&quot;</span>2) 1) <span class="hljs-string">&quot;bjn&quot;</span>   2) <span class="hljs-string">&quot;5.1452&quot;</span>3) 1) <span class="hljs-string">&quot;bjx&quot;</span>   2) <span class="hljs-string">&quot;6.6723&quot;</span></code></pre></div><blockquote><p>GEO是用ZSet实现的，可以使用Zset的命令操作GEO</p></blockquote><h3 id="导入店铺数据到geo">6.2、导入店铺数据到GEO</h3><p>在首页中点击某个频道，即可看到频道下的商户：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241222135744125-2024-12-2213:58:07.png"alt="image-20241222135744125" /><figcaption aria-hidden="true">image-20241222135744125</figcaption></figure><p>由于要基于商户类型<code>typeId</code>展示对应商铺，所以可按照商户类型做分组，类型相同的商户作为同一组，以typeld为key存入同一个GEO集合中。GEO中存入的是每个店铺的经度、纬度，和<strong>店铺ID</strong>。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadShop2GEO</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//1、获取所有店铺</span>    List&lt;Shop&gt; shops = shopService.list();    <span class="hljs-comment">//2、根据typeID分组,typeId一致的放到一个集合</span>    Map&lt;Long, List&lt;Shop&gt;&gt; collect = shops.stream().collect(Collectors.    <span class="hljs-comment">//3、分批写入Redis</span>    <span class="hljs-keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : collect.entrySet()) &#123;        <span class="hljs-comment">//3.1 获取类型id</span>        <span class="hljs-type">Long</span> <span class="hljs-variable">typeId</span> <span class="hljs-operator">=</span> entry.getKey();        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;        <span class="hljs-comment">//3.2 获取对应店铺集合</span>        List&lt;Shop&gt; shopList = entry.getValue();        List&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; locations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Arr</span>        <span class="hljs-comment">//3.3将各个店铺的经纬度封装在一个GEOLocation中，一次完成所有写入</span>        <span class="hljs-keyword">for</span> (Shop shop : shopList) &#123;            locations.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisGeoCommands</span>.GeoLocation&lt;&gt;(                    shop.getId().toString(),                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(shop.getX(), shop.getY())            ));        &#125;        <span class="hljs-comment">//3.4、写入Redis  GEOADD key 经度 纬度 member</span>        stringRedisTemplate.opsForGeo().add(key ,locations);    &#125;&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241222142414209-2024-12-2214:25:03.png"alt="image-20241222142414209" /><figcaption aria-hidden="true">image-20241222142414209</figcaption></figure><h3 id="实现附近商户功能">6.3、实现附近商户功能</h3><p>接口和参数如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241222143610371-2024-12-2214:36:31.png"alt="image-20241222143610371" /><figcaption aria-hidden="true">image-20241222143610371</figcaption></figure><p>1、当前的SpringDataRedis的2.3.9版本并不支持Redis6.2提供的GEOSEARCH命令，因此我们需要提示其版本，修改自己的<code>POM.xml</code>文件</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lettuce-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.lettuce<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.data<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.lettuce<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lettuce-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2、ShopController</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据商铺类型分页查询商铺信息</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> typeId 商铺类型</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> current 页码</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 商铺列表</span><span class="hljs-comment"> */</span><span class="hljs-meta">@GetMapping(&quot;/of/type&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopByType</span><span class="hljs-params">(</span><span class="hljs-params">        <span class="hljs-meta">@RequestParam(&quot;typeId&quot;)</span> Integer typeId,</span><span class="hljs-params">        <span class="hljs-meta">@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;)</span> Integer current,</span><span class="hljs-params">        <span class="hljs-meta">@RequestParam(value = &quot;x&quot;, required = false)</span> Double x,</span><span class="hljs-params">        <span class="hljs-meta">@RequestParam(value = &quot;y&quot;, required = false)</span> Double y</span><span class="hljs-params">)</span> &#123;    <span class="hljs-keyword">return</span> shopService.queryShopByType(typeId,current,x,y);&#125;</code></pre></div><p>3、ShopServiceImpl</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopByType</span><span class="hljs-params">(Integer typeId, Integer current, Double x, Double y)</span> &#123;   log.info(<span class="hljs-string">&quot;current:&#123;&#125;&quot;</span>,current);    <span class="hljs-comment">//1、判断需不需要根据坐标查询</span>    <span class="hljs-keyword">if</span> (x == <span class="hljs-literal">null</span> || y == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">//不需要按坐标查询，直接查询数据库</span>        <span class="hljs-comment">// 根据类型分页查询</span>        Page&lt;Shop&gt; page = query()                .eq(<span class="hljs-string">&quot;type_id&quot;</span>, typeId)                .page(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(current, DEFAULT_PAGE_SIZE));        <span class="hljs-comment">// 返回数据</span>        <span class="hljs-keyword">return</span> Result.ok(page.getRecords());    &#125;        <span class="hljs-comment">//2、计算分页参数</span>    <span class="hljs-type">int</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> (current - <span class="hljs-number">1</span>) * DEFAULT_PAGE_SIZE;    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> current * DEFAULT_PAGE_SIZE;        <span class="hljs-comment">//3、查询Redis，按照距离排序、分页。结果：shopId、distance</span>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;    <span class="hljs-comment">//查询以指定经纬度为圆心半径五公里的商铺</span>    GeoResults&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt; results = stringRedisTemplate.opsForGeo().search(            key,            GeoReference.fromCoordinate(x, y),            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Distance</span>(<span class="hljs-number">5000</span>),            <span class="hljs-comment">//GEO的分页无法指定起始位置，只能从头读取指定条，此处先读取end条，之后再手动截取</span>            RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end));    <span class="hljs-keyword">if</span> (results == <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">//五公里内没有店铺</span>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());    &#125;        <span class="hljs-comment">//4、解析出店铺id及店铺距离</span>    List&lt;GeoResult&lt;RedisGeoCommands.GeoLocation&lt;String&gt;&gt;&gt; list = results.getContent();    <span class="hljs-keyword">if</span> (list.size() &lt;= from) &#123;        <span class="hljs-comment">// 没有下一页了，结束</span>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());    &#125;    <span class="hljs-comment">//此时list中保存的是0 ~ end范围内的店铺，需要返回的是 from ~ end 范围内的店铺</span>    <span class="hljs-comment">//4.1跳过前面的from条，截取 from ~ end内的</span>    ArrayList&lt;Long&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(list.size());    HashMap&lt;String, Distance&gt; distanceMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(list.size());    <span class="hljs-keyword">if</span> (list.size() &lt;= from) &#123;        <span class="hljs-comment">// 没有下一页了，结束</span>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());    &#125;    list.stream().skip(from).forEach(result -&gt;&#123;        <span class="hljs-comment">//4.2、获取对应的店铺id</span>        <span class="hljs-type">String</span> <span class="hljs-variable">shopIdStr</span> <span class="hljs-operator">=</span> result.getContent().getName();        ids.add(Long.valueOf(shopIdStr));        <span class="hljs-comment">//4.3、获取对应店铺的距离</span>        <span class="hljs-type">Distance</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> result.getDistance();        distanceMap.put(shopIdStr,distance);    &#125;);        <span class="hljs-comment">//5、根据id查询商铺</span>    <span class="hljs-type">String</span> <span class="hljs-variable">idStr</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);    List&lt;Shop&gt; shopList = query().in(<span class="hljs-string">&quot;id&quot;</span>, ids).last(<span class="hljs-string">&quot;ORDER BY FIELD ( id,&quot;</span> + idStr + <span class="hljs-string">&quot;)&quot;</span>).list();    <span class="hljs-keyword">for</span> (Shop shop : shopList) &#123;        <span class="hljs-comment">//设置店铺距离字段</span>        shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());    &#125;        <span class="hljs-comment">//6、返回结果</span>    <span class="hljs-keyword">return</span> Result.ok(shopList);&#125;</code></pre></div><h2 id="七用户签到">七、用户签到</h2><blockquote><p>Redis的BitMap数据统计功能</p></blockquote><h3 id="bitmap">7.1、BitMap</h3><p>按月来统计用户签到信息，签到记录为1，未签到则记录为0.</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241222153836975-2024-12-2215:39:07.png"alt="image-20241222153836975" /><figcaption aria-hidden="true">image-20241222153836975</figcaption></figure><p>位图（BitMap）的核心思想就是<strong>将比特位与某种业务状态进行映射</strong>。此处把每一个bit位对应当月的每一天，形成了映射关系。用0和1标示业务状态。</p><p>Redis中是利用<strong>string类型</strong>数据结构实现<strong>BitMap</strong>，因此最大上限是512M，转换为bit则是2^32个bit位。</p><p>BitMap的操作命令有：</p><ul><li><p><ahref="https://redis.io/docs/latest/commands/setbit/">SETBIT</a>：向指定位置（offset）存入一个0或1</p></li><li><p><ahref="https://redis.io/docs/latest/commands/getbit/">GETBIT</a>：获取指定位置（offset）的bit值（<strong>只能查询一位bit值</strong>）</p></li><li><p><ahref="https://redis.io/docs/latest/commands/bitcount/">BITCOUNT</a>：统计BitMap中值为1的bit位的数量</p></li><li><p><ahref="https://redis.io/docs/latest/commands/bitfield/">BITFIELD</a>：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值（多用作查询，<strong>一次可查询多个bit位的值</strong>）</p><div class="code-wrapper"><pre><code class="hljs bash">BITFIELD key [GET <span class="hljs-built_in">type</span> offset] [SET <span class="hljs-built_in">type</span> offset value] [INCRBY <span class="hljs-built_in">type</span> offset increment] [OVERFLOW WRAP|SAT|FAIL]</code></pre></div><p><code>key</code>：要操作的位图的键。</p><p><code>GET type offset</code>：获取指定位置的数值。</p><ul><li><code>type</code>：指定<strong>数值类型</strong>和<strong>要读取的位数</strong>，如<code>u8</code>（无符号的8位整数）、<code>u16</code>（无符号16位整数）、<code>i16</code>（有符号16位整数）、<code>i32</code>（有符号32位整数）。</li><li><code>offset</code>：位偏移量，从0开始。</li></ul></li><li><p><ahref="https://redis.io/docs/latest/commands/bitfield_ro/">BITFIELD_RO</a>：获取BitMap中bit数组，并以十进制形式返回</p></li><li><p><ahref="https://redis.io/docs/latest/commands/bitop/">BITOP</a>：将多个BitMap的结果做位运算（与、或、异或）</p></li><li><p><ahref="https://redis.io/docs/latest/commands/bitpos/">BITPOS</a>：查找bit数组中指定范围内第一个0或1出现的位置</p></li></ul><h3 id="实现签到功能">7.2、实现签到功能</h3><p>实现签到接口，将<u>当前用户</u> <u>当天</u>的签到信息保存到Redis中</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241222201057612-2024-12-2220:11:07.png" alt="image-20241222201057612" style="zoom:80%;" /></p><p>可以把<u>用户ID、年和月</u>作为bitMap的key，然后保存到一个bitMap中，每次签到就到对应的位上把数字从0变成1，只要对应是1，就表明说明这一天已经签到了，反之则没有签到。</p><blockquote><p>注：因为BitMap底层是基于String数据结构，因此其操作也都封装在字符串相关操作中了。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241222201249198-2024-12-2220:13:05.png"alt="image-20241222201249198" /><figcaption aria-hidden="true">image-20241222201249198</figcaption></figure></blockquote><p>UserController</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/sign&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sign</span><span class="hljs-params">()</span>&#123;   <span class="hljs-keyword">return</span> userService.sign();&#125;</code></pre></div><p>UserServiceImpl</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sign</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//1、获取当前用户</span>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();    <span class="hljs-comment">//2、获取当前年和月，以及当天是这个月的第几天</span>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();    <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();    <span class="hljs-comment">//3、拼接key</span>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + date;    <span class="hljs-comment">//4、写入redis  SETBIT key offset 1</span>    stringRedisTemplate.opsForValue().setBit(key,dayOfMonth - <span class="hljs-number">1</span>,<span class="hljs-literal">true</span>);    <span class="hljs-keyword">return</span> Result.ok();&#125;</code></pre></div><h3 id="签到统计">7.4、签到统计</h3><p>普通签到统计：使用<code>BITCOUNT</code>统计1出现的次数即为当前月的签到次数。</p><p>连续签到天数统计：从最后一次签到开始向前统计，直到遇到第一次未签到为止，计算总的签到次数。</p><p>需求：统计当前用户截止当前时间在本月的连续签到天数。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241222203728355-2024-12-2220:37:31.png" alt="image-20241222203728355" style="zoom:80%;" /></p><p>思路：获取本月截止今天为止的所有的签到记录，结果是一个十进制数字。将该数字和 1相与，每次得到最低位的比特。判断是不是0，若是0，则返回已统计的次数；判断是不是1，若是1则签到次数加一，同时该数字右移一位，继续下一次判断。</p><p>UserController</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 返回截止当天，本月用户的连续签到次数</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-meta">@GetMapping(&quot;/sign/count&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">getSignCount</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">return</span> userService.getSignCount();&#125;</code></pre></div><p>UserServiceImpl</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">getSignCount</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//1、获取当前用户</span>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();    <span class="hljs-comment">//2、获取当前年和月，以及当天是这个月的第几天</span>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();    <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;:yyyyMM&quot;</span>));    <span class="hljs-type">int</span> <span class="hljs-variable">dayOfMonth</span> <span class="hljs-operator">=</span> now.getDayOfMonth();    <span class="hljs-comment">//3、拼接key</span>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> USER_SIGN_KEY + userId + date;    <span class="hljs-comment">//4、获取截止当天，用户本月的签到记录 bitfield sign:1010:202412 get u22 0</span>    List&lt;Long&gt; result = stringRedisTemplate.opsForValue().bitField(            key,            BitFieldSubCommands.create()                    <span class="hljs-comment">//执行bitfield的get方法，从0开始返回 （dayOfMonth）位无符号数</span>                    .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class="hljs-number">0</span>)    );    <span class="hljs-comment">//该命令可以做多个操作，返回结果是一个集合</span>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span> || result.isEmpty()) &#123;        <span class="hljs-comment">//没有签到记录</span>        <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-type">Long</span> <span class="hljs-variable">signHistory</span> <span class="hljs-operator">=</span> result.get(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (signHistory == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">//没有签到记录</span>        <span class="hljs-keyword">return</span> Result.ok(<span class="hljs-number">0</span>);    &#125;    <span class="hljs-comment">//5、循环遍历</span>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-comment">//5.1 让这个数字与1做与运算，得到数字的最后一个bit位进行判断</span>        <span class="hljs-keyword">if</span> ((signHistory &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)  &#123;            <span class="hljs-comment">// 如果为0，说明未签到，结束</span>            <span class="hljs-keyword">break</span>;        &#125; <span class="hljs-keyword">else</span>  &#123;            <span class="hljs-comment">// 如果不为0，说明已签到，计数器+1</span>            count ++;            <span class="hljs-comment">// 无符号右移 &gt;&gt;&gt;</span>            signHistory &gt;&gt;&gt;= <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">//6、返回连续签到次数</span>    <span class="hljs-keyword">return</span> Result.ok(count);&#125;</code></pre></div><p>补充：使用bitMap解决缓存穿透，<ahref="https://catpaws.top/e0606bbf/#缓存穿透">布隆过滤器</a></p><h2 id="八uv网页的访问量统计">八、UV（网页的访问量）统计</h2><blockquote><p>Redis的HyperLogLog的统计功能</p></blockquote><p>两个概念</p><ul><li>UV：全称UniqueVisitor，也叫独立访客量，是指通过互联网访问、浏览这个网页的自然人。1天内同一个用户多次访问该网站，只记录1次。</li><li>PV：全称PageView，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量。</li></ul><p>UV统计在服务端做会比较麻烦，因为要判断该用户是否已经统计过了，需要将统计过的用户信息保存。但是如果每个访问的用户都保存到Redis中，数据量会非常恐怖。</p><h3 id="hyperloglog">8.1、HyperLogLog</h3><p>​Redis中的HyperLogLog是一种用于基数统计的数据结构，它允许在非常小的内存空间内估计一个集合中<strong>不重复元素的数量</strong>。</p><p>特点</p><ol type="1"><li><p>‌<strong>内存占用小</strong>‌：每个HyperLogLog键只需要12KB的内存，就可以计算接近264个不同元素的基数。</p></li><li><p>‌<strong>适用于大数据集</strong>‌：在处理海量数据时，HyperLogLog能够高效地估计集合的基数，而不需要存储集合中的所有元素。</p></li><li><p>‌<strong>不精确但误差小</strong>‌：由于HyperLogLog是基于概率的算法，因此它的估计结果不是完全准确的，但误差通常很小，标准误算率是0.81%。</p></li></ol><p>Redis为HyperLogLog提供了三个命令：</p><ul><li>‌<strong>PFADD key element [element...]</strong>‌：向指定的HyperLogLog添加一个或多个元素。</li><li>‌<strong>PFCOUNT key [key...]</strong>‌：返回给定HyperLogLog的基数估算值。如果作用于多个键，则返回所有给定HyperLogLog的并集的近似基数。</li><li>‌<strong>PFMERGE destkey sourcekey [sourcekey...]</strong>‌：将多个HyperLogLog合并为一个HyperLogLog。</li></ul><h3 id="测试百万条数据的统计效果">8.2、测试百万条数据的统计效果</h3><p>直接利用单元测试，向HyperLogLog中添加100万条数据，看看内存占用和统计效果如何</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#查看当前redis内存使用情况</span>127.0.0.1:6379&gt; info memory<span class="hljs-comment"># Memory</span>used_memory:1681168 <span class="hljs-comment">#当前内存占用为 1681168 字节</span>used_memory_human:1.60Mused_memory_rss:2818048</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHyperLogLog</span><span class="hljs-params">()</span> &#123;    String[] values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">1000</span>];    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;        j = i % <span class="hljs-number">1000</span>;        values[j] = <span class="hljs-string">&quot;user_&quot;</span>+ i;        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">999</span>) &#123;            <span class="hljs-comment">// 存入redis</span>            stringRedisTemplate.opsForHyperLogLog().add(<span class="hljs-string">&quot;hl1&quot;</span>,values);        &#125;    &#125;    <span class="hljs-comment">//统计数量</span>    <span class="hljs-type">Long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForHyperLogLog().size(<span class="hljs-string">&quot;hl1&quot;</span>);    System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + count);&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241222214308050-2024-12-2221:44:07.png"alt="image-20241222214308050" /><figcaption aria-hidden="true">image-20241222214308050</figcaption></figure><p>再次查看内存情况</p><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; info memory<span class="hljs-comment"># Memory</span>used_memory:1695584used_memory_human:1.62M</code></pre></div><p>内存使用：1695584 - 1681168 = 14416B = 14.08KB</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>缓存问题</tag>
      
      <tag>全局唯一ID</tag>
      
      <tag>Lua脚本</tag>
      
      <tag>分布式锁</tag>
      
      <tag>Redisson</tag>
      
      <tag>Redis消息队列</tag>
      
      <tag>Feed流</tag>
      
      <tag>GEO</tag>
      
      <tag>BitMap</tag>
      
      <tag>HyperLogLog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis - 基础篇</title>
    <link href="/bcfabe89/"/>
    <url>/bcfabe89/</url>
    
    <content type="html"><![CDATA[<meta name = "referrer", content = "no-referrer"/><h2 id="一初始redis">一、初始Redis</h2><h3 id="认识nosql">1.1、认识NoSQL</h3><p>​ NoSQL最常见的解释是“non-relational”， “Not OnlySQL”也被很多人接受。NoSQL仅仅是一个概念，泛指<strong>非关系型的数据库</strong>，区别于关系数据库。</p><p>与关系型数据库对比，在以下几点存在差异：</p><p>1、数据结构组织</p><ul><li><p>存入SQL的数据都是结构化（Structured）的数据，这些数据都有固定的格式和要求，通过<strong>表和表的约束</strong>确定下来。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241210105846784-2024-12-1010:59:01.png"alt="image-20241210105846784" /><figcaption aria-hidden="true">image-20241210105846784</figcaption></figure></li><li><p>NoSQL中的数据是非结构化的数据，对数据的格式没有严格的限制。NoSQL主要有四种数据组织方式：键值类型、文档类型、列类型、图（Graph）类型。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241211015432742-2024-12-1101:54:38.png"alt="image-20241211015432742" /><figcaption aria-hidden="true">image-20241211015432742</figcaption></figure></li></ul><p>2、数据关联</p><ul><li><p>关系型数据库的数据是可以直接关联（Relational）的，可以通过<strong>外键</strong>建立数据的联系，这种外键关系一旦建立，数据库就会自动维护表和表之间的关联。同时可以减少数据的冗余。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241210111342983-2024-12-1011:13:44.png"alt="image-20241210111342983" /><figcaption aria-hidden="true">image-20241210111342983</figcaption></figure></li><li><p>非关系型数据库没有直接维护数据与数据的关联，如采用外键方式，而是使用<strong>JSON文档嵌套</strong>的形式。要想实现外键关系这种效果，需要程序员通过业务逻辑来维护。这种方式也会造成数据的重复，同一份数据可能存储在多个用户下。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241210112239209-2024-12-1011:22:40.png"alt="image-20241210112239209" /><figcaption aria-hidden="true">image-20241210112239209</figcaption></figure></li></ul><p>3、数据查询方式</p><ul><li><p>关系型数据库采用SQL查询，有固定的语法，只要是关系型数据库都能采用相同的语句进行查询</p></li><li><p>非关系型数据库的查询没有固定的语法格式，不同的NoSQL数据库有自己的语法格式</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210112815212-2024-12-1011:28:16.png" alt="image-20241210112815212" style="zoom:80%;" /></p></li></ul><p>4、事务特性</p><ul><li>关系型数据库能够保证事务的<code>ACID</code>特性。当系统中的事务需要满足ACID时，优先选择关系型数据库。</li><li>对于非关系型数据库，有的没有事务，有的无法满足事务的强一致性，只能做到基本一致。<ahref="https://blog.csdn.net/yuanmayuzhou/article/details/137498595">BASE理论</a></li></ul><p>5、存储方式</p><ul><li>关系型数据库基于<strong>磁盘</strong>进行存储，会有大量的磁盘IO，对性能有一定影响。</li><li>非关系型数据库，它操作更多的是依赖于内存来操作，内存的读写速度会非常快，性能自然会好一些。</li></ul><p>6、扩展性</p><ul><li><p>关系型数据库：<strong>垂直扩展性</strong>‌。关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。SQL数据库通常通过增强单个服务器的性能（如增加CPU、内存、存储等）来实现垂直扩展。</p></li><li><p>非关系型数据库：<strong>水平扩展性</strong>。非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题。称为水平扩展。NoSQL数据库通常设计为分布式系统，天生支持水平扩展。通过添加更多的节点到集群中，NoSQL数据库可以轻松地扩展存储和计算能力，以处理海量数据和并发请求。</p></li></ul><p>7、使用场景</p><ul><li>当数据结构固定，相关业务对数据安全性一致性要求较高时，采用关系型数据库。</li><li>数据结构否固定，对一致性、安全性要求不高，对性能要求高时，采用非关系型数据库。</li></ul><h3 id="认识redis">1.2、认识Redis</h3><figure><imgsrc="https://i-blog.csdnimg.cn/blog_migrate/85f82d1770ba79525dec9edff840861a.jpeg"alt="redis-logo" /><figcaption aria-hidden="true">redis-logo</figcaption></figure><p>​ Redis诞生于2009年全称是<strong>R</strong>emote<strong>Di</strong>ctionary<strong>S</strong>erver，远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p>特征：</p><ul><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个<strong>命令</strong>具备原子性</li><li>低延迟，速度快（基于<strong>内存</strong>、IO多路复用、良好的编码）。</li><li>支持数据持久化（保证内存中数据的安全）</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ul><h3 id="安装redis">1.3.安装Redis</h3><p><ahref="https://www.bilibili.com/video/BV1cr4y1671t?vd_source=51d78ede0a0127d1839d6abf9204d1ee&amp;spm_id_from=333.788.player.switch&amp;p=5">参考视频</a></p><h2 id="二redis常用数据结构">二、Redis常用数据结构</h2><h3 id="redis数据结构介绍">2.1、Redis数据结构介绍</h3><p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241210154119504-2024-12-1015:41:58.png"alt="image-20241210154119504" /><figcaption aria-hidden="true">image-20241210154119504</figcaption></figure><p>除此之外，还有其他具有特殊功能的数据类型，可在Redis官网查看。</p><p>Redis将操作不同数据类型的命令做了分组，可以在<ahref="https://redis.io/commands">官网</a>查看相关命令</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241210154408388-2024-12-1015:44:58.png"alt="image-20241210154408388" /><figcaption aria-hidden="true">image-20241210154408388</figcaption></figure><p>也可以也可以通过Help命令来查看对应数据结构类型的命令</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241210154609868-2024-12-1015:46:47.png"alt="image-20241210154609868" /><figcaption aria-hidden="true">image-20241210154609868</figcaption></figure><h3 id="redis通用命令">2.2、Redis通用命令</h3><p>通用指令是所有数据类型都可以使用的指令。<ahref="https://redis.io/docs/latest/commands/?group=generic">查看所有通用命令</a></p><p>可以控制台查看命令的用法，如：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241210155923897-2024-12-1015:59:24.png"alt="image-20241210155923897" /><figcaption aria-hidden="true">image-20241210155923897</figcaption></figure><p>常见的有：</p><ul><li><p><code>KEYS</code>：查看<strong>符合模板</strong>的所有key，即可以使用<code>*,?,[],^</code>等通配符进行模糊匹配。</p><blockquote><p><strong>在生产环境下不推荐使用keys命令，因为进行模糊查询效率不高，数据量过大时，花费时间过长，由于Redis命令是单线程的，会阻塞后面命令的执行。</strong></p></blockquote></li><li><p><code>DEL</code>：删除一个指定的key。</p></li><li><p><code>EXISTS</code>：判断key是否存在</p></li><li><p><code>EXPIRE</code>：给一个key设置有效期，有效期到期时该key会被自动删除</p></li><li><p><code>TTL</code>：查看一个KEY的剩余有效期 &gt; i.当前key没有设置过期时间，返回-1. &gt; &gt; ii.当前key有设置过期时间，而且key已经过期，返回-2. &gt; &gt; iii.当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.</p></li><li><p><code>Type</code>: 查看一个key的数据类型</p></li></ul><h3 id="string类型">2.3、String类型</h3><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p><ul><li>string：普通字符串</li><li>int：整数类型，可以做自增.自减操作</li><li>float：浮点类型，可以做自增.自减操作</li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241210161609186-2024-12-1016:16:10.png"alt="image-20241210161609186" /><figcaption aria-hidden="true">image-20241210161609186</figcaption></figure><p>String类型常见命令：</p><ul><li><p>SET：<strong>添加</strong>或者<strong>修改</strong>已经存在的一个String类型的键值对</p></li><li><p>GET：根据key获取String类型的value</p></li><li><p>MSET：批量添加多个String类型的键值对</p></li><li><p>MGET：根据多个key获取多个String类型的value</p></li><li><p>INCR：让一个整型的key自增1。</p></li><li><p>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2让num值自增2</p></li><li><p>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</p></li></ul><blockquote><p>以上三个数值增加的函数，如果所操作的key不存在，则<strong>在执行操作前将其设置为0</strong>。</p></blockquote><ul><li><p>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行（真正的新增操作）</p></li><li><p>SETEX：添加一个String类型的键值对，并且指定有效期</p></li></ul><h3 id="key的层级结构">2.4、KEY的层级结构</h3><p>Redis没有类似MySQL中的Table的概念，我们该如何区分不同类型的key呢？</p><p>例如，需要存储用户.商品信息到redis，有一个用户id是1，有一个商品id恰好也是1，此时如果使用id作为key，那就会冲突了，该怎么办？</p><p>我们可以通过给key添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范：</p><p>Redis的key允许有多个单词形成层级结构，多个单词之间用<code>:</code>隔开，格式如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241210164117344-2024-12-1016:41:58.png"alt="image-20241210164117344" /><figcaption aria-hidden="true">image-20241210164117344</figcaption></figure><p>例如我们的项目名称叫heima，有user和product两种不同类型的数据，我们可以这样定义key：</p><ul><li><p>user相关的key：<strong>heima:user:1</strong></p></li><li><p>product相关的key：<strong>heima:product:1</strong></p></li></ul><p>如果Value是一个Java对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储：</p><table><thead><tr class="header"><th><strong>KEY</strong></th><th><strong>VALUE</strong></th></tr></thead><tbody><tr class="odd"><td>heima:user:1</td><td>{"id":1, "name": "Jack", "age": 21}</td></tr><tr class="even"><td>heima:product:1</td><td>{"id":1, "name": "小米11", "price": 4999}</td></tr></tbody></table><p>一旦我们向redis采用这样的方式存储，那么在可视化界面中，redis会以层级结构来进行存储，形成类似于这样的结构，更加方便Redis获取数据。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241210164316431-2024-12-1016:43:58.png"alt="image-20241210164316431" /><figcaption aria-hidden="true">image-20241210164316431</figcaption></figure><h3 id="hash类型">2.5、Hash类型</h3><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p><p>String结构是将对象序列化为JSON字符串后存储，当需要<strong>修改其中某个字段</strong>时很不方便：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241210164556205-2024-12-1016:45:58.png"alt="image-20241210164556205" /><figcaption aria-hidden="true">image-20241210164556205</figcaption></figure><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241210164642490-2024-12-1016:46:58.png"alt="image-20241210164642490" /><figcaption aria-hidden="true">image-20241210164642490</figcaption></figure><p><strong>Hash类型的常见命令</strong></p><ul><li>HSET key fieldvalue：<strong>添加</strong>或者<strong>修改</strong>hash类型key的field的值</li><li>HGET key field：获取一个hash类型key的field的值</li><li>HMSET：批量添加多个hash类型key的field的值</li><li>HMGET：批量获取多个hash类型key的field的值</li></ul><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; HSET heima:user:2 name rose(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; HSET heima:user:2 age 21(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; HGET heima:user:2 name<span class="hljs-string">&quot;rose&quot;</span>127.0.0.1:6379&gt; HMSET heima:user:3 name Lucy age 22 sex femaleOK127.0.0.1:6379&gt; HMGET heima:user:3 name age sex1) <span class="hljs-string">&quot;Lucy&quot;</span>2) <span class="hljs-string">&quot;22&quot;</span>3) <span class="hljs-string">&quot;female&quot;</span></code></pre></div><ul><li>HGETALL：获取一个hash类型的key中的所有的field和value</li><li>HKEYS：获取一个hash类型的key中的所有的field</li><li>HVALS：获取一个hash类型的key中的所有的value</li></ul><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; HGETALL heima:user:31) <span class="hljs-string">&quot;name&quot;</span>2) <span class="hljs-string">&quot;Lucy&quot;</span>3) <span class="hljs-string">&quot;age&quot;</span>4) <span class="hljs-string">&quot;22&quot;</span>5) <span class="hljs-string">&quot;sex&quot;</span>6) <span class="hljs-string">&quot;female&quot;</span>127.0.0.1:6379&gt; HKEYS heima:user:31) <span class="hljs-string">&quot;name&quot;</span>2) <span class="hljs-string">&quot;age&quot;</span>3) <span class="hljs-string">&quot;sex&quot;</span>127.0.0.1:6379&gt; HVALS heima:user:31) <span class="hljs-string">&quot;Lucy&quot;</span>2) <span class="hljs-string">&quot;22&quot;</span>3) <span class="hljs-string">&quot;female&quot;</span></code></pre></div><ul><li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; HINCRBY heima:user:3 age 3(<span class="hljs-built_in">integer</span>) 25127.0.0.1:6379&gt; HGET heima:user:3 age<span class="hljs-string">&quot;25&quot;</span>127.0.0.1:6379&gt; HINCRBY heima:user:3 age -2  <span class="hljs-comment">#增量为负数，则为自减操作</span>(<span class="hljs-built_in">integer</span>) 23127.0.0.1:6379&gt; HGET heima:user:3 age<span class="hljs-string">&quot;23&quot;</span>127.0.0.1:6379&gt; HSETNX heima:user:3 sex male  <span class="hljs-comment"># user3已存在sex字段，设置无效</span>(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6379&gt; HGET heima:user:3 sex<span class="hljs-string">&quot;female&quot;</span>127.0.0.1:6379&gt; HSETNX heima:user:2 sex male <span class="hljs-comment">#user2没有sex字段，设置成功</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; HGET heima:user:2 sex<span class="hljs-string">&quot;male&quot;</span></code></pre></div><ul><li>HEXISTS keyfield：判断指定key中是否已存在field字段，存在返回1，不存在返回0.</li><li>HDEL key field [field...]：删除指定key中的field字段，如果指定field不存在则忽略；如果该key的所有字段都被删除，则该key也被删除。如果key 不存在，则将其视为空散列，此命令返回 0。</li><li>HLEN key：返回该Key所含有的field字段的数量</li></ul><h3 id="list类型">2.6、List类型</h3><p>Redis中的List类型与Java中的<strong>LinkedList</strong>类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p><strong>List的常见命令有：</strong></p><ul><li><p>LPUSH key element ... ：向列表左侧插入一个或多个元素</p></li><li><p>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</p></li><li><p>RPUSH key element ... ：向列表右侧插入一个或多个元素</p></li><li><p>RPOP key：移除并返回列表右侧的第一个元素</p></li><li><p>LRANGE key star end：返回一段角标范围内的所有元素</p></li><li><p>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil。</p><blockquote><p>使用BLPOP和BRPO时，若不存在该元素，会<strong>阻塞进程</strong>等待指定时间。若指定时间内等待元素出现，返回该元素值，否则返回nil。</p></blockquote></li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241210170706103-2024-12-1017:07:58.png"alt="image-20241210170706103" /><figcaption aria-hidden="true">image-20241210170706103</figcaption></figure><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; LPUSH <span class="hljs-built_in">users</span> 1 2 3(<span class="hljs-built_in">integer</span>) 3127.0.0.1:6379&gt; RPUSH <span class="hljs-built_in">users</span> 4 5 6(<span class="hljs-built_in">integer</span>) 6127.0.0.1:6379&gt; LRANGE <span class="hljs-built_in">users</span> 0 5  <span class="hljs-comment">#注意此时队列中数字的顺序</span>1) <span class="hljs-string">&quot;3&quot;</span>2) <span class="hljs-string">&quot;2&quot;</span>3) <span class="hljs-string">&quot;1&quot;</span>4) <span class="hljs-string">&quot;4&quot;</span>5) <span class="hljs-string">&quot;5&quot;</span>6) <span class="hljs-string">&quot;6&quot;</span>127.0.0.1:6379&gt; LPOP <span class="hljs-built_in">users</span><span class="hljs-string">&quot;3&quot;</span>127.0.0.1:6379&gt; RPOP <span class="hljs-built_in">users</span> 2  <span class="hljs-comment">#出队多个元素</span>1) <span class="hljs-string">&quot;6&quot;</span>2) <span class="hljs-string">&quot;5&quot;</span>127.0.0.1:6379&gt; LRange key 0 -1 <span class="hljs-comment">#不知道最后一个元素下标时，用-1代替</span>(empty array)127.0.0.1:6379&gt; LRange <span class="hljs-built_in">users</span>  0 -11) <span class="hljs-string">&quot;2&quot;</span>2) <span class="hljs-string">&quot;1&quot;</span>3) <span class="hljs-string">&quot;4&quot;</span></code></pre></div><ul><li><p>如何利用List结构模拟一个栈？</p><p>入口和出口在同一边。使用LPUSH/LPOP 或RPUSH/RPOP进行元素操作。</p></li><li><p>如何利用List结构模拟一个队列？</p><p>入口和出口在不同边。使用LPUSH/RPOP 或RPUSH/LPOP进行元素操作。</p></li><li><p>如何利用List结构模拟一个阻塞队列？</p><p>入口和出口在不同边，且出队时采用BLPOP或BRPOP</p></li></ul><h3 id="set类型">2.7、Set类型</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个<strong>value为null的HashMap</strong>。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><p><strong>Set类型的常见命令</strong></p><ul><li>SADD key member ... ：向set中添加一个或多个元素</li><li>SREM key member ... : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li></ul><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; SADD s1 a b c d <span class="hljs-comment">#向s1中添加四个元素 a b c d</span>(<span class="hljs-built_in">integer</span>) 4127.0.0.1:6379&gt; SMEMBERS s1 <span class="hljs-comment">#查看s1中的元素</span>1) <span class="hljs-string">&quot;a&quot;</span>2) <span class="hljs-string">&quot;c&quot;</span>3) <span class="hljs-string">&quot;d&quot;</span>4) <span class="hljs-string">&quot;b&quot;</span>127.0.0.1:6379&gt; SREM s1 a (<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; SREM s1 b  <span class="hljs-comment">#删除s1中的a b</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; SISMEMBER s1 a <span class="hljs-comment">#判断a是否是s1的元素，返回值为0</span>(<span class="hljs-built_in">integer</span>) 0127.0.0.1:6379&gt; SCARD s1 <span class="hljs-comment">#查看此时s1中元素的个数</span>(<span class="hljs-built_in">integer</span>) 2</code></pre></div><ul><li>SINTER key1 key2 ... ：求key1与key2的交集</li><li>SDIFF key1 key2 ... ：求key1与key2的差集</li><li>SUNION key1 key2 ..：求key1和key2的并集</li></ul><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">#将下列数据用Redis的Set集合来存储：</span><span class="hljs-comment">#张三的好友有：李四、王五、赵六</span><span class="hljs-comment">#李四的好友有：王五、麻子、二狗</span>127.0.0.1:6379&gt; SADD zs lisi wangwu zhaoliu(<span class="hljs-built_in">integer</span>) 3127.0.0.1:6379&gt; SADD <span class="hljs-built_in">ls</span> wangwu mazi ergou(<span class="hljs-built_in">integer</span>) 3127.0.0.1:6379&gt; SINTER zs <span class="hljs-built_in">ls</span> <span class="hljs-comment"># 计算张三和李四有哪些共同好友</span>1) <span class="hljs-string">&quot;wangwu&quot;</span>127.0.0.1:6379&gt; SDIFF zs <span class="hljs-built_in">ls</span><span class="hljs-comment"># 查询哪些人是张三的好友却不是李四的好友</span>1) <span class="hljs-string">&quot;lisi&quot;</span>2) <span class="hljs-string">&quot;zhaoliu&quot;</span>127.0.0.1:6379&gt; SUNION zs <span class="hljs-built_in">ls</span> <span class="hljs-comment"># 查询张三和李四的好友总共有哪些人</span>1) <span class="hljs-string">&quot;lisi&quot;</span>2) <span class="hljs-string">&quot;zhaoliu&quot;</span>3) <span class="hljs-string">&quot;wangwu&quot;</span>4) <span class="hljs-string">&quot;mazi&quot;</span>5) <span class="hljs-string">&quot;ergou&quot;</span></code></pre></div><h3 id="sortedset类型">2.8、SortedSet类型</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。</p><p>SortedSet中的每一个元素都带有一个<code>score</code>属性，可以基于score属性对元素<code>排序</code>，底层的实现是一个跳表（SkipList）加hash表。</p><p>SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现<u>排行榜</u>这样的功能。</p><p>SortedSet的常见命令有：</p><ul><li><p>ZADD key score member：添加一个或多个元素到sorted set，如果已经存在则更新其score值</p></li><li><p>ZREM key member：删除sorted set中的一个指定元素</p></li><li><p>ZSCORE key member : 获取sorted set中的指定元素的score值</p></li><li><p>ZRANK key member：获取sorted set中的指定元素的排名（<strong><u>排名从0开始</u></strong>）</p></li><li><p>ZCARD key：获取sorted set中的元素<strong>个数</strong></p></li><li><p>ZCOUNT key minmax：统计<code>score值</code>在给定范围内的所有元素的<strong>个数</strong></p></li><li><p>ZRANGE key minmax：按照score排序后，获取指定排名范围内的<strong>元素</strong></p></li><li><p>ZRANGEBYSCORE key minmax：按照score排序后，获取指定score范围内的<strong>元素</strong></p></li><li><p>ZINCRBY key increment member：让sortedset中的指定元素自增，步长为指定的increment值</p></li><li><p>ZDIFF.ZINTER.ZUNION：求差集.交集.并集</p></li></ul><blockquote><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，如ZREVRANK</p></blockquote><p>练习案例</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241210174728207-2024-12-1017:47:45.png" alt="image-20241210174728207" style="zoom:70%;" /></p><div class="code-wrapper"><pre><code class="hljs bash">127.0.0.1:6379&gt; ZADD scores 85 Jack 89 Lucy 82 Rose  95 Tom 78 Jerry 92 Amy 76 Miles <span class="hljs-comment">#导入学生分数到scores</span>(<span class="hljs-built_in">integer</span>) 7127.0.0.1:6379&gt; ZREM scores Tom  <span class="hljs-comment">#删除Tom同学</span>(<span class="hljs-built_in">integer</span>) 1127.0.0.1:6379&gt; ZSCORE scores Amy <span class="hljs-comment">#获取Amy的分数</span><span class="hljs-string">&quot;92&quot;</span>127.0.0.1:6379&gt; ZREVRANK scores Rose <span class="hljs-comment">#score降序，获得Rose的排名</span>(<span class="hljs-built_in">integer</span>) 3127.0.0.1:6379&gt; ZCOUNT scores 0 80 <span class="hljs-comment">#查询80分以下的学生个数</span>(<span class="hljs-built_in">integer</span>) 2127.0.0.1:6379&gt; ZINCRBY scores  2 Amy  <span class="hljs-comment">#Amy的分数加2</span><span class="hljs-string">&quot;94&quot;</span>127.0.0.1:6379&gt; ZREVRANGE scores 0 2  <span class="hljs-comment">#score降序排序，获取前三名</span>1) <span class="hljs-string">&quot;Amy&quot;</span>2) <span class="hljs-string">&quot;Lucy&quot;</span>3) <span class="hljs-string">&quot;Jack&quot;</span>127.0.0.1:6379&gt; ZRANGEBYSCORE scores 0 80  <span class="hljs-comment">#查出80分以下的同学</span>1) <span class="hljs-string">&quot;Miles&quot;</span>2) <span class="hljs-string">&quot;Jerry&quot;</span></code></pre></div><h2 id="三redis三种特殊数据结构">三、Redis三种特殊数据结构</h2><h3 id="geo地理位置">3.1、<ahref="https://catpaws.top/e0606bbf/#六附近的商户">GEO地理位置</a></h3><h3 id="bitmap">3.2、<ahref="https://catpaws.top/e0606bbf/#七用户签到">BitMap</a></h3><h3 id="hyperloglog">3.3、<ahref="https://catpaws.top/e0606bbf/#八uv网页的访问量统计">Hyperloglog</a></h3><h2 id="四redis的java客户端">四、Redis的Java客户端</h2><p>在Redis官网中提供了各种语言的客户端，地址：https://redis.io/clients</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241210215022257-2024-12-1021:50:26.png"alt="image-20241210215022257" /><figcaption aria-hidden="true">image-20241210215022257</figcaption></figure><ul><li>jedis和Lettuce：这两个主要是提供了Redis命令对应的API，方便我们操作Redis，而SpringDataRedis又对这两种做了抽象和封装（SpringBoot<strong>默认使用Lettuce</strong>），因此后期可以以SpringDataRedis来学习。</li><li>Redisson：是在Redis基础上实现了分布式的可伸缩的java数据结构，例如Map.Queue等，而且支持跨进程的同步机制：Lock.Semaphore等待，比较适合用来实现特殊的功能需求。</li></ul><h3 id="jedis">4.1、Jedis</h3><h4 id="快速入门">快速入门</h4><ol type="1"><li><p>引入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jedis--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>建立连接</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Jedis jedis;<span class="hljs-meta">@BeforeEach</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 1.建立连接</span>    jedis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>(<span class="hljs-string">&quot;主机ip&quot;</span>, <span class="hljs-number">6379</span>);    <span class="hljs-comment">// 2.设置密码</span>    jedis.auth(<span class="hljs-string">&quot;123321&quot;</span>);    <span class="hljs-comment">// 3.选择库</span>    jedis.select(<span class="hljs-number">0</span>);&#125;</code></pre></div></li><li><p>测试</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 存入数据</span>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;虎哥&quot;</span>);    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);    <span class="hljs-comment">// 获取数据</span>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> jedis.get(<span class="hljs-string">&quot;name&quot;</span>);    System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);&#125;<span class="hljs-meta">@Test</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">// 插入hash数据</span>    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Jack&quot;</span>);    jedis.hset(<span class="hljs-string">&quot;user:1&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;21&quot;</span>);    <span class="hljs-comment">// 获取</span>    Map&lt;String, String&gt; map = jedis.hgetAll(<span class="hljs-string">&quot;user:1&quot;</span>);    System.out.println(map);&#125;</code></pre></div></li><li><p>释放资源</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@AfterEach</span><span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;    <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;        jedis.close();    &#125;&#125;</code></pre></div></li></ol><h4 id="jedis连接池">Jedis连接池</h4><p>Jedis本身是线程不安全的，并发模式下需要为每个线程创建Jedis连接，使用完再释放连接。频繁的创建和销毁连接会有性能损耗，因此推荐使用Jedis连接池代替Jedis的直连方式</p><p>创建Jedis连接池，通过连接池获取Jedis连接</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JedisConnectionFactory</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-comment">//配置连接池</span>        <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">poolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();        <span class="hljs-comment">//最大连接</span>        poolConfig.setMaxTotal(<span class="hljs-number">10</span>);        <span class="hljs-comment">//最大空闲连接</span>        poolConfig.setMaxIdle(<span class="hljs-number">8</span>);        <span class="hljs-comment">//最小空闲连接</span>        poolConfig.setMinIdle(<span class="hljs-number">0</span>);        <span class="hljs-comment">//设置最长等待时间 ，单位ms</span>        poolConfig.setMaxWaitMillis(<span class="hljs-number">200</span>);        <span class="hljs-comment">//创建连接池对象</span>        jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(poolConfig,                <span class="hljs-string">&quot;192.168.181.100&quot;</span>,<span class="hljs-number">6379</span>,<span class="hljs-number">1000</span>,<span class="hljs-string">&quot;liuhao123&quot;</span>);    &#125;    <span class="hljs-comment">//获取Jedis对象</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title function_">getJedis</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> jedisPool.getResource();    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"> <span class="hljs-meta">@BeforeEach</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span>&#123;     <span class="hljs-comment">//建立连接</span>     <span class="hljs-comment">/*jedis = new Jedis(&quot;127.0.0.1&quot;,6379);*/</span>     jedis = JedisConnectionFacotry.getJedis();      <span class="hljs-comment">//选择库</span>     jedis.select(<span class="hljs-number">0</span>); &#125;<span class="hljs-meta">@AfterEach</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;     <span class="hljs-keyword">if</span> (jedis != <span class="hljs-literal">null</span>) &#123;         jedis.close();     &#125; &#125;</code></pre></div><ol type="1"><li><p>在完成了使用工厂设计模式来完成代码的编写之后，我们在获得连接时，就可以通过工厂来获得，而不用直接去new对象，降低耦合，并且使用的还是连接池对象。</p></li><li><p>当我们使用了连接池后，当我们关闭连接其实并不是关闭，而是将Jedis连接<strong>归还</strong>给连接池。</p></li></ol><h3 id="springdataredis">4.2、SpringDataRedis</h3><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，<ahref="https://spring.io/projects/spring-data-redis">官网地址</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了<strong>RedisTemplate</strong>统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK.JSON.字符串.Spring对象的数据序列化及反序列化（方便数据的存储和读取）</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。像redis一样，对不同数据类型做了分组，将不同数据类型的操作API封装到了不同的类型中：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241210221341487-2024-12-1022:13:58.png"alt="image-20241210221341487" /><figcaption aria-hidden="true">image-20241210221341487</figcaption></figure><h4 id="快速入门-1">快速入门</h4><p>SpringBoot已经提供了对SpringDataRedis的支持，创建一个SpringBoot项目进行测试，步骤如下：</p><ol type="1"><li><p>引入依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--redis依赖--&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-comment">&lt;!--common-pool--&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-comment">&lt;!--Jackson依赖--&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>配置文件</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">redis:</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.181</span><span class="hljs-number">.100</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123321</span>    <span class="hljs-attr">lettuce:</span>      <span class="hljs-attr">pool:</span>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span>  <span class="hljs-comment">#最大连接</span>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">8</span>   <span class="hljs-comment">#最大空闲连接</span>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">0</span>   <span class="hljs-comment">#最小空闲连接</span>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">100ms</span> <span class="hljs-comment">#连接等待时间</span></code></pre></div></li><li><p>测试</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisDemoApplicationTests</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// 写入一条String数据</span>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;jack&quot;</span>);        <span class="hljs-comment">// 获取string数据</span>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);        System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);    &#125;&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241211003003488-2024-12-1100:30:05.png"alt="image-20241211003003488" /><figcaption aria-hidden="true">image-20241211003003488</figcaption></figure></li></ol><h4id="redistemplate的两种序列化实践方案">RedisTemplate的两种序列化实践方案</h4><p>RedisTemplate可以接收任意Object作为值写入Redis，在写入前会把Object序列化为字节形式，默认是采用<strong>JDK序列化</strong></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241211014252619-2024-12-1101:42:58.png"alt="image-20241211014252619" /><figcaption aria-hidden="true">image-20241211014252619</figcaption></figure><p>得到的结果如下，可读性差，内存占用较大。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241211005242136-2024-12-1100:52:52.png" alt="image-20241211005242136" style="zoom:67%;" /></p><p>可以采用两种方案解决</p><p>方案一：</p><ol type="1"><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> &#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span>&#123;        <span class="hljs-comment">// 创建RedisTemplate对象</span>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();        <span class="hljs-comment">// 设置连接工厂</span>        template.setConnectionFactory(connectionFactory);        <span class="hljs-comment">// 创建JSON序列化工具</span>        <span class="hljs-type">GenericJackson2JsonRedisSerializer</span> <span class="hljs-variable">jsonRedisSerializer</span> <span class="hljs-operator">=</span>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericJackson2JsonRedisSerializer</span>();        <span class="hljs-comment">// 设置Key的序列化</span>        template.setKeySerializer(RedisSerializer.string());        template.setHashKeySerializer(RedisSerializer.string());        <span class="hljs-comment">// 设置Value的序列化</span>        template.setValueSerializer(jsonRedisSerializer);        template.setHashValueSerializer(jsonRedisSerializer);        <span class="hljs-comment">// 返回</span>        <span class="hljs-keyword">return</span> template;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//测试代码</span><span class="hljs-meta">@SpringBootTest</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">HmDianPingApplicationTests</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String,Object&gt; redisTemplate;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">// 写入一条String数据</span>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;jack&quot;</span>);        <span class="hljs-comment">// 获取string数据</span>        <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);        System.out.println(<span class="hljs-string">&quot;name = &quot;</span> + name);    &#125;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUser</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//存入对象数据</span>        redisTemplate.opsForValue().set(<span class="hljs-string">&quot;user:100&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">TestUser</span>(<span class="hljs-string">&quot;Dylan&quot;</span>,<span class="hljs-number">20</span>));        <span class="hljs-comment">//获取数据</span>        <span class="hljs-type">TestUser</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> (TestUser) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;user:100&quot;</span>);        System.out.println(<span class="hljs-string">&quot;o = &quot;</span>+ o);    &#125;&#125;</code></pre></div><p>采用了JSON序列化来代替默认的JDK序列化方式。最终结果如图：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241211011952945-2024-12-1101:19:58.png" alt="image-20241211011952945" style="zoom:80%;" /></p><p>同时可以将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象。不过，其中记录了序列化时对应的class名称，目的是为了查询时实现自动反序列化。这会带来额外的内存开销。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241211012224081-2024-12-1101:22:49.png" alt="image-20241211012224081" style="zoom:80%;" /></p><p>方案二：</p><ol type="1"><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ol><p>​为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。为了减少内存的消耗，我们可以采用手动序列化和反序列化。</p><p>​同时，只采用String的序列化器，这样，在存储value时，就不需要在内存中就不用多存储数据，从而节约内存空间。SpringDataRedis就提供了RedisTemplate的子类：<code>StringRedisTemplate</code>，它的key和value的序列化方式默认就是String方式。</p><p>省去了自定义RedisTemplate的序列化方式的步骤，而是直接使用：StringRedisTemplate</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">HmDianPingApplicationTests</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;    <span class="hljs-comment">//进行序列化和反序列化的工具</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();        <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUser</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException &#123;        <span class="hljs-comment">//创建对象</span>        <span class="hljs-type">TestUser</span> <span class="hljs-variable">testUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TestUser</span>(<span class="hljs-string">&quot;Lucy&quot;</span>, <span class="hljs-number">21</span>);        <span class="hljs-comment">//手动序列化</span>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(testUser);        <span class="hljs-comment">//写入数据</span>        stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;user:200&quot;</span>,json);        <span class="hljs-comment">//获取数据</span>        <span class="hljs-type">String</span> <span class="hljs-variable">jsonUser</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;user:200&quot;</span>);        <span class="hljs-comment">//反序列化</span>        <span class="hljs-type">TestUser</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.readValue(jsonUser, TestUser.class);        System.out.println(<span class="hljs-string">&quot;user =&quot;</span>+ user);    &#125;&#125;</code></pre></div><p>此时存储的内容没有之前的class信息，节约了存储空间</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241211013242601-2024-12-1101:32:44.png" alt="image-20241211013242601" style="zoom:80%;" /></p><h2 id="补充">补充</h2><p>Windows的Redis图形化客户端连接不上虚拟机中的Redis问题</p><p><strong>1、修改redis.conf配置文件</strong></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241212095439904-2024-12-1209:56:28.png"alt="image-20241212095439904" /><figcaption aria-hidden="true">image-20241212095439904</figcaption></figure><p><strong>2、在linux下的防火墙中开放6379端口</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> firewall-cmd --zone=public --add-port=6379/tcp --permanent</code></pre></div><p><strong>3、重新载入firewalld以应用更改</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> firewall-cmd --reload</code></pre></div><p><strong>4、检查端口是否已开放</strong></p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> firewall-cmd --zone=public --list-ports</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>Redis基本数据类型</tag>
      
      <tag>Jedis</tag>
      
      <tag>SpringDataRedis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis</title>
    <link href="/1bff3c65/"/>
    <url>/1bff3c65/</url>
    
    <content type="html"><![CDATA[<meta name = "referrer", content = "no-referrer"/><h2 id="一简介">一、简介</h2><p>https://mybatis.org/mybatis-3/zh/index.html</p><h3 id="什么是mybatis">1.1、什么是mybatis</h3><ul><li>MyBatis 是一款优秀的<strong>持久层</strong>框架，它支持自定义SQL、存储过程以及高级映射。</li><li>MyBatis 免除了几乎所有的 JDBC代码以及设置参数和获取结果集的工作。</li><li>MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 JavaPOJO（Plain Old Java Objects，普通老式 Java对象）为数据库中的记录。</li></ul><h3 id="持久化动作">1.2、持久化（动作）</h3><p>数据持久化</p><ul><li>持久化就是将程序的数据在持久状态和瞬时状态转化的过程</li><li>内存：断电即失</li><li>数据库（Jdbc），io文件持久化。</li><li>生活：冷藏.罐头。</li></ul><h3 id="持久层名词">1.3、持久层（名词）</h3><p>Dao层，Service层，Controller层.</p><ul><li>完成持久化工作的代码块</li><li>层界限十分明显。</li></ul><h2 id="二第一个mybatis程序">二、第一个mybatis程序</h2><h3 id="搭建环境">2.1、搭建环境</h3><h3 id="创建一个模块">2.2、创建一个模块</h3><h4 id="编写mybatis核心配置文件">编写mybatis核心配置文件</h4><p>每个基于 MyBatis 的应用都是以一个 <strong>SqlSessionFactory</strong>的实例为核心的。SqlSessionFactory 的实例可以通过SqlSessionFactoryBuilder获得。而 SqlSessionFactoryBuilder 则可以从 <strong>XML配置文件</strong>或一个预先配置的 Configuration 实例来构建出SqlSessionFactory 实例。</p><p>XML 配置文件中包含了对 MyBatis系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。后面会再探讨XML 配置文件的详细内容，这里先给出一个简单的示例：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--configuration 核心配置文件--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=Hongkong<span class="hljs-symbol">&amp;amp;</span>useSSL=false<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;liuhao123&quot;</span>/&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span>    <span class="hljs-comment">&lt;!--每一个Mapper.xml文件都需要在mybatis核心配置文件中注册--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/hao/dao/UserMapper.xml&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></code></pre></div><p>从 XML 文件中构建 SqlSessionFactory的实例非常简单，建议使用类路径下的资源文件进行配置。但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或file:// URL 构造的输入流。MyBatis 包含一个名叫 Resources的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>; <span class="hljs-comment">//xml文件</span><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);  <span class="hljs-comment">//读取xml文件</span><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream); <span class="hljs-comment">//加载文件流创建工厂</span></code></pre></div><p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过SqlSession 实例来直接执行已映射的 SQL 语句。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession()) &#123;  <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> (Blog) session.selectOne(<span class="hljs-string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="hljs-number">101</span>);&#125;</code></pre></div><p>诚然，这种方式能够正常工作，对使用旧版本 MyBatis的用户来说也比较熟悉。但现在有了一种更简洁的方式——使用和指定语句的参数和返回值相匹配的接口（比如BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession()) &#123;  <span class="hljs-type">BlogMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(BlogMapper.class);  <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> mapper.selectBlog(<span class="hljs-number">101</span>);&#125;</code></pre></div><h4 id="编写mybatis工具类">编写mybatis工具类</h4><p>通过上述方法，创建工具类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hao.utils;<span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-comment">//sqlSessionFactor ---&gt;sqlSession</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisUtils</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//获取sqlSessionFactory对象</span>            <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>; <span class="hljs-comment">//xml文件</span>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);  <span class="hljs-comment">//读取xml文件</span>             sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream); <span class="hljs-comment">//加载文件流创建工厂</span>        &#125;<span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;<span class="hljs-comment">//返回sqlSession对象</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();    &#125;&#125;</code></pre></div><h3 id="编写代码">2.3、编写代码</h3><ul><li><p>实体类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hao.pojo;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String pwd;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name, String pwd)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;        <span class="hljs-built_in">this</span>.name = name;        <span class="hljs-built_in">this</span>.pwd = pwd;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPwd</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> pwd;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPwd</span><span class="hljs-params">(String pwd)</span> &#123;        <span class="hljs-built_in">this</span>.pwd = pwd;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User&#123;&quot;</span> +                <span class="hljs-string">&quot;id=&quot;</span> + id +                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, pwd=&#x27;&quot;</span> + pwd + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div></li><li><p>Dao接口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hao.dao;<span class="hljs-keyword">import</span> com.hao.pojo.User;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;    <span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title function_">getUserList</span><span class="hljs-params">()</span>;&#125;</code></pre></div></li><li><p>接口实现类 : 由原来的UseDaoImpl 转变为一个Mapper配置文件</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--namespace 绑定一个Dao/Mapper接口 ，相当于创建了对应接口的实现类--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--id绑定对应接口的方法 ，相当于实现该方法。  select 查询语句。 resultType/resultMap 返回结果--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.hao.pojo.User&quot;</span>&gt;</span>        select * from mybatis.user    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div></li></ul><h3 id="测试">2.4、测试</h3><p>注意点：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//UserDao这个Mapper没有被注册</span>org.apache.ibatis.binding.BindingException: Type <span class="hljs-keyword">interface</span> <span class="hljs-title class_">com</span>.hao.dao.UserDao is not known to the MapperRegistry.</code></pre></div><p><strong>每一个Mapper.xml文件都需要在mybatis核心配置文件中注册</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hao.dao;<span class="hljs-keyword">import</span> com.hao.pojo.User;<span class="hljs-keyword">import</span> com.hao.utils.MybatisUtils;<span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoTest</span> &#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//1、获取SQLSession对象</span>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();        <span class="hljs-comment">//2、执行sql</span>        <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserDao.class);        List&lt;User&gt; userList = userDao.getUserList();        <span class="hljs-keyword">for</span> (User user: userList) &#123;            System.out.println(user.toString());        &#125;        <span class="hljs-comment">//3、关闭SQLSession</span>        sqlSession.close();    &#125;&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220519220624809-2024-12-921:58:36.png"alt="image-20220519220624809" /><figcaption aria-hidden="true">image-20220519220624809</figcaption></figure><p>----------------------编写流程：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220519221147004-2024-12-921:58:45.png"alt="image-20220519221147004" /><figcaption aria-hidden="true">image-20220519221147004</figcaption></figure><h2 id="三crud">三、CRUD</h2><h3 id="namespace">3.1、namespace</h3><p>namespace中的包名要和Dao/mapper接口的包名一致！</p><h3 id="select">3.2、select</h3><p>参数：</p><ul><li>id：对应namespace中的方法名，即绑定对应接口中的一个方法。<ul><li>resultType：sql语句的返回值类型</li></ul></li><li>parameterType：参数类型</li></ul><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.hao.pojo.User&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span>    select * from mybatis.user where id = #&#123;id&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>通过<strong>#{}</strong>读取对应方法中的参数</p><h4 id="模糊查询">模糊查询</h4><ol type="1"><li><p>java代码执行的时候添加通配符</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;User&gt; userList = userMapper.getUserListByLike(<span class="hljs-string">&quot;%李%&quot;</span>);</code></pre></div></li><li><p>在sql拼接中使用通配符（存在sql注入风险）</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserListByLike&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.hao.pojo.User&quot;</span>&gt;</span>    select * from mybatis.user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div></li></ol><h3 id="insert">3.3、insert</h3><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//添加一个用户</span><span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--参数对象中的属性可以直接取出来--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.hao.pojo.User&quot;</span>&gt;</span>        insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div><p>测试时注意：<strong>增删改需要提交事务后才能生效</strong></p><p>测试:</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//1、获取SQLSession对象</span>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();        <span class="hljs-comment">//2、执行sql</span>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;赵六&quot;</span>, <span class="hljs-string">&quot;1234567&quot;</span>);        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> userMapper.addUser(user);        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;            System.out.println(<span class="hljs-string">&quot;执行成功！&quot;</span>);        &#125;        <span class="hljs-comment">//提交事务</span>        sqlSession.commit();                <span class="hljs-comment">//3、关闭SQLSession</span>        sqlSession.close();    &#125;</code></pre></div><p>万能的map</p><p>当我们的实体类或数据库中的表，参数或者字段过多时，我们应当考虑使用map。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">addUser2</span><span class="hljs-params">(Map&lt;String,Object&gt; map)</span>;</code></pre></div><p>使用map时，通过map的key来取得数据。key可以自己定义，不必和数据库字段或实体类属性相同。可以传递任意个。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser2&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span>    insert into mybatis.user (id, name, pwd) values (#&#123;userId&#125;, #&#123;userName&#125;, #&#123;password&#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser2</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//1、获取SQLSession对象</span>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();    <span class="hljs-comment">//2、执行sql</span>    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">userMapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    map.put(<span class="hljs-string">&quot;userId&quot;</span>,<span class="hljs-number">2</span>);    map.put(<span class="hljs-string">&quot;userName&quot;</span>,<span class="hljs-string">&quot;李四&quot;</span>);    map.put(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;1231456&quot;</span>);    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> userMapper.addUser2(map);    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;        System.out.println(<span class="hljs-string">&quot;执行成功！&quot;</span>);    &#125;    <span class="hljs-comment">//提交事务</span>    sqlSession.commit();    <span class="hljs-comment">//3、关闭SQLSession</span>    sqlSession.close();&#125;</code></pre></div><ul><li>map传递参数，直接在sql中取出key即可。</li><li>对象传递参数，直接在sql中取出对象属性即可。</li><li>只有一个基本类型参数的情况下，可以直接在sql中取到。</li></ul><h3 id="update">3.4、update</h3><h3 id="delete">3.5、 delete</h3><h2 id="四配置解析">四、配置解析</h2><h3 id="核心配置文件">4.1、核心配置文件</h3><p>mybatis-config.xml</p><p>MyBatis 配置包含对 MyBatis行为有显着影响的设置和属性。文档的高层结构如下：</p><ul><li>configuration（配置）<ul><li><ahref="https://mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a></li><li><ahref="https://mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a></li><li><ahref="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a></li><li><ahref="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li><li><ahref="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li><li><ahref="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li><li>environments（环境配置）<ul><li>environment（环境变量）<ul><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li></ul></li></ul></li><li><ahref="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li><li><ahref="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a></li></ul></li></ul><h3 id="环境配置enviroments">4.2、环境配置(enviroments)</h3><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL映射应用于多种数据库之中</p><p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory实例只能选择一种环境。</strong>所以，如果你想连接两个数据库，就需要创建两个SqlSessionFactory 实例，每个数据库对应一个。</p><p>为了指定创建哪种环境，只要将它作为可选的参数传递给SqlSessionFactoryBuilder 即可。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(reader, environment);<span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(reader, environment, properties);</code></pre></div><p>如果忽略了环境参数(enviroment)，那么将会加载默认环境。</p><p>environments 元素定义了如何配置环境。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;...&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span></code></pre></div><ul><li>默认环境是 id为development的环境</li><li>每个环境包含 <strong>事务管理器的配置</strong>(transactionManager)和 <strong>数据源的配置</strong>(dataSource)</li></ul><p><strong>事务管理器(transactionManager)</strong></p><p>​ 在 MyBatis 中有两种类型的事务管理器（也就是type="[<strong>JDBC</strong>|<strong>MANAGED</strong>]"）</p><ul><li><p>JDBC</p></li><li><p>这个配置直接使用了 JDBC的提交和回滚功能，它依赖从数据源获得的连接来管理事务作用域。</p></li><li><p>MANAGED</p><ul><li>这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期。</li></ul></li></ul><p><strong>数据源(dataSource)</strong></p><p>​ dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC连接对象的资源。</p><p>​ 有三种内建的数据源类型（也就是type="[<strong>UNPOOLED</strong>|<strong>POOLED</strong>|<strong>JNDI</strong>]"）：</p><ul><li>UNPOOLED<ul><li>没有连接池。这个数据源的实现会每次请求时打开和关闭连接。</li></ul></li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20220525091721413-2024-12-922:03:51.png" alt="image-20220525091721413" style="zoom:150%;" /></p><ul><li>POOLED<ul><li>带连接池的。每次从池中获取链接，使用完后回收链接而不是关闭。避免了创建新的连接实例时所必需的初始化和认证时间。</li><li>常用的数据库连接池：dbcp、c3p0、druid</li><li>默认是有池的连接 <imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220525091703820-2024-12-922:04:01.png"alt="image-20220525091703820" /></li></ul></li><li>JNDI<ul><li>这个数据源实现是为了能在如 EJB或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个JNDI 上下文的数据源引用。</li></ul></li></ul><p><strong>Mybatis默认使用的事务管理器是JDBC，数据源默认使用连接池：POOLED</strong></p><h3 id="属性properties">4.3、属性(properties)</h3><p>我们可以通过properties属性来实现引用配置文件</p><p>这些属性都是可外部配置且可动态替换的，既可以在典型的Java属性文件中配置，亦可通过properties元素的子元素来传递。【db.properties】</p><ul><li><p>编写一个配置文件 dp.properties</p><p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?serverTimezone=Hongkong&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><span class="hljs-attr">username</span>=<span class="hljs-string">root   </span><span class="hljs-attr">password</span>=<span class="hljs-string">liuhao123</span></code></pre></div></p></li><li><p>在核心配置文件中引入 <div class="code-wrapper"><pre><code class="hljs xml">   <span class="hljs-comment">&lt;!--引入配置文件--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;dp.properties&quot;</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-comment">&lt;!--使用配置文件中的属性，通过$&#123;&#125;--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span></code></pre></div></p><p>在properties标签内部也可以定义一些属性<strong>作为补充</strong>，而当有相同字段时，<strong>优先读取外部配置文件</strong>中的属性。</p></li></ul><p>注意：xml文件中的标签是可以定义顺序的，如在核心配置文件中，必须遵守以下的标签顺序：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220525093326045-2024-12-922:09:05.png"alt="image-20220525093326045" /><figcaption aria-hidden="true">image-20220525093326045</figcaption></figure><h3 id="类型别名typealiases">4.4、类型别名(typeAliases)</h3><p>类型别名是为Java类型<strong>设置一个短的名字</strong>。它只和XML配置有关，存在的意义仅在于用<strong>来减少类完全限定名的冗余。</strong></p><p>如之前返回值类型需要填写完整的类完全限定名com.hao.pojo.user，此时可以通过设置类型别名来使用一个简单名字来优化。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.hao.pojo.User&quot;</span>&gt;</span>    select * from mybatis.user;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>方法一：在typeAliases标签中为需要起别名的类，添加别名。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--给类起别名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.hao.pojo.User&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;User&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span></code></pre></div><p>方法二：可以指定一个包，MyBatis 会在包名下面搜索需要的 JavaBean。<strong>在没有注解的情况下</strong>，会使用 Bean的<strong>首字母小写</strong>的非限定类名来作为它的别名。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--给类起别名--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.hao.pojo&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span></code></pre></div><ul><li>比较</li></ul><p>在实体类较少的时候使用第一种方式，如果实体类较多则使用第二种。</p><p>第一种方式可以自定义别名，第二种则默认为类名首字母小写。若在第二种方式下也要自定义别名，需要在实体类上添加注解。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Alias(&quot;hello&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;&#125;</code></pre></div><h3 id="设置settings">4.5、设置(settings)</h3><p><strong>这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis的运行时行为。</strong></p><p>其中主要使用到的如下，其余见官网文档。</p><table><thead><tr class="header"><th style="text-align: left;">设置名</th><th style="text-align: left;">描述</th><th style="text-align: left;">有效值</th><th style="text-align: left;">默认值</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">cacheEnabled</td><tdstyle="text-align: left;">全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。</td><td style="text-align: left;">true | false</td><td style="text-align: left;">true</td></tr><tr class="even"><td style="text-align: left;">lazyLoadingEnabled</td><tdstyle="text-align: left;">延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。特定关联关系中可通过设置 <code>fetchType</code>属性来覆盖该项的开关状态。</td><td style="text-align: left;">true | false</td><td style="text-align: left;">false</td></tr><tr class="odd"><td style="text-align: left;">useColumnLabel</td><tdstyle="text-align: left;">使用列标签代替列名。实际表现依赖于数据库驱动，具体可参考数据库驱动的相关文档，或通过对比测试来观察。</td><td style="text-align: left;">true | false</td><td style="text-align: left;">true</td></tr><tr class="even"><td style="text-align: left;">useGeneratedKeys</td><td style="text-align: left;">允许 JDBC支持自动生成主键，需要数据库驱动支持。如果设置为true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如Derby）。</td><td style="text-align: left;">true | false</td><td style="text-align: left;">false</td></tr><tr class="odd"><td style="text-align: left;">mapUnderscoreToCamelCase</td><tdstyle="text-align: left;">是否开启驼峰命名自动映射，即从经典数据库列名A_COLUMN 映射到经典 Java 属性名 aColumn。</td><td style="text-align: left;">true | false</td><td style="text-align: left;">false</td></tr><tr class="even"><td style="text-align: left;">logImpl</td><td style="text-align: left;">指定 MyBatis所用日志的具体实现，未指定时将自动查找。</td><td style="text-align: left;">SLF4J | LOG4J（3.5.9 起废弃） | LOG4J2 |JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING</td><td style="text-align: left;">未设置</td></tr></tbody></table><h3 id="其他配置">4.6、其他配置</h3><ul><li><ahref="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li><li><ahref="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li><li>plugins（插件）<ul><li>mybatis-generator-core</li><li><ahref="https://baomidou.com/pages/24112f/#%E7%89%B9%E6%80%A7">mybatis-plus</a></li><li>通用mapper</li></ul></li></ul><h3 id="映射器mapper">4.7、映射器(mapper)</h3><p>告诉mybatis去哪里寻找我们写好的SQL映射语句，即找到mapper.xml.</p><p>MapperRegistry：注册绑定我们的mapper文件</p><p><strong>方式一</strong>：使用相对于类路径的资源引用(<strong>推荐</strong>)</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--每一个Mapper.xml文件都需要在mybatis核心配置文件中注册--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/hao/mapper/UserMapper.xml&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre></div><p><strong>方式二</strong>：使用class文件绑定注册</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--每一个Mapper.xml文件都需要在mybatis核心配置文件中注册--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.hao.mapper.UserMapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre></div><p>注意点：</p><ul><li>接口和它的mapper配置文件<strong>必须同名</strong></li><li>接口和它的mapper配置文件<strong>必须在同一个包下</strong>，否则找不到。</li></ul><p><strong>方式三</strong>：使用扫描包进行绑定</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--每一个Mapper.xml文件都需要在mybatis核心配置文件中注册--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.hao.mapper&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre></div><p>注意点：</p><ul><li>接口和它的mapper配置文件必须同名</li><li>接口和它的mapper配置文件必须在同一个包下，否则找不到。</li></ul><h3 id="生命周期和作用域">4.8、生命周期和作用域</h3><p>作用域和生命周期类别是至关重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong>。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220525105645605-2024-12-922:09:25.png"alt="image-20220525105645605" /><figcaption aria-hidden="true">image-20220525105645605</figcaption></figure><p><strong>SqlSessionFactoryBuilder</strong>：</p><ul><li>一旦创建了 SqlSessionFactory，就不再需要它了。</li><li>局部变量</li></ul><p><strong>SqlSessionFactory</strong></p><ul><li>可以想象为<strong>数据库连接池</strong></li><li>SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建另一个实例</strong>。</li><li>因此 SqlSessionFactory的最佳作用域是<strong>应用作用域</strong>。</li><li>最简单的就是使用单例模式或者静态单例模式。</li></ul><p><strong>SqlSession</strong></p><ul><li>相当于连接到连接池的一个请求</li><li>每个线程都应该有它自己的 SqlSession 实例。</li><li>SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是<strong>请求或方法作用域</strong>。</li><li>用完后赶紧关闭，否则会占用资源。</li></ul><p>三者关系：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220525111254216-2024-12-922:09:33.png"alt="image-20220525111254216" /><figcaption aria-hidden="true">image-20220525111254216</figcaption></figure><p>这里的每一个Mapper，就代表一个具体的业务。</p><h2id="五解决字段名和属性名不一致的问题">五、解决字段名和属性名不一致的问题</h2><h3 id="问题">5.1、问题</h3><p>数据库中的字段：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220525113551949-2024-12-922:09:42.png"alt="image-20220525113551949" /><figcaption aria-hidden="true">image-20220525113551949</figcaption></figure><p>实体类的属性：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String password; <span class="hljs-comment">//和数据库中的不一致</span>&#125;</code></pre></div><p>测试通过id获取用户，对应的sql语句</p><div class="code-wrapper"><pre><code class="hljs java">select * from mybatis.user <span class="hljs-type">where</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> #&#123;id&#125;;<span class="hljs-comment">//---------&gt;</span>select id, name, pwd from mybatis.user <span class="hljs-type">where</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> #&#123;id&#125;;</code></pre></div><p>结果出现异常：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220525113817281-2024-12-922:09:44.png"alt="image-20220525113817281" /><figcaption aria-hidden="true">image-20220525113817281</figcaption></figure><p>解决方法：</p><p><strong>由于从数据库中取出的数据不能准确映射到实体类的属性，所以出现了错误。</strong></p><p>该例子中没有显式地配置一个resultMap,但MyBatis会在幕后<strong>自动创建</strong>一个<code>ResultMap</code>，再根据属性名来映射列到 JavaBean的属性上。如果列名和属性名不能匹配上，可以在 SELECT语句中设置列别名（这是一个基本的 SQL 特性）来完成匹配</p><ul><li><p>起别名</p><div class="code-wrapper"><pre><code class="hljs xml">select id, name, pwd as password from mybatis.user where id = #&#123;id&#125;;</code></pre></div></li></ul><h3 id="resultmap">5.2、resultMap</h3><p>结果集映射</p><div class="code-wrapper"><pre><code class="hljs java">id name pwdid name password</code></pre></div><p>使用resultMap进行映射</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--column 数据库中的字段  property 实体类的属性--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span>    select * from mybatis.user where id = #&#123;id&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p><strong>resultMap</strong></p><ul><li><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。</li><li>ResultMap的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</li></ul><h2 id="六日志">六、日志</h2><h3 id="日志工厂">6.1、日志工厂</h3><p>如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手！</p><p>曾经：sout，debug</p><p>现在：日志工厂！</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220525163711323-2024-12-922:09:52.png"alt="image-20220525163711323" /><figcaption aria-hidden="true">image-20220525163711323</figcaption></figure><ul><li>SLF4J</li><li>LOG4J(deprecated since 3.5.9) （掌握）</li><li>LOG4J2</li><li>JDK_LOGGING</li><li>COMMONS_LOGGING</li><li>STDOUT_LOGGING （掌握） 标准日志工厂实现</li><li>NO_LOGGING</li></ul><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span></code></pre></div><p>测试时在控制台输出：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220525164842001-2024-12-922:10:45.png"alt="image-20220525164842001" /><figcaption aria-hidden="true">image-20220525164842001</figcaption></figure><h3 id="log4j">6.2、Log4j</h3><p>什么是Log4j？</p><ul><li>Log4j是<ahref="https://baike.baidu.com/item/Apache/8512995">Apache</a>的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是<ahref="https://baike.baidu.com/item/控制台/2438626">控制台</a>、文件、<ahref="https://baike.baidu.com/item/GUI">GUI</a>组件，甚至是套接口服务器、<ahref="https://baike.baidu.com/item/NT/3443842">NT</a>的事件记录器、<ahref="https://baike.baidu.com/item/UNIX">UNIX</a> <ahref="https://baike.baidu.com/item/Syslog">Syslog</a><ahref="https://baike.baidu.com/item/守护进程/966835">守护进程</a>等；</li><li>我们也可以控制每一条日志的输出格式</li><li>通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</li><li>可以通过一个<ahref="https://baike.baidu.com/item/配置文件/286550">配置文件</a>来灵活地进行配置，而不需要修改应用的代码。</li></ul><p>1、导包</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- log4j --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2、添加配置 log4j.properties</p><div class="code-wrapper"><pre><code class="hljs properties"><span class="hljs-comment">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码</span><span class="hljs-attr">log4j.rootLogger</span>=<span class="hljs-string">DEBUG,console,file</span><span class="hljs-comment"></span><span class="hljs-comment">#控制台输出的相关设置</span><span class="hljs-attr">log4j.appender.console</span> = <span class="hljs-string">org.apache.log4j.ConsoleAppender</span><span class="hljs-attr">log4j.appender.console.Target</span> = <span class="hljs-string">System.out</span><span class="hljs-attr">log4j.appender.console.Threshold</span>=<span class="hljs-string">DEBUG</span><span class="hljs-attr">log4j.appender.console.layout</span> = <span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-attr">log4j.appender.console.layout.ConversionPattern</span>=<span class="hljs-string">[%c]-%m%n</span><span class="hljs-comment"></span><span class="hljs-comment">#文件输出的相关设置</span><span class="hljs-attr">log4j.appender.file</span> = <span class="hljs-string">org.apache.log4j.RollingFileAppender</span><span class="hljs-attr">log4j.appender.file.File</span>=<span class="hljs-string">./log/kuang.log</span><span class="hljs-attr">log4j.appender.file.MaxFileSize</span>=<span class="hljs-string">10mb</span><span class="hljs-attr">log4j.appender.file.Threshold</span>=<span class="hljs-string">DEBUG</span><span class="hljs-attr">log4j.appender.file.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-attr">log4j.appender.file.layout.ConversionPattern</span>=<span class="hljs-string">[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n</span><span class="hljs-comment"></span><span class="hljs-comment">#日志输出级别</span><span class="hljs-attr">log4j.logger.org.mybatis</span>=<span class="hljs-string">DEBUG</span><span class="hljs-attr">log4j.logger.java.sql</span>=<span class="hljs-string">DEBUG</span><span class="hljs-attr">log4j.logger.java.sql.Statement</span>=<span class="hljs-string">DEBUG</span><span class="hljs-attr">log4j.logger.java.sql.ResultSet</span>=<span class="hljs-string">DEBUG</span><span class="hljs-attr">log4j.logger.java.sql.PreparedStatement</span>=<span class="hljs-string">DEBUG</span></code></pre></div><p>3、测试输出</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220525172132457-2024-12-922:10:57.png"alt="image-20220525172132457" /><figcaption aria-hidden="true">image-20220525172132457</figcaption></figure><p><strong>简单使用</strong></p><p>1、在要使用Log4j的类中，导入包<code>import org.apache.log4j.Logger</code>;</p><p>2、日志对象，参数为当前类的class</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(UserDaoTest.class);</code></pre></div><p>3、日志级别</p><div class="code-wrapper"><pre><code class="hljs java">logger.info(<span class="hljs-string">&quot;info:进入了testLog4j&quot;</span>);logger.debug(<span class="hljs-string">&quot;debug:进入了testLog4j&quot;</span>);logger.error(<span class="hljs-string">&quot;error:进入了testLog4j&quot;</span>);</code></pre></div><h2 id="七分页">七、分页</h2><h3 id="使用limit分页-推荐">7.1、使用limit分页 （推荐）</h3><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> limit startIndex,pageSize;</code></pre></div><p>在mybatis中使用</p><p>1、接口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//分页查询</span>List&lt;User&gt; <span class="hljs-title function_">getUserListByLimit</span><span class="hljs-params">(Map map)</span>;</code></pre></div><p>2、mapper.xml</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserListByLimit&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span>    select * from mybatis.user limit #&#123;startIndex&#125;, #&#123;pageSize&#125;</code></pre></div><p>3、测试</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetUerListByLimit</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();    map.put(<span class="hljs-string">&quot;startIndex&quot;</span>,<span class="hljs-number">0</span>);    map.put(<span class="hljs-string">&quot;pageSize&quot;</span>,<span class="hljs-number">2</span>);    List&lt;User&gt; userList = mapper.getUserListByLimit(map);    <span class="hljs-keyword">for</span>(User user:userList) &#123;        System.out.println(user);    &#125;&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220525180052212-2024-12-922:11:05.png"alt="image-20220525180052212" /><figcaption aria-hidden="true">image-20220525180052212</figcaption></figure><h3 id="rowbounds实现分页">7.2、RowBounds实现分页</h3><p>不再使用Sql实现，而是使用java对象 RowBounds。不推荐</p><p>1、接口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//分页查询2</span>List&lt;User&gt; <span class="hljs-title function_">getUserListByRowBounds</span><span class="hljs-params">()</span>;</code></pre></div><p>2、mapper.xml</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserListByRowBounds&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span>    select * from mybatis.user;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>3、测试</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetUserListByRowBounds</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();    <span class="hljs-comment">//RowBounds实现</span>    <span class="hljs-type">RowBounds</span> <span class="hljs-variable">rowBounds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RowBounds</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);    List&lt;User&gt; userList = sqlSession.selectList(<span class="hljs-string">&quot;com.hao.mapper.UserMapper.getUserListByRowBounds&quot;</span>, <span class="hljs-literal">null</span>, rowBounds);    <span class="hljs-keyword">for</span> (User user : userList) &#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220525181339906-2024-12-922:11:13.png"alt="image-20220525181339906" /><figcaption aria-hidden="true">image-20220525181339906</figcaption></figure><h3 id="分页插件">7.3、分页插件</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220525181646324-2024-12-922:11:18.png"alt="image-20220525181646324" /><figcaption aria-hidden="true">image-20220525181646324</figcaption></figure><p><a href="https://pagehelper.github.io/docs/">查看</a></p><h2 id="八使用注解开发">八、使用注解开发</h2><p>1、注解在接口上实现</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;    <span class="hljs-meta">@Select(&quot;select * from mybatis.user&quot;)</span>    List&lt;User&gt; <span class="hljs-title function_">getUserList</span><span class="hljs-params">()</span>;&#125;</code></pre></div><p>2、<strong>在核心配置文件中绑定接口</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.hao.mapper.UserMapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span></code></pre></div><p>3、测试</p><p>本质：反射机制</p><p>底层：动态代理</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220526171648377-2024-12-922:11:27.png"alt="image-20220526171648377" /><figcaption aria-hidden="true">image-20220526171648377</figcaption></figure><p><strong>Mybatis详细执行流程：</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/mybatis-2024-12-922:11:32.png" alt="mybatis" style="zoom: 100%;" /></p><p><ahref="https://www.processon.com/diagraming/628d98f50e3e747f1e8dcde6">图片</a></p><h3 id="param">8.1、<span class="citation"data-cites="Param">@Param</span></h3><p>在实际的开发中，经常会遇到<strong>多个接口参数</strong>的情况。在之前的例子中，我们都是将多个参数合并到一个JavaBean中，但是不可能每次都为不同的参数创建一个新的JavaBean，所以需要使用其他方式来传递多个参数，常见的方法有使用<strong>Map类型</strong>和使用<strong><spanclass="citation" data-cites="param注解">@param注解</span></strong></p><p><span class="citation"data-cites="Param的作用就是">@Param的作用就是</span><strong>给参数命名</strong>，比如在mapper里面某方法A（intid），当添加注解后A（<span class="citation"data-cites="Param">@Param</span>("userId") intid），也就是说外部想要取出传入的id值，<strong>只需要取它的参数名userId就可以了</strong>。将参数值传如SQL语句中，通过#{userId}进行取值给SQL的参数赋值。</p><ul><li>方法存在多个参数，所有参数前面必须加上 <span class="citation"data-cites="Param">@Param</span>("")注解</li></ul><p>当使用@Param给参数命名后，在xml或注解形式下使用 #{}取值</p><p><strong>XML形式下</strong>：</p><ul><li><strong><span class="citation"data-cites="Param注解单一属性">@Param注解单一属性</span></strong><ul><li>这里给参数配置@param注解后，Mybatis会自动将参数封装成<strong>Map类型</strong>，而@param注解的值会成为Map中的key，因此在sql中可以通过配置的注解值来使用参数。</li><li>使用注解传递参数,这时是不涉及单独一个类型的,所以<strong>去掉parameterType属性</strong></li></ul></li><li><strong><span class="citation"data-cites="Param注解JavaBean对象">@Param注解JavaBean对象</span></strong><ul><li>当参数是JavaBean类型时，使用@param注解后就不能直接使用，而是要通过<strong>点取值</strong>的方式。</li><li>在没有注解时，可以直接使用该JavaBean的属性</li></ul></li></ul><p><strong>注解形式下：同上</strong></p><h3 id="crud">8.2、CRUD</h3><p>编写接口，增加注解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;    <span class="hljs-meta">@Select(&quot;select * from mybatis.user&quot;)</span>    List&lt;User&gt; <span class="hljs-title function_">getUserList</span><span class="hljs-params">()</span>;    <span class="hljs-meta">@Select(&quot;select * from mybatis.user where id = #&#123;userId&#125;&quot;)</span>    User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userId&quot;)</span> <span class="hljs-type">int</span> id)</span>;    <span class="hljs-meta">@Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)</span>    <span class="hljs-type">int</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(User user)</span>;    <span class="hljs-meta">@Update(&quot;update user set name = #&#123;user.name&#125; where id = #&#123;user.id&#125;&quot;)</span>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;user&quot;)</span> User user)</span>;    <span class="hljs-meta">@Delete(&quot;delete from user where id = #&#123;uid&#125;&quot;)</span>    <span class="hljs-type">int</span> <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;uid&quot;)</span> <span class="hljs-type">int</span> id)</span>;&#125;</code></pre></div><p>测试</p><blockquote><p>我们必须要将接口注册绑定到我们的核心配置文件中</p></blockquote><h2 id="九lombok">九、Lombok</h2><p>有好有坏，适当使用。</p><p>1、在IDEA中下载 LomBok插件</p><p>2、在项目中导入jar包</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>3、在实体类上添加注解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> String password;&#125;</code></pre></div><p>所包含的注解：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span> and <span class="hljs-meta">@Setter</span><span class="hljs-meta">@FieldNameConstants</span><span class="hljs-meta">@ToString</span><span class="hljs-meta">@EqualsAndHashCode</span><span class="hljs-meta">@AllArgsConstructor</span>, <span class="hljs-meta">@RequiredArgsConstructor</span> and <span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@Log</span>, <span class="hljs-meta">@Log4j</span>, <span class="hljs-meta">@Log4j2</span>, <span class="hljs-meta">@Slf4j</span>, <span class="hljs-meta">@XSlf4j</span>, <span class="hljs-meta">@CommonsLog</span>, <span class="hljs-meta">@JBossLog</span>, <span class="hljs-meta">@Flogger</span>, <span class="hljs-meta">@CustomLog</span><span class="hljs-meta">@Data</span><span class="hljs-meta">@Builder</span><span class="hljs-meta">@SuperBuilder</span><span class="hljs-meta">@Singular</span><span class="hljs-meta">@Delegate</span><span class="hljs-meta">@Value</span><span class="hljs-meta">@Accessors</span><span class="hljs-meta">@Wither</span><span class="hljs-meta">@With</span><span class="hljs-meta">@SneakyThrows</span><span class="hljs-meta">@val</span><span class="hljs-meta">@var</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//常用</span><span class="hljs-meta">@Data</span> ：添加Getter、Setter、无参构造器、equals、hashCode、toString<span class="hljs-meta">@AllArgsConstructor</span>： 添加有参构造器（所有参数）<span class="hljs-meta">@Getter</span> and <span class="hljs-meta">@Setter</span>：可以加在类前面，也可以加在属性前面</code></pre></div><h2 id="十多对一处理">十、多对一处理</h2><ul><li>多个学生，对应一个老师</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220527110704142-2024-12-922:11:51.png"alt="image-20220527110704142" /><figcaption aria-hidden="true">image-20220527110704142</figcaption></figure><ul><li>对于学生这边而言，<strong>关联</strong>..多个学生，关联一个老师【多对一】</li><li>对于老师而言，<strong>集合</strong>，一个老师，有很多学生【一对多】</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220527103918366-2024-12-922:11:55.png"alt="image-20220527103918366" /><figcaption aria-hidden="true">image-20220527103918366</figcaption></figure><p>实体类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">//学生需要关联一个老师</span>    <span class="hljs-keyword">private</span> Teacher teacher; <span class="hljs-comment">//对象</span>&#125;<span class="hljs-comment">//数据库中对应的列是 id name tid</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hao.pojo;<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String name;&#125;</code></pre></div><p>mapper</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentMapper</span> &#123;    List&lt;Student&gt; <span class="hljs-title function_">getStudents</span><span class="hljs-params">()</span>;&#125;</code></pre></div><p><strong>按照嵌套查询</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudents&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;stu_list&quot;</span>&gt;</span>    select * from student<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;stu_list&quot;</span>   <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!--复杂类型需要单独处理</span><span class="hljs-comment">            对象：association</span><span class="hljs-comment">            集合：collection</span><span class="hljs-comment">        --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getTeacher&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><span class="hljs-comment">&lt;!--子查询--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span>    select * from teacher where id = #&#123;tid&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">通过子查询得到实体类所需的属性</span><span class="hljs-comment">--&gt;</span></code></pre></div><p><strong>按照连接查询</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudents&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;student_list&quot;</span>&gt;</span>    select s.id sid, s.name sname, t.name tname    from student s, teacher t    where s.tid = t.id<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student_list&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--由于sql中使用了别名，数据库中的列名改为别名--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><span class="hljs-comment">&lt;!--</span><span class="hljs-comment">使用连接查询，将所需要的的所有信息都查出来，由于此时的返回值不对应任何一个实体类，所以使用resultMap将查询到的值，都填到方法返回值所需的实体类中。</span><span class="hljs-comment">--&gt;</span></code></pre></div><p>测试</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();    <span class="hljs-type">StudentMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentMapper.class);    List&lt;Student&gt; students = mapper.getStudents();    <span class="hljs-keyword">for</span> (Student student : students) &#123;        System.out.println(student);    &#125;&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20220530093648543-2024-12-922:12:06.png" alt="image-20220530093648543" style="zoom:80%;" /></p><h2 id="十一一对多处理">十一、一对多处理</h2><p>比如：一个老师拥有多个学生。</p><p>对老师而言就是一对多的关系</p><p>实体类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">//一个老师拥有多个学生</span>    <span class="hljs-keyword">private</span> List&lt;Student&gt; students;&#125;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tid;&#125;</code></pre></div><p>mapper</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TeacherMapper</span> &#123;    <span class="hljs-comment">//获取指定老师的信息，及其所有学生的信息</span>    Teacher <span class="hljs-title function_">getTeacher</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;tid&quot;)</span> <span class="hljs-type">int</span> id)</span>;&#125;</code></pre></div><p><strong>按照结果嵌套处理，连接查询</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;teacher&quot;</span> &gt;</span>    select s.id sid, s.name sname, t.name tname, t.id tid    from student s, teacher t    where s.tid = t.id and t.id = #&#123;tid&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tname&quot;</span>/&gt;</span>    <span class="hljs-comment">&lt;!--复杂类型需要单独处理</span><span class="hljs-comment">                对象：association</span><span class="hljs-comment">                集合：collection</span><span class="hljs-comment">            javaType=&quot;&quot;指定属性的类型</span><span class="hljs-comment">            集合中的泛型信息使用 ofType获取</span><span class="hljs-comment">        --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sid&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;sname&quot;</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;tid&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;tid&quot;</span>/&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></code></pre></div><p><strong>嵌套查询</strong></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;teacher&quot;</span> &gt;</span>    select *    from teacher    where id = #&#123;tid&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Teacher&quot;</span>&gt;</span>    <span class="hljs-comment">&lt;!--student的返回值类型：首先是ArrayList 其次内部泛型是Student--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;students&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;ArrayList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Student&quot;</span> <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;getStudents&quot;</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><span class="hljs-comment">&lt;!--子查询--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStudents&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Student&quot;</span>&gt;</span>    select *    from student    where tid = #&#123;tid&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h4 id="小结">小结</h4><ul><li><p>关联 --- association【多对一】</p></li><li><p>集合 --- collection【一对多】</p></li><li><p>javaType &amp; ofType</p><p>JavaType用来指定实体类中属性的类型</p><p>ofType用来指定映射到List或者集合中的pojo类型，泛型中的约束类型！</p></li></ul><h2 id="十二动态sql">十二、动态SQL</h2><p><strong>什么是动态SQL：动态SQL就是根据不同的条件生成不同的SQL语句</strong></p><p>所谓动态SQL，本质还是SQL语句，只是我们可以在SQL层面，执行一些逻辑代码。</p><h3 id="主要元素">12.1、主要元素</h3><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><h3 id="if">12.2、IF</h3><p>使用动态 SQL 最常见情景是根据条件<strong>包含 where子句的一部分</strong>。</p><p><code>&lt;if test="判断条件"&gt; where 子句的一部分 &lt;/if&gt;</code></p><p>根据判断条件是否为真来<code>动态拼接</code>对应的sql代码。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220530115235733-2024-12-922:12:18.png"alt="image-20220530115235733" /><figcaption aria-hidden="true">image-20220530115235733</figcaption></figure><p>如，在博客表中：根据传入的查询条件查询相应的博客，若传入title不为空，则<strong>添加</strong>title模糊查询；若传入author不为空，<strong>添加</strong>author模糊查询条件；若不传入参数，则返回所有博客。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getBlogIf&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span>    select *    from blog    where 1 = 1    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span>        and title like #&#123;title&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span>        and author like #&#123;author&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>实际中不可能使用where 1= 1这样的语句，为了避免where之后 直接跟逻辑运算符而导致SQL语句错误的情况，需要使用<code>&lt;where&gt; &lt;/where&gt;</code>标签。见下。</p><h3 id="choose-when-otherwise">12.3、choose (when, otherwise)</h3><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis提供了 choose 元素，它有点像 Java 中的 switch 语句。</p><p><strong>choose只选择执行其中一种情况，而if可以多个条件叠加</strong></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">switch</span><span class="hljs-keyword">case</span><span class="hljs-keyword">case</span><span class="hljs-keyword">default</span>choose  whenwhenotherwise</code></pre></div><p>查询博客，若传入了 “title” 就按 “title” 查找，传入了 “author” 就按“author”查找，若两者都没有传入就查询全部</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getBlogChoose&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span>    select *     from blog    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span>                title = #&#123;title&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span>                author = #&#123;author&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span>                views = #&#123;views&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><h3 id="trim-where-set">12.4、trim (where, set)</h3><p><strong>where</strong></p><ul><li><p>为了避免where之后 直接跟逻辑运算符而导致SQL语句错误的情况，需要使用<code>&lt;where&gt; &lt;/where&gt;</code>标签。</p></li><li><p><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE”子句。</p></li><li><p>而且，若子句的开头为 “AND” 或 “OR”，<em>where</em>元素也会将它们去除。</p></li></ul><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getBlogIf&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span>    select *    from blog    where 1 = 1    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span>        and title like #&#123;title&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span>        and author like #&#123;author&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>===========================================================================&gt;    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getBlogIf&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span>        select *        from blog        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span>                title like #&#123;title&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span>                and author like #&#123;author&#125;            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p><strong>set</strong></p><ul><li><p>用于动态更新语句的类似解决方案叫做 <em>set</em></p></li><li><p><em>set</em>元素可以用于动态包含需要更新的列，忽略其它不更新的列。</p></li><li><p><em>set</em> 元素会动态地在行首插入 SET关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。</p></li></ul><p>根据博客id更新博客内容</p><div class="code-wrapper"><pre><code class="hljs mysql">&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt;    update blog    &lt;set&gt;        &lt;if test=&quot;tile != null&quot;&gt;            title = #&#123;title&#125;,        &lt;/if&gt;        &lt;if test=&quot;author != null&quot;&gt;            author = #&#123;author&#125;        &lt;/if&gt;    &lt;/set&gt;    where id = #&#123;id&#125;&lt;/update&gt;</code></pre></div><p>如上，不用写set关键字；若title不为空而author为空时，会自动去掉 title= #{title} , 中的逗号。</p><p><strong>trim</strong></p><ul><li>使用trim可以进一步定制where和set标签的功能</li></ul><h3 id="foreach">12.5、foreach</h3><ul><li><p>动态 SQL的另一个常见使用场景是<strong>对集合进行遍历</strong>（尤其是在构建 IN条件语句的时候）。</p></li><li><p>它允许你指定一个集合，声明可以在元素体内使用的<strong>集合项（item）</strong>和<strong>索引（index）</strong>变量。</p></li><li><p>它也允许你<strong>指定开头与结尾的字符串</strong>以及<strong>集合项迭代之间的分隔符</strong>。</p></li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220530160534936-2024-12-922:12:29.png"alt="image-20220530160534936" /><figcaption aria-hidden="true">image-20220530160534936</figcaption></figure><p>查询 1、2和3号博客</p><div class="code-wrapper"><pre><code class="hljs xml">#sql代码select * from blog where id = 1 or id = 2 or id = 3;#将其拼接成动态SQL<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getBlogForeach&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;blog&quot;</span>&gt;</span>    select *    from blog    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;ids&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;or&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span>            id = #&#123;id&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>拼接后的sql为：</p><div class="code-wrapper"><pre><code class="hljs mysql">select * from blog WHERE ( id = ? or id = ? or id = ? )</code></pre></div><p>测试:</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetBlogForeach</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();    <span class="hljs-type">BlogMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(BlogMapper.class);    Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();    ArrayList&lt;Integer&gt; ids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();    ids.add(<span class="hljs-number">1</span>);    ids.add(<span class="hljs-number">2</span>);    ids.add(<span class="hljs-number">3</span>);    map.put(<span class="hljs-string">&quot;ids&quot;</span>,ids);    List&lt;Blog&gt; blogs = mapper.getBlogForeach(map);    <span class="hljs-keyword">for</span> (Blog blog : blogs) &#123;        System.out.println(blog);    &#125;    sqlSession.close();&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220530161516137-2024-12-922:12:35.png"alt="image-20220530161516137" /><figcaption aria-hidden="true">image-20220530161516137</figcaption></figure><h3 id="sql片段">12.6、SQL片段</h3><p>有时候，我们要将一些功能的部分抽取出来，方便复用。</p><p>1、使用SQL标签抽取公共部分</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;if-title-author&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span>        title like #&#123;title&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null&quot;</span>&gt;</span>        and author like #&#123;author&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span></code></pre></div><p>2、在需要使用的地方 使用 include标签引用即可</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getBlogIf&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span>    select *    from blog    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;if-title-author&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>注意点：</p><ul><li>最好基于单表来定义SQL片段</li><li>其中不要包含where标签</li></ul><h2 id="十三缓存了解">十三、缓存（了解）</h2><h3 id="简介">13.1、简介</h3><p>1、什么是缓存[Cache]？</p><ul><li>保存在内存中的临时数据</li><li>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库数据文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。</li></ul><p>2、为什么使用缓存</p><ul><li><strong>减少和数据库的交互次数</strong>，减少系统开销，提高系统效率。</li></ul><p>3、什么样的数据能使用缓存</p><ul><li><strong>经常查询</strong>并且<strong>不经常改变</strong>的数据。</li></ul><h3 id="mybatis缓存">13.2、mybatis缓存</h3><p>Mybatis系统中默认定义了两级缓存：<strong>一级缓存</strong>和<strong>二级缓存</strong></p><ul><li>默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也成本地缓存）</li><li>二级缓存需要手动开启。（namespace级别的缓存）</li><li>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存。</li></ul><h3 id="一级缓存">13.3、一级缓存</h3><p>一级缓存也叫本地缓存</p><ul><li><p>与数据库同一次会话期间查到的数据会存放在本地缓存中</p></li><li><p>以后如果需要获取<strong>相同的数据</strong>，直接从缓存中拿，而不用再一次去访问数据库。</p></li></ul><p>测试：首先开启日志。</p><p>测试在一个SQLSession中两次查询同一个用户，观察SQL执行情况。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.getUserById(<span class="hljs-number">1</span>);    System.out.println(user);    System.out.println(<span class="hljs-string">&quot;===========================&quot;</span>);    <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span>mapper.getUserById(<span class="hljs-number">1</span>);    System.out.println(user1);    System.out.println(user == user1);    sqlSession.close();&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220530204031937-2024-12-922:12:43.png"alt="image-20220530204031937" /><figcaption aria-hidden="true">image-20220530204031937</figcaption></figure><p>缓存失效的情况：</p><ul><li><p>查询不同的东西</p></li><li><p><strong>增删改</strong>操作，可能会改变原来的数据，使缓存中的变为脏数据，所以必定会刷新缓存。</p></li><li><p>查询不同的Mapper.xml</p></li><li><p>手动清理缓存</p><p><div class="code-wrapper"><pre><code class="hljs java">sqlSession.clearCache(); <span class="hljs-comment">//手动清理缓存</span></code></pre></div></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220530204442286-2024-12-922:12:48.png"alt="image-20220530204442286" /><figcaption aria-hidden="true">image-20220530204442286</figcaption></figure></li></ul><h3 id="二级缓存">13.4、二级缓存</h3><ul><li>二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存</li><li>基于namespace级别的缓存，一个名称空间，对应一个二级缓存；即一个Mapper对应一个二级缓存。</li><li><strong>工作机制</strong><ul><li>一个会话查询一条数据，这个数据就会<strong>首先</strong>被放在当前会话的一级缓存中；</li><li><strong>当前会话关闭时</strong>，该会话的一级缓存会被清理，此时会将一级缓存中的数据保存到二级缓存中。</li><li>新的会话查询信息，就可以从二级缓存中获取内容</li><li>不同mapper查出的数据会放在自己对应的缓存(map)中</li></ul></li></ul><p>步骤：</p><ol type="1"><li><p>开启全局缓存</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--显式开启，便于阅读，默认为开启状态--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span></code></pre></div></li><li><p>在要使用二级缓存的Mapper中开启</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--在当前mapper中开启二级缓存--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/&gt;</span></code></pre></div><p>也可以自定义参数</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span></span><span class="hljs-tag">  <span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;512&quot;</span></span><span class="hljs-tag">  <span class="hljs-attr">readOnly</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span></code></pre></div><p>创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的512个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。</p><p>可用的清除策略有：</p><ul><li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li><li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li><li><code>SOFT</code> –软引用：基于垃圾回收器状态和软引用规则移除对象。</li><li><code>WEAK</code> –弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li></ul><p>默认的清除策略是 <strong>LRU</strong>。</p><ol start="3" type="1"><li>测试</li></ol><p>注意：实体类需要序列化，否则会报错</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;&#125;</code></pre></div></li></ol><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.getUserById(<span class="hljs-number">1</span>);    System.out.println(user);    sqlSession.close(); <span class="hljs-comment">//关闭第一个会话</span>    System.out.println(<span class="hljs-string">&quot;===========================&quot;</span>);    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession1</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper1</span> <span class="hljs-operator">=</span> sqlSession1.getMapper(UserMapper.class);    <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span>mapper1.getUserById(<span class="hljs-number">1</span>);    System.out.println(user1);    System.out.println(user == user1);    sqlSession1.close();&#125;</code></pre></div><p>关闭第一个会话后，其查询到数据会从一级缓存转移到二级缓存，之后创建新的会话再次查询相同内容时，直接从二级缓存中读取。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220530214627595-2024-12-922:12:56.png"alt="image-20220530214627595" /><figcaption aria-hidden="true">image-20220530214627595</figcaption></figure><p>小结：</p><ul><li>只要开启了二级缓存，在同一个Mapper下就有效。</li><li>查询到的所有数据，会首先放在一级缓存中；只有当前会话提交或关闭时，才会提交到二级缓存</li></ul><h3 id="缓存原理">13.5、缓存原理</h3><p>一个查询语句查询的过程：</p><ul><li>先看二级缓存中有没有</li><li>再看一级缓存中有没有</li><li>若都没有，查询数据库</li></ul><h3 id="自定义缓存">13.6、自定义缓存</h3><p>之后主要使用 Redis缓存。</p>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb基础（二）后端相关</title>
    <link href="/68ec802/"/>
    <url>/68ec802/</url>
    
    <content type="html"><![CDATA[<meta name = "referrer", content = "no-referrer"/><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509183750447-2024-5-918:38:46.png"alt="image-20240509183750447" /><figcaption aria-hidden="true">image-20240509183750447</figcaption></figure><h2 id="一maven">一、maven</h2><h3 id="概述">1.1、概述</h3><p><strong>Maven</strong>是apache旗下的一个开源项目，是一款用于管理和构建java项目的工具。</p><p>作用：</p><ul><li><p>依赖管理。方便快捷的管理项目依赖的资源（jar包），避免版本冲突问题。只需将要使用的jar包的依赖加入<code>pom.xml</code>中，maven会自动下载导入，方便对其进行管理</p></li><li><p>统一项目结构。提供标准、统一的项目结构</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501100246270-2024-5-918:50:55.png" alt="image-20240501100246270" style="zoom:80%;" /></p></li><li><p>项目构建标准跨平台（Linux、Windows、MacOS）的自动化项目构建方式。提供多平台通用的项目构建指令</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501100401906-2024-5-918:51:02.png" alt="image-20240501100401906" style="zoom:80%;" /></p></li></ul><h3 id="安装步骤">1.2、安装步骤</h3><ol type="1"><li><p>下载解压 apache-maven-3.6.1-bin.zip</p></li><li><p>配置本地仓库：修改 conf/settings.xml 中的<code>&lt;localRepository&gt;</code>为一个指定目录。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>E:\develop\apache-maven-3.6.1\mvn_repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span></code></pre></div></li><li><p>配置阿里云私服：修改 conf/settings.xml 中的<code>&lt;mirrors&gt;</code>标签，为其添加如下子标签：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre></div></li><li><p>配置环境变量：MAVEN_HOME为maven的解压目录，并将其bin目录加入PATH环境变量。</p></li></ol><h3 id="在idea中配置maven环境">1.3、在idea中配置Maven环境</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240501102342977-2024-5-918:51:05.png"alt="image-20240501102342977" /><figcaption aria-hidden="true">image-20240501102342977</figcaption></figure><h3 id="maven坐标">1.4、Maven坐标</h3><ul><li><p>什么是坐标</p><ul><li>Maven中的坐标是<strong>资源的唯一标识，通过该坐标可以唯一定位资源位置。</strong></li><li>使用坐标来定义项目或引入项目中需要的依赖。</li></ul></li><li><p>Maven坐标主要组成</p><ul><li>groupld：定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima）</li><li>artifactld：定义当前Maven项目名称（通常是模块名称，例如order-service、goods-service）</li><li>version：定义当前项目版本号</li></ul><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupld</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupld</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactid</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactid</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li></ul><h3 id="idea导入maven项目">1.5、IDEA导入Maven项目</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240501105109534-2024-5-918:51:09.png"alt="image-20240501105109534" /><figcaption aria-hidden="true">image-20240501105109534</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240501105243121-2024-5-918:51:15.png"alt="image-20240501105243121" /><figcaption aria-hidden="true">image-20240501105243121</figcaption></figure><h3 id="依赖管理">1.6、依赖管理</h3><h4 id="依赖配置">依赖配置</h4><p>依赖：当前项目运行所需要的jar包，一个项目中可以引入多个依赖。</p><p>配置：</p><ol type="1"><li>在 pom.xml 中编写 <code>&lt;dependencies&gt;</code>标签</li><li>在<code>&lt;dependencies&gt;</code>标签中使用<code>&lt;dependency&gt;</code> 引入坐标</li><li>定义坐标的groupld，artifactld，version</li></ol><p>​ 需要什么依赖就去 <ahref="https://mvnrepository.com/">Maven仓库</a>搜索下载对应的依赖，添加到pox.xml文件的<code>&lt;dependencies&gt;</code>中，maven会下载导入该依赖。如：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven_project_01<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-comment">&lt;!--    将依赖在这里添加--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p>​</p><h4 id="依赖传递">依赖传递</h4><p>依赖具有传递性：</p><ul><li>直接依赖：在当前项目中通过依赖配置建立的依赖关系</li><li>间接依赖：被依赖的资源如果依赖其他资源，当前项目间接依赖其他资源</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209150346440-2024-12-915:04:23.png"alt="image-20241209150346440" /><figcaption aria-hidden="true">image-20241209150346440</figcaption></figure><p>排除依赖：</p><p>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本。projectA不想使用projectB中的某个依赖时，可以使用<code>&lt;exclusions&gt;</code>排除依赖</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209150632297-2024-12-915:06:33.png"alt="image-20241209150632297" /><figcaption aria-hidden="true">image-20241209150632297</figcaption></figure><h4 id="依赖范围">依赖范围</h4><p>依赖的jar包，默认情况下，可以在任何地方使用。可以通过<code>&lt;scope&gt;...&lt;/scope&gt;</code>设置其作用范围。</p><p>作用范围：</p><ul><li>主程序范围有效。（main文件夹范围内）</li><li>测试程序范围有效。（test文件夹范围内）</li><li>是否参与打包运行。（package指令范围内）</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209150812630-2024-12-915:08:13.png"alt="image-20241209150812630" /><figcaption aria-hidden="true">image-20241209150812630</figcaption></figure><h4 id="生命周期">生命周期</h4><p>Maven的生命周期就是为了对所有的maven项目构建过程进行抽象和统一。</p><p>Maven中有3套<strong>相互独立</strong>的生命周期：</p><ul><li>clean：清理工作。</li><li>default：核心工作，如：编译、测试、打包、安装、部署等。</li><li>site：生成报告、发布站点等。</li></ul><p>每套生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段。</p><blockquote><p>在同一套生命周期中，当运行后面的阶段时，前面的阶段都会运行。</p><p>如：运行package阶段会运行之前的compile和test阶段，并不会运行clean阶段，因为它们属于不同的生命周期</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209151204171-2024-12-915:12:10.png"alt="image-20241209151204171" /><figcaption aria-hidden="true">image-20241209151204171</figcaption></figure><p>一些重要的什么周期阶段的职责：</p><ul><li>clean：移除上一次构建生成的文件</li><li>compile：编译项目源代码</li><li>test：使用合适的单元测试框架运行测试（junit）</li><li>package：将编译后的文件打包，如：jar、war等</li><li>install：安装项目到本地仓库</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209151350389-2024-12-915:13:51.png"alt="image-20241209151350389" /><figcaption aria-hidden="true">image-20241209151350389</figcaption></figure><p>执行指定声明周期的两种方式</p><ul><li>在idea中，右侧的maven工具栏，选中对应的生命周期，双击执行。</li><li>在命令行中，通过命令执行。</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-09_15-16-08-2024-12-915:19:29.png"alt="PixPin_2024-12-09_15-16-08" /><figcaption aria-hidden="true">PixPin_2024-12-09_15-16-08</figcaption></figure><p>如果想要跳过某些阶段，如在package的过程中跳过test阶段，点击test，再点击小闪电即可跳过该模块</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501114000111-2024-5-918:51:58.png" alt="image-20240501114000111" style="zoom:80%;" /></p><h2 id="二http协议">二、HTTP协议</h2><p><code>H</code>yper <code>T</code>ext <code>T</code>ransfer<code>P</code>rotocol，超文本传输协议，规定了浏览器和服务器之间数据传输的规则。</p><h3 id="http请求的数据格式">2.1、HTTP请求的数据格式</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209152227266-2024-12-915:22:28.png"alt="image-20241209152227266" /><figcaption aria-hidden="true">image-20241209152227266</figcaption></figure><p>包含三部分：</p><ul><li><p>请求行</p><p>第一行，由三部分组成：请求方式、资源路径和协议。</p></li><li><p>请求头</p><p>第二行开始，格式为 key : value</p></li><li><p>请求体</p><p>Post方式所特有的，用来存放请求参数。</p></li></ul><blockquote><ul><li>请求方式-GET：请求参数在<strong>请求行</strong>中，没有请求体，如：<code>/brand/findAll？name=OPPO&amp;status=1</code>，GET请求大小是有限制的。</li><li>请求方式-POST：请求参数在<strong>请求体</strong>中，POST请求大小是没有限制的。</li></ul></blockquote><p>常见的请求头的含义<imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240501190830361-2024-5-918:52:08.png"alt="image-20240501190830361" /></p><h3 id="http响应的数据格式">2.2、HTTP响应的数据格式</h3><p>包含三部分：</p><ul><li><p>响应行</p><p>位于相应数据第一行，包含协议、状态码和相关描述。</p></li><li><p>响应头</p><p>从第二行开始，格式为：key : value</p></li><li><p>响应体</p><p>最后一部分，存放相应数据</p></li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501191754933-2024-5-918:52:11.png" alt="image-20240501191754933" style="zoom:80%;" /></p><p>响应状态码 <ahref="https://cloud.tencent.com/developer/chapter/13553">状态码大全</a></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240501192042349-2024-5-918:52:15.png"alt="image-20240501192042349" /><figcaption aria-hidden="true">image-20240501192042349</figcaption></figure><p>响应头格式</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240501191939039-2024-5-918:52:20.png"alt="image-20240501191939039" /><figcaption aria-hidden="true">image-20240501191939039</figcaption></figure><h3 id="http解析">2.3、HTTP解析</h3><p>​现在主要通过Web服务器来完成。<strong>Web服务器</strong>对HTTP协议操作进行封装，简化web程序开发；可以部署web项目，对外提供网上信息浏览服务。<strong>Tomcat</strong>一个轻量级的web服务器，支持servlet、jsp等少量javaEE规范。也被称为web容器、servlet容器。</p><h2 id="三请求响应">三、请求响应</h2><h3 id="请求参数">3.1、请求参数</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240503090114509-2024-5-918:52:26.png"alt="image-20240503090114509" /><figcaption aria-hidden="true">image-20240503090114509</figcaption></figure><h4 id="简单参数">简单参数</h4><ul><li><p>原始方式</p><p>在原始的web程序中，获取请求参数，需要通过<code>HttpServletRequest</code>对象手动获取。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>（<span class="hljs-string">&quot;/simpleParam&quot;</span>）<span class="hljs-keyword">public</span> String simpleParam（HttpServletRequest request）&#123;    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> request.getParameter（<span class="hljs-string">&quot;name&quot;</span>）;    <span class="hljs-type">String</span> <span class="hljs-variable">ageStr</span> <span class="hljs-operator">=</span> request.getParameter（<span class="hljs-string">&quot;age&quot;</span>）;    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> Integer.parseint（ageStr）;    System.out.println（name+<span class="hljs-string">&quot;：&quot;</span>+age）;    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>；&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209153920637-2024-12-915:39:21.png" alt="image-20241209153920637" style="zoom:80%;" /></p></li><li><p>SpringBoot方式</p><p>简单参数：参数名与形参变量名相同，定义形参即可接收参数。</p><div class="code-wrapper"><pre><code class="hljs java">@ RequestMapping(<span class="hljs-string">&quot;/simpleParam&quot;</span>)<span class="hljs-keyword">public</span> String <span class="hljs-title function_">simpleParam</span><span class="hljs-params">(String name , Integer age)</span>&#123;System.out.println(name+<span class="hljs-string">&quot;: &quot;</span>+age);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;   &#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209154118637-2024-12-915:41:19.png" alt="image-20241209154118637" style="zoom:80%;" /></p><p>若传递的参数和函数形参变量名不同，则得到的值为<code>null</code>。若要使用两个不同的参数名，则使用<code>@RequestParam</code>完成映射。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/simpleParam&quot;)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">simpleParam</span><span class="hljs-params">(</span><span class="hljs-params">    //会将请求参数中name属性的值，映射到username这个变量上</span><span class="hljs-params">    <span class="hljs-meta">@RequestParam(value = &quot;name&quot;, required = false)</span> String username, </span><span class="hljs-params">    <span class="hljs-type">int</span> age)</span> &#123;        System.out.println(username+<span class="hljs-string">&quot;:&quot;</span>+age);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209154458280-2024-12-915:45:15.png" alt="image-20241209154458280" style="zoom:80%;" /></p></li></ul><h4 id="实体参数">实体参数</h4><blockquote><p>简单实体参数</p></blockquote><p>​当传递参数太多或者具有某种结构属性时，可以将其封装为一个实体对象。创建实体类xxx，在其中定义与请求参数名相同的属性名，设置get和set方法，springboot会自动请求参数封装到一个对象中。即：请求参数名与形参对象属性名相同，定义POJO接收即可</p><div class="code-wrapper"><pre><code class="hljs java">Public <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>（<span class="hljs-string">&quot;/simplePojo&quot;</span>）<span class="hljs-keyword">public</span> String <span class="hljs-title function_">simplePojo</span><span class="hljs-params">(User user)</span> &#123;    System.out.println(user);    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>;&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209155024205-2024-12-915:50:40.png" alt="image-20241209155024205" style="zoom:80%;" /></p><blockquote><p>复杂实体参数</p></blockquote><p>当一个类的属性是另一个类的对象时，传递的参数是复杂实体参数。请求参数名与形参对象属性名相同，按照对象<strong>层次结构关系</strong>即可接收嵌套POJO属性参数。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> Address address;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;    <span class="hljs-keyword">private</span> String province;    <span class="hljs-keyword">private</span> String city;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>（<span class="hljs-string">&quot;/complexPojo&quot;</span>）<span class="hljs-keyword">public</span> String <span class="hljs-title function_">complesPojo</span><span class="hljs-params">(User user)</span> &#123;    System.out.println(user);    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>;&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209155618690-2024-12-915:56:40.png"alt="image-20241209155618690" /><figcaption aria-hidden="true">image-20241209155618690</figcaption></figure><h4 id="数组集合参数">数组集合参数</h4><p>请求参数名与<strong>形参数组名称</strong>相同且请求参数为多个，定义数组类型形参即可接收参数</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/arrayParam&quot;)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">arrayParam</span><span class="hljs-params">(String[]hobby)</span>&#123;    System.out.println（Arrays.toString(hobby));    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>;&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209160226768-2024-12-916:02:40.png"alt="image-20241209160226768" /><figcaption aria-hidden="true">image-20241209160226768</figcaption></figure><p>也可使用集合接收参数。默认用数组接收，要使用集合接收时，需使用<code>@RequestParam</code>绑定参数关系</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/arrayParam&quot;)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">arrayParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> List&lt;String&gt;hobby)</span>&#123;    System.out.println（Arrays.toString(hobby));    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>;&#125;</code></pre></div><h4 id="日期参数">日期参数</h4><p>使用<code>@DateTimeFormat</code>注解完成日期参数格式转换</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/dateParam&quot;)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">dateParam</span><span class="hljs-params">(</span><span class="hljs-params">    //指定前端传递的日期格式，请求参数名称和形参名称保持一致</span><span class="hljs-params">    <span class="hljs-meta">@DateTimeFormat</span>（pattern =<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)</span>LocalDateTime updateTime)&#123; System.out.println(updateTime);    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>;&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209160746102-2024-12-916:08:40.png"alt="image-20241209160746102" /><figcaption aria-hidden="true">image-20241209160746102</figcaption></figure><h4 id="json参数">JSON参数</h4><p>后端使用实体对象接收JSON数据，JSON数据<code>键名</code>与形参<code>对象属性名</code>相同，同时使用<code>@RequestBody</code>标识</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> Address address;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;    <span class="hljs-keyword">private</span> String province;    <span class="hljs-keyword">private</span> String city;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>（<span class="hljs-string">&quot;/jsonParam&quot;</span>）<span class="hljs-keyword">public</span> String <span class="hljs-title function_">jsonParam</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> &#123;    System.out.println(user);    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>;&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209161110433-2024-12-916:11:40.png" alt="image-20241209161110433" style="zoom:80%;" /></p><p>传递JSON参数使用post方法，json格式的数据需要在请求体中传递到后端。在postman中传递JSON数据的方法</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240503103956956-2024-5-918:53:24.png"alt="image-20240503103956956" /><figcaption aria-hidden="true">image-20240503103956956</figcaption></figure><h4 id="路径参数">路径参数</h4><p>通过请求URL直接传递参数，使用<code>&#123;...&#125;</code>来标识该路径参数，需要使用<code>@PathVariable</code>获取路径参数</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/path/&#123;id&#125;&quot;)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">pathParam</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> &#123; System.out.println(id);    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>;  &#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209161510698-2024-12-916:15:11.png"alt="image-20241209161510698" /><figcaption aria-hidden="true">image-20241209161510698</figcaption></figure><p>有多个路径参数时：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/path/&#123;id&#125;/&#123;name&#125;&quot;)</span><span class="hljs-keyword">public</span> String <span class="hljs-title function_">pathParam</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id, <span class="hljs-meta">@PathVariable</span> String name)</span> &#123; System.out.println(id);    <span class="hljs-keyword">return</span><span class="hljs-string">&quot;OK&quot;</span>;  &#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209161804011-2024-12-916:18:29.png"alt="image-20241209161804011" /><figcaption aria-hidden="true">image-20241209161804011</figcaption></figure><h3 id="响应数据">3.2、响应数据</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209162140240-2024-12-916:21:41.png"alt="image-20241209162140240" /><figcaption aria-hidden="true">image-20241209162140240</figcaption></figure><p><code>@ResponseBody</code></p><ul><li><p>类型：<strong>方法注解</strong>，<strong>类注解</strong></p></li><li><p>位置：Controller方法上/类上</p></li><li><p>作用：将<strong>方法返回值</strong>直接响应，<u>如果返回值类型是实体对象/集合，将会转换为JSON格式响应</u></p></li><li><p>说明：<code>@RestController = @Controller + @ResponseBody</code></p></li></ul><h4 id="设置统一响应结果">设置统一响应结果</h4><p>对于不同的返回数据，有不同的返回格式，前端解析时需要按照不同方法操作，不便开发和维护</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240503110657053-2024-5-918:53:37.png"alt="image-20240503110657053" /><figcaption aria-hidden="true">image-20240503110657053</figcaption></figure><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.pojo;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> Result</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO 统一响应结果封装类</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> 86152</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/5/3 11:08</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;    <span class="hljs-keyword">private</span> Integer code; <span class="hljs-comment">//1 成功， 0 失败</span>    <span class="hljs-keyword">private</span> String msg;<span class="hljs-comment">//提示信息</span>    <span class="hljs-keyword">private</span> Object data;<span class="hljs-comment">//响应数据 data</span>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Result</span><span class="hljs-params">()</span> &#123;&#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Result</span><span class="hljs-params">(Integer code, String msg, Object data)</span> &#123;        <span class="hljs-built_in">this</span>.code = code;        <span class="hljs-built_in">this</span>.msg = msg;        <span class="hljs-built_in">this</span>.data = data;    &#125;    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> code;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCode</span><span class="hljs-params">(Integer code)</span> &#123;        <span class="hljs-built_in">this</span>.code = code;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMsg</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> msg;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMsg</span><span class="hljs-params">(String msg)</span> &#123;        <span class="hljs-built_in">this</span>.msg = msg;    &#125;    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getData</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> data;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setData</span><span class="hljs-params">(Object data)</span> &#123;        <span class="hljs-built_in">this</span>.data = data;    &#125;    <span class="hljs-comment">//静态方法，方便快速创建Result对象</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;sucess&quot;</span>,<span class="hljs-literal">null</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">(Object data)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;sucess&quot;</span>,data);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">error</span><span class="hljs-params">(String msg)</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>(<span class="hljs-number">0</span>,msg,<span class="hljs-literal">null</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result&#123;&quot;</span> +                <span class="hljs-string">&quot;code=&quot;</span> + code +                <span class="hljs-string">&quot;, msg=&#x27;&quot;</span> + msg + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&quot;, data=&quot;</span> + data +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResponseController</span> &#123;    <span class="hljs-meta">@RequestMapping(&quot;/getAddress&quot;)</span>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">Address</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>();        address.setProvince(<span class="hljs-string">&quot;陕西省&quot;</span>);        address.setCity(<span class="hljs-string">&quot;西安&quot;</span>);        <span class="hljs-keyword">return</span> Result.success(address);    &#125;&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240503111753128-2024-5-918:53:42.png"alt="image-20240503111753128" /><figcaption aria-hidden="true">image-20240503111753128</figcaption></figure><h2 id="四分层解耦">四、分层解耦</h2><h3 id="三层架构">4.1、三层架构</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209162222532-2024-12-916:22:23.png"alt="image-20241209162222532" /><figcaption aria-hidden="true">image-20241209162222532</figcaption></figure><ul><li>controller：控制层，接收前端发送的请求，对请求进行处理，并响应数据。</li><li>service：业务逻辑层，处理具体的业务逻辑。</li><li>dao：数据访问层（Data AccessObject）（持久层），负责数据访问操作，包括数据的增、删、改、查。</li></ul><h3 id="ioc控制翻转">4.2、IOC（控制翻转）*</h3><p>之前Controller层调用Service层方法是通过在类内主动创建一个特定的Service对象，并调用该对象的方法来实现的（service层调dao层的方法同理）。在这种方式下，若service层增加新的实现类，在Controller层使用该类时，需修改之前的创建对象，改为new新对象。每次变动 , 都需要修改大量代码.耦合度高。<strong>传统方式下是程序主动去创建依赖对象，控制权在程序员手上。<code>IOC</code>这种<code>设计思想</code>是将设计好的对象交给IOC容器（或spring容器）管理，由IOC容器来控制对象的创建，成为IOC容器的bean。</strong>此时，程序不再具有主动性，而是被动的接收对象，把主动权交给了调用者。</p><p>没有IoC的程序中 , 我们使用面向对象编程 ,对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方。所谓控制反转就是：<strong>获得依赖对象的方式反转了，由主动的编程变成被动的接收.</strong>。</p><p>Springboot中通过<code>注解</code>将类交给IOC容器，在运行时创建对象。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240504154537635-2024-5-918:53:55.png"alt="image-20240504154537635" /><figcaption aria-hidden="true">image-20240504154537635</figcaption></figure><h3 id="di依赖注入">4.3、DI（依赖注入）*</h3><p>​ <strong>控制反转IoC(Inversion ofControl)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>。loC的一个重点是在系统运行中，<strong>动态的向某个对象提供它所需要的其他对象</strong>，这一点是通过DI（DependencyInjection，依赖注入）来实现的。Java1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</p><p>​通过在需要注入的类属性上添加<strong>自动注入的注解</strong>，spring就会在运行时适当的时候从IOC容器中创建一个bean，并注入到该属性中。</p><ul><li><p><code>@Autowired</code>注解，默认是按照类型进行，如果存在多个相同类型的bean，将会报出如下错误</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209162514910-2024-12-916:25:40.png"alt="image-20241209162514910" /><figcaption aria-hidden="true">image-20241209162514910</figcaption></figure></li></ul><p>如果同类型的bean存在多个，可以通过以下几种方案完成注入</p><ul><li><code>@Primary</code>指定bean的优先级，添加该注解，说明优先注入同类型中的哪个bean</li><li><code>@Qualifier（"bean的名称"）+ @Autowired</code>，两个注解配合使用，指定要注入bean的名称（创建时没有指定时，默认为类名首字母小写）</li><li><code>@Resource（name-"bean的名称"</code>，<span class="citation"data-cites="Resource是JDK的注解">@Resource是JDK的注解</span>，默认你按照名称注入</li></ul><h2 id="五mysql">五、<ahref="https://catpaws.top/8d742da7/">MySQL</a></h2><h2 id="六mybatis">六、<a href="web-02-Mybatis.md">MyBatis</a></h2><h3 id="快速入门">6.1、快速入门</h3><h4 id="连接配置">连接配置</h4><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">application.propoties</span><span class="hljs-comment">#驱动类名称</span><span class="hljs-string">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><span class="hljs-comment">#数据库连接的url</span><span class="hljs-string">spring.datasource.url=jdbc:mysql://localhost:3306/mybatis_01?serverTimezone=Hongkong&amp;amp;useSSL=false&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8</span><span class="hljs-comment">#连接数据库的用户名</span><span class="hljs-string">spring.datasource.username=root</span><span class="hljs-comment">#连接数据库的密码</span><span class="hljs-string">spring.datasource.password=liuhao123</span><span class="hljs-comment">#配置mybatis的日志，指定输出到控制台</span><span class="hljs-string">mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</span><span class="hljs-string">pom.xml相关</span><span class="hljs-string">需手动指定MySQL连接的版本</span><span class="hljs-string">&lt;dependency&gt;</span>    <span class="hljs-string">&lt;groupId&gt;com.mysql&lt;/groupId&gt;</span>    <span class="hljs-string">&lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;</span>    <span class="hljs-string">&lt;version&gt;8.0.32&lt;/version&gt;</span>    <span class="hljs-string">&lt;scope&gt;runtime&lt;/scope&gt;</span><span class="hljs-string">&lt;/dependency&gt;</span></code></pre></div><h4 id="配置mysql提示">配置MySQL提示</h4><p>默认在mybatis中编写SQL语句是不识别的。可以做如下配置:</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209163040488-2024-12-916:31:19.png"alt="image-20241209163040488" /><figcaption aria-hidden="true">image-20241209163040488</figcaption></figure><p>当完成语言注入后，在sql语句中输入表名时，MyBatis并没有给出提示甚至报红，无法识别。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241209163302625-2024-12-916:33:03.png" alt="image-20241209163302625" style="zoom:67%;" /></p><p>产生的原因是Idea和数据库没有建立连接，不识别表信息。需要在Idea中配置MySQL数据库连接</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209163420385-2024-12-916:34:21.png"alt="image-20241209163420385" /><figcaption aria-hidden="true">image-20241209163420385</figcaption></figure><h4 id="jdbc和mybatis">JDBC和Mybatis</h4><p>JDBC：（Java DataBaseConnectivity），就是使用Java语言操作关系型数据库的一套API。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209163537712-2024-12-916:35:38.png"alt="image-20241209163537712" /><figcaption aria-hidden="true">image-20241209163537712</figcaption></figure><p>它是sun公司官方定义的一套操作所有关系型数据库的<strong>规范</strong>即接口。各个数据库厂商去实现这套接口，提供数据库驱动ar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240505094254808-2024-5-918:54:23.png"alt="image-20240505094254808" /><figcaption aria-hidden="true">image-20240505094254808</figcaption></figure><h4 id="数据库连接池">数据库连接池</h4><p>​数据库连接池是个容器，负责分配、管理数据库连接（Connection）。它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个。释放空闲时间超过最大空闲时间的连接，来避免因为没有释放连接而引起的数据库连接遗漏</p><p>优势：</p><ul><li>资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209163852325-2024-12-916:39:10.png"alt="image-20241209163852325" /><figcaption aria-hidden="true">image-20241209163852325</figcaption></figure><p>常见产品：</p><ul><li><p>C3P0</p></li><li><p>DBCP</p></li><li><p>Druid</p><p>由阿里巴巴开源的数据库连接池项目，功能强大，性能优秀，是Java语言最好的数据库连接池之一。</p></li><li><p>Hikari</p><p>SpringBoot默认采用的数据库连接池</p></li></ul><p>切换Druid数据库连接池</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.19<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="lombok">LomBok</h4><p>​Lombok是一个实用的Java类库，能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，并可以自动化生成日志变量，简化java开发、提高效率。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209164307613-2024-12-916:43:08.png"alt="image-20241209164307613" /><figcaption aria-hidden="true">image-20241209164307613</figcaption></figure><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="mybatis基础操作crud">6.2、MyBatis基础操作（CRUD）</h3><p><strong>使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。</strong></p><p><strong>选择何种方式来配置映射，以及认为是否应该要统一映射语句定义的形式，完全取决于你和你的团队。换句话说，永远不要拘泥于一种方式，你可以很轻松的在基于注解和 XML的语句映射方式间自由移植和切换。</strong></p><h4 id="使用注解开发">使用注解开发</h4><h5 id="删除操作">删除操作</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;    <span class="hljs-meta">@Delete(&quot;delete from emp where id = #&#123;id&#125;&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteUser</span><span class="hljs-params">(Integer id)</span>;&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240505162729553-2024-5-918:54:45.png"alt="image-20240505162729553" /><figcaption aria-hidden="true">image-20240505162729553</figcaption></figure><p>预编译sql性能更高（会将优化后的sql缓存起来），更安全（防止sql注入）</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240505165633607-2024-5-918:54:49.png"alt="image-20240505165633607" /><figcaption aria-hidden="true">image-20240505165633607</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240505165445199-2024-5-918:54:54.png"alt="image-20240505165445199" /><figcaption aria-hidden="true">image-20240505165445199</figcaption></figure><h5 id="新增操作">新增操作</h5><p>主键返回：<span class="citation"data-cites="Options注解只能搭配Insert语句使用">@Options注解只能搭配Insert语句使用</span>，会自动将生成的主键值，赋值给emp对象的id属性。经过Options注解，Mybatis会自动把数据库生成的主键值写入到实体类中。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;<span class="hljs-comment">//主键返回：将当前创建记录的主键封装在emp对象的id属性中，可以通过get方法获取</span>    <span class="hljs-meta">@Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)</span>        <span class="hljs-comment">//有多个参数时，使用对应的实体类封装起来，通过参数占位符获取对象的属性</span>    <span class="hljs-meta">@Insert(&quot;insert into emp(username, name, gender, image, job, entrydate, dept_id, create_time, update_time)&quot; +</span><span class="hljs-meta">            &quot;values (#&#123;username&#125;,#&#123;name&#125;,#&#123;gender&#125;,#&#123;image&#125;,#&#123;job&#125;,#&#123;entrydate&#125;,#&#123;deptId&#125;,#&#123;createTime&#125;,#&#123;updateTime&#125;)&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">(Emp emp)</span>;&#125;</code></pre></div><h5 id="更新操作">更新操作</h5><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;    <span class="hljs-comment">//更新员工信息</span>    <span class="hljs-meta">@Update(&quot;update emp &quot; +</span><span class="hljs-meta">            &quot;set username = #&#123;username&#125;, name = #&#123;name&#125;, gender = #&#123;gender&#125;, image = #&#123;image&#125;, job = #&#123;job&#125;, entrydate = #&#123;entrydate&#125;, dept_id = #&#123;deptId&#125;, update_time = #&#123;updateTime&#125;&quot; +</span><span class="hljs-meta">            &quot; where id = #&#123;id&#125;;&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateUser</span><span class="hljs-params">(Emp emp)</span>;&#125;</code></pre></div><h5 id="查询操作">查询操作</h5><p>1、根据id查询员工</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;    <span class="hljs-comment">//将查询到的记录封装到实体类Emp的一个对象中</span>    <span class="hljs-meta">@Select(&quot;select * from emp where  id = #&#123;id&#125;&quot;)</span>    <span class="hljs-keyword">public</span> Emp <span class="hljs-title function_">getUserById</span><span class="hljs-params">(Integer id)</span>;        <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectTest</span><span class="hljs-params">()</span> &#123;        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> empMapper.getUserById(<span class="hljs-number">19</span>);        System.out.println(emp);    &#125;&#125;</code></pre></div><p>查看封装结果：由于数据库采用下划线命名，而java使用驼峰命名，两者名称不一致，数据没有封装进去</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240505172402159-2024-12-921:38:01.png"alt="image-20240505172402159" /><figcaption aria-hidden="true">image-20240505172402159</figcaption></figure><ul><li>实体类属性名和数据库表查询返回的字段名一致，mybatis会自动封装。</li><li>如果实体类属性名 和数据库表查询返回的字段名不一致，不能自动封装。</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209164557149-2024-12-916:45:58.png"alt="image-20241209164557149" /><figcaption aria-hidden="true">image-20241209164557149</figcaption></figure><ul><li><p>方案一：给字段起别名，让别名与实体类属性保持一致</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select id, username, password, name, gender, image, job, entrydate, dept_id deptId, create_time createTime, update_time updateTime from emp where  id = #&#123;uid&#125;&quot;)</span><span class="hljs-keyword">public</span> Emp <span class="hljs-title function_">getUserById</span><span class="hljs-params">(Integer id)</span>;</code></pre></div></li><li><p>方案二：通过<code>@Results</code>和<code>@Result</code>进行手动封装</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Results(&#123;</span><span class="hljs-meta">        @Result(column = &quot;dept_id&quot;,property = &quot;deptId&quot;),</span><span class="hljs-meta">        @Result(column = &quot;create_time&quot;,property = &quot;createTime&quot;),</span><span class="hljs-meta">        @Result(column = &quot;update_time&quot;,property = &quot;updateTime&quot;)</span><span class="hljs-meta">&#125;)</span><span class="hljs-meta">@Select(&quot;select * from emp where id = #&#123;id&#125;&quot;)</span><span class="hljs-keyword">public</span> Emp <span class="hljs-title function_">getUserById</span><span class="hljs-params">(Integer id)</span>;</code></pre></div></li><li><p><label><input type="checkbox"checked="" />方案三：开启MyBatis驼峰命名自动映射开关，完成 a_cloumn----&gt; aColumn (推荐)</label></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#application.properties</span><span class="hljs-comment">#开启mybatis驼峰命名自动映射开关 a_cloumn ----&gt; aColumn</span><span class="hljs-string">mybatis.configuration.map-underscore-to-camel-case=true</span></code></pre></div></li></ul><p>2、复杂查询</p><p>例：要求查询员工，且：</p><ul><li>根据输入的 员工姓名、员工性别、入职时间搜索满足条件的员工信息。</li><li>其中 员工姓名，支持模糊匹配；性别进行精确查询；入职时间进行范围查询。</li><li>支持分页查询。</li><li>并对查询的结果，根据最后修改时间进行倒序排序。</li></ul><p>对应的SQL语句：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span><span class="hljs-string">&#x27;%张%&#x27;</span><span class="hljs-keyword">and</span> gender<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> entrydate <span class="hljs-keyword">between</span><span class="hljs-string">&#x27;2010-01-01&#x27;</span><span class="hljs-keyword">and</span><span class="hljs-string">&#x27;2020-01-01&#x27;</span><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> update_time <span class="hljs-keyword">desc</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * &quot; +</span><span class="hljs-meta">            &quot;from emp &quot; +</span><span class="hljs-meta">            &quot;where name like concat(&#x27;$&#x27;,#&#123;name&#125;,&#x27;$&#x27;) and gender = #&#123;gender&#125; and entrydate between #&#123;begin&#125; and #&#123;end&#125; &quot; +</span><span class="hljs-meta">            &quot;order by  update_time desc&quot;)</span>    <span class="hljs-keyword">public</span> List&lt;Emp&gt; <span class="hljs-title function_">getUserList</span><span class="hljs-params">(String name, <span class="hljs-type">short</span> gender, LocalDate begin, LocalDate end)</span>;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209165105204-2024-12-916:51:19.png"alt="image-20241209165105204" /><figcaption aria-hidden="true">image-20241209165105204</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240505180035515-2024-5-918:55:12.png"alt="image-20240505180035515" /><figcaption aria-hidden="true">image-20240505180035515</figcaption></figure><h5 id="补充">补充</h5><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240505180332250-2024-5-918:55:46.png"alt="image-20240505180332250" /><figcaption aria-hidden="true">image-20240505180332250</figcaption></figure><p><span class="citation"data-cites="Param的作用就是">@Param的作用就是</span><strong>给参数命名</strong>，比如在mapper里面某方法A（intid），当添加注解后A（<span class="citation"data-cites="Param">@Param</span>("userId") intid），也就是说外部想要取出传入的id值，<strong>只需要取它的参数名userId就可以了</strong>。将参数值传如SQL语句中，通过#{userId}进行取值给SQL的参数赋值。</p><ul><li>方法存在多个参数，所有参数前面必须加上 <span class="citation"data-cites="Param">@Param</span>("")注解</li></ul><p>当使用@Param给参数命名后，在xml或注解形式下使用 #{}取值</p><p><strong>XML形式下</strong>：</p><ul><li><strong><span class="citation"data-cites="Param注解单一属性">@Param注解单一属性</span></strong><ul><li>这里给参数配置@param注解后，Mybatis会自动将参数封装成<strong>Map类型</strong>，而@param注解的值会成为Map中的key，因此在sql中可以通过配置的注解值来使用参数。</li><li>使用注解传递参数,这时是不涉及单独一个类型的,所以<strong>去掉parameterType属性</strong></li></ul></li><li><strong><span class="citation"data-cites="Param注解JavaBean对象">@Param注解JavaBean对象</span></strong><ul><li>当参数是JavaBean类型时，使用@param注解后就不能直接使用，而是要通过<strong>点取值</strong>的方式。</li><li>在没有注解时，可以直接使用该JavaBean的属性</li></ul></li></ul><h4 id="使用xml文件开发">使用XML文件开发</h4><p>使用XML文件开发，需要遵循以下规范</p><ul><li>XML映射文件的名称与Mapper接口名称一致，并且将XML映射文件和Mapper接口放置在相同包下（同包同名）。</li><li>XML映射文件的namespace属性为Mapper接口全限定名一致。</li><li>XML映射文件中sql语句的id与Mapper接口中的方法名一致，并保持返回类型一致。</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209165322631-2024-12-916:53:23.png"alt="image-20241209165322631" /><figcaption aria-hidden="true">image-20241209165322631</figcaption></figure><p>使用mybatis完成数据库操作是通过执行mapper接口中的方法，但这个方法并没有指定实际执行的sql语句，<code>关键是如何找到该方法对应的sql语句并执行.</code></p><p>通过遵守xml映射文件的三条规范，可以保证在调用Mapper接口中的方法时，mybatis框架会自动查找与namespace属性值与这个接口全类名相同的xml文件，在该xml文件中找到id属性值与方法名相同的sql语句，最终运行这条sql语句从而完成对数据库的操作。</p><blockquote><p>步骤</p></blockquote><ol type="1"><li>在resources下创建与mapper相同的包结构，此时创建的是目录，各级直接要用<code>/</code>分隔，而不是<code>.</code>，这样创建的才是分等级的文件结构</li></ol><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240505181114981-2024-5-918:55:57.png"alt="image-20240505181114981" /><figcaption aria-hidden="true">image-20240505181114981</figcaption></figure><p>​ 2、创建与mapper接口名称相同的xml文件</p><p>​ 首先添加xml约束</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><span class="hljs-meta">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></code></pre></div><p>添加mapper标签，获取对应的mapper接口的全限定名：</p><p>右键mapper接口，选择<code>Copy Reference</code>即可</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240505184351463-2024-5-918:55:58.png"alt="image-20240505184351463" /><figcaption aria-hidden="true">image-20240505184351463</figcaption></figure><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--使用namespace 将mapper接口与xml文件绑定起来--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mapper.EmpMapper&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><p>3、添加sql语句</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--使用namespace 将mapper接口与xml文件绑定起来--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mapper.EmpMapper&quot;</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 使用id绑定到EmpMapper接口中的getUserList方法，返回值类型设置为Emp类   --&gt;</span>    <span class="hljs-comment">&lt;!--resultType ：单条记录所封装的类型（全限定名）    --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.pojo.Emp&quot;</span>&gt;</span>            select *            from emp            where name like concat(&#x27;$&#x27;,#&#123;name&#125;,&#x27;$&#x27;) and gender = #&#123;gender&#125; and entrydate between #&#123;begin&#125; and #&#123;end&#125;            order by  update_time desc    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span></code></pre></div><h3 id="动态sql">6.3、动态sql</h3><p><strong>什么是动态SQL：动态SQL就是根据不同的条件组装生成不同的SQL语句</strong></p><p>所谓动态SQL，本质还是SQL语句，只是我们可以在SQL层面，执行一些逻辑代码。</p><blockquote><p>主要元素</p></blockquote><ul><li>if ，where，set</li><li>foreach</li><li>sql，include</li></ul><h4 id="ifwhereset">IF，where，set</h4><p>使用动态 SQL 最常见情景是根据条件<strong>包含 where子句的一部分</strong>。</p><p><code>&lt;if test="判断条件"&gt; where 子句的一部分 &lt;/if&gt;</code></p><p>根据判断条件是否为真来动态添加对应的sql代码。</p><p>注：test判断条件中使用的是<u>实体类中的属性名</u>而不是数据库表的字段名</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240505210552447-2024-5-918:55:59.png"alt="image-20240505210552447" /><figcaption aria-hidden="true">image-20240505210552447</figcaption></figure><p>例1：根据用户输入的查询条件获得用户列表。若输入了用户名，则按照用户名模糊查询；若输入了性别，同时按性别查询；若输入了入职时间，同时按照入职时间查询；若不输入参数，则查询所有员工。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.pojo.Emp&quot;</span>&gt;</span>    select *    from emp    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span>            name like concat(&#x27;$&#x27;,#&#123;name&#125;,&#x27;$&#x27;)        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span>            and gender = #&#123;gender&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;begin != null and end != null&quot;</span>&gt;</span>            and entrydate between #&#123;begin&#125; and #&#123;end&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span>    order by update_time desc;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>例2：动态更新员工表，若传入了对应字段的值，则更新；否则保持不变。</p><p>与where中遇到的情况类似，若只有第一个if标签有效则预编译sql如下，会将其中的逗号保留，造成sql语法错误</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240505210252503-2024-5-918:56:00.png"alt="image-20240505210252503" /><figcaption aria-hidden="true">image-20240505210252503</figcaption></figure><p>使用set标签解决</p><p><code>&lt;set&gt;</code>：动态地在行首插入SET关键字，并会删掉额外的逗号。（用在update语句中）</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span>&gt;</span>    update emp    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span>username = #&#123;username&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span> name = #&#123;name&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span>gender = #&#123;gender&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;image != null&quot;</span>&gt;</span>image = #&#123;image&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;job != null&quot;</span>&gt;</span>job = #&#123;job&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;entrydate != null&quot;</span>&gt;</span>entrydate = #&#123;entrydate&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span>dept_id = #&#123;deptId&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;updateTime != null&quot;</span>&gt;</span>update_time = #&#123;updateTime&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span>    where id = #&#123;id&#125;;<span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span></code></pre></div><h4 id="foreach">foreach</h4><ul><li>动态 SQL的另一个常见使用场景是<strong>对集合进行遍历</strong>（尤其是在构建 IN条件语句的时候）。</li><li>它允许你指定一个集合，声明可以在元素体内使用的<strong>集合项（item）</strong>和<strong>索引（index）</strong>变量。</li><li>它也允许你<strong>指定开头与结尾的字符串</strong>以及<strong>集合项迭代之间的分隔符</strong>。</li></ul><p>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有以下3种情况：</p><ul><li><p><strong>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list。</strong></p></li><li><p><strong>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array。</strong></p></li><li><p><strong>如果传入的参数是多个的时候，就需要把它们封装成一个Map了，当然单参数也可以封装成Map。实际上在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key。</strong></p></li></ul><p>当然在作为入参时可以使用@Param("keyName")来设置键，设置keyName后，list和array将会失效</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240505212015373-2024-5-918:56:14.png"alt="image-20240505212015373" /><figcaption aria-hidden="true">image-20240505212015373</figcaption></figure><p><ahref="https://blog.csdn.net/qq_36631553/article/details/105680200">使用foreach进行批量操作</a></p><h4 id="sql片段">SQL片段</h4><p>有时候，我们要将一些功能的部分抽取出来，方便复用。同时这些公共部分若要修改，只需修改一处即可。</p><p>1、使用SQL标签抽取公共部分</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;commenSelect&quot;</span>&gt;</span>    select id,    username,    password,    name,    gender,    image,    job,    entrydate,    dept_id,    create_time,    update_time    from emp<span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span></code></pre></div><p>2、在需要使用的地方 使用 include标签引用即可</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    根据id查询用户 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.pojo.Emp&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;commenSelect&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span>    where id = #&#123;uid&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></code></pre></div><p>注意点：</p><ul><li>最好基于单表来定义SQL片段</li><li>其中不要包含where标签</li></ul><h3 id="idea插件">6.4、idea插件</h3><p>MybatisX 是一款基于 IDEA的快速开发Mybatis的插件，为效率而生。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209195949274-2024-12-920:00:40.png"alt="image-20241209195949274" /><figcaption aria-hidden="true">image-20241209195949274</figcaption></figure><blockquote><p>直接在xml中生成Mapper接口中的方法对应的标签</p></blockquote><p>安装了MyBatisX插件后，在mapper接口中添加一个方法后，使用<code>alt+shift+enter</code>可直接在对应的xml文件中生成该方法对应的标签</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240505220350091-2024-5-918:56:28.png"alt="image-20240505220350091" /><figcaption aria-hidden="true">image-20240505220350091</figcaption></figure><blockquote><p>在xml文件中开启sql提示</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240505220829405-2024-5-918:56:32.png"alt="image-20240505220829405" /><figcaption aria-hidden="true">image-20240505220829405</figcaption></figure><blockquote><p>添加操作日志</p></blockquote><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240506100818823-2024-5-918:56:37.png" alt="image-20240506100818823" style="zoom:80%;" /></p><p>添加<code>@Slf4j</code>注解后，可以在方法内直接使用<code>log</code>对象的<code>info或debug</code>方法输入日志。（不要用system.out）</p><h2 id="七整合demo">七、整合Demo</h2><h3 id="请求路径管理">7.1、请求路径管理</h3><p><span class="citation"data-cites="RequestMapping">@RequestMapping</span></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209200052266-2024-12-920:01:16.png"alt="image-20241209200052266" /><figcaption aria-hidden="true">image-20241209200052266</figcaption></figure><blockquote><p>注：一个完整的请求路径，应该是类上的<code>@RequestMapping</code>的value属性+方法上的<code>@RequestMapping</code>的value属性。</p></blockquote><h3 id="restful-风格">7.2、RestFul 风格</h3><p><strong>概念</strong></p><p>Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，<strong>只是一种风格</strong>。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p><p><strong>功能</strong></p><p>资源：互联网所有的事物都可以被抽象为资源</p><p>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。</p><p>分别对应 添加、 删除、修改、查询。</p><ul><li><p><strong>传统方式操作资源</strong>：通过<strong>不同的参数</strong>来实现不同的效果！<strong>方法单一，post和 get</strong></p><p>​ http://127.0.0.1/item/queryItem.action?id=1 查询,GET</p><p>​ http://127.0.0.1/item/saveItem.action 新增,POST</p><p>​ http://127.0.0.1/item/updateItem.action 更新,POST</p><p>​ http://127.0.0.1/item/deleteItem.action?id=1 删除,GET或POST</p></li><li><p><strong>使用RESTful操作资源</strong>：可以通过<strong>不同的请求方式</strong>来实现不同的效果！如下：<strong>请求地址一样，但是功能可以不同</strong>！</p><p>​ http://127.0.0.1/item/1 查询,GET</p><p>​ http://127.0.0.1/item 新增,POST</p><p>​ http://127.0.0.1/item 更新,PUT</p><p>​ http://127.0.0.1/item/1 删除,DELETE</p></li></ul><h3 id="分页查询">7.3、分页查询</h3><h4 id="原始方式">原始方式</h4><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240506144301718-2024-5-918:56:45.png"alt="image-20240506144301718" /><figcaption aria-hidden="true">image-20240506144301718</figcaption></figure><h4 id="使用分页插件pagehelper">使用分页插件PageHelper</h4><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220525181646324-2024-5-918:56:50.png"alt="image-20220525181646324" /><figcaption aria-hidden="true">image-20220525181646324</figcaption></figure><p><a href="https://pagehelper.github.io/docs/">查看</a></p><p>其核心原理是将传入的页码和条数赋值给一个Page对象，并保存到本地线程ThreadLocal中。接下来，PageHelper会进入Mybatis的拦截器环节，在拦截器中获取并处理刚才保存在ThreadLocal中的分页参数。这些分页参数会与原本的SQL语句和内部已经定义好的SQL进行拼接，从而完成带有分页处理的SQL语句的构建。</p><p><strong>PageHelper注意事项</strong></p><p>使用pagehelper进行分页的时候推荐使用 PageHelper.startPage(1, 10);这种方式；</p><p>另外<strong>startPage语句最好紧挨着查询语句，避免中间抛出异常，没有办法清除ThreadLocal中当前线程的page对象。</strong></p><p>步骤：</p><p>1、编写正常查询语句</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmpMapper</span> &#123;    <span class="hljs-meta">@Select(&quot;select * from emp&quot;)</span>    List&lt;Emp&gt; <span class="hljs-title function_">list</span><span class="hljs-params">()</span>;&#125;</code></pre></div><p>2、在service层使用PageHelper进行分页查询</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmpServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EmpService</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> EmpMapper empMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> PageBean <span class="hljs-title function_">page</span><span class="hljs-params">(Integer page, Integer pageSize)</span> &#123;        <span class="hljs-comment">//1、配置分页参数</span>        PageHelper.startPage(page,pageSize);        <span class="hljs-comment">//2、执行查询</span>         <span class="hljs-comment">//规定获得分页查询结果对象用page封装，其继承了ArrayList，增加了自己的属性</span>         Page&lt;<span class="hljs-type">Emp</span> <span class="hljs-variable">empList</span> <span class="hljs-operator">=</span> empMapper.list();        <span class="hljs-comment">//3、封装PageBean对象</span>        <span class="hljs-type">PageBean</span> <span class="hljs-variable">pageBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageBean</span>(p.getTotal(), p.getResult());        <span class="hljs-keyword">return</span> pageBean;    &#125;&#125;</code></pre></div><h3 id="文件上传">7.4、文件上传</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240506171942500-2024-5-918:56:54.png"alt="image-20240506171942500" /><figcaption aria-hidden="true">image-20240506171942500</figcaption></figure><p>前端表单：</p><ul><li>大文件提交方式要选择<code>post</code></li><li>文件编码格式<code>enctype</code>必须选择<code>multipart/form-data</code>，使用默认值只会将文件名提交到服务器</li><li>使用一个 type属性为<code>file</code>的组件来选择文件进行上传</li></ul><p>后端接收到的是临时文件，在表单中有三个标签，会将其数据保存在三个对应的临时文件中上传结束后会将其删除<imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240506173248059-2024-5-918:56:59.png"alt="image-20240506173248059" /></p><h4 id="本地存储">本地存储</h4><p>使用<code>MutipartFile</code>类的<code>transferTo()</code>方法，将当前对象保存为指定路径下的文件</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">upload</span><span class="hljs-params">(String username, Integer age, MultipartFile image)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-comment">//1、获取上传文件原始名</span>    <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> image.getOriginalFilename();        <span class="hljs-comment">//2、构造新的唯一的文件名（uuid+文件后缀）</span>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>);    <span class="hljs-type">String</span> <span class="hljs-variable">suffix</span> <span class="hljs-operator">=</span> originalFilename.substring(index);    <span class="hljs-type">String</span> <span class="hljs-variable">newFileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + suffix;    log.info(<span class="hljs-string">&quot;所提交的表单信息为:&#123;&#125;,&#123;&#125;,&#123;&#125;&quot;</span>,username,age,newFileName);    <span class="hljs-comment">//3、将文件保存在本地目录 D:/videos/目录下</span>    image.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/videos/&quot;</span>+newFileName));    <span class="hljs-keyword">return</span> Result.success();&#125;</code></pre></div><p>在SpringBoot中，文件上传，默认单个文件允许最大大小为<code>1MB</code>.当上传文件大小超过时，会抛出异常</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240506175756491-2024-5-918:57:03.png"alt="image-20240506175756491" /><figcaption aria-hidden="true">image-20240506175756491</figcaption></figure><p>如果需要上传大文件，可以在配置文件中设置</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-comment">#配置单个文件最大上传大小</span><span class="hljs-string">spring.servlet.multipart.max-file-size=10MB</span><span class="hljs-comment">#配置单个请求最大上传文件大小（一次请求可以上传多个文件）</span><span class="hljs-string">spring.servlet.multipart.max-request-size=100B</span></code></pre></div><p>postman测试文件上传</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240506180504095-2024-5-918:57:08.png"alt="image-20240506180504095" /><figcaption aria-hidden="true">image-20240506180504095</figcaption></figure><h4 id="阿里云oss存储">阿里云OSS存储</h4><p>见本地代码</p><h3 id="配置文件">7.5、配置文件</h3><h4 id="参数配置化">参数配置化</h4><p>将需要用到的参数硬编码在java代码中，当代码量庞大，参数需要修改时，维护代价大，不便管理。</p><p>解决方法：将参数及其值添加到项目配置文件中，java代码中不直接写值，而是采用外部注入的方式</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240506220341750-2024-5-919:02:24.png"alt="image-20240506220341750" /><figcaption aria-hidden="true">image-20240506220341750</figcaption></figure><h4 id="yml配置文件">yml配置文件</h4><p>常见配置文件格式对比</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209165802973-2024-12-916:58:04.png"alt="image-20241209165802973" /><figcaption aria-hidden="true">image-20241209165802973</figcaption></figure><p>YML基本语法：</p><ul><li>大小写敏感</li><li>数值前边必须有空格，作为分隔符 冒号后必须有空格</li><li>使用缩进表示层级关系，缩进时，不允许使用Tab键，只能用空格（idea中会自动将Tab转换为空格）</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li><li>#表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul><p>YML数据格式</p><ul><li><p>对象/Map集合</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">user:</span> <span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span> <span class="hljs-attr">age:</span> <span class="hljs-number">18</span> <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><span class="hljs-comment"># 统一缩进，类似于python语法，用缩进表示结构关系</span></code></pre></div></li><li><p>数组/List/Set集合</p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">hobby:</span>  <span class="hljs-string">-java</span>  <span class="hljs-string">-game</span>  <span class="hljs-string">-sport</span><span class="hljs-comment">#元素成员前有一个短杠 -</span></code></pre></div></li></ul><p>使用<code>application.yml</code>替换<code>application.properties</code></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">springboot-employeemanagement</span>  <span class="hljs-comment">#数据库连接配置</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mybatis</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">liuhao123</span>  <span class="hljs-comment">#文件上传配置</span>  <span class="hljs-attr">servlet:</span>    <span class="hljs-attr">multipart:</span>      <span class="hljs-attr">max-file-size:</span> <span class="hljs-string">10MB</span> <span class="hljs-comment">#配置单个文件最大上传大小</span>      <span class="hljs-attr">max-request-size:</span> <span class="hljs-string">100MB</span> <span class="hljs-comment">#配置单个请求最大上传文件大小（一次请求可以上传多个文件）</span><span class="hljs-comment">#mybatis配置</span><span class="hljs-attr">mybatis:</span>  <span class="hljs-attr">configuration:</span>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="hljs-comment">#配置mybatis的日志，指定输出到控制台</span>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment">#开启mybatis驼峰命名自动映射开关 a_cloumn ----&gt; aColumn</span><span class="hljs-comment">#阿里云OSS配置</span><span class="hljs-comment">#aliyun:</span><span class="hljs-comment">#  oss:</span><span class="hljs-comment">#    endpoint: xxxxxx</span><span class="hljs-comment">#    accessKeyId: xxxxxx</span><span class="hljs-comment">#    accessKeySecret: xxxxxx</span><span class="hljs-comment">#    bucketName: xxxxxxx</span></code></pre></div><h4 id="配置信息注入">配置信息注入</h4><p><code>@ConfigurationProperties</code>与<code>@Value</code></p><p>相同点：都是用来注入外部配置的属性的。</p><p>不同点：</p><ul><li><span class="citation"data-cites="Value注解只能一个一个的进行外部属性的注入">@Value注解只能一个一个的进行外部属性的注入</span>。（如果相关配置只有几个，用这个也可）</li><li><span class="citation"data-cites="ConfigurationProperties可以批量的将外部的属性配置注入到bean对象的属性中">@ConfigurationProperties可以批量的将外部的属性配置注入到bean对象的属性中</span>。（要获得配置信息，在对应类中注入该bean对象，调用其get方法即可）</li></ul><p>使用<code>@ConfigurationProperties</code>将配置文件中配置项的值自动注入到bean对象的属性中</p><p>前提：</p><ul><li>配置文件中key的名字与实体类的属性名相同</li><li>为实体类提供get和set方法（使用<code>@Data</code>注解）</li><li>将实体类交个IOC容器管理，成为IOC容器的bean对象（使用<code>@Component</code>注解）</li><li>指定配置项的前缀：使用<code>ConfigurationProperties(prefix ="xxxx")</code></li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240506222720114-2024-5-919:02:54.png"alt="image-20240506222720114" /><figcaption aria-hidden="true">image-20240506222720114</figcaption></figure><p>添加如下注解，在完成实体类定义后，添加配置项时会生成提示信息</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="登录校验">7.6、登录校验</h3><p>登录时根据用户名和密码查询数据库，若返回信息为null，则用户名或密码错误；不为null，则数据库中存在记录，登录成功。但是由于客户端和服务器直接交互是基于HTTP协议的，而HTTP协议又是无状态的协议，两个访问直接没有关联。即使登录失败，也可以在地址栏中输入页面地址直接访问。登录操作形同虚设。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240506230923099-2024-5-919:03:10.png" alt="image-20240506230923099" style="zoom:80%;" /></p><h4 id="会话技术">会话技术</h4><ul><li>会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应。</li><li>会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据。</li><li>会话跟踪方案：<ul><li>客户端会话跟踪技术：Cookie</li><li>服务端会话跟踪技术：Session</li><li>令牌技术</li></ul></li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209170355187-2024-12-917:04:10.png"alt="image-20241209170355187" /><figcaption aria-hidden="true">image-20241209170355187</figcaption></figure><p>​</p><p>会话跟踪方案对比</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240507095823985-2024-5-919:03:26.png"alt="image-20240507095823985" /><figcaption aria-hidden="true">image-20240507095823985</figcaption></figure><blockquote><p>Cookie</p></blockquote><p>1、浏览器在第一次访问服务器时，在服务端保存相关访问数据，在给浏览器的响应头中通过Set-Cookie自动将服务端保存的信息响应给浏览器</p><p>2、浏览器识别响应头中的Set-Cookie，将其中的数据自动保存在本地Cookie</p><p>3、以后每次发起服务端访问请求都会通过请求头中的Cookie携带本地数据到服务端，在服务端获得该Cookie的值，进行判断</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//设置Cookie</span><span class="hljs-meta">@GetMapping(&quot;/c1&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">cookie1</span><span class="hljs-params">(HttpServletResponse response)</span>&#123;    response.addCookie(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;login_username&quot;</span>,<span class="hljs-string">&quot;itheima&quot;</span>)); <span class="hljs-comment">//设置Cookie/响应Cookie</span>    <span class="hljs-keyword">return</span> Result.success();&#125;<span class="hljs-comment">//获取Cookie</span><span class="hljs-meta">@GetMapping(&quot;/c2&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">cookie2</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;    Cookie[] cookies = request.getCookies();    <span class="hljs-keyword">for</span> (Cookie cookie : cookies) &#123;        <span class="hljs-keyword">if</span>(cookie.getName().equals(<span class="hljs-string">&quot;login_username&quot;</span>))&#123;            System.out.println(<span class="hljs-string">&quot;login_username: &quot;</span>+cookie.getValue()); <span class="hljs-comment">//输出name为login_username的cookie</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> Result.success();&#125;</code></pre></div><blockquote><p>Session</p></blockquote><p>Session是基于Cookie实现的，Session会话对象保存在服务器端，浏览器访问服务器时，可以在服务器中获取对应的Session对象。</p><p>1、浏览器第一次访问服务器时session不存在，服务器会自动创建一个会话对象Session，每个session都有一个id，服务器通过Cookie将SessionId响应给浏览器。（在响应头中增加一条Set-Cookie，其内容就是SessionID）</p><p>2、浏览器解析响应头，将Cookie保存在本地</p><p>3、在浏览器每次访问服务器时都会将本地Cookie数据获取出来，携带到服务端。服务端从中获取SessionID，从众多的Session中找到当前请求对应的会话对象Session。</p><p>这样就可以通过Session在同一个会话的多次请求直接传共享数据</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/s1&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">session1</span><span class="hljs-params">(HttpSession session)</span>&#123;    log.info(<span class="hljs-string">&quot;HttpSession-s1: &#123;&#125;&quot;</span>, session.hashCode());    session.setAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>, <span class="hljs-string">&quot;tom&quot;</span>); <span class="hljs-comment">//往session中存储数据</span>    <span class="hljs-keyword">return</span> Result.success();&#125;<span class="hljs-meta">@GetMapping(&quot;/s2&quot;)</span><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">session2</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;    <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();    log.info(<span class="hljs-string">&quot;HttpSession-s2: &#123;&#125;&quot;</span>, session.hashCode());    <span class="hljs-type">Object</span> <span class="hljs-variable">loginUser</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>); <span class="hljs-comment">//从session中获取数据</span>    log.info(<span class="hljs-string">&quot;loginUser: &#123;&#125;&quot;</span>, loginUser);    <span class="hljs-keyword">return</span> Result.success(loginUser);&#125;</code></pre></div><blockquote><p>令牌技术</p></blockquote><p>​用户登录成功后生成令牌，并将令牌响应前端，前端将令牌保存起来，在以后的每一次请求中都要携带令牌。首先服务端对接收到的令牌进行校验，若令牌有效则放行，否则进行拦截，跳转至指定页面。</p><p>JWT</p><ul><li>全称：JSON Web Token（https://jwt.io/）</li><li>定义了一种简洁的、自包含的格式，用于在通信双方以json数据格式安全的传输信息。由于数字签名的存在，这些信息是可靠的。</li><li>组成：<ul><li>第一部分：Header（头），记录令牌类型、签名算法等。例如：{"alg"："HS256"，"type"："JWT"}</li><li>第二部分：Payload（有效载荷），携带一些自定义信息、默认信息等。例如：{"id"："1"，"username"："Tom"}</li><li>第三部分：Signature（签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，<strong>通过指定签名算法计算而来</strong>。</li></ul></li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209170933608-2024-12-917:09:34.png"alt="image-20241209170933608" /><figcaption aria-hidden="true">image-20241209170933608</figcaption></figure><p>1、添加依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--    JWT令牌    --&gt;</span><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-api --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>2、生成JWT令牌</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">JwtGenTest</span><span class="hljs-params">()</span> &#123;    Map&lt;String, Object&gt; claims = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();    claims.put(<span class="hljs-string">&quot;id&quot;</span>,<span class="hljs-number">1</span>);    claims.put(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;Tom&quot;</span>);    <span class="hljs-type">String</span> <span class="hljs-variable">jwt</span> <span class="hljs-operator">=</span> Jwts.builder()            .signWith(SignatureAlgorithm.HS256, <span class="hljs-string">&quot;itheima&quot;</span>) <span class="hljs-comment">//指定编码格式和秘钥</span>            .setClaims(claims) <span class="hljs-comment">//添加自定义内容（有效载荷）</span>            .setExpiration(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis() + <span class="hljs-number">12</span>*<span class="hljs-number">3600</span>*<span class="hljs-number">1000</span>)) <span class="hljs-comment">//令牌有效期</span>            .compact();    <span class="hljs-comment">//eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNzE1MDkyOTg2LCJ1c2VybmFtZSI6IlRvbSJ9.vZkW8LOXOGODIhbuy4MSrL5BR6638eJM9uOJNnBScAc</span>    System.out.println(jwt);&#125;</code></pre></div><p>3、校验令牌</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseJwtTest</span><span class="hljs-params">()</span> &#123;    <span class="hljs-type">String</span> <span class="hljs-variable">jwt</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZXhwIjoxNzE1MDkyOTg2LCJ1c2VybmFtZSI6IlRvbSJ9.vZkW8LOXOGODIhbuy4MSrL5BR6638eJM9uOJNnBScAc&quot;</span>;        <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> Jwts.parser()        .setSigningKey(<span class="hljs-string">&quot;itheima&quot;</span>) <span class="hljs-comment">//指定签名秘钥</span>        .parseClaimsJws(jwt) <span class="hljs-comment">//解析秘钥</span>        .getBody(); <span class="hljs-comment">//获得其中的自定义数据</span>    System.out.println(claims);&#125;</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240507104834966-2024-5-919:03:49.png" alt="image-20240507104834966" style="zoom:80%;" /></p><p>4、生成JWT工具类，使用时调用其中的方法即可</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//JwtUtils.java</span><span class="hljs-keyword">import</span> io.jsonwebtoken.Claims;<span class="hljs-keyword">import</span> io.jsonwebtoken.Jwts;<span class="hljs-keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtUtils</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">signKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itheima&quot;</span>; <span class="hljs-comment">//设置秘钥</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Long</span> <span class="hljs-variable">expire</span> <span class="hljs-operator">=</span> <span class="hljs-number">43200000L</span>; <span class="hljs-comment">//设置秘钥过期时间</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 生成JWT令牌</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> claims JWT第二部分负载 payload 中存储的内容</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">generateJwt</span><span class="hljs-params">(Map&lt;String, Object&gt; claims)</span>&#123;        <span class="hljs-type">String</span> <span class="hljs-variable">jwt</span> <span class="hljs-operator">=</span> Jwts.builder()                .addClaims(claims)                .signWith(SignatureAlgorithm.HS256, signKey)                .setExpiration(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis() + expire))                .compact();        <span class="hljs-keyword">return</span> jwt;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 解析JWT令牌</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jwt JWT令牌</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JWT第二部分负载 payload 中存储的内容</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Claims <span class="hljs-title function_">parseJWT</span><span class="hljs-params">(String jwt)</span>&#123;        <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> Jwts.parser()                .setSigningKey(signKey)                .parseClaimsJws(jwt)                .getBody();        <span class="hljs-keyword">return</span> claims;    &#125;&#125;</code></pre></div><p>5、登录成功下发令牌，登录失败返回错误信息</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginController</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> EmpService empService;    <span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Emp emp)</span> &#123;        <span class="hljs-type">Emp</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> empService.getByUsernameAndPassword(emp);        <span class="hljs-comment">//登录成功，生成令牌，下发令牌</span>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;            Map&lt;String, Object&gt; claims = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();            claims.put(<span class="hljs-string">&quot;id&quot;</span>,e.getId());            claims.put(<span class="hljs-string">&quot;name&quot;</span>,e.getName());            claims.put(<span class="hljs-string">&quot;username&quot;</span>,e.getUsername());            <span class="hljs-type">String</span> <span class="hljs-variable">jwt</span> <span class="hljs-operator">=</span> JwtUtils.generateJwt(claims); <span class="hljs-comment">//生成的Jwt令牌中已经包含了员工信息</span>            <span class="hljs-keyword">return</span> Result.success(jwt);        &#125;        <span class="hljs-comment">//登录失败，返回错误信息</span>        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;用户名或密码错误&quot;</span>);    &#125;&#125;</code></pre></div><h4 id="过滤器实现登录校验">过滤器实现登录校验</h4><p>过滤器（Filter）</p><ul><li>概念：<strong>Filter过滤器</strong>，是JavaWeb三大组件（Servlet、Filter、Listener）之一。</li><li>过滤器可以把对资源的请求<strong>拦截</strong>下来，从而实现一些特殊的功能。</li><li>过滤器一般完成一些<strong>通用</strong>的操作，比如：登录校验、统一编码处理、敏感字符处理等。</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209170705008-2024-12-917:07:06.png"alt="image-20241209170705008" /><figcaption aria-hidden="true">image-20241209170705008</figcaption></figure><blockquote><p>快速入门</p></blockquote><p>步骤：</p><ol type="1"><li>定义Filter：定义一个类，实现 Filter接口，并重写其所有方法。（只有三个：init，doFilter，destroy）</li><li>配置Filter：Filter类上加@webFilter注解，配置拦截资源的路径。引导类上加@ServletComponentScan开启Servlet组件支持。</li></ol><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209171051916-2024-12-917:10:53.png"alt="image-20241209171051916" /><figcaption aria-hidden="true">image-20241209171051916</figcaption></figure><p>注：一定要继承 <code>javax.servlet</code>的Filter</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240507111913871-2024-5-919:04:04.png"alt="image-20240507111913871" /><figcaption aria-hidden="true">image-20240507111913871</figcaption></figure><blockquote><p>过滤器细节（过滤器执行流程、过滤器拦截路径、过滤器链）</p></blockquote><ol type="1"><li><p><strong>过滤器执行流程</strong></p><p>请求----&gt;放行前逻辑 ----&gt;放行 -----&gt;访问Web资源-----&gt;放行后逻辑</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240507113959486-2024-5-919:04:08.png"alt="image-20240507113959486" /><figcaption aria-hidden="true">image-20240507113959486</figcaption></figure></li><li><p><strong>过滤器拦截路径</strong></p><p>Filter可以根据需求，配置不同的拦截资源路径：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-09_17-13-19-2024-12-917:14:29.png"alt="PixPin_2024-12-09_17-13-19" /><figcaption aria-hidden="true">PixPin_2024-12-09_17-13-19</figcaption></figure></li><li><p><strong>过滤器链</strong></p><p>一个web应用中，配置了多个过滤器，就形成了一个过滤器链。</p><ul><li>介绍：一个web应用中，可以配置多个过滤器，这多个过滤器就形成了一个过滤器链。</li><li>顺序：注解配置的Filter，|优先级是按照过滤器类名（字符串）的自然排序。</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209171527241-2024-12-917:15:40.png"alt="image-20241209171527241" /><figcaption aria-hidden="true">image-20241209171527241</figcaption></figure></li></ol><blockquote><p>登录拦截实现</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240507114549100-2024-5-919:04:23.png"alt="image-20240507114549100" /><figcaption aria-hidden="true">image-20240507114549100</figcaption></figure><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.filter;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<span class="hljs-keyword">import</span> com.example.pojo.Result;<span class="hljs-keyword">import</span> com.example.utils.JwtUtils;<span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<span class="hljs-keyword">import</span> org.springframework.util.StringUtils;<span class="hljs-keyword">import</span> javax.servlet.*;<span class="hljs-keyword">import</span> javax.servlet.annotation.WebFilter;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> LoginCheckFilter</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> 86152</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/5/7 16:02</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginCheckFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">req</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;        <span class="hljs-type">HttpServletResponse</span> <span class="hljs-variable">resp</span>  <span class="hljs-operator">=</span> (HttpServletResponse) response;        <span class="hljs-comment">//1、获得请求的路径URL</span>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> req.getRequestURI().toString();        log.info(<span class="hljs-string">&quot;请求路径为&#123;&#125;&quot;</span>,url);        <span class="hljs-comment">//2、判断是否为登录请求。判断请求ur1中是否包含login，如果包含，说明是登录操作，放行。</span>        <span class="hljs-keyword">if</span>(url.contains(<span class="hljs-string">&quot;login&quot;</span>)) &#123;            log.info(<span class="hljs-string">&quot;登录操作，放行....&quot;</span>);            chain.doFilter(request,response);            <span class="hljs-keyword">return</span>;<span class="hljs-comment">//放行后不必返回执行后续代码</span>        &#125;        <span class="hljs-comment">//3、获取请求头中的令牌(token)</span>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> req.getHeader(<span class="hljs-string">&quot;token&quot;</span>);        <span class="hljs-comment">//4、判断令牌是否存在，如果不存在返回错误结果（未登录）</span>        <span class="hljs-keyword">if</span>(!StringUtils.hasLength(token)) &#123;            log.info(<span class="hljs-string">&quot;请求头中token为空，返回未登录的信息&quot;</span>);            <span class="hljs-type">Result</span> <span class="hljs-variable">notLogin</span> <span class="hljs-operator">=</span> Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);            <span class="hljs-comment">//手动转换 javaBean --&gt; JSON ，使用FastJSON</span>            <span class="hljs-type">String</span> <span class="hljs-variable">notLoginStr</span> <span class="hljs-operator">=</span> JSON.toJSONString(notLogin);            resp.getWriter().write(notLoginStr);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//5、解析令牌</span>        <span class="hljs-keyword">try</span> &#123;            JwtUtils.parseJWT(token);        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123; <span class="hljs-comment">//jwt解析失败</span>            log.info(<span class="hljs-string">&quot;令牌解析失败，返回未登录的信息&quot;</span>);            <span class="hljs-type">Result</span> <span class="hljs-variable">notLogin</span> <span class="hljs-operator">=</span> Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);            <span class="hljs-comment">//手动转换 javaBean --&gt; JSON ，使用FastJSON</span>            <span class="hljs-type">String</span> <span class="hljs-variable">notLoginStr</span> <span class="hljs-operator">=</span> JSON.toJSONString(notLogin);            resp.getWriter().write(notLoginStr);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//6、放行</span>        log.info(<span class="hljs-string">&quot;令牌合法，放行....&quot;</span>);        chain.doFilter(request, response);    &#125;&#125;</code></pre></div><h4 id="拦截器实现登录校验">拦截器实现登录校验</h4><blockquote><p>快速入门</p></blockquote><p>步骤：</p><ol type="1"><li><p>定义拦截器，实现Handlerinterceptor接口，并重写其所有方法。</p></li><li><p>注册拦截器</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209171639829-2024-12-917:17:23.png"alt="image-20241209171639829" /><figcaption aria-hidden="true">image-20241209171639829</figcaption></figure></li></ol><blockquote><p>拦截器详解</p></blockquote><p>拦截路径：</p><p>拦截器可以根据需求，配置不同的拦截路径：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span>&#123;  registry.addInterceptor(loginCheckInterceptor)      .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>) <span class="hljs-comment">//需要拦截哪些资源</span>      .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>); <span class="hljs-comment">//不需要拦截哪些资源</span>&#125;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209172035778-2024-12-917:20:37.png"alt="image-20241209172035778" /><figcaption aria-hidden="true">image-20241209172035778</figcaption></figure><p>多个拦截器的执行顺序：</p><p>当拦截器添加后，会被封装成一个注册器<code>InterceptorRegistration</code>，它有一个order属性，用来控制当前拦截器的执行顺序，默认为0，即按照添加顺序执行。<strong>order越小，执行优先级越高</strong>。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241211211406367-2024-12-1121:15:20.png"alt="image-20241211211406367" /><figcaption aria-hidden="true">image-20241211211406367</figcaption></figure><p>拦截器执行流程</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209172125513-2024-12-917:21:26.png"alt="image-20241209172125513" /><figcaption aria-hidden="true">image-20241209172125513</figcaption></figure><p>Filter 与 Interceptor对比</p><ul><li>接口规范不同：过滤器需要实现Filter接口，而拦截器需要实现Handlerinterceptor接口。</li><li>拦截范围不同：过滤器Filter会拦截所有的资源，而Interceptor只会拦截Spring环境中的资源。</li></ul><blockquote><p>实现登录校验</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240507170311521-2024-5-817:18:26.png"alt="image-20240507170311521" /><figcaption aria-hidden="true">image-20240507170311521</figcaption></figure><p>1、定义拦截器，在preHandle方法中编写拦截逻辑</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginCheckInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;        <span class="hljs-meta">@Override</span> <span class="hljs-comment">//目标资源方法执行前执行，放回true：放行，返回false：不放行</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">//1、获得请求的路径URL</span>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> req.getRequestURI().toString();        log.info(<span class="hljs-string">&quot;请求路径为&#123;&#125;&quot;</span>,url);        <span class="hljs-comment">//2、判断是否为登录请求。判断请求ur1中是否包含login，如果包含，说明是登录操作，放行。</span>        <span class="hljs-keyword">if</span>(url.contains(<span class="hljs-string">&quot;login&quot;</span>)) &#123;            log.info(<span class="hljs-string">&quot;登录操作，放行....&quot;</span>);            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;        <span class="hljs-comment">//3、获取请求头中的令牌(token)</span>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> req.getHeader(<span class="hljs-string">&quot;token&quot;</span>);        <span class="hljs-comment">//4、判断令牌是否存在，如果不存在返回错误结果（未登录）</span>        <span class="hljs-keyword">if</span>(!StringUtils.hasLength(token)) &#123;            log.info(<span class="hljs-string">&quot;请求头中token为空，返回未登录的信息&quot;</span>);            <span class="hljs-type">Result</span> <span class="hljs-variable">notLogin</span> <span class="hljs-operator">=</span> Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);            <span class="hljs-comment">//手动转换 javaBean --&gt; JSON ，使用FastJSON</span>            <span class="hljs-type">String</span> <span class="hljs-variable">notLoginStr</span> <span class="hljs-operator">=</span> JSON.toJSONString(notLogin);            resp.getWriter().write(notLoginStr);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//不放行</span>        &#125;        <span class="hljs-comment">//5、解析令牌</span>        <span class="hljs-keyword">try</span> &#123;            JwtUtils.parseJWT(token);        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123; <span class="hljs-comment">//jwt解析失败</span>            log.info(<span class="hljs-string">&quot;令牌解析失败，返回未登录的信息&quot;</span>);            <span class="hljs-type">Result</span> <span class="hljs-variable">notLogin</span> <span class="hljs-operator">=</span> Result.error(<span class="hljs-string">&quot;NOT_LOGIN&quot;</span>);            <span class="hljs-comment">//手动转换 javaBean --&gt; JSON ，使用FastJSON</span>            <span class="hljs-type">String</span> <span class="hljs-variable">notLoginStr</span> <span class="hljs-operator">=</span> JSON.toJSONString(notLogin);            resp.getWriter().write(notLoginStr);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//不放行</span>        &#125;        <span class="hljs-comment">//6、放行</span>        log.info(<span class="hljs-string">&quot;令牌合法，放行....&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//目标资源方法执行后执行</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;        System.out.println(<span class="hljs-string">&quot;postHandle....&quot;</span>);    &#125;    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//视图渲染完毕后执行，最后执行</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;        System.out.println(<span class="hljs-string">&quot;afterCompletion....&quot;</span>);    &#125;&#125;</code></pre></div><p>2、注册拦截器</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//配置类</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">//拦截器对象自动注入</span>    LoginCheckInterceptor loginCheckInterceptor;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;        registry.addInterceptor(loginCheckInterceptor)            .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)  <span class="hljs-comment">//需要拦截的路径</span>            .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>); <span class="hljs-comment">//不需要拦截的路径</span>    &#125;&#125;</code></pre></div><h3 id="异常处理">7.7、异常处理</h3><p>定义全局异常处理器，对项目中出现的异常进行处理，并返回格式化的错误信息</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240507172946016-2024-5-817:17:26.png"alt="image-20240507172946016" /><figcaption aria-hidden="true">image-20240507172946016</figcaption></figure><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span>  <span class="hljs-comment">//声明当前类是一个全局异常处理器</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span> <span class="hljs-comment">//指定所捕获的异常类型：当前捕获所有异常</span>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">ex</span><span class="hljs-params">(Exception e)</span> &#123;        e.printStackTrace();        <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;操作失败，请联系管理员！&quot;</span>);    &#125;&#125;</code></pre></div><h2 id="八spring事务管理">八、Spring事务管理</h2><p>与数据库的事务概念相同</p><p><strong>事务</strong>是一组操作的集合，它是一个不可分割的工作单位，这些操作要么同时成功，要么同时失败。</p><p>操作：</p><ul><li>开启事务（一组操作开始前，开启事务）：start transaction/begin；</li><li>提交事务（这组操作全部成功后，提交事务）：commit；</li><li>回滚事务（中间任何一个操作出现异常，回滚事务）：rollback；</li></ul><h3 id="transactional">8.1、<span class="citation"data-cites="Transactional">@Transactional</span></h3><ul><li>位置：业务（service）层的方法上、类上、接口上</li><li>作用：将当前方法交给spring进行事务管理，<strong>方法执行前，开启事务；成功执行完毕，提交事务；出现异常，回滚事务</strong>。</li></ul><p>注解作用在方法上，将当前方法交给Spring进行事务管理</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>方法<span class="hljs-meta">@override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Integer id)</span>&#123;<span class="hljs-comment">//1.删除部门</span>deptMapper.delete(id);    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>/<span class="hljs-number">0</span>;<span class="hljs-comment">//模拟抛出异常</span><span class="hljs-comment">//2.根据部门id，删除部门下的员工信息</span>    empMapper.deleteByDeptId(id);&#125;</code></pre></div><p>作用在类上，将这个类的所有方法都交给Spring进行事务管理</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeptServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DeptService</span>&#123;&#125;</code></pre></div><p>作用在接口上，将这个接口所有的实现类的所有方法都交给Spring进行事务管理</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Deptservice</span> &#123;&#125;</code></pre></div><p>案例：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240508095827014-2024-5-809:58:27.png"alt="image-20240508095827014" /><figcaption aria-hidden="true">image-20240508095827014</figcaption></figure><p>若一个方法需要多次修改数据库（执行多条DML语句），为了保证原子性，需要在该方法上添加<code>@Transactional</code>注解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span> <span class="hljs-comment">//开启Spring事务</span><span class="hljs-meta">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Integer id)</span> &#123;    deptMapper.deleteDeptById(id); <span class="hljs-comment">//根据部门id删除部门</span>    empMapper.deleteByDeptId(id); <span class="hljs-comment">//同时删除该部门下的所有员工</span>&#125;</code></pre></div><h3 id="rollbackfor属性">8.2、rollbackFor属性</h3><p>默认情况下，只有出现<code>RuntimeException</code>才回滚异常。rollbackFor属性用于控制出现何种异常类型，回滚事务。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209172929990-2024-12-917:29:40.png"alt="image-20241209172929990" /><figcaption aria-hidden="true">image-20241209172929990</figcaption></figure><h3 id="propagation属性">8.3、propagation属性</h3><p>事务传播行为，若一个事务方法A调用了另一个事务方法B，B应该加入A的事务中，还是新建一个事务，这就是事务的传播行为问题。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240508104656427-2024-5-810:47:26.png"alt="image-20240508104656427" /><figcaption aria-hidden="true">image-20240508104656427</figcaption></figure><p>常用：前两个属性</p><ul><li><p>REQUIRED：大部分情况下都是用该传播行为即可。</p></li><li><p>REQUIRES_NEW：<strong>当我们不希望事务之间相互影响时</strong>，可以使用该传播行为。比如：下订单前需要记录日志，不论订单保存成功与否，都需要保证日志记录能够记录成功。</p><blockquote><p>当前方法的事务设置该属性后，调用该方法，会先挂起已有的事务，为该方法创建一个新的事务，当新事物提交或回滚后，再执行挂起的事务</p></blockquote></li></ul><h2 id="九aop">九、AOP</h2><h3 id="aop基础">9.1、AOP基础</h3><h4 id="概述-1">概述</h4><p><strong>AOP</strong>：<strong>A</strong>spect<strong>O</strong>riented<strong>P</strong>rogramming（面向切面编程、面向方面编程），其实就是面向特定方法编程。</p><p>使用场景：</p><ul><li>记录操作日志</li><li>权限控制</li><li>事务管理</li><li>.....</li></ul><p>优势：</p><ul><li>代码无入侵</li><li>减少重复代码</li><li>提高开发效率</li><li>维护方便</li></ul><p>例如：部分功能运行较慢，定位执行耗时较长的业务方法，此时需要统计每一个业务方法的执行耗时</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209173503658-2024-12-917:35:40.png"alt="image-20241209173503658" /><figcaption aria-hidden="true">image-20241209173503658</figcaption></figure><p>AOP的解决方案：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209173611618-2024-12-917:36:40.png"alt="image-20241209173611618" /><figcaption aria-hidden="true">image-20241209173611618</figcaption></figure><h4 id="快速入门-1">快速入门</h4><p>Spring AOP快速入门：统计各个业务层方法执行耗时</p><ol type="1"><li><p>导入AOP依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- AOP--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>编写AOP程序：针对特定方法根据业务需要进行编程</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Aspect</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeAspect</span> &#123;    <span class="hljs-meta">@Around(&quot;execution(* com.example.service.*.*(..))&quot;)</span> <span class="hljs-comment">//指定</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">recordTime</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;        <span class="hljs-comment">//1、获得方法运行开始时间</span>        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        <span class="hljs-comment">//2、运行原始方法</span>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> joinPoint.proceed(); <span class="hljs-comment">//执行切入点方法，</span>        <span class="hljs-comment">//3、获取方法结束时间，计算运行耗时</span>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        log.info(joinPoint.getSignature()+<span class="hljs-string">&quot;方法执行耗时为:&#123;&#125;ms&quot;</span>,end-begin);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre></div></li></ol><h4 id="核心概念">核心概念</h4><ul><li>连接点：JoinPoint，<strong>可以被AOP控制的方法</strong>（暗含方法执行时的相关信息）</li><li>通知：Advice，指哪些重复的逻辑，也就是<strong>共性功能</strong>（最终体现为一个方法）</li><li>切入点：Pointcut，<strong>匹配连接点的条件</strong>，通知仅会在切入点方法执行时被应用</li><li>切面：Aspect，描述通知与切入点的对应关系（<strong>通知+切入点</strong>）</li><li>目标对象：Target，通知所应用的对象</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209201837028-2024-12-920:18:40.png"alt="image-20241209201837028" /><figcaption aria-hidden="true">image-20241209201837028</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209201913094-2024-12-920:19:20.png"alt="image-20241209201913094" /><figcaption aria-hidden="true">image-20241209201913094</figcaption></figure><h4 id="aop执行流程">AOP执行流程</h4><p>AOP是基于<code>动态代理</code>实现的，程序运行时会针对目标对象生成<code>代理对象</code>，按照通知中的逻辑对原始方法进行增强，执行时所注入的不再是目标对象而是增强后的代理对象，调用方法时使用的也是代理对象中的方法</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240508115303160-2024-5-811:53:26.png"alt="image-20240508115303160" /><figcaption aria-hidden="true">image-20240508115303160</figcaption></figure><h3 id="aop进阶">9.2、AOP进阶</h3><h4 id="通知的类型">通知的类型</h4><ol type="1"><li><span class="citation"data-cites="Around">@Around</span>：环绕通知，此注解标注的通知方法在目标方法前、后都被执行</li><li><span class="citation"data-cites="Before">@Before</span>：前置通知，此注解标注的通知方法在目标方法前被执行</li><li><span class="citation"data-cites="After">@After</span>：后置通知，此注解标注的通知方法在目标方法后被执行，无论是否有异常都会执行（又称为最终执行）</li><li><span class="citation"data-cites="AfterReturning">@AfterReturning</span>：返回后通知，此注解标注的通知方法在目标方法后被执行，有异常不会执行（正常返回后执行）</li><li><span class="citation"data-cites="AfterThrowing">@AfterThrowing</span>：异常后通知，此注解标注的通知方法发生异常后执行（发生异常时执行，与上一个互斥）</li></ol><blockquote><p>注意</p><ul><li><span class="citation"data-cites="Around环绕通知需要自己调用ProceedingJoinPoint.proceed">@Around环绕通知需要自己调用ProceedingJoinPoint.proceed</span>（）来让原始方法执行，其他通知不需要考虑目标方法执行</li><li><span class="citation"data-cites="Around环绕通知方法的返回值">@Around环绕通知方法的返回值</span>，必须指定为object，来接收原始方法的返回值。（手动将原始方法的返回值return）</li></ul></blockquote><h4 id="通知顺序">通知顺序</h4><p>当有多个切面的切入点都匹配到了目标方法，目标方法运行时，多个通知方法都会被执行。</p><p>执行顺序：</p><ol type="1"><li>不同切面类中，默认按照切面类的类名字母排序：<ul><li>目标方法前的通知方法：字母排名靠前的先执行</li><li>目标方法后的通知方法：字母排名靠前的后执行</li></ul></li><li>用<code>@Order（数字）</code>加在切面类上来控制顺序<ul><li>目标方法前的通知方法：数字小的先执行</li><li>目标方法后的通知方法：数字小的后执行</li></ul></li></ol><h4 id="切入点">切入点</h4><p>每个通知中都必须通过切入点表达式指定要增强的方法，每个都需要写一个表达式，臃肿且不变修改，可以将切入点表达式抽取出来，可供多个切面类使用</p><p><span class="citation" data-cites="PintCut">@PintCut</span></p><p>该注解的作用是将公共的切点表达式抽取出来，需要用到时引用该切入点表达式即可。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209180045106-2024-12-918:00:50.png"alt="image-20241209180045106" /><figcaption aria-hidden="true">image-20241209180045106</figcaption></figure><p><strong>切入点表达式</strong></p><ul><li><p>描述切入点方法的一种表达式</p></li><li><p>作用：主要用来<strong>决定项目中的哪些方法需要加入通知</strong></p></li><li><p>常见形式</p><ul><li><p>execution(...)：根据方法的签名来匹配</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209202517446-2024-12-920:25:40.png"alt="image-20241209202517446" /><figcaption aria-hidden="true">image-20241209202517446</figcaption></figure></li><li><p><span class="citation"data-cites="annotation">@annotation</span>(...)：根据注解匹配</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209202542532-2024-12-920:25:48.png"alt="image-20241209202542532" /><figcaption aria-hidden="true">image-20241209202542532</figcaption></figure></li></ul></li></ul><h5 id="切入点表达式-execution">切入点表达式-execution</h5><p>execution主要根据方法的返回值、包名、类名、方法名、方法参数等信息来匹配，语法为：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209202845076-2024-12-920:28:46.png"alt="image-20241209202845076" /><figcaption aria-hidden="true">image-20241209202845076</figcaption></figure><p>其中带<code>？</code>的表示可以省略的部分</p><ul><li>访问修饰符：可省略（比如：public、protected）</li><li>包名.类名：可省略</li><li>throws异常：可省略（注意是方法上声明抛出的异常，不是实际抛出的异常）</li></ul><p>可以使用通配符描述切入点</p><ul><li><p><code>*</code>：单个独立的任意符号，可以通配任意返回值、包名、类名、方法名、任意类型的<strong>一个参数</strong>，也可以<u>通配包、类、方法名的一部分</u>。</p><div class="code-wrapper"><pre><code class="hljs java">execution(* com.*.service.update(*))</code></pre></div></li><li><p><code>..</code>：多个连续的任意符号，可以通配任意层级的包，或任意类型、<strong>任意个数的参数</strong></p><div class="code-wrapper"><pre><code class="hljs java">execution(* com.itheima..DeptService.*(..))</code></pre></div></li></ul><blockquote><p>根据业务需要，可以使用且（&amp;&amp;）、或（||）、非（！）来组合比较复杂的切入点表达式。</p></blockquote><p>书写建议：</p><ul><li>所有业务<strong>方法名</strong>在命名时尽量<strong>规范</strong>，方便切入点表达式快速匹配。如：查询类方法都是find开头，更新类方法都是update开头。</li><li>描述切入点方法通常<strong>基于接口描述</strong>，而不是直接描述实现类，<strong>增强拓展性</strong>。</li><li>在满足业务需要的前提下，<strong>尽量缩小切入点的匹配范围</strong>。如：包名匹配尽量不使用..，使用*匹配单个包。</li></ul><h5 id="切入点表达式-annotation">切入点表达式-<span class="citation"data-cites="annotation">@annotation</span></h5><p><span class="citation"data-cites="annotation切入点表达式">@annotation切入点表达式</span>，用于匹配标识有<strong>特定注解</strong>的方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@annotation(com.itheima.anno.Log)</span> <span class="hljs-comment">//括号内为注解的全类名</span></code></pre></div><p>因此，可以自定义一个注解，用作标识</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Target(ElementType.METHOD)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Log &#123;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Before</span>（<span class="hljs-string">&quot;@annotation（com.itheima.anno.Log）&quot;</span>）<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;    log.info(<span class="hljs-string">&quot;before....&quot;</span>);&#125;</code></pre></div><p>这种方法十分灵活，对于一些命名不规范的方法，采用<code>execution表达式</code>来匹配需要添加多个表达式，十分冗长。此时可以使用<code>@annotation</code>切入点表达式来匹配，只需在要匹配的方法上添加自定义注解即可。</p><h4 id="连接点">连接点</h4><p>​在Spring中用<code>JoinPoint</code>抽象了连接点，用它可以获得方法执行时的相关信息，如目标类名、方法名、方法参数等。</p><ul><li>对于@Around 通知,获取连接点信息只能使用<code>ProceedingJoinPoint</code></li><li>对于其他四种通知，获取连接点信息只能使用<code>JoinPoint</code>，它是<code>ProceedingJoinPoint</code>的父类型</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209205048611-2024-12-920:51:02.png"alt="image-20241209205048611" /><figcaption aria-hidden="true">image-20241209205048611</figcaption></figure><h3 id="案例">9.3、案例</h3><p>​ 将案例中 <strong>增、删、改</strong>相关接口的操作日志记录到数据库表中。</p><p>​日志信息包含：操作人、操作时间、执行方法的全类名、执行方法名、方法运行时参数、返回值、方法执行时长</p><ul><li>需要对所有业务类中的增、删、改方法添加统一功能，使用AOP技术最为方便</li><li>需要获得方法的返回值和方法的执行时长，故应该采用<code>@Arround</code>环绕通知</li><li>由于增、删、改方法名没有规律，可以自定义注解（<span class="citation"data-cites="Log">@Log</span>）完成目标方法匹配，使用<code>@annotation</code>切入点表达式</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240508170551209-2024-5-817:06:49.png"alt="image-20240508170551209" /><figcaption aria-hidden="true">image-20240508170551209</figcaption></figure><p>准备：</p><ul><li><p>AOP依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- AOP--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>日志表</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 操作日志表</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> operate_log(    id <span class="hljs-type">int</span> unsigned <span class="hljs-keyword">primary</span> key auto_increment comment <span class="hljs-string">&#x27;ID&#x27;</span>,    operate_user <span class="hljs-type">int</span> unsigned comment <span class="hljs-string">&#x27;操作人ID&#x27;</span>,    operate_time datetime comment <span class="hljs-string">&#x27;操作时间&#x27;</span>,    class_name <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) comment <span class="hljs-string">&#x27;操作的类名&#x27;</span>,    method_name <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) comment <span class="hljs-string">&#x27;操作的方法名&#x27;</span>,    method_params <span class="hljs-type">varchar</span>(<span class="hljs-number">1000</span>) comment <span class="hljs-string">&#x27;方法参数&#x27;</span>,    return_value <span class="hljs-type">varchar</span>(<span class="hljs-number">2000</span>) comment <span class="hljs-string">&#x27;返回值&#x27;</span>,    cost_time <span class="hljs-type">bigint</span> comment <span class="hljs-string">&#x27;方法执行耗时, 单位:ms&#x27;</span>) comment <span class="hljs-string">&#x27;操作日志表&#x27;</span>;</code></pre></div></li></ul><p>编码：</p><ul><li><p>自定义注解<code>@Log</code>用作标识</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Target(ElementType.METHOD)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Log &#123;&#125;</code></pre></div></li><li><p>定义日志表的实体类<code>OperateLog</code>，定义操作数据库的Mapper接口<code>OperateLogMapper</code>，在接口中定义插入方法即可。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperateLog</span> &#123;    <span class="hljs-keyword">private</span> Integer id; <span class="hljs-comment">//ID</span>    <span class="hljs-keyword">private</span> Integer operateUser; <span class="hljs-comment">//操作人ID</span>    <span class="hljs-keyword">private</span> LocalDateTime operateTime; <span class="hljs-comment">//操作时间</span>    <span class="hljs-keyword">private</span> String className; <span class="hljs-comment">//操作类名</span>    <span class="hljs-keyword">private</span> String methodName; <span class="hljs-comment">//操作方法名</span>    <span class="hljs-keyword">private</span> String methodParams; <span class="hljs-comment">//操作方法参数</span>    <span class="hljs-keyword">private</span> String returnValue; <span class="hljs-comment">//操作方法返回值</span>    <span class="hljs-keyword">private</span> Long costTime; <span class="hljs-comment">//操作耗时</span>&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OperateLogMapper</span> &#123;    <span class="hljs-comment">//插入日志数据</span>    <span class="hljs-meta">@Insert(&quot;insert into operate_log (operate_user, operate_time, class_name, method_name, method_params, return_value, cost_time) &quot; +</span><span class="hljs-meta">            &quot;values (#&#123;operateUser&#125;, #&#123;operateTime&#125;, #&#123;className&#125;, #&#123;methodName&#125;, #&#123;methodParams&#125;, #&#123;returnValue&#125;, #&#123;costTime&#125;);&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(OperateLog log)</span>;&#125;</code></pre></div></li><li><p>定义切面类，完成记录操作日志的逻辑</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@Aspect</span><span class="hljs-meta">@Slf4j</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogAspect</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HttpServletRequest request;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> OperateLogMapper operateLogMapper;    <span class="hljs-meta">@Around(&quot;@annotation(com.example.anno.Log)&quot;)</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">recordLog</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;        <span class="hljs-comment">//获得操作者id</span>            <span class="hljs-comment">//通过对请求头中JWT令牌解析，获得当前操作者的id</span>        <span class="hljs-type">String</span> <span class="hljs-variable">JwtToken</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);        <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> JwtUtils.parseJWT(JwtToken);        <span class="hljs-type">Integer</span> <span class="hljs-variable">operatorUser</span> <span class="hljs-operator">=</span>(Integer) claims.get(<span class="hljs-string">&quot;id&quot;</span>);        <span class="hljs-comment">//操作执行的时间</span>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">operateTime</span> <span class="hljs-operator">=</span> LocalDateTime.now();        <span class="hljs-comment">//所操作的类名</span>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> joinPoint.getClass().getName();        <span class="hljs-comment">//所执行的方法名</span>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();        <span class="hljs-comment">//方法传入的参数</span>        Object[] args = joinPoint.getArgs();        <span class="hljs-type">String</span> <span class="hljs-variable">methodParams</span> <span class="hljs-operator">=</span> Arrays.toString(args);        <span class="hljs-comment">//调用原始目标方法运行</span>        <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> joinPoint.proceed();        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();        <span class="hljs-comment">//返回值</span>        <span class="hljs-type">String</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> JSON.toJSONString(result);        <span class="hljs-comment">//方法执行耗时</span>        <span class="hljs-type">Long</span> <span class="hljs-variable">costTime</span> <span class="hljs-operator">=</span> end - begin;        <span class="hljs-comment">//记录操作日志</span>        <span class="hljs-type">OperateLog</span> <span class="hljs-variable">operateLog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OperateLog</span>(<span class="hljs-literal">null</span>,operatorUser,operateTime,className,methodName,methodParams,returnValue,costTime);        operateLogMapper.insert(operateLog);        log.info(<span class="hljs-string">&quot;记录操作日志：&#123;&#125;&quot;</span>,operateLog);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre></div></li><li><p>在部门管理和员工管理的Controller中，在执行增、删、改的方法上添加自定义注解<code>@Log</code>，当访问这些接口时会自动记录日志。如：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240508171422153-2024-5-817:14:26.png"alt="image-20240508171422153" /><figcaption aria-hidden="true">image-20240508171422153</figcaption></figure></li></ul><h2 id="十springboot原理探究">十、Springboot原理探究</h2><h3 id="配置优先级">10.1、配置优先级</h3><p><strong>优先级：低→高</strong></p><ul><li>application.yaml（忽略）</li><li>application.yml</li><li>application.properties</li><li>java系统属性（-Dxxx=xxx）</li><li>命令行参数（--xxx=xxx）</li></ul><p>在SpringBoot 中支持三种格式的配置文件：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-09_20-57-21-2024-12-920:58:40.png"alt="PixPin_2024-12-09_20-57-21" /><figcaption aria-hidden="true">PixPin_2024-12-09_20-57-21</figcaption></figure><p>SpringBoot除了支持配置文件属性配置，还支持<strong>Java系统属性</strong>和<strong>命令行参数</strong>的方式进行属性配置。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209210111973-2024-12-921:01:40.png"alt="image-20241209210111973" /><figcaption aria-hidden="true">image-20241209210111973</figcaption></figure><h3 id="bean管理">10.2、Bean管理</h3><h4 id="bean的获取">bean的获取</h4><p>​默认情况下，Spring项目启动时，会把bean都创建好放在IOC容器中，如果想要主动获取这些bean可以通过如下方式：</p><ul><li><p>根据name获取bean</p><div class="code-wrapper"><pre><code class="hljs java">Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span></code></pre></div></li><li><p>根据类型获取bean</p><div class="code-wrapper"><pre><code class="hljs java">&lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span></code></pre></div></li><li><p>根据name获取bean（带类型转换）</p><div class="code-wrapper"><pre><code class="hljs java">&lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span></code></pre></div></li></ul><blockquote><p>注意：上述所说的【Spring项目启动时，会把其中的bean都创建好】还会受到作用域及延迟初始化影响，这里主要针对于默认的单例非延迟加载的bean而言。</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootWebConfig2ApplicationTests</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> ApplicationContext applicationContext; <span class="hljs-comment">//IOC容器对象</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetBean</span><span class="hljs-params">()</span>&#123;        <span class="hljs-comment">//根据bean的名称获取，bean名称默认为类名首字母小写</span>        <span class="hljs-type">DeptController</span> <span class="hljs-variable">bean1</span> <span class="hljs-operator">=</span> (DeptController) applicationContext.getBean(<span class="hljs-string">&quot;deptController&quot;</span>);        System.out.println(bean1);        <span class="hljs-comment">//根据bean的类型获取</span>        <span class="hljs-type">DeptController</span> <span class="hljs-variable">bean2</span> <span class="hljs-operator">=</span> applicationContext.getBean(DeptController.class);        System.out.println(bean2);        <span class="hljs-comment">//根据bean的名称 及 类型获取</span>        <span class="hljs-type">DeptController</span> <span class="hljs-variable">bean3</span> <span class="hljs-operator">=</span> applicationContext.getBean(            <span class="hljs-string">&quot;deptController&quot;</span>, DeptController.class);        System.out.println(bean3);    &#125;&#125;</code></pre></div><p>三种方式获得的是同一个bean对象，说明IOC容器中改bean对象只有一个，是<code>单例</code>的</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509091138415-2024-5-909:11:46.png"alt="image-20240509091138415" /><figcaption aria-hidden="true">image-20240509091138415</figcaption></figure><h4 id="bean的作用域">bean的作用域</h4><p>Spring支持五种作用域，后三种在web环境才生效：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209210632428-2024-12-921:06:40.png"alt="image-20241209210632428" /><figcaption aria-hidden="true">image-20241209210632428</figcaption></figure><p>可以通过<code>@Scope</code>注解来进行配置作用域：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span> <span class="hljs-comment">//通过@Scope注解来进行配置作用域</span><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping(&quot;/depts&quot;)</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeptController</span> f</code></pre></div><blockquote><p>注意：</p><ol type="i"><li><p>默认singleton的bean，在容器启动时被创建，可以使用@Lazy注解来延迟初始化（延迟到第一次使用时）。</p></li><li><p>prototype的bean，每一次使用该bean的时候都会创建一个新的实例。</p></li><li><p>实际开发当中，绝大部分的Bean是单例的，也就是说绝大部分Bean不需要配置scope属性。</p></li></ol></blockquote><h4 id="第三方bean">第三方bean</h4><p>如果要管理的bean对象来自于第三方（不是自定义的），是无法用@Component及衍生注解声明bean的，就需要用到<code>@Bean</code>注解。</p><p>若要管理的第三方bean对象，建议对这些bean进行集中分类配置，可以通过@Configuration注解声明一个配置类。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209211050702-2024-12-921:10:51.png"alt="image-20241209211050702" /><figcaption aria-hidden="true">image-20241209211050702</figcaption></figure><blockquote><ol type="i"><li>通过@Bean注解的name或value属性可以声明bean的名称，如果不指定，<strong><u>默认bean的名称就是方法名</u></strong>。</li><li><u>如果第三方bean需要依赖其它bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。</u></li></ol></blockquote><p>将第三方操作XML文件的工具类交给spring管理，使用时直接自动注入，不用再自己创建对象。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//配置类</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonConfig</span> &#123;    <span class="hljs-comment">//声明第三方bean</span>    <span class="hljs-meta">@Bean</span> <span class="hljs-comment">//将当前方法的返回值对象交给IOC容器管理, 成为IOC容器bean</span>          <span class="hljs-comment">//通过@Bean注解的name/value属性指定bean名称, 如果未指定, 默认是方法名</span>    <span class="hljs-keyword">public</span> SAXReader <span class="hljs-title function_">reader</span><span class="hljs-params">(DeptService deptService)</span>&#123;        System.out.println(deptService);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SAXReader</span>();    &#125;&#125;</code></pre></div><p>测试</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootWebConfig2ApplicationTests</span> &#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> SAXReader saxReader;    <span class="hljs-comment">//第三方bean的管理</span>    <span class="hljs-meta">@Test</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testThirdBean</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">//SAXReader saxReader = new SAXReader();</span>        <span class="hljs-type">Document</span> <span class="hljs-variable">document</span> <span class="hljs-operator">=</span> saxReader.read(<span class="hljs-built_in">this</span>.getClass().getClassLoader().getResource(<span class="hljs-string">&quot;1.xml&quot;</span>));        <span class="hljs-type">Element</span> <span class="hljs-variable">rootElement</span> <span class="hljs-operator">=</span> document.getRootElement();        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> rootElement.element(<span class="hljs-string">&quot;name&quot;</span>).getText();        <span class="hljs-type">String</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> rootElement.element(<span class="hljs-string">&quot;age&quot;</span>).getText();        System.out.println(name + <span class="hljs-string">&quot; : &quot;</span> + age);    &#125;&#125;</code></pre></div><p>补充：读写XML文档主要依赖于<code>org.dom4j.io</code>包，有DOMReader和SAXReader两种方式。</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--Dom4j--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.dom4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dom4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="springboot原理">10.3、springboot原理</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509095011100-2024-5-909:50:46.png"alt="image-20240509095011100" /><figcaption aria-hidden="true">image-20240509095011100</figcaption></figure><h4 id="起步依赖">起步依赖</h4><p>SpringBoot官方的起步依赖都遵循一样的命名规范，都以<code>spring-boot-starter-</code>开头</p><p>原理：起步依赖背后使用的其实就是<code>Maven的传递依赖机制</code>。假设B依赖于C，而A又依赖于B，那么A无需明确声明对C的依赖，而是通过B依赖于C。因此看似只添加了一个依赖，但实际上通过传递依赖，我们已经引入了一堆的依赖。</p><h4 id="自动配置">自动配置</h4><h5 id="概述-2">概述</h5><p>SpringBoot的自动配置就是当spring容器启动后，一些配置类、bean对象就自动存入到了IOC容器中，不需要我们手动去声明，从而简化了开发，省去了繁琐的配置操作。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230114205745221-2024-5-912:20:02.png"alt="image-20230114205745221" /><figcaption aria-hidden="true">image-20230114205745221</figcaption></figure><h5 id="常见方案">常见方案</h5><blockquote><p>方案一：<span class="citation"data-cites="ComponentScan">@ComponentScan</span> 组件扫描</p></blockquote><p><span class="citation"data-cites="ComponentScan组件扫描">@ComponentScan组件扫描</span></p><p>在类上添加@Component注解来声明bean对象，同时使用@ComponentScan保证<spanclass="citation"data-cites="Component注解能被Spring的组件扫描到">@Component注解能被Spring的组件扫描到</span>，将其中的对象交给Spring管理，实现自动配置。</p><p>如果采用以上这种方式来完成自动配置，那我们进行项目开发时，当需要引入大量的第三方的依赖，就需要在启动类上配置N多要扫描的包，这种方式会很繁琐。而且这种大面积的扫描性能也比较低。</p><p><strong>SpringBoot中并没有采用以上这种方案。</strong></p><blockquote><p>方案二：<span class="citation" data-cites="Import">@Import</span>导入</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509123913221-2024-5-912:39:46.png"alt="image-20240509123913221" /><figcaption aria-hidden="true">image-20240509123913221</figcaption></figure><p>1). 使用@Import导入普通类：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Import(TokenParser.class)</span> <span class="hljs-comment">//导入的类会被Spring加载到IOC容器中</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootWebConfig2Application</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        SpringApplication.run(SpringbootWebConfig2Application.class, args);    &#125;&#125;</code></pre></div><p>2). 使用@Import导入配置类：</p><ul><li><p>配置类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeaderConfig</span> &#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> HeaderParser <span class="hljs-title function_">headerParser</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeaderParser</span>();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-keyword">public</span> HeaderGenerator <span class="hljs-title function_">headerGenerator</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HeaderGenerator</span>();    &#125;&#125;</code></pre></div></li><li><p>启动类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Import(HeaderConfig.class)</span> <span class="hljs-comment">//导入配置类</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootWebConfig2Application</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        SpringApplication.run(SpringbootWebConfig2Application.class, args);    &#125;&#125;</code></pre></div></li></ul><p>3). 使用@Import导入ImportSelector接口实现类：</p><ul><li><p>ImportSelector接口实现类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportSelector</span> &#123;    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;        <span class="hljs-comment">//返回值字符串数组（数组中封装了全限定名称的类）</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;com.example.HeaderConfig&quot;</span>&#125;;    &#125;&#125;</code></pre></div><blockquote><p>将要加载的类定义在一份文件中，最终读取这份文件，将文件中的字符串读取处理，封装在String数组中返回即可</p></blockquote></li><li><p>启动类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Import(MyImportSelector.class)</span> <span class="hljs-comment">//导入ImportSelector接口实现类</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootWebConfig2Application</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        SpringApplication.run(SpringbootWebConfig2Application.class, args);    &#125;&#125;</code></pre></div></li></ul><p>4). 使用第三方依赖提供的 <span class="citation"data-cites="EnableXxxxx注解">@EnableXxxxx注解</span>，其中封装了@import</p><ul><li><p>第三方依赖中提供的注解@EnableXxxxx</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Target(ElementType.TYPE)</span><span class="hljs-meta">@Import(MyImportSelector.class)</span><span class="hljs-comment">//指定要导入哪些bean对象或配置类</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableHeaderConfig &#123; &#125;</code></pre></div></li><li><p>在使用时只需在启动类上加上@EnableXxxxx注解即可</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableHeaderConfig</span>  <span class="hljs-comment">//使用第三方依赖提供的Enable开头的注解</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringbootWebConfig2Application</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        SpringApplication.run(SpringbootWebConfig2Application.class, args);    &#125;&#125;</code></pre></div></li></ul><h5 id="原理分析">原理分析</h5><h6 id="源码跟踪">源码跟踪</h6><p>通过源码跟踪的形式来剖析下SpringBoot底层到底是如何完成自动配置的。</p><p>要搞清楚SpringBoot的自动配置原理，要从SpringBoot启动类上使用的核心注解<code>@SpringBootApplication</code>开始分析：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230115001439110-2024-5-911:55:46.png"alt="image-20230115001439110" /><figcaption aria-hidden="true">image-20230115001439110</figcaption></figure><p>在@SpringBootApplication注解中包含了：</p><ul><li>元注解</li><li><span class="citation"data-cites="SpringBootConfiguration">@SpringBootConfiguration</span></li><li><span class="citation"data-cites="EnableAutoConfiguration">@EnableAutoConfiguration</span></li><li><span class="citation"data-cites="ComponentScan">@ComponentScan</span></li></ul><p>我们先来看第一个注解：<span class="citation"data-cites="SpringBootConfiguration">@SpringBootConfiguration</span></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230115001950076-2024-5-911:53:46.png"alt="image-20230115001950076" /><figcaption aria-hidden="true">image-20230115001950076</figcaption></figure><blockquote><p><span class="citation"data-cites="SpringBootConfiguration注解中使用了">@SpringBootConfiguration注解中使用了</span><spanclass="citation"data-cites="Configuration">@Configuration</span>，表明SpringBoot启动类就是一个配置类。</p><p><span class="citation"data-cites="Indexed注解">@Indexed注解</span>，是用来加速应用启动的（不用关心）。</p></blockquote><p>接下来再先看@ComponentScan注解：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230115002450993-2024-5-911:54:46.png"alt="image-20230115002450993" /><figcaption aria-hidden="true">image-20230115002450993</figcaption></figure><blockquote><p><span class="citation"data-cites="ComponentScan注解是用来进行组件扫描的">@ComponentScan注解是用来进行组件扫描的</span>，扫描启动类所在的包及其子包下所有被@Component及其衍生注解声明的类。</p><p>SpringBoot启动类，之所以具备扫描包功能，就是因为包含了@ComponentScan注解。</p></blockquote><p>最后我们来看看@EnableAutoConfiguration注解（自动配置核心注解）：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230115002743115-2024-5-911:50:46.png"alt="image-20230115002743115" /><figcaption aria-hidden="true">image-20230115002743115</figcaption></figure><blockquote><p>使用@Import注解，导入了实现ImportSelector接口的实现类。</p><p>AutoConfigurationImportSelector类是ImportSelector接口的实现类。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230115003242549-2024-5-911:51:46.png"alt="image-20230115003242549" /><figcaption aria-hidden="true">image-20230115003242549</figcaption></figure></blockquote><p>AutoConfigurationImportSelector类中重写了ImportSelector接口的<code>selectImports()</code>方法：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230115003348288-2024-5-911:58:46.png"alt="image-20230115003348288" /><figcaption aria-hidden="true">image-20230115003348288</figcaption></figure><blockquote><p>selectImports()方法底层调用getAutoConfigurationEntry()方法，获取可自动配置的配置类信息集合</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230115003704385-2024-5-912:06:46.png"alt="image-20230115003704385" /><figcaption aria-hidden="true">image-20230115003704385</figcaption></figure><blockquote><p>getAutoConfigurationEntry()方法通过调用getCandidateConfigurations(annotationMetadata,attributes)方法获取在配置文件中配置的所有自动配置类的集合</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230115003903302-2024-5-911:52:46.png"alt="image-20230115003903302" /><figcaption aria-hidden="true">image-20230115003903302</figcaption></figure><blockquote><p>getCandidateConfigurations方法的功能：</p><p>获取所有基于META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件、META-INF/spring.factories文件中配置类的集合</p></blockquote><p>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件和META-INF/spring.factories文件这两个文件在哪里呢？</p><ul><li>通常在引入的起步依赖中，都有包含以上两个文件</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230129090835964-2024-5-912:03:46.png"alt="image-20230129090835964" /><figcaption aria-hidden="true">image-20230129090835964</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230115064329460-2024-5-911:56:46.png"alt="image-20230115064329460" /><figcaption aria-hidden="true">image-20230115064329460</figcaption></figure><p><strong>自动配置源码小结</strong></p><p>自动配置原理源码入口就是@SpringBootApplication注解，在这个注解中封装了3个注解，分别是：</p><ul><li><span class="citation"data-cites="SpringBootConfiguration">@SpringBootConfiguration</span><ul><li>声明当前类是一个配置类</li></ul></li><li><span class="citation"data-cites="ComponentScan">@ComponentScan</span><ul><li>进行组件扫描（SpringBoot中默认扫描的是启动类所在的当前包及其子包）</li></ul></li><li><span class="citation"data-cites="EnableAutoConfiguration">@EnableAutoConfiguration</span><ul><li>封装了@Import注解（Import注解中指定了一个ImportSelector接口的实现类）<ul><li>在实现类重写的selectImports()方法，读取当前项目下所有依赖jar包中<em>META-INF/spring.factories</em>、<em>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</em>两个文件里面定义的配置类（配置类中定义了@Bean注解标识的方法）。根据<code>特定条件</code>决定可以导入哪些配置类，接口中的selectImports()方法返回的就是可以导入的配置类名。</li></ul></li></ul></li></ul><blockquote><p>从Spring Boot2.7开始，AutoConfigurationImportSelector不再从/META-INF/spring.factories加载自动配置类，而是开始使用新的/META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件，直接在里面添加自动配置类的全限定类名即可。</p></blockquote><p>当SpringBoot程序启动时，就会加载配置文件当中所定义的配置类，并将这些配置类信息(类的全限定名)封装到String类型的数组中，最终通过@Import注解将这些配置类全部加载到Spring的IOC容器中，交给IOC容器管理。</p><p>但是在两个文件中定义的配置类非常多，而且每个配置类中又可以定义很多的bean，这些bean并不会都注册到Spring的IOC容器中。在声明bean对象时，上面有加一个以<code>@Conditional开头</code>的注解，这种注解的作用就是按照条件进行装配，只有满足条件之后，才会将bean注册到Spring的IOC容器中（下面会详细来讲解）</p><h6 id="conditional"><span class="citation"data-cites="Conditional">@Conditional</span></h6><ul><li>作用：按照一定的条件进行判断，在满足给定条件后才会注册对应的bean对象到SpringIOC容器中。</li><li>位置：方法、类</li><li><code>@Conditional</code><strong>本身是一个父注解，派生出大量的子注解</strong>：<ul><li><code>@ConditionalOnClass</code>：判断环境中是否有对应字节码文件，才注册bean到IOC容器。</li><li><code>@ConditionalOnMissingBean</code>：判断环境中没有对应的bean（类型或名称），才注册bean到IOC容器。</li><li><code>@ConditionalOnProperty</code>：判断配置文件中有对应属性和值，才注册bean到IOC容器。</li></ul></li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509121245446-2024-5-912:12:46.png"alt="image-20240509121245446" /><figcaption aria-hidden="true">image-20240509121245446</figcaption></figure><h4 id="案例自定义starter">案例：自定义Starter</h4><p>场景：在实际开发中，经常会定义一些公共组件，提供给各个项目团队使用。而在SpringBoot的项目中，一般会将这些公共组件封装为SpringBoot的 starter。</p><p>需求：自定义<code>aliyun-oss-spring-boot-starter</code>，完成阿里云OSS操作工具类<code>AliyunOSSUtils</code>的自动配置</p><p>目标：引入起步依赖引入之后，要想使用阿里云OSS，注入<code>AliyunOsSutils</code>直接使用即可。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209211734419-2024-12-921:17:35.png"alt="image-20241209211734419" /><figcaption aria-hidden="true">image-20241209211734419</figcaption></figure><blockquote><p>SpringBoot官方starter命名： spring-boot-starter-xxxx</p><p>第三组织提供的starter命名： xxxx-spring-boot-starter</p></blockquote><p>分析mybatis的依赖是如何加载的</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509181251283-2024-5-918:13:46.png"alt="image-20240509181251283" /><figcaption aria-hidden="true">image-20240509181251283</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230115225703863-2024-5-918:14:03.png"alt="image-20230115225703863" /><figcaption aria-hidden="true">image-20230115225703863</figcaption></figure><blockquote><p>Mybatis提供了配置类，并且也提供了springboot会自动读取的配置文件。当SpringBoot项目启动时，会读取到spring.factories配置文件中的配置类并加载配置类，生成相关bean对象注册到IOC容器中。</p><p>结果：我们可以直接在SpringBoot程序中使用Mybatis自动配置的bean对象。</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241209211958547-2024-12-921:19:59.png"alt="image-20241209211958547" /><figcaption aria-hidden="true">image-20241209211958547</figcaption></figure><p>1、创建 aliyun-oss-springboot-start 模块</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509181625217-2024-5-918:16:26.png"alt="image-20240509181625217" /><figcaption aria-hidden="true">image-20240509181625217</figcaption></figure><p>2、创建 aliyun-oss-spring-boot-autoconfigure 模块</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509182110887-2024-5-918:21:46.png"alt="image-20240509182110887" /><figcaption aria-hidden="true">image-20240509182110887</figcaption></figure><ol type="1"><li><p>在pom.xml文件中添加相关依赖</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aliyun.oss<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aliyun-oss-spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--  引入web开发起步依赖      --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--        添加阿里云OSS依赖  --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aliyun.oss<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.15.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- lombok --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div></li><li><p>修改AliOSSProperties.java 和 AliOSSUtiles.java中的代码</p><p>这两个类都不用再使用@Component注解，在SpringBoot项目中，并不会去扫描com.aliyun.oss这个包，不扫描这个包那类上的注解也就失去了作用。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.aliyun.oss;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> AliOSSProperties</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> 86152</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/5/6 22:28</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Data</span><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSProperties</span> &#123;    <span class="hljs-keyword">private</span> String endpoint;    <span class="hljs-keyword">private</span> String accessKeyId;    <span class="hljs-keyword">private</span> String accessKeySecret;    <span class="hljs-keyword">private</span> String bucketName;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.aliyun.oss;<span class="hljs-keyword">import</span> com.aliyun.oss.OSS;<span class="hljs-keyword">import</span> com.aliyun.oss.OSSClientBuilder;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.util.UUID;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 阿里云 OSS 工具类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSUtils</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 实现上传图片到OSS</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> AliOSSProperties aliOSSProperties;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAliOSSProperties</span><span class="hljs-params">(AliOSSProperties aliOSSProperties)</span> &#123;        <span class="hljs-built_in">this</span>.aliOSSProperties = aliOSSProperties;    &#125;    <span class="hljs-keyword">public</span> AliOSSProperties <span class="hljs-title function_">getAliOSSProperties</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> aliOSSProperties;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">upload</span><span class="hljs-params">(MultipartFile file)</span> <span class="hljs-keyword">throws</span> IOException &#123;        <span class="hljs-comment">//获取阿里云OSS配置信息</span>        <span class="hljs-type">String</span> <span class="hljs-variable">endpoint</span> <span class="hljs-operator">=</span> aliOSSProperties.getEndpoint();        <span class="hljs-type">String</span> <span class="hljs-variable">accessKeyId</span> <span class="hljs-operator">=</span> aliOSSProperties.getAccessKeyId();        <span class="hljs-type">String</span> <span class="hljs-variable">accessKeySecret</span> <span class="hljs-operator">=</span> aliOSSProperties.getAccessKeySecret();        <span class="hljs-type">String</span> <span class="hljs-variable">bucketName</span> <span class="hljs-operator">=</span> aliOSSProperties.getBucketName();        <span class="hljs-comment">// 获取上传的文件的输入流</span>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> file.getInputStream();        <span class="hljs-comment">// 避免文件覆盖</span>        <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> file.getOriginalFilename();        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + originalFilename.substring(originalFilename.lastIndexOf(<span class="hljs-string">&quot;.&quot;</span>));        <span class="hljs-comment">//上传文件到 OSS</span>        <span class="hljs-type">OSS</span> <span class="hljs-variable">ossClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);        ossClient.putObject(bucketName, fileName, inputStream);        <span class="hljs-comment">//文件访问路径</span>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> endpoint.split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;//&quot;</span> + bucketName + <span class="hljs-string">&quot;.&quot;</span> + endpoint.split(<span class="hljs-string">&quot;//&quot;</span>)[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;/&quot;</span> + fileName;        <span class="hljs-comment">// 关闭ossClient</span>        ossClient.shutdown();        <span class="hljs-keyword">return</span> url;<span class="hljs-comment">// 把上传到oss的路径返回</span>    &#125;&#125;</code></pre></div></li><li><p>添加配置类</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.aliyun.oss;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@ClassName</span> AliyunOSSAutoconfiguration</span><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span> TODO 自动配置类</span><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> 86152</span><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2024/5/9 17:28</span><span class="hljs-comment"> * <span class="hljs-doctag">@Version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@EnableConfigurationProperties(AliOSSProperties.class)</span>  <span class="hljs-comment">//将AliOSSProperties导入IOC容器，称为IOC容器中的bean</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliOSSAutoConfiguration</span> &#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-comment">//第三方bean要使用其他bean对象，直接在bean定义方法中设置形参即可，容器会根据类型自动装配。</span>    <span class="hljs-keyword">public</span> AliOSSUtils <span class="hljs-title function_">aliOSSUtils</span><span class="hljs-params">(AliOSSProperties aliOSSProperties)</span> &#123;          <span class="hljs-type">AliOSSUtils</span> <span class="hljs-variable">aliOSSUtils</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AliOSSUtils</span>();        aliOSSUtils.setAliOSSProperties(aliOSSProperties);<span class="hljs-comment">//手动设置私有属性aliOSSProperties</span>        <span class="hljs-keyword">return</span> aliOSSUtils;    &#125;&#125;</code></pre></div></li><li><p>创建自动配置文件：<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>，将配置类添加进入，Spring启动的时候就会扫描这个文件，将其中的类交给Spring容器管理，称为IOC容器中的bean</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509182812818-2024-5-918:28:46.png"alt="image-20240509182812818" /><figcaption aria-hidden="true">image-20240509182812818</figcaption></figure></li></ol><p>5、测试</p><p>在项目pom文件中导入aliyun-oss-springboot-starter依赖，使用@Autowired在运行中获取AliOSSUtils对象完成文件上传</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509183259325-2024-5-918:33:46.png"alt="image-20240509183259325" /><figcaption aria-hidden="true">image-20240509183259325</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509183330365-2024-5-918:34:46.png"alt="image-20240509183330365" /><figcaption aria-hidden="true">image-20240509183330365</figcaption></figure><h2 id="后端开发总结">1.12、后端开发总结</h2><p>到此基于SpringBoot进行web后端开发的相关知识我们已经学习完毕了。下面我们一起针对这段web课程做一个总结。</p><p>我们来回顾一下关于web后端开发，我们都学习了哪些内容，以及每一块知识，具体是属于哪个框架的。</p><p>web后端开发现在基本上都是基于标准的三层架构进行开发的，在三层架构当中，Controller控制器层负责接收请求响应数据，Service业务层负责具体的业务逻辑处理，而Dao数据访问层也叫持久层，就是用来处理数据访问操作的，来完成数据库当中数据的增删改查操作。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230114180044897-2024-5-920:42:46.png"alt="image-20230114180044897" /><figcaption aria-hidden="true">image-20230114180044897</figcaption></figure><blockquote><p>在三层架构当中，前端发起请求首先会到达Controller(不进行逻辑处理)，然后Controller会直接调用Service进行逻辑处理， Service再调用Dao完成数据访问操作。</p></blockquote><p>如果我们在执行具体的业务处理之前，需要去做一些通用的业务处理，比如：我们要进行统一的登录校验，我们要进行统一的字符编码等这些操作时，我们就可以借助于Javaweb当中三大组件之一的过滤器Filter或者是Spring当中提供的拦截器Interceptor来实现。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230114191737227-2024-5-920:41:47.png"alt="image-20230114191737227" /><figcaption aria-hidden="true">image-20230114191737227</figcaption></figure><p>而为了实现三层架构层与层之间的解耦，我们学习了Spring框架当中的第一大核心：IOC控制反转与DI依赖注入。</p><blockquote><p>所谓控制反转，指的是将对象创建的控制权由应用程序自身交给外部容器，这个容器就是我们常说的IOC容器或Spring容器。</p><p>而DI依赖注入指的是容器为程序提供运行时所需要的资源。</p></blockquote><p>除了IOC与DI我们还讲到了AOP面向切面编程，还有Spring中的事务管理、全局异常处理器，以及传递会话技术Cookie、Session以及新的会话跟踪解决方案JWT令牌，阿里云OSS对象存储服务，以及通过Mybatis持久层架构操作数据库等技术。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230114192921673-2024-5-920:45:46.png"alt="image-20230114192921673" /><figcaption aria-hidden="true">image-20230114192921673</figcaption></figure><p>我们在学习这些web后端开发技术的时候，我们都是基于主流的SpringBoot进行整合使用的。而SpringBoot又是用来简化开发，提高开发效率的。像过滤器、拦截器、IOC、DI、AOP、事务管理等这些技术到底是哪个框架提供的核心功能？</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230114193609782-2024-5-920:44:46.png"alt="image-20230114193609782" /><figcaption aria-hidden="true">image-20230114193609782</figcaption></figure><blockquote><p>Filter过滤器、Cookie、 Session这些都是传统的JavaWeb提供的技术。</p><p>JWT令牌、阿里云OSS对象存储服务，是现在企业项目中常见的一些解决方案。</p><p>IOC控制反转、DI依赖注入、AOP面向切面编程、事务管理、全局异常处理、拦截器等，这些技术都是Spring Framework框架当中提供的核心功能。</p><p>Mybatis就是一个持久层的框架，是用来操作数据库的。</p></blockquote><p>在Spring框架的生态中，对web程序开发提供了很好的支持，如：全局异常处理器、拦截器这些都是Spring框架中web开发模块所提供的功能，而Spring框架的web开发模块，我们也称为：SpringMVC</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230114195143418-2024-5-920:43:46.png"alt="image-20230114195143418" /><figcaption aria-hidden="true">image-20230114195143418</figcaption></figure><blockquote><p>SpringMVC不是一个单独的框架，它是Spring框架的一部分，是Spring框架中的web开发模块，是用来简化原始的Servlet程序开发的。</p></blockquote><p>外界俗称的SSM，就是由：SpringMVC、SpringFramework、Mybatis三块组成。</p><p>基于传统的SSM框架进行整合开发项目会比较繁琐，而且效率也比较低，所以在现在的企业项目开发当中，基本上都是直接基于SpringBoot整合SSM进行项目开发的。</p><p>到此我们web后端开发的内容就已经全部讲解结束了。</p><h2 id="十一maven高级">十一、Maven高级</h2><h2 id="分模块开发与设计">11.1、分模块开发与设计</h2><p>​对于开发一个大型的电商项目，里面可能就包括了商品模块的功能、搜索模块的功能、购物车模块、订单模块、用户中心等等。如果这些所有的业务代码我们都在一个Java项目当中编写，项目管理和维护起来将会非常的困难。而且对一些通用的工具类以及通用的组件，难以共享复用。</p><p>​采用分模块开发，可以将商品的相关功能放在商品模块当中，搜索的相关业务功能我都封装在搜索模块当中，还有像购物车模块、订单模块。而为了组件的复用，也可以将项目当中的实体类、工具类以及定义的通用的组件都单独的抽取到一个模块当中。</p><p>​如果当前这个模块，比如订单模块需要用到这些实体类以及工具类或者这些通用组件，此时直接在订单模块当中引入工具类的坐标就可以了。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240509213323666-2024-5-921:33:46.png" alt="image-20240509213323666" style="width:95%;" /></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509213240413-2024-5-921:32:46.png"alt="image-20240509213240413" /><figcaption aria-hidden="true">image-20240509213240413</figcaption></figure><blockquote><p>步骤1：创建Maven模块 tlias-pojo，存放实体类。</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230113101216305-2024-5-921:41:43.png"alt="image-20230113101216305" /><figcaption aria-hidden="true">image-20230113101216305</figcaption></figure><blockquote><p>步骤2：创建Maven模块 tlias-utils，存放相关工具类。</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230113102113451-2024-5-921:42:30.png"alt="image-20230113102113451" /><figcaption aria-hidden="true">image-20230113102113451</figcaption></figure><blockquote><p>步骤3：在需要的项目中引入模块</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509214402937-2024-5-921:44:03.png"alt="image-20240509214402937" /><figcaption aria-hidden="true">image-20240509214402937</figcaption></figure><h2 id="继承与聚合">11.2、继承与聚合</h2><h3 id="继承">继承</h3><p>在案例项目分模块开发之后，在lias-pojo、tlias-utils、tlias-web-management中都引入了一个依赖lombok 的依赖。我们在三个模块中分别配置了一次。</p><p>如果是做一个大型的项目，这三个模块当中重复的依赖可能会很多很多。如果每一个Maven模块里面，我们都来单独的配置一次，功能虽然能实现，但是配置是比较<strong>繁琐</strong>的。Maven 的继承用来解决该问题的。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509225135625-2024-5-922:51:46.png"alt="image-20240509225135625" /><figcaption aria-hidden="true">image-20240509225135625</figcaption></figure><h4 id="继承关系实现">继承关系实现</h4><p>在Maven中是持多重继承的。让自己创建的三个模块，都继承tlias-parent，而tlias-parent再继承 spring-boot-starter-parent。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230113113004727-2024-5-922:55:46.png"alt="image-20230113113004727" /><figcaption aria-hidden="true">image-20230113113004727</figcaption></figure><blockquote><p>步骤一：创建父工程模块</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509225851531-2024-5-922:58:52.png"alt="image-20240509225851531" /><figcaption aria-hidden="true">image-20240509225851531</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509230119583-2024-5-923:01:46.png"alt="image-20240509230119583" /><figcaption aria-hidden="true">image-20240509230119583</figcaption></figure><blockquote><p>步骤二：在子工程的pom.xml文件中，继承父工程</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509225702655-2024-5-922:57:03.png"alt="image-20240509225702655" /><figcaption aria-hidden="true">image-20240509225702655</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509230637887-2024-5-923:06:39.png"alt="image-20240509230637887" /><figcaption aria-hidden="true">image-20240509230637887</figcaption></figure><p>注：在ralativePath中，使用<code>../</code>返回当前pom文件的上一级，可以在文件管理器中查看目录结构，正确填写父工程pom文件的路径</p><blockquote><p>步骤三：在父工程中配置各个子工程共有的依赖</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509231011187-2024-5-923:10:36.png"alt="image-20240509231011187" /><figcaption aria-hidden="true">image-20240509231011187</figcaption></figure><h4 id="版本锁定">版本锁定</h4><p>在父工程中集中管理一些依赖的版本，在子工程中，直接使用该依赖而不再需要指定属性。当版本需要变更时，只需修改父工程中设定的版本号即可，不用去修改每个子工程中的版本号。</p><p>在maven中，可以在父工程的pom文件中通过<code>&lt;dependencyManagement&gt;</code> 来统一管理依赖版本。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509233543781-2024-5-923:36:46.png"alt="image-20240509233543781" /><figcaption aria-hidden="true">image-20240509233543781</figcaption></figure><p>父工程：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--统一管理依赖版本--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--JWT令牌--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></code></pre></div><p>子工程：</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!--JWT令牌--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><blockquote><p>注意：</p><ul><li><p>在父工程中所配置的 <code>&lt;dependencyManagement&gt;</code>只能统一管理依赖版本，并不会将这个依赖直接引入进来。 这点和<code>&lt;dependencies&gt;</code> 是不同的。</p></li><li><p>子工程要使用这个依赖，还是需要使用<code>&lt;dependencies&gt;</code> 引入，只是此时就无需指定<code>&lt;version&gt;</code>版本号了，父工程统一管理。变更依赖版本，只需在父工程中统一变更。</p></li></ul></blockquote><p>我们也可以通过<code>自定义属性及属性引用</code>的形式，在父工程中将依赖的版本号进行集中管理维护。当父工程管理的依赖很多时，要修改版本号，不需要在<code>&lt;dependencyManagement&gt;</code>标签中找到该依赖再去修改版本号，直接修改自定义属性即可。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509233515708-2024-5-923:35:46.png"alt="image-20240509233515708" /><figcaption aria-hidden="true">image-20240509233515708</figcaption></figure><p>1). 自定义属性</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">lombok.version</span>&gt;</span>1.18.24<span class="hljs-tag">&lt;/<span class="hljs-name">lombok.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span></code></pre></div><p>2). 引用属性</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>查看Spring框架的版本管理方式：先使用自定义标签设置依赖版本号，使用时通过<code>$&#123;&#125;</code>获取自定义标签的值</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509233651035-2024-5-923:37:46.png"alt="image-20240509233651035" /><figcaption aria-hidden="true">image-20240509233651035</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509233741269-2024-5-923:38:46.png"alt="image-20240509233741269" /><figcaption aria-hidden="true">image-20240509233741269</figcaption></figure><h3 id="聚合">聚合</h3><p>项目分模块开发后，最后打包上线，需要让<u>每个模块</u>都执行maven的<code>package</code>生命周期，安装到本地仓库，才能实现成功打包，若仓库中缺失某个模块打包后的jar包，最终项目就会打包失败。</p><p>如果开发一个大型项目，拆分的模块很多，模块之间的依赖关系错综复杂，那此时要进行项目的打包、安装操作，是非常繁琐的。maven的聚合就是来解决这个问题的，通过maven的聚合就可以轻松实现项目的一键构建（清理、编译、测试、打包、安装等）。</p><h4 id="介绍">介绍</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230113151533948-2024-5-923:53:24.png" alt="image-20230113151533948" style="zoom:80%;" /></p><ul><li><strong>聚合：</strong>将多个模块组织成一个整体，同时进行项目的构建。</li><li><strong>聚合工程：</strong>一个不具有业务功能的“空”工程（有且仅有一个pom文件）【PS：一般来说，继承关系中的父工程与聚合关系中的聚合工程是同一个】</li><li><strong>作用：</strong>快速构建项目（无需根据依赖关系手动构建，直接在聚合工程上构建即可）</li></ul><h4 id="实现">实现</h4><p>在maven中，我们可以在聚合工程中通过 <code>&lt;moudules&gt;</code>设置当前聚合工程所包含的子模块的名称。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509235523700-2024-5-923:55:24.png"alt="image-20240509235523700" /><figcaption aria-hidden="true">image-20240509235523700</figcaption></figure><p>我们可以在tlias-parent中，添加如下配置，来指定当前聚合工程，需要聚合的模块：</p><div class="code-wrapper"><pre><code class="hljs java">&lt;!--聚合其他模块--&gt;&lt;modules&gt;    &lt;<span class="hljs-keyword">module</span>&gt;../tlias-pojo&lt;/<span class="hljs-keyword">module</span>&gt;    &lt;<span class="hljs-keyword">module</span>&gt;../tlias-utils&lt;/<span class="hljs-keyword">module</span>&gt;    &lt;<span class="hljs-keyword">module</span>&gt;../tlias-web-management&lt;/<span class="hljs-keyword">module</span>&gt;&lt;/modules&gt;</code></pre></div><p>此时要进行编译、打包、安装操作，就无需在每一个模块上操作了。只需要在聚合工程上，统一进行操作就可以了。</p><h3 id="继承与聚合对比">继承与聚合对比</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240509235806269-2024-5-923:58:07.png"alt="image-20240509235806269" /><figcaption aria-hidden="true">image-20240509235806269</figcaption></figure><h2 id="私服">11.3、私服</h2><h3 id="介绍-1">介绍</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240510000150698-2024-5-1000:02:46.png"alt="image-20240510000150698" /><figcaption aria-hidden="true">image-20240510000150698</figcaption></figure><h3 id="资源的上传和下载">资源的上传和下载</h3><h4 id="步骤分析">步骤分析</h4><p>资源上传与下载，我们需要做三步配置，执行一条指令。</p><p>第一步配置：在maven的配置文件中配置访问私服的用户名、密码。</p><p>第二步配置：在maven的配置文件中配置连接私服的地址(url地址)。</p><p>第三步配置：在项目的pom.xml文件中配置上传资源的位置(url地址)。</p><p>配置好了上述三步之后，要上传资源到私服仓库，就执行执行maven生命周期：deploy。</p><blockquote><p>私服仓库说明：</p><ul><li>RELEASE：存储自己开发的RELEASE发布版本的资源。</li><li>SNAPSHOT：存储自己开发的SNAPSHOT发布版本的资源。</li><li>Central：存储的是从中央仓库下载下来的依赖。</li></ul></blockquote><blockquote><p>项目版本说明：</p><ul><li>RELEASE(发布版本)：功能趋于稳定、当前更新停止，可以用于发行的版本，存储在私服中的RELEASE仓库中。</li><li>SNAPSHOT(快照版本)：功能不稳定、尚处于开发中的版本，即快照版本，存储在私服的SNAPSHOT仓库中。</li></ul></blockquote><h4 id="具体操作">具体操作</h4><p><ahref="https://www.bilibili.com/video/BV1m84y1w7Tb?p=199&amp;spm_id_from=pageDriver&amp;vd_source=51d78ede0a0127d1839d6abf9204d1ee">b站课程</a></p><p>使用私服，需要在maven的settings.xml配置文件中，做如下配置：</p><ol type="1"><li><p>需要在 <strong>servers</strong>标签中，配置访问私服的个人凭证(访问的用户名和密码)</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>maven-releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>maven-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span></code></pre></div></li><li><p>在 <strong>mirrors</strong>中只配置我们自己私服的连接地址(如果之前配置过阿里云，需要直接替换掉)</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>maven-public<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span></code></pre></div></li><li><p>需要在 <strong>profiles</strong>中，增加如下配置，来指定snapshot快照版本的依赖，依然允许使用</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>allow-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>maven-public<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span></code></pre></div></li><li><p>如果需要上传自己的项目到私服上，需要在项目的pom.xml文件中，增加如下配置，来配置项目发布的地址(也就是私服的地址)</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span>    <span class="hljs-comment">&lt;!-- release版本的发布地址 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>maven-releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-releases/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-comment">&lt;!-- snapshot版本的发布地址 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>maven-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://192.168.150.101:8081/repository/maven-snapshots/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span></code></pre></div></li><li><p>发布项目，直接运行 deploy 生命周期即可(发布时，建议跳过单元测试)</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>Springboot原理</tag>
      
      <tag>IOC</tag>
      
      <tag>DI</tag>
      
      <tag>MyBatis</tag>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaWeb基础（一）前端相关</title>
    <link href="/4b1cca40/"/>
    <url>/4b1cca40/</url>
    
    <content type="html"><![CDATA[<meta name = "referrer", content = "no-referrer"/><h1 id="一前端相关">一、前端相关</h1><h2 id="html相关标签">1.1、HTML相关标签</h2><p><ahref="https://www.runoob.com/html/html-tutorial.html">HTML教程</a></p><blockquote><p>注：在HTML中无论输入多少个空格，只会显示一个。可以使用空格占位符：<code>&amp;nbsp;</code></p></blockquote><h2 id="css样式">1.2、css样式</h2><p><a href="https://www.runoob.com/css3/css3-tutorial.html">CSS3教程</a><ahref="https://www.w3school.com.cn/cssref/index.asp#google_vignette">CSS参考手册</a></p><ul><li><p>css引入方式</p><ul><li>行内样式：写在标签的style属性中<code>&lt;h1 style="..."&gt;</code>（不推荐）</li><li>内嵌样式：写在style标签中<code>&lt;style&gt;.&lt;/style&gt;</code>（可以写在页面任何位置，但通常约定写在head标签中）</li><li>外联样式：写在一个单独的.css文件中：<code>&lt;link href="..."&gt;</code>（需要通过link 标签在网页中引入）</li></ul></li><li><p>颜色表示</p><ul><li>关键字：red、green.</li><li>rgb表示法：rgb（255，0，0）、rgb（134，100，89）</li><li>十六进制：#ff0000、#cccccc、#ccc</li></ul></li><li><p>css选择器 （用来选取需要设置样式的元素（标签））</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240428102417186-2024-5-918:42:43.png"alt="image-20240428102417186" /><figcaption aria-hidden="true">image-20240428102417186</figcaption></figure><p>优先级：id选择器 &gt; 类选择器 &gt; 元素选择器</p></li><li><p>css页面布局</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240428105655324-2024-5-918:42:45.png"alt="image-20240428105655324" /><figcaption aria-hidden="true">image-20240428105655324</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240428110005175-2024-5-918:42:47.png"alt="image-20240428110005175" /><figcaption aria-hidden="true">image-20240428110005175</figcaption></figure><ul><li><p>相关css属性</p><p>width：设置宽度 height：设置高度 border：设置边框的属性，如：1pxsolid#000；</p><p>padding：内边距 margin：外边距 注意：</p><p>1、padding和margin分别有四个边界，设置值时的顺序为<strong>上右下左</strong></p><p>2、如果只需要设置某一个方位的边框、内边距、外边距，可以在属性名后加上-位置，如：padding-top、padding-left、padding-right….</p></li></ul></li></ul><h2 id="javascript">1.3、JavaScript</h2><p><ahref="https://www.w3school.com.cn/jsref/index.asp">JavaScript参考手册</a></p><h3 id="js引入方式">JS引入方式</h3><blockquote><h4 id="js引入方式-1">js引入方式</h4></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240428112704651-2024-5-918:43:16.png"alt="image-20240428112704651" /><figcaption aria-hidden="true">image-20240428112704651</figcaption></figure><blockquote><h4 id="js基础语法">js基础语法</h4></blockquote><ol type="1"><li><p>书写语法（与java程序完全一致）</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240428113648353-2024-5-918:43:36.png"alt="image-20240428113648353" /><figcaption aria-hidden="true">image-20240428113648353</figcaption></figure><ul><li>输出语句<ul><li>使用<code>window.alert()</code>写入警告框</li><li>使用 <code>document.write()</code>写入 HTML 输出</li><li>使用 <code>console.log()</code>写入浏览器控制台</li></ul></li></ul></li><li><p>变量</p><p>JavaScript是一门弱类型语言，变量可以存放不同类型的值。</p><div class="code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;a = <span class="hljs-string">&quot;张三&quot;</span>;</code></pre></div><ul><li><p>用<code>var</code>关键字声明变量</p><ul><li>作用域比较大，<strong>全局变量</strong></li><li>可以重复定义，后定义的覆盖之前的</li></ul></li><li><p>用<code>let</code>关键字声明变量</p><p>所声明的变量，只在let关键字所在的代码块内有效，<strong>局部变量</strong>。不允许重复声明</p></li><li><p>用<code>const</code>关键字声明<u>常量</u>，其值不能改变</p></li></ul></li><li><p>数据类型、运算符、流程控制语句</p><p><strong>数据类型</strong></p><p>JavaScript中分为：原始类型 和引用类型。使用<code>typeof</code>运算符可以获取数据类型。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240428115836276-2024-5-918:43:40.png" alt="image-20240428115836276" style="zoom:80%;" /></p><p><strong>运算符</strong></p><div data-align="left"><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240428120023229-2024-5-918:44:39.png" alt="image-20240428120023229" style="zoom:80%;" /></div><p>其中，<code>==</code>在进行比较时会进行类型转化，<code>===</code>在进行比较时不会进行类型转化（必须类型一样，值一样）</p><div class="code-wrapper"><pre><code class="hljs javascript">   <span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span>;    <span class="hljs-keyword">var</span> _age = <span class="hljs-string">&quot;20&quot;</span>;    <span class="hljs-keyword">var</span> <span class="hljs-title class_">Sage</span> = <span class="hljs-number">20</span>;    <span class="hljs-title function_">alert</span> (age age);<span class="hljs-comment">//true </span>   <span class="hljs-title function_">alert</span> (age age);<span class="hljs-comment">//false </span><span class="hljs-title function_">alert</span> (age <span class="hljs-title class_">Sage</span>) ;<span class="hljs-comment">//true</span></code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240428121232842-2024-5-918:43:45.png"alt="image-20240428121232842" /><figcaption aria-hidden="true">image-20240428121232842</figcaption></figure><p><strong>流程控制语句</strong></p><div data-align="left"><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240428121540761-2024-5-918:44:56.png" alt="image-20240428121540761" style="zoom:80%;" /></div></li></ol><blockquote><p><strong>js函数</strong></p></blockquote><p><strong>函数定义</strong></p><p>JavaScript 函数通过<code>function</code>关键字进行定义，语法为：</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//方法一</span><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionName</span>(<span class="hljs-params">参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2.</span>....</span>) &#123;<span class="hljs-comment">//函数体&#125;</span><span class="hljs-comment">//方法二</span><span class="hljs-keyword">var</span> functionName = <span class="hljs-keyword">function</span>(<span class="hljs-params">参数<span class="hljs-number">1</span>,参数<span class="hljs-number">2.</span>....</span>) &#123;<span class="hljs-comment">//函数体&#125;</span>    <span class="hljs-comment">//函数调用：函数名称（实际参数列表）</span></code></pre></div><p>注：</p><ol type="1"><li>由于JavaScript是弱类型语言，形式参数不需要类型，返回值也不需要定义类型。需要返回的可以在函数内部直接使用return返回即可。</li><li>JS中，函数调用可以传递任意个数的参数，但具体函数会根据自己的参数个数相应接收，多出来的不接收</li></ol><h3 id="js对象">JS对象</h3><h4 id="js基础对象"><strong>JS基础对象</strong></h4><ul><li><p><strong>Array</strong></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240428190747477-2024-5-918:45:38.png"alt="image-20240428190747477" /><figcaption aria-hidden="true">image-20240428190747477</figcaption></figure><p>JavaScript中的数组相当于Java中集合，数组的长度是可变的，而JavaScript是弱类型，所以可以存储任意的类型的数据。</p><div class="code-wrapper"><pre><code class="hljs javascript">&lt;script&gt;  <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-literal">true</span>]; <span class="hljs-comment">//数组可以存储任意类型</span>  arr[<span class="hljs-number">10</span>] = <span class="hljs-number">8</span>; <span class="hljs-comment">//由于数组长度可变，可以在任意位置存储</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">10</span>]) <span class="hljs-comment">//8</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">9</span>]) <span class="hljs-comment">//undefined，该位置未被初始化</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">8</span>]) <span class="hljs-comment">//undefined，该位置未被初始化</span>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); &lt;/script&gt;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240428182931419-2024-12-912:09:40.png"alt="image-20240428182931419" /><figcaption aria-hidden="true">image-20240428182931419</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240428191056054-2024-5-918:45:45.png"alt="image-20240428191056054" /><figcaption aria-hidden="true">image-20240428191056054</figcaption></figure><div class="code-wrapper"><pre><code class="hljs javascript">&lt;script&gt;  <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-literal">true</span>];  arr[<span class="hljs-number">10</span>] = <span class="hljs-number">8</span>;    <span class="hljs-comment">//遍历数组中所有的元素</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i]);  &#125;  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;--------------------------------&quot;</span>);    <span class="hljs-comment">//遍历数组中有值的元素，每遍历一个元素就调用一次传入的函数</span>  arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);  &#125;);    <span class="hljs-comment">//使用箭头函数简化函数的定义</span>  <span class="hljs-comment">//箭头函数：(参数) =&gt; &#123;函数体&#125;</span>  arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">e</span>)=&gt;</span>&#123;      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);  &#125;)  arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>);  arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);<span class="hljs-comment">//删除从下标为2开的两个数组元素</span>&lt;/script&gt;</code></pre></div></li><li><p><strong>String</strong></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240428191203260-2024-5-918:45:51.png"alt="image-20240428191203260" /><figcaption aria-hidden="true">image-20240428191203260</figcaption></figure></li><li><p>JavaScript自定义对象</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240428190617022-2024-5-918:45:58.png"alt="image-20240428190617022" /><figcaption aria-hidden="true">image-20240428190617022</figcaption></figure></li><li><p><strong>JSON</strong></p><p>JSON（<code>J</code>ava<code>S</code>cript<code>O</code>bject<code>N</code>otation，JavaScript对象标记法）,JSON是通过 JavaScript对象标记法书写的<strong>文本</strong>。由于其语法简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240428185748370-2024-5-918:46:05.png"alt="image-20240428185748370" /><figcaption aria-hidden="true">image-20240428185748370</figcaption></figure><div class="code-wrapper"><pre><code class="hljs javascript">&lt;script&gt;  <span class="hljs-comment">//定义JSON，注：其中的键必须用双引号包含</span>  <span class="hljs-keyword">var</span> jsonStr =    <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;liming&quot;, &quot;age&quot;:18, &quot;addr&quot;:[&quot;北京&quot;,&quot;上海&quot;,&quot;西安&quot;]&#125;&#x27;</span>;    <span class="hljs-comment">//JSON字符串==&gt;JSON对象</span>  <span class="hljs-keyword">var</span> jsonObj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(jsonStr);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jsonObj.<span class="hljs-property">name</span>); <span class="hljs-comment">//通过 `对象.属性` 的方式访问数据</span>    <span class="hljs-comment">//JSON对象 ==&gt;JSON字符串</span>  <span class="hljs-keyword">var</span> str = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(jsonObj);  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);&lt;/script&gt;</code></pre></div></li></ul><h4 id="浏览器对象模型bom"><strong>浏览器对象模型BOM</strong></h4><div class="code-wrapper"><pre><code class="hljs">    [参考手册](https://www.w3school.com.cn/jsref/obj_window.asp)</code></pre></div><ul><li>概念：<code>B</code>rowser <code>O</code>bject<code>M</code>odel浏览器对象模型，允许JavaScript与浏览器对话，JavaScript将浏览器的各个组成部分封装为对象。</li><li>组成<ul><li><strong>Window：浏览器窗口对象</strong></li><li>Navigator：浏览器对象</li><li>Screen：屏幕对象</li><li>History：历史记录对象</li><li><strong>Location：地址栏对象</strong></li></ul></li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240428204731206-2024-5-918:46:09.png"alt="image-20240428204731206" /><figcaption aria-hidden="true">image-20240428204731206</figcaption></figure><div class="code-wrapper"><pre><code class="hljs javascript">&lt;script&gt;  <span class="hljs-comment">//获取</span>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello BOM&quot;</span>);  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello bom&quot;</span>);  <span class="hljs-comment">//方法：</span>  <span class="hljs-comment">//1、confirm 对话框。确认--&gt;返回true；取消--&gt;返回false。</span>  <span class="hljs-keyword">var</span> flag = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">confirm</span>(<span class="hljs-string">&quot;您确定删除这条记录吗？&quot;</span>);  <span class="hljs-title function_">alert</span>(flag);  <span class="hljs-comment">//2、定时器 setInterval(func,时间ms),周期性执行某个函数</span>  <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;  <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;    i++;    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;该方法执行了&quot;</span> + i + <span class="hljs-string">&quot;次&quot;</span>);  &#125;, <span class="hljs-number">2000</span>);  <span class="hljs-comment">//3、定时器  setTimeout(func,时间ms)，延迟指定时间后执行一次</span>  <span class="hljs-variable language_">window</span>.<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello&quot;</span>);  &#125;, <span class="hljs-number">3000</span>);&lt;/script&gt;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240428205739043-2024-5-918:46:17.png"alt="image-20240428205739043" /><figcaption aria-hidden="true">image-20240428205739043</figcaption></figure><div class="code-wrapper"><pre><code class="hljs javascript">&lt;script&gt;  <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>);  location.<span class="hljs-property">href</span> = <span class="hljs-string">&quot;https://www.baidu.com&quot;</span>; <span class="hljs-comment">//浏览器自动跳转到指定地址</span>&lt;/script&gt;</code></pre></div><h4 id="文档对象模型dom"><strong>文档对象模型DOM</strong></h4><p><code>D</code>ocument <code>O</code>bject<code>M</code>odel，文档对象模型。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240429091016585-2024-5-918:46:21.png"alt="image-20240429091016585" /><figcaption aria-hidden="true">image-20240429091016585</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240429091239798-2024-5-918:46:26.png"alt="image-20240429091239798" /><figcaption aria-hidden="true">image-20240429091239798</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240429091558233-2024-5-918:46:29.png"alt="image-20240429091558233" /><figcaption aria-hidden="true">image-20240429091558233</figcaption></figure><p><ahref="https://www.w3school.com.cn/jsref/dom_obj_anchor.asp">HTML标签对象参考手册</a></p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JSTest<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;h1&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/news_logo.png&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls&quot;</span>&gt;</span>传智教育<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cls&quot;</span>&gt;</span>黑马程序员<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> /&gt;</span> 电影    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> /&gt;</span> 旅游    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> /&gt;</span> 游戏  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">/*1、获取Element对象*/</span></span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">//1.1 获取元素--根据ID获取</span></span><span class="language-javascript">    <span class="hljs-keyword">var</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;h1&quot;</span>);</span><span class="language-javascript">    <span class="hljs-title function_">alert</span>(img);</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">//1.2 获取元素 -- 根据标签获取</span></span><span class="language-javascript">    <span class="hljs-keyword">var</span> divs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&quot;div&quot;</span>);</span><span class="language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; divs.<span class="hljs-property">length</span>; i++) &#123;</span><span class="language-javascript">      <span class="hljs-title function_">alert</span>(divs[i]);</span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">//1.3 获取元素 -- 根据name属性获取</span></span><span class="language-javascript">    <span class="hljs-keyword">var</span> hobbys = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByName</span>(<span class="hljs-string">&quot;hobby&quot;</span>);</span><span class="language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> id = <span class="hljs-number">0</span>; id &lt; hobbys.<span class="hljs-property">length</span>; id++) &#123;</span><span class="language-javascript">      <span class="hljs-keyword">const</span> element = hobbys[id];</span><span class="language-javascript">      <span class="hljs-title function_">alert</span>(element);</span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">//1.4 获取元素 -- 根据class属性获取</span></span><span class="language-javascript">    <span class="hljs-keyword">var</span> cls = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&quot;cls&quot;</span>);</span><span class="language-javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; cls.<span class="hljs-property">length</span>; i++) &#123;</span><span class="language-javascript">      <span class="hljs-title function_">alert</span>(cls[i]);</span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">/*2、查询参考手册，调用该对象的属性和方法*/</span></span><span class="language-javascript">    divs[<span class="hljs-number">0</span>].<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;传智教育666&quot;</span>;</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="js事件监听">JS事件监听</h3><p><strong>常见事件</strong></p><div data-align="left"><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240429094019410-2024-5-918:46:50.png" alt="image-20240429094019410" style="zoom:80%;" /></div><p><strong>事件绑定</strong></p><div data-align="left"><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240429094206629-2024-5-918:47:25.png" alt="image-20240429094206629" style="zoom:80%;" /></div><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JSTest<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pic&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img/shuangshuang.png&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;250px&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;点亮&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;on()&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;熄灭&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;off()&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ITCAST&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> /&gt;</span> 电影    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> /&gt;</span> 旅游    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobby&quot;</span> /&gt;</span> 游戏    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;全选&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;selectAll()&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;反选&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;removeAll()&quot;</span> /&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">//1、点击“点亮”或“熄灭”按钮，切换图片</span></span><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">on</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-keyword">var</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;pic&quot;</span>);</span><span class="language-javascript">      img.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;img/shuangshuang.png&quot;</span>;</span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">off</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-keyword">var</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;pic&quot;</span>);</span><span class="language-javascript">      img.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;img/lihanshuang.png&quot;</span>;</span><span class="language-javascript">    &#125;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-comment">//2、input输入框，获得焦点时，设置其内容为大写；失去焦点时，设置内容为小写。</span></span><span class="language-javascript">    <span class="hljs-keyword">var</span> inputText = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;name&quot;</span>);</span><span class="language-javascript">    inputText.<span class="hljs-property">onfocus</span> = <span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">      <span class="hljs-keyword">var</span> text = inputText.<span class="hljs-property">value</span>;</span><span class="language-javascript">      inputText.<span class="hljs-property">value</span> = text.<span class="hljs-title function_">toUpperCase</span>();</span><span class="language-javascript">    &#125;;</span><span class="language-javascript">    inputText.<span class="hljs-property">onblur</span> = <span class="hljs-function">() =&gt;</span> &#123;</span><span class="language-javascript">      <span class="hljs-keyword">var</span> text = inputText.<span class="hljs-property">value</span>;</span><span class="language-javascript">      inputText.<span class="hljs-property">value</span> = text.<span class="hljs-title function_">toLowerCase</span>();</span><span class="language-javascript">    &#125;;</span><span class="language-javascript">    <span class="hljs-comment">//3、点击“全选”按钮，选择所有选项；点击“反选”按钮，取消所有选项。</span></span><span class="language-javascript">    <span class="hljs-keyword">var</span> hobbys = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByName</span>(<span class="hljs-string">&quot;hobby&quot;</span>);</span><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">selectAll</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; hobbys.<span class="hljs-property">length</span>; index++) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">const</span> element = hobbys[index];</span><span class="language-javascript">        element.<span class="hljs-property">checked</span> = <span class="hljs-literal">true</span>;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">removeAll</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; hobbys.<span class="hljs-property">length</span>; index++) &#123;</span><span class="language-javascript">        <span class="hljs-keyword">const</span> element = hobbys[index];</span><span class="language-javascript">        element.<span class="hljs-property">checked</span> = <span class="hljs-literal">false</span>;</span><span class="language-javascript">      &#125;</span><span class="language-javascript">    &#125;</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="vue">1.4、Vue</h2><p>Vue是一套<strong>前端框架</strong>，免除原生JavaScript中的DOM操作，简化书写。基于<code>MVVM</code>（Model-View-ViewModel）思想，实现数据的双向绑定，将编程的关注点放在数据上。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240430100738759-2024-5-918:47:39.png" alt="image-20240430100738759" style="zoom:80%;" /></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430101038318-2024-5-918:47:43.png"alt="image-20240430101038318" /><figcaption aria-hidden="true">image-20240430101038318</figcaption></figure><h3 id="常用指令">常用指令</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240430103300388-2024-5-918:47:47.png" alt="image-20240430103300388" style="zoom:80%;" /></p><p>输入vue指令时，可以通过不写指令中的<code>-</code>,获得vue的语法提示</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--Vue指令测试--&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>VueTest<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>      <span class="hljs-comment">&lt;!-- 1、 v-bind指令:绑定HTML标签的属性值 --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>链接1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>      <span class="hljs-comment">&lt;!-- 也可直接省略v-bind只保留 ： --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>链接2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>      <span class="hljs-comment">&lt;!-- 2、 v-model指令：在表单元素上创建双向数据绑定  --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;url&quot;</span> /&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>      <span class="hljs-comment">&lt;!-- 3、 v-on指令：为HTML标签绑定事件  写法 v-on:事件=“function”，简化写法@事件=“function”--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;按钮1&quot;</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;handler()&quot;</span> /&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;按钮2&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handler()&quot;</span> /&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>      <span class="hljs-comment">&lt;!-- 4、v-if &amp; v-else-if &amp; v-else 根据条件判断是否渲染该元素--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;age &lt;= 35&quot;</span>&gt;</span>年龄判定为年轻人<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;age &gt;35 &amp;&amp; age &lt;= 60&quot;</span>&gt;</span>年龄判定中年人 <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else</span>&gt;</span> 年龄判定老年人<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>      <span class="hljs-comment">&lt;!-- 5、 v-show：根据判断条件动态设置标签的display属性来决定是否展示，会渲染该元素--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;age &lt;= 35&quot;</span>&gt;</span>年龄判定为年轻人<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;age &gt;35 &amp;&amp; age &lt;= 60&quot;</span>&gt;</span>年龄判定中年人 <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;age &gt; 60&quot;</span>&gt;</span> 年龄判定老年人<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>      <span class="hljs-comment">&lt;!-- 6、v-for：列表渲染，遍历容器的元素或者对象的属性 --&gt;</span>      <span class="hljs-comment">&lt;!-- 其中，括号内第一个是数组元素，index是对应元素的下标;不需要下标也可不指定--&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(addr,index) in address&quot;</span>&gt;</span>&#123;&#123;index+1&#125;&#125;：&#123;&#123;addr&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;addr in address&quot;</span>&gt;</span>&#123;&#123;addr&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">      <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>, <span class="hljs-comment">//Vue接管的区域</span></span><span class="language-javascript">      <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">        <span class="hljs-comment">//Vue的数据模型</span></span><span class="language-javascript">        <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;https://www.baidu.com&quot;</span>,</span><span class="language-javascript">        <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,</span><span class="language-javascript">        <span class="hljs-attr">address</span>: [<span class="hljs-string">&quot;北京&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>, <span class="hljs-string">&quot;广州&quot;</span>, <span class="hljs-string">&quot;西安&quot;</span>],</span><span class="language-javascript">      &#125;,</span><span class="language-javascript">      <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">        <span class="hljs-attr">handler</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我被点击了&quot;</span>);</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">      &#125;,</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>指令练习案例</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240430105352837-2024-5-918:47:53.png" alt="image-20240430105352837" style="zoom:80%;" /></p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>VueTest<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;l&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;60%&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>编号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>年龄<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>成绩<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>等级<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(user,index) in users&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;index+1&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;user.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;user.age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;user.gender==1&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;user.gender == 2&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;user.score&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;user.score &gt;=85&quot;</span>&gt;</span>优秀<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;user.score &gt;= 60&quot;</span>&gt;</span>及格<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red&quot;</span> <span class="hljs-attr">v-else</span>&gt;</span>不及格<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">      <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>, <span class="hljs-comment">//Vue接管的区域，election的缩写</span></span><span class="language-javascript">      <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">        <span class="hljs-comment">//Vue的数据模型</span></span><span class="language-javascript">        <span class="hljs-attr">users</span>: [</span><span class="language-javascript">          &#123;</span><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Tom&quot;</span>,</span><span class="language-javascript">            <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,</span><span class="language-javascript">            <span class="hljs-attr">gender</span>: <span class="hljs-number">1</span>,</span><span class="language-javascript">            <span class="hljs-attr">score</span>: <span class="hljs-number">78</span>,</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          &#123;</span><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Rose&quot;</span>,</span><span class="language-javascript">            <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,</span><span class="language-javascript">            <span class="hljs-attr">gender</span>: <span class="hljs-number">2</span>,</span><span class="language-javascript">            <span class="hljs-attr">score</span>: <span class="hljs-number">86</span>,</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          &#123;</span><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Jerry&quot;</span>,</span><span class="language-javascript">            <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>,</span><span class="language-javascript">            <span class="hljs-attr">gender</span>: <span class="hljs-number">1</span>,</span><span class="language-javascript">            <span class="hljs-attr">score</span>: <span class="hljs-number">90</span>,</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">          &#123;</span><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Tony&quot;</span>,</span><span class="language-javascript">            <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>,</span><span class="language-javascript">            <span class="hljs-attr">gender</span>: <span class="hljs-number">1</span>,</span><span class="language-javascript">            <span class="hljs-attr">score</span>: <span class="hljs-number">52</span>,</span><span class="language-javascript">          &#125;,</span><span class="language-javascript">        ],</span><span class="language-javascript">      &#125;,</span><span class="language-javascript">      <span class="hljs-attr">methods</span>: &#123;</span><span class="language-javascript">        <span class="hljs-attr">handler</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">          <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;我被点击了&quot;</span>);</span><span class="language-javascript">        &#125;,</span><span class="language-javascript">      &#125;,</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h3 id="生命周期">生命周期</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430111829086-2024-5-918:47:58.png"alt="image-20240430111829086" /><figcaption aria-hidden="true">image-20240430111829086</figcaption></figure><p>（1）beforeCreate 在实例初始化(newVue())后执行，此时的数据监听和事件绑定机制都未完成，获取不到DOM节点。（可以在此阶段加loading事件，在加载实例时触发）</p><p>（2）created这个阶段vue实例已经创建，以下内容已被配置完毕：数据侦听、计算属性、方法、事件/侦听器的回调函数。但挂载阶段还没开始，仍然获取不到DOM元素。（在此阶段，初始化完成时的事件写在这里，如在这结束loading事件，也可以进行异步请求）</p><p>（3）beforeMount在这个阶段完成了DOM的初始化，但仍然无法获取到具体的DOM元素，因为vue还没有进行根节点挂载，但是根节点已经创建完成，下面Vue对DOM的操作将围绕这个根节点进行。（beforeMount这个阶段是过渡性的，在项目中使用得比较少）</p><p>（4）mounted在这个阶段，实例已经被挂载完成了，也就是能获取到数据和DOM元素了。</p><p>（注意 mounted不会保证所有的子组件也都被挂载完成。如果你希望等到整个视图都渲染完毕再执行某些操作，可以在mounted 内部使用 vm.$nextTick.）</p><div class="code-wrapper"><pre><code class="hljs vue">mounted: function () &#123;  this.$nextTick(function () &#123;    // 仅在整个视图都被渲染之后才会运行的代码  &#125;)&#125;</code></pre></div><p>（5）beforeUpdate在数据发生改变，但页面还没有完成更新时执行的操作，在此阶段视图的数据和DOM元素的数据没有保持同步。（这里适合在现有DOM 将要被更新之前访问它，比如移除手动添加的事件监听器）</p><p>（6）updated这个时候数据发生了改变，并且视图页面也已经完成了更新，因此，该阶段看到的DOM元素的内容是最新内容。</p><p>（注意updated不会保证所有的子组件也都被重新渲染完毕。如果你希望等到整个视图都渲染完毕，可以在updated 里使用 vm.$nextTick）</p><p>（7）beforeDestroy此阶段Vue实例仍然完全可用，也就是还能访问到页面的响应式数据和事件。（可以在这里注销eventBus等事件）</p><p>（8）destroyed DOM元素被销毁，此时对应 的Vue实例所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/vue生命周期-2024-5-918:48:04.jpeg" alt="img" style="zoom:150%;" /></p><h2 id="ajax">1.5、AJAX</h2><h3 id="原生ajax">原生AJAX</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430113437411-2024-5-918:48:10.png"alt="image-20240430113437411" /><figcaption aria-hidden="true">image-20240430113437411</figcaption></figure><p><ahref="https://www.w3school.com.cn/js/js_ajax_intro.asp">AJAX参考手册</a></p><h3 id="axios">Axios</h3><p>Axios对原生的Ajax进行了封装，简化书写，快速开发。<ahref="https://www.axios-http.cn/">官网</a></p><p><strong>Axios入门</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240430114238650-2024-5-918:48:14.png" alt="image-20240430114238650" style="zoom:80%;" /></p><p><strong>Axios简化格式</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240430114852949-2024-5-918:48:18.png" alt="image-20240430114852949" style="zoom:80%;" /></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430115502624-2024-5-918:48:23.png"alt="image-20240430115502624" /><figcaption aria-hidden="true">image-20240430115502624</figcaption></figure><p>思路：在vue的monuted生命周期的钩子中调用Axios异步请求，当页面挂载完成后，发起请求，并将返回的数据保存在vue对象的emps中。通过vue渲染，将返回数据添加到页面</p><div class="code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>AxiosTest<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/Axios.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;js/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;l&quot;</span> <span class="hljs-attr">cellspacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;60%&quot;</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>编号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>图像<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>职位<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>入职日期<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>最后操作时间<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(emp,index) in emps&quot;</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;index + 1&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;emp.name&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>          &lt;img:src=&quot;emp.image&quot; width=&quot;70px&quot; height=&quot;50px&quot;&gt;          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;emp.gender == 1&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;emp.gender == 2&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>          <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;emp.job&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;emp.entrydate&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;emp.updatetime&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><span class="language-javascript">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><span class="language-javascript">      <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#app&quot;</span>,</span><span class="language-javascript">      <span class="hljs-attr">data</span>: &#123;</span><span class="language-javascript">        <span class="hljs-attr">emps</span>: [],</span><span class="language-javascript">      &#125;,</span><span class="language-javascript">      <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span><span class="language-javascript">        axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://yapi.smart-xwork.cn/mock/169327/emp/list&quot;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">result</span>)=&gt;</span>&#123;</span><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">emps</span> = result.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>; <span class="hljs-comment">//将返回数据传给这个vue对象的emps</span></span><span class="language-javascript">        &#125;);</span><span class="language-javascript">      &#125;,</span><span class="language-javascript">    &#125;);</span><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h1 id="二前端工程化">二、前端工程化</h1><p>前后端分离开发的流程</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240430170553838-2024-5-918:48:28.png" alt="image-20240430170553838" style="zoom:80%;" /></p><h2 id="接口文档管理-yapi">2.1、接口文档管理 YAPI</h2><p><a href="https://yapi.pro/">官网</a></p><p><ahref="https://hellosean1025.github.io/yapi/documents/index.html">YAPI教程</a></p><blockquote><p>Swagger和Yapi</p></blockquote><p>1、Yapi 是设计阶段使用的工具，管理和维护接口</p><p>2、Swagger 在开发阶段使用的框架，帮助后端开发人员做后端的接口测试</p><p><strong>YApi</strong>是高效、易用、功能强大的api管理平台，旨在为开发、产品、测试人员提供更优雅的接口管理服务。</p><p>1、添加项目</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430173411596-2024-5-918:48:32.png"alt="image-20240430173411596" /><figcaption aria-hidden="true">image-20240430173411596</figcaption></figure><p>2、根据业务添加分类，方便管理接口。如添加用户管理</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430173504098-2024-5-918:48:37.png"alt="image-20240430173504098" /><figcaption aria-hidden="true">image-20240430173504098</figcaption></figure><p>3、在该分类下创建API接口</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430173756736-2024-12-912:15:40.png"alt="image-20240430173756736" /><figcaption aria-hidden="true">image-20240430173756736</figcaption></figure><p>4、在对应接口的编辑页面完善接口内容，保存即可</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430173854156-2024-5-918:48:40.png"alt="image-20240430173854156" /><figcaption aria-hidden="true">image-20240430173854156</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430173919563-2024-12-912:16:40.png"alt="image-20240430173919563" /><figcaption aria-hidden="true">image-20240430173919563</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430174239605-2024-5-918:48:49.png"alt="image-20240430174239605" /><figcaption aria-hidden="true">image-20240430174239605</figcaption></figure><p>5、预览所设置的API信息</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430174514866-2024-5-918:48:53.png"alt="image-20240430174514866" /><figcaption aria-hidden="true">image-20240430174514866</figcaption></figure><p>6、使用Mock地址测试API返回数据</p><p>点击对应接口的Mock地址，可获取模拟的返回数据</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430174628011-2024-5-918:49:02.png"alt="image-20240430174628011" /><figcaption aria-hidden="true">image-20240430174628011</figcaption></figure><p>7、使用高级Mock设置，配置模拟数据的具体信息，如设置默认返回的数据</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240430174858481-2024-5-918:49:06.png" alt="image-20240430174858481" style="zoom:80%;" /></p><h2 id="工程化的vue">2.2、工程化的Vue</h2><h3 id="安装vue-cli">安装vue-cli</h3><p>使用Vue提供的脚手架vue-cli初始化前端项目<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240430175347229-2024-5-918:49:10.png" alt="image-20240430175347229" style="zoom:80%;" /></p><p>安装好node.js后使用<code>npm install -g @vue/cli</code>安装vue脚手架，最后使用<code>vue --version</code>查看安装是否成功</p><h3 id="vue项目创建">vue项目创建</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430190113243-2024-5-918:49:14.png"alt="image-20240430190113243" /><figcaption aria-hidden="true">image-20240430190113243</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430190256107-2024-5-918:49:24.png"alt="image-20240430190256107" /><figcaption aria-hidden="true">image-20240430190256107</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430190518763-2024-5-918:49:28.png"alt="image-20240430190518763" /><figcaption aria-hidden="true">image-20240430190518763</figcaption></figure><p>补：在<code>vue.config.js</code>中配置vue项目的端口</p><div class="code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; defineConfig &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@vue/cli-service&#x27;</span>)<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title function_">defineConfig</span>(&#123;  <span class="hljs-attr">transpileDependencies</span>: <span class="hljs-literal">true</span>,      <span class="hljs-attr">devServer</span>: &#123;    <span class="hljs-attr">port</span>:<span class="hljs-number">7000</span>,  &#125;    &#125;)</code></pre></div><h3 id="vue项目运行流程">vue项目运行流程</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430210431807-2024-5-918:49:32.png"alt="image-20240430210431807" /><figcaption aria-hidden="true">image-20240430210431807</figcaption></figure><p>其中index.html中展示的内容是来自组件文件App.vue中定义的元素，在main.js中使用render函数生成了对应的虚拟DOM元素，最终将这个vue对象挂载到id为 app的div中，将内容展示出来。</p><blockquote><p><strong>Vue的组件文件以.vue结尾，每个组件由三个部分组成：<code>&lt;template&gt;、&lt;script&gt;、&lt;style&gt;</code>。</strong></p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430210929199-2024-5-918:49:36.png"alt="image-20240430210929199" /><figcaption aria-hidden="true">image-20240430210929199</figcaption></figure><p><code>ElementView.vue</code></p><div class="code-wrapper"><pre><code class="hljs vue">&lt;template&gt;  &lt;div&gt;    &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;!--（输入script时选择JavaScript.vue这个选项，回车即可）--&gt;&lt;script&gt;//将所定义的数据模型和方法导出成一个默认模块，在其他地方才能import export default &#123;  //定义数据模型，通过data函数定义，并将数据对象return出去（直接敲data回车即可）  data() &#123;    return &#123;      message:&quot;Hello Vue&quot;    &#125;  &#125;,  //定义方法  methods: &#123;      &#125;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre></div><h3 id="vue的组件库-elementui">Vue的组件库 ElementUI</h3><p><a href="https://element.eleme.cn/#/zh-CN">快速上手 ElementUI</a></p><p>Element：是饿了么团队研发的，一套为开发者、设计师和产品经理准备的基于Vue的桌面端组件库。</p><blockquote><h4 id="快速入门">快速入门</h4></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430212514880-2024-5-918:49:43.png"alt="image-20240430212514880" /><figcaption aria-hidden="true">image-20240430212514880</figcaption></figure><p>在需要使用该组件的template中，先输入左尖括号，再输入ElementView，此时vue已经识别出这个组件，回车即可完成该组件的导入和添加</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430213636310-2024-5-918:49:48.png"alt="image-20240430213636310" /><figcaption aria-hidden="true">image-20240430213636310</figcaption></figure><blockquote><h4 id="element常用组件">Element常用组件</h4></blockquote><p><code>CTRL + ALT + L</code> 格式化代码</p><ol type="1"><li><p>组件--Table表格：用于展示多条结构类似的数据，可对数据进行排序、筛选、对比或其他自定义操作。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430215306618-2024-5-918:49:54.png"alt="image-20240430215306618" /><figcaption aria-hidden="true">image-20240430215306618</figcaption></figure></li><li><p>组件--Pagination分页：当数据量过多时，使用分页分解数据。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430215240125-2024-5-918:49:56.png"alt="image-20240430215240125" /><figcaption aria-hidden="true">image-20240430215240125</figcaption></figure><div class="code-wrapper"><pre><code class="hljs vue">&lt;!-- pagination 分页组件 --&gt;&lt;el-pagination background layout=&quot;total, prev, pager, next, jumper&quot; :total=&quot;1000&quot;&gt;&lt;/el-pagination&gt;</code></pre></div><p>layout属性：组件布局，子组件名用逗号分隔。prev, pager, next, jumper,-&gt;, total</p><table><thead><tr class="header"><th>事件名称</th><th>说明</th><th>回调参数</th></tr></thead><tbody><tr class="odd"><td>size-change</td><td>pageSize 改变时会触发</td><td>每页条数</td></tr><tr class="even"><td>current-change</td><td>currentPage 改变时会触发</td><td>当前页</td></tr></tbody></table></li><li><p>组件--Dialog对话框：在保留当前页面状态的情况下，告知用户并承载相关操作。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430221347648-2024-5-918:50:12.png"alt="image-20240430221347648" /><figcaption aria-hidden="true">image-20240430221347648</figcaption></figure><p>通过对话框的<code>visible.sync</code>属性，控制其展示或隐藏</p><div class="code-wrapper"><pre><code class="hljs vue">&lt;!-- Table --&gt;&lt;el-button type=&quot;text&quot; @click=&quot;dialogTableVisible = true&quot;&gt;打开嵌套表格的 Dialog&lt;/el-button&gt;&lt;el-dialog title=&quot;收货地址&quot; :visible.sync=&quot;dialogTableVisible&quot;&gt;  &lt;el-table :data=&quot;gridData&quot;&gt;    &lt;el-table-column property=&quot;date&quot; label=&quot;日期&quot; width=&quot;150&quot;&gt;&lt;/el-table-column&gt;    &lt;el-table-column property=&quot;name&quot; label=&quot;姓名&quot; width=&quot;200&quot;&gt;&lt;/el-table-column&gt;    &lt;el-table-column property=&quot;address&quot; label=&quot;地址&quot;&gt;&lt;/el-table-column&gt;  &lt;/el-table&gt;&lt;/el-dialog&gt;</code></pre></div></li><li><p>组件-Form表单：由输入框、选择器、单选框、多选框等控件组成，用以收集、校验、提交数据。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240430223333647-2024-5-918:50:14.png" alt="image-20240430223333647" style="zoom:80%;" /></p><p>在 Form 组件中，每一个表单域由一个 Form-Item组件构成，表单域中可以放置各种类型的表单控件，包括Input、Select、Checkbox、Radio、Switch、DatePicker、TimePicker</p></li></ol><div class="code-wrapper"><pre><code class="hljs vue">&lt;!-- Form表单 嵌套在Dialog中--&gt;        &lt;el-button type=&quot;text&quot; @click=&quot;dialogFormVisible = true&quot;&gt;打开嵌套表单的 Dialog&lt;/el-button&gt;        &lt;el-dialog title=&quot;Form表单&quot; :visible.sync=&quot;dialogFormVisible&quot;&gt;            &lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; label-width=&quot;80px&quot;&gt;                &lt;el-form-item label=&quot;活动名称&quot;&gt;                    &lt;el-input v-model=&quot;form.name&quot;&gt;&lt;/el-input&gt;                &lt;/el-form-item&gt;                &lt;el-form-item label=&quot;活动区域&quot;&gt;                    &lt;el-select v-model=&quot;form.region&quot; placeholder=&quot;请选择活动区域&quot;&gt;                        &lt;el-option label=&quot;区域一&quot; value=&quot;shanghai&quot;&gt;&lt;/el-option&gt;                        &lt;el-option label=&quot;区域二&quot; value=&quot;beijing&quot;&gt;&lt;/el-option&gt;                    &lt;/el-select&gt;                &lt;/el-form-item&gt;                &lt;el-form-item label=&quot;活动时间&quot;&gt;                    &lt;el-col :span=&quot;11&quot;&gt;                        &lt;el-date-picker type=&quot;date&quot; placeholder=&quot;选择日期&quot; v-model=&quot;form.date1&quot;                            style=&quot;width: 100%;&quot;&gt;&lt;/el-date-picker&gt;                    &lt;/el-col&gt;                    &lt;el-col class=&quot;line&quot; :span=&quot;2&quot;&gt;-&lt;/el-col&gt;                    &lt;el-col :span=&quot;11&quot;&gt;                        &lt;el-time-picker placeholder=&quot;选择时间&quot; v-model=&quot;form.date2&quot; style=&quot;width: 100%;&quot;&gt;&lt;/el-time-picker&gt;                    &lt;/el-col&gt;                &lt;/el-form-item&gt;                &lt;el-form-item&gt;                    &lt;el-button type=&quot;primary&quot; @click=&quot;onSubmit&quot;&gt;提交&lt;/el-button&gt;                    &lt;el-button&gt;取消&lt;/el-button&gt;                &lt;/el-form-item&gt;            &lt;/el-form&gt;        &lt;/el-dialog&gt;</code></pre></div><h3 id="vue路由">Vue路由</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240430234745953-2024-5-918:50:20.png"alt="image-20240430234745953" /><figcaption aria-hidden="true">image-20240430234745953</figcaption></figure><ul><li><p>安装Vue Router</p><div class="code-wrapper"><pre><code class="hljs js">npm install vue-router@<span class="hljs-number">3.5</span><span class="hljs-number">.1</span></code></pre></div></li><li><p>定义路由</p><p>在rouer目录下的index.js中配置页面对应的请求路径</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240501002059928-2024-5-918:50:26.png"alt="image-20240501002059928" /><figcaption aria-hidden="true">image-20240501002059928</figcaption></figure></li><li><p>使用 router-link进行跳转</p><p>浏览器最终会将<code>router-link</code>解析为一个超链接，点击即可跳转到指定路由</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240501002303426-2024-5-918:50:33.png"alt="image-20240501002303426" /><figcaption aria-hidden="true">image-20240501002303426</figcaption></figure></li><li><p>动态加载展示</p><p>在要切换组件的位置使用<code>&lt;router-view&gt;&lt;/router-view&gt;</code>，动态展示某个组件</p></li></ul><h3 id="案例">案例</h3><p>设计一个页面，包含顶部Header，侧边栏和中心内容展示区域</p><p>侧边栏包含两个功能：部门管理和员工管理，默认进入员工管理界面。点击进行切换</p><p>当页面加载完成时，使用Axios异步从Mock链接获取数据加载到页面表格中。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240501003019740-2024-5-918:50:36.png"alt="image-20240501003019740" /><figcaption aria-hidden="true">image-20240501003019740</figcaption></figure><h2 id="打包部署">2.3、打包部署</h2><p>1、使用<code>npm run build</code>对前端工程进行打包，会在当前目录下生成一个dist文件夹，其中就是打包后的内容</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501094931349-2024-5-918:50:38.png" alt="image-20240501094931349" style="zoom:80%;" /></p><p>2、将其部署到NGINX服务器</p><p><strong>Nginx</strong>是一款轻量级的web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。其特点是占有内存少，并发能力强，在各大型互联网公司都有非常广泛的使用。其目录结构如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240501095113499-2024-5-918:50:41.png" alt="image-20240501095113499" style="zoom:80%;" /></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240501095225148-2024-5-918:50:45.png"alt="image-20240501095225148" /><figcaption aria-hidden="true">image-20240501095225148</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>CSS</tag>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
      <tag>AJAX</tag>
      
      <tag>Axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注解和反射</title>
    <link href="/a974f5b0/"/>
    <url>/a974f5b0/</url>
    
    <content type="html"><![CDATA[<meta name = "referrer", content = "no-referrer"/><h2 id="一注解">一、注解</h2><h3 id="什么是注解">1.1、什么是注解</h3><p>Annotation</p><ul><li><p>Annotation的作用：</p><p>不是程序本身，可以对程序作出解释.（这一点和注释（comment）没什么区别）<strong>可以被其他程序（比如：编译器等）读取</strong>.</p></li><li><p>Annotation的格式</p><p>注解是以"<span class="citation"data-cites="注释名">@注释名</span>"在代码中存在的，还可以添加一些<strong>参数值</strong>，例如：<spanclass="citation"data-cites="SuppressWarnings">@SuppressWarnings</span>（value="unchecked"）.</p></li><li><p>Annotation在哪里使用？ 可以附加在package，class，method，field等上面，相当于给他们添加了额外的辅助信息，我们可以通过<strong>反射机制</strong>编程实现对这些元数据的访问</p></li></ul><h3 id="内置注解">1.2、内置注解</h3><ul><li><strong><span class="citation"data-cites="Override">@Override</span></strong>：定义在java.lang.Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明.</li><li><strong><span class="citation"data-cites="Deprecated">@Deprecated</span></strong>：定义在java.lang.Deprecated中，此注释可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择.</li><li><strong><span class="citation"data-cites="SuppressWarnings">@SuppressWarnings</span></strong>：定义在java.lang.SuppressWarnings中，用来抑制编译时的警告信息.与前两个注释有所不同，你需要添加一个参数才能正确使用，这些参数都是已经定义好了的，我们选择性的使用就<span class="citation"data-cites="SuppressWarnings">@SuppressWarnings</span>（"all"） <spanclass="citation"data-cites="SuppressWarnings">@SuppressWarnings</span>（"unchecked"）<span class="citation"data-cites="SuppressWarnings">@SuppressWarnings</span>（value=["unchecked"，"deprecation"））等等.</li></ul><h3 id="元注解">1.3、元注解</h3><ul><li>元注解的作用就是<strong>负责解释其他注解</strong>。</li><li>Java定义了4个标准的meta-annotation类型。<ul><li><strong><span class="citation"data-cites="Target">@Target</span></strong>：表示我们的注解可以用在哪些地方</li><li><strong><span class="citation"data-cites="Retention">@Retention</span></strong>：表示我们的注解什么时候还有效，用于描述注解的生命周期：<strong>RUNTIME</strong> &gt; CLASS &gt; SOURCE</li><li><strong><span class="citation"data-cites="Documented">@Documented</span></strong>：表示是否将我们的注解生成到javadoc中</li><li><strong><span class="citation"data-cites="Inherited">@Inherited</span></strong>：表示子类可以继承父类的注解</li></ul></li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//定义一个注解</span><span class="hljs-meta">@Target(value = &#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Inherited</span><span class="hljs-meta">@interface</span>  MyAnnotation &#123;&#125;</code></pre></div><h3 id="自定义注解">1.4、自定义注解</h3><ul><li>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(value = &#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@interface</span>  MyAnnotation2 &#123;    <span class="hljs-comment">//注解的参数 ：参数类型 + 参数名 () ;</span>    String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;李瑞&quot;</span>;    <span class="hljs-type">int</span> <span class="hljs-title function_">age</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;    <span class="hljs-type">int</span> <span class="hljs-title function_">id</span> <span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -<span class="hljs-number">1</span>;<span class="hljs-comment">//默认值为-1，表示不存在</span>    String[] schools () <span class="hljs-keyword">default</span> &#123;<span class="hljs-string">&quot;青岛理工大学，合肥工业大学&quot;</span>&#125;;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(value = &#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@interface</span> MyAnnotation3&#123;    <span class="hljs-comment">//当只有一个值的时候，参数名推荐使用value</span>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;&#125;</code></pre></div><p>测试注解</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//自定义注解</span><span class="hljs-meta">@MyAnnotation2</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test03</span> &#123;    <span class="hljs-comment">//注解的参数可以显示赋值，如果没有默认值，我们就必须给注解赋值</span>    <span class="hljs-meta">@MyAnnotation2(name=&quot;刘浩&quot;)</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;    &#125;     <span class="hljs-comment">//当只有一个值的时候且参数名使用value，注解使用时可以直接赋值，不用写成value = xxx，其他名字时必须要写规范</span>    <span class="hljs-meta">@MyAnnotation3(&quot;林沫&quot;)</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;           &#125;&#125;</code></pre></div><h2 id="二反射">二、反射</h2><p>静态语言 &amp; 动态语言</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220607085406423-2024-12-911:18:42.png"alt="image-20220607085406423" /><figcaption aria-hidden="true">image-20220607085406423</figcaption></figure><h3 id="反射概述">2.1、反射概述</h3><ul><li><p>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于ReflectionAPI取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p></li><li><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（<strong>一个类只有一个Class对象</strong>），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220607085646665-2024-12-911:18:55.png"alt="image-20220607085646665" /><figcaption aria-hidden="true">image-20220607085646665</figcaption></figure></li></ul><h3 id="class类">2.2、Class类</h3><ul><li>在Object类中定义了以下的方法，<code>public final Class getClass()</code>，此方法将被所有子类继承；以上的方法返回值的类型是一个<strong>Class类</strong>，此类是Java反射的源头，实际上所谓反射<u>从程序的运行结果来看</u>也很好理解，即：<strong>可以通过对象反射求出类的名称</strong>。</li><li>对象照镜子（getClass）后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。</li><li><strong>对于每个类而言，JRE都为其保留一个不变的Class类型的对象。</strong>一个Class对象包含了特定某个结构的有关信息。<ul><li>Class 本身也是一个类</li><li>Class对象只能由系统建立对象</li><li>一个加载的类在JVM中只会有一个Class实例</li><li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li><li>每个类的实例都会记得自己是由哪个Class实例所生成</li><li>通过Class可以完整地得到一个类中的所有被加载的结构</li><li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li></ul></li></ul><p><strong>Class类常用方法</strong></p><ul><li><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220607091351248-2024-12-911:19:05.png"alt="image-20220607091351248" /><figcaption aria-hidden="true">image-20220607091351248</figcaption></figure></li></ul><p><strong>获取Class类</strong></p><ul><li><p>若已知具体的类，通过类的class属性获取，该方法最为可靠，程序性能最高</p><ul><li>```java Class c1 = Person.class; <div class="code-wrapper"><pre><code class="hljs autohotkey">- 若已知某个类的实例，调用该实例的getClass()方法获取Class对象  - ```java    Class c2 = person.getClass()<span class="hljs-comment">;</span></code></pre></div></li></ul></li><li><p>若已知一个类的全类名，且该类在路径下，可以通过Class类的静态方法forName()获取，可能会抛出ClassNotFountException</p><ul><li>```java Class c3 = Class.forName("demo01.Student");<div class="code-wrapper"><pre><code class="hljs pgsql">- 内置基本数据类型的包装类都有一个<span class="hljs-keyword">Type</span>属性，可以直接用类名.<span class="hljs-keyword">Type</span>获取  - ```java    <span class="hljs-keyword">Class</span> c4 = <span class="hljs-type">Integer</span>.<span class="hljs-keyword">TYPE</span>;    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(c4);//<span class="hljs-type">int</span></code></pre></div></li></ul></li></ul><p><strong>哪些类型可以有Class对象</strong></p><ul><li>class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类。</li><li>interface：接口</li><li>[]：数组，(一维数组，二维数组)</li><li>enum：枚举</li><li>annotation：注解</li><li><span class="citation" data-cites="interface">@interface</span></li><li>primitive type：基本数据类型</li><li>void</li></ul><h3 id="类的加载与classloader">2.3、类的加载与ClassLoader</h3><h4 id="java内存分析">java内存分析</h4><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220607100335290-2024-12-911:19:10.png"alt="image-20220607100335290" /><figcaption aria-hidden="true">image-20220607100335290</figcaption></figure><ul><li>三块内存当中变化最频繁的是栈内存，最先有数据的是方法区内存，垃圾回收器主要针对的是堆内存。</li></ul><h4 id="类的加载过程">类的加载过程</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20220607093429295-2024-12-911:19:16.png" alt="image-20220607093429295" style="zoom: 67%;" /></p><p>详细过程：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220607094612603-2024-12-911:19:26.png"alt="image-20220607094612603" /><figcaption aria-hidden="true">image-20220607094612603</figcaption></figure><p>测试</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test04</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();        System.out.println(A.m);        <span class="hljs-comment">/*</span><span class="hljs-comment">        * 1、加载到内存，会产生一个类对应的Class对象</span><span class="hljs-comment">        * 2、链接，链接结束后 m = 0</span><span class="hljs-comment">        * 3、初始化</span><span class="hljs-comment">        *       &lt;clinit&gt;()&#123;</span><span class="hljs-comment">        *           System.out.println(&quot;A类静态代码块初始化&quot;);</span><span class="hljs-comment">                    m = 300;</span><span class="hljs-comment">        *           m = 100;</span><span class="hljs-comment">        *       &#125;</span><span class="hljs-comment">        * */</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;    <span class="hljs-keyword">static</span> &#123;        System.out.println(<span class="hljs-string">&quot;A类静态代码块初始化&quot;</span>);        m = <span class="hljs-number">300</span>;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;A类的无参构造器初始化&quot;</span>);    &#125;&#125;============================================================A类静态代码块初始化A类的无参构造器初始化<span class="hljs-number">100</span></code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220607102953406-2024-12-911:19:37.png"alt="image-20220607102953406" /><figcaption aria-hidden="true">image-20220607102953406</figcaption></figure><ul><li>java中new出来的对象存放在java堆中，而对象的引用存放在虚拟机栈中。</li><li>Java中的Class<strong>也是一个类</strong>，所以<strong>Class对象也存放在堆当中</strong>，<strong>存放在方法区当中的是类的元数据</strong>，即类加载器从class文件中提取出来的类型信息、方法信息、字段信息等。</li><li>Java的对象（包括class对象）中保存着指向相应类的元数据的引用，元数据中又保存着指向class对象的引用。</li></ul><h4 id="类加载器">类加载器</h4><p>​类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成<strong>方法区</strong>的运行时数据结构，然后在<strong>堆</strong>中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220607105038367-2024-12-911:19:48.png"alt="image-20220607105038367" /><figcaption aria-hidden="true">image-20220607105038367</figcaption></figure><p>类加载器作用是用来把类（class）装载进内存的。JVM规范定义了如下类型的类的加载器。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20220607105201765-2024-12-911:19:56.png" alt="image-20220607105201765" style="zoom:67%;" /></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test6</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;        <span class="hljs-comment">//获取系统类的加载器</span>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">systemClassLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();        System.out.println(systemClassLoader);        <span class="hljs-comment">//获取系统类加载器的父类加载器 --&gt; 扩展类加载器</span>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> systemClassLoader.getParent();        System.out.println(parent);        <span class="hljs-comment">//获取扩展类加载器的父类加载器 --&gt; 根加载器（c/c++）,无法直接获取</span>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">parent1</span> <span class="hljs-operator">=</span> parent.getParent();        System.out.println(parent1);        <span class="hljs-comment">//测试当前类是哪个加载其加载的</span>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;Reflection.test6&quot;</span>).getClassLoader();        System.out.println(classLoader);        <span class="hljs-comment">//测试JDK内置的类是哪个加载器加载的</span>        classLoader = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getClassLoader();        System.out.println(classLoader);        <span class="hljs-comment">//如何获得系统类加载器可以加载的路径</span>       <span class="hljs-comment">// System.out.println(System.getProperty(&quot;java.class.path&quot;));</span>    &#125;&#125;==================================================================sun.misc.Launcher$AppClassLoader@18b4aac2sun.misc.Launcher$ExtClassLoader@1b6d3586<span class="hljs-literal">null</span>sun.misc.Launcher$AppClassLoader@18b4aac2<span class="hljs-literal">null</span></code></pre></div><p>​<strong>双亲委派机制</strong>是指当一个类加载器收到一个类加载请求时,该类加载器首先会把请求委派给父类加载器。每个类加载器都是如此,只有在父类加载器在自己的搜索范围内找不到指定类时,子类加载器才会尝试自己去加载。</p><h4 id="类的初始化">类的初始化</h4><p>什么时候会发生类的初始化？</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220607103707686-2024-12-911:20:01.png"alt="image-20220607103707686" /><figcaption aria-hidden="true">image-20220607103707686</figcaption></figure><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//测试类什么时候初始化</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test5</span> &#123;    <span class="hljs-keyword">static</span> &#123;        System.out.println(<span class="hljs-string">&quot;Main类被加载&quot;</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;        <span class="hljs-comment">//1.主动引用</span>        <span class="hljs-comment">//Son son = new Son();</span>        <span class="hljs-comment">//2.反射也会产生主动引用</span>        <span class="hljs-comment">//Class.forName(&quot;Reflection.Son&quot;);</span>        <span class="hljs-comment">//不会产生主动引用</span>        <span class="hljs-comment">//System.out.println(Son.b);</span>        <span class="hljs-comment">//Son[] array = new Son[5];</span>        System.out.println(Son.a);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;    <span class="hljs-keyword">static</span> &#123;        System.out.println(<span class="hljs-string">&quot;父类被加载&quot;</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;    <span class="hljs-keyword">static</span> &#123;        System.out.println(<span class="hljs-string">&quot;子类被加载&quot;</span>);        m = <span class="hljs-number">300</span>;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;&#125;</code></pre></div><h3 id="创建运行时类的对象">2.4、创建运行时类的对象</h3><h4 id="获取类运行时的结构">获取类运行时的结构</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//实体类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;    <span class="hljs-keyword">private</span> String username;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> Integer id;       <span class="hljs-comment">//构造器</span>    get/set方法&#125;<span class="hljs-comment">//获得类的信息</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test7</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException, NoSuchMethodException &#123;        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> user.getClass();        <span class="hljs-comment">//1、获得类的名字</span>        System.out.println(c1.getName()); <span class="hljs-comment">//获得包名+类名</span>        System.out.println(c1.getSimpleName());<span class="hljs-comment">//获得类名</span>        <span class="hljs-comment">//2、获得类的属性</span>        System.out.println(<span class="hljs-string">&quot;======================================&quot;</span>);        Field[] fields = c1.getFields(); <span class="hljs-comment">//只能找到public属性</span>        <span class="hljs-keyword">for</span>(Field field:fields) &#123;            System.out.println(field);        &#125;        fields = c1.getDeclaredFields(); <span class="hljs-comment">//获得全部属性</span>        <span class="hljs-keyword">for</span>(Field field:fields) &#123;            System.out.println(field);        &#125;        <span class="hljs-comment">//获得指定属性的值</span>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>);        System.out.println(name);        <span class="hljs-comment">//3、获得类的方法</span>        System.out.println(<span class="hljs-string">&quot;======================================&quot;</span>);        Method[] methods = c1.getMethods(); <span class="hljs-comment">//获得本类及其父类的全部public方法</span>        <span class="hljs-keyword">for</span>(Method method:methods) &#123;            System.out.println(<span class="hljs-string">&quot;正常的：&quot;</span>+method);        &#125;        methods = c1.getDeclaredMethods();<span class="hljs-comment">//获得本类的所有方法</span>        <span class="hljs-keyword">for</span>(Method method:methods) &#123;            System.out.println(<span class="hljs-string">&quot;getDeclaredMethods：&quot;</span>+method);        &#125;        <span class="hljs-comment">//获得指定方法</span>        <span class="hljs-comment">//getMethod(函数名，参数类型)</span>        <span class="hljs-type">Method</span> <span class="hljs-variable">getId</span> <span class="hljs-operator">=</span> c1.getMethod(<span class="hljs-string">&quot;getId&quot;</span>, <span class="hljs-literal">null</span>);        <span class="hljs-type">Method</span> <span class="hljs-variable">setId</span> <span class="hljs-operator">=</span> c1.getMethod(<span class="hljs-string">&quot;setId&quot;</span>, Integer.class);        System.out.println(getId);        System.out.println(setId);        <span class="hljs-comment">//4、获得指定构造器</span>        System.out.println(<span class="hljs-string">&quot;======================================&quot;</span>);        Constructor[] constructors = c1.getConstructors();<span class="hljs-comment">//只能获得public的</span>        <span class="hljs-keyword">for</span>(Constructor constructor:constructors) &#123;            System.out.println(<span class="hljs-string">&quot;getConstructors: &quot;</span>+constructor);        &#125;        constructors= c1.getDeclaredConstructors();<span class="hljs-comment">//获得所有的构造方法</span>        <span class="hljs-keyword">for</span>(Constructor constructor:constructors) &#123;            System.out.println(<span class="hljs-string">&quot;getDeclaredConstructors: &quot;</span>+constructor);        &#125;        <span class="hljs-comment">//获得指定构造器</span>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> c1.getDeclaredConstructor(String.class,Integer.class,Integer.class);        System.out.println(constructor);    &#125;&#125;</code></pre></div><h4 id="动态创建对象执行方法">动态创建对象执行方法</h4><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220607111710652-2024-12-911:20:09.png"alt="image-20220607111710652" /><figcaption aria-hidden="true">image-20220607111710652</figcaption></figure><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20220607112331734-2024-12-911:20:13.png" alt="image-20220607112331734" style="zoom:100%;" /></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//通过反射动态的创建对象</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test9</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException, NoSuchFieldException &#123;        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;Reflection.User&quot;</span>);        <span class="hljs-comment">//1、构造一个对象</span>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> (User)c1.newInstance();  <span class="hljs-comment">//本质上调用了无参构造器，否则会报错</span>        System.out.println(user1);                        <span class="hljs-comment">//通过构造器创建对象</span>        <span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> c1.getDeclaredConstructor(String.class, Integer.class, Integer.class);        <span class="hljs-type">User</span> <span class="hljs-variable">user2</span> <span class="hljs-operator">=</span> (User)constructor.newInstance(<span class="hljs-string">&quot;李瑞&quot;</span>, <span class="hljs-number">21</span>, <span class="hljs-number">01</span>);        System.out.println(user2);        <span class="hljs-comment">//2、通过反射调用普通方法</span>         <span class="hljs-comment">//通过反射获取一个方法</span>        <span class="hljs-type">Method</span> <span class="hljs-variable">setAge</span> <span class="hljs-operator">=</span> c1.getDeclaredMethod(<span class="hljs-string">&quot;setAge&quot;</span>, Integer.class);        <span class="hljs-comment">//invoke：激活的意思</span>        <span class="hljs-comment">//（对象，“方法的值”）</span>        setAge.invoke(user2,<span class="hljs-number">18</span>);        System.out.println(user2.getAge());        <span class="hljs-comment">//3、通过反射操作属性</span>        <span class="hljs-type">Field</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;username&quot;</span>);        <span class="hljs-comment">//不能直接操作私有属性，我们需要关闭程序的安全检测</span>        <span class="hljs-comment">//通过属性或方法的setAccessible(true)</span>        username.setAccessible(<span class="hljs-literal">true</span>);        username.set(user2,<span class="hljs-string">&quot;林沫&quot;</span>);        System.out.println(user2.getUsername());    &#125;&#125;</code></pre></div><h3 id="反射操作注解">2.5、反射操作注解</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20220607112621635-2024-12-911:20:22.png"alt="image-20220607112621635" /><figcaption aria-hidden="true">image-20220607112621635</figcaption></figure><p>利用注解和反射完成类和表结构的映射关系</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Reflection;<span class="hljs-keyword">import</span> java.lang.annotation.*;<span class="hljs-keyword">import</span> java.lang.reflect.Field;<span class="hljs-comment">//练习反射操作注解</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test11</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchFieldException &#123;        <span class="hljs-type">Class</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;Reflection.Student2&quot;</span>);        <span class="hljs-comment">//通过反射获得注解</span>        Annotation[] annotations = c1.getAnnotations();        <span class="hljs-keyword">for</span> (Annotation annotation : annotations) &#123;            System.out.println(annotation);        &#125;        <span class="hljs-comment">//获得注解value的值</span>        <span class="hljs-type">TableLi</span> <span class="hljs-variable">tableLi</span> <span class="hljs-operator">=</span> (TableLi)c1.getAnnotation(TableLi.class);        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> tableLi.value();        System.out.println(value);        <span class="hljs-comment">//获得类指定的注解</span>        <span class="hljs-type">Field</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c1.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>);        <span class="hljs-type">FieldLi</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> name.getAnnotation(FieldLi.class);        System.out.println(annotation.columnName());        System.out.println(annotation.length());        System.out.println(annotation.type());    &#125;&#125;<span class="hljs-comment">//类名的注解</span><span class="hljs-meta">@Target(ElementType.TYPE)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@interface</span>  TableLi &#123;    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;&#125;<span class="hljs-comment">//属性的注解</span><span class="hljs-meta">@Target(ElementType.FIELD)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@interface</span> FieldLi &#123;    String <span class="hljs-title function_">columnName</span><span class="hljs-params">()</span>;    String <span class="hljs-title function_">type</span><span class="hljs-params">()</span>;    <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>;&#125;<span class="hljs-meta">@TableLi(&quot;db_student&quot;)</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student2</span> &#123;    <span class="hljs-meta">@FieldLi(columnName = &quot;db_id&quot;,type=&quot;int&quot;,length = 10)</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;    <span class="hljs-meta">@FieldLi(columnName = &quot;db_age&quot;,type=&quot;int&quot;,length = 3)</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;    <span class="hljs-meta">@FieldLi(columnName = &quot;db_name&quot;,type=&quot;String&quot;,length = 3)</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student2</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student2</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> age, String name)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;        <span class="hljs-built_in">this</span>.age = age;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;        <span class="hljs-built_in">this</span>.id = id;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;        <span class="hljs-built_in">this</span>.age = age;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;        <span class="hljs-built_in">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student2&#123;&quot;</span> +                <span class="hljs-string">&quot;id=&quot;</span> + id +                <span class="hljs-string">&quot;, age=&quot;</span> + age +                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +                <span class="hljs-string">&#x27;&#125;&#x27;</span>;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>注解</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程-Stream流</title>
    <link href="/146f67fb/"/>
    <url>/146f67fb/</url>
    
    <content type="html"><![CDATA[<meta name = "referrer", content = "no-referrer"/><blockquote><p><a href="https://github.com/cmyk359/JavaStream_demo">Demo地址</a></p></blockquote><h2 id="一-概述">一、 概述</h2><h3 id="为什么学">1.1 为什么学？</h3><ul><li>大数量下处理集合效率高</li><li>代码可读性高</li><li>消灭嵌套地狱</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//查询未成年作家的评分在70以上的书籍 由于洋流影响所以作家和书籍可能出现重复，需要进行去重</span>List&lt;Book&gt; bookList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();Set&lt;Book&gt; uniqueBookValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();Set&lt;Author&gt; uniqueAuthorValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<span class="hljs-keyword">for</span> (Author author : authors) &#123;    <span class="hljs-keyword">if</span> (uniqueAuthorValues.add(author)) &#123;        <span class="hljs-keyword">if</span> (author.getAge() &lt; <span class="hljs-number">18</span>) &#123;            List&lt;Book&gt; books = author.getBooks();            <span class="hljs-keyword">for</span> (Book book : books) &#123;                <span class="hljs-keyword">if</span> (book.getScore() &gt; <span class="hljs-number">70</span>) &#123;                    <span class="hljs-keyword">if</span> (uniqueBookValues.add(book)) &#123;                        bookList.add(book);                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;System.out.println(bookList);</code></pre></div><div class="code-wrapper"><pre><code class="hljs java">List&lt;Book&gt; collect = authors.stream()    .distinct()    .filter(author -&gt; author.getAge() &lt; <span class="hljs-number">18</span>)    .map(author -&gt; author.getBooks())    .flatMap(Collection::stream)    .filter(book -&gt; book.getScore() &gt; <span class="hljs-number">70</span>)    .distinct()    .collect(Collectors.toList());System.out.println(collect);</code></pre></div><h3 id="函数式编程思想">1.2 函数式编程思想</h3><p>​面向对象思想需要关注用什么对象完成什么事情。而函数式编程思想就类似于我们数学中的函数。它主要关注的是对数据进行了什么操作。</p><p>优点：</p><ul><li>代码简洁，开发快速</li><li>接近自然语言，易于理解</li><li>易于"并发编程"</li></ul><h2 id="二-lambda表达式">二、 Lambda表达式</h2><h3 id="概述">2.1 概述</h3><p>​Lambda是JDK8中一个语法糖。他可以对某些匿名内部类的写法进行简化（原则：是接口的匿名内部类，且接口中只有一个待重写的抽象方法）。它是函数式编程思想的一个重要体现。让我们不用关注是什么对象。而是更关注我们对数据进行了什么操作。</p><h3 id="核心原则">2.2 核心原则</h3><blockquote><p>可推导可省略</p></blockquote><h3 id="基本格式">2.3 基本格式</h3><div class="code-wrapper"><pre><code class="hljs java">(参数列表)-&gt;&#123;代码&#125;</code></pre></div><h4 id="例一">例一</h4><p>我们在创建线程并启动时可以使用匿名内部类的写法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        System.out.println(<span class="hljs-string">&quot;你知道吗 我比你想象的 更想在你身边&quot;</span>);    &#125;&#125;).start();</code></pre></div><p>可以使用Lambda的格式对其进行修改。修改后如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;    System.out.println(<span class="hljs-string">&quot;你知道吗 我比你想象的 更想在你身边&quot;</span>);&#125;).start();</code></pre></div><h4 id="例二">例二</h4><p>现有方法定义如下，其中IntBinaryOperator是一个接口。先使用匿名内部类的写法调用该方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateNum</span><span class="hljs-params">(IntBinaryOperator operator)</span>&#123;    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;    <span class="hljs-keyword">return</span> operator.applyAsInt(a, b);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> calculateNum(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntBinaryOperator</span>() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">applyAsInt</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;            <span class="hljs-keyword">return</span> left + right;        &#125;    &#125;);    System.out.println(i);&#125;</code></pre></div><p>Lambda写法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> calculateNum((<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)-&gt;&#123;        <span class="hljs-keyword">return</span> left + right;    &#125;);    System.out.println(i);&#125;</code></pre></div><h4 id="例三">例三</h4><p>现有方法定义如下，其中IntPredicate是一个接口。先使用匿名内部类的写法调用该方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNum</span><span class="hljs-params">(IntPredicate predicate)</span>&#123;    <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr) &#123;        <span class="hljs-keyword">if</span>(predicate.test(i))&#123;            System.out.println(i);        &#125;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    printNum(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntPredicate</span>() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;            <span class="hljs-keyword">return</span> value%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;        &#125;    &#125;);&#125;</code></pre></div><p>Lambda写法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    printNum((<span class="hljs-type">int</span> value)-&gt; &#123;        <span class="hljs-keyword">return</span> value%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;    &#125;);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printNum</span><span class="hljs-params">(IntPredicate predicate)</span>&#123;    <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr) &#123;        <span class="hljs-keyword">if</span>(predicate.test(i))&#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre></div><h4 id="例四">例四</h4><p>现有方法定义如下，其中Function是一个接口。先使用匿名内部类的写法调用该方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;R&gt; R <span class="hljs-title function_">typeConver</span><span class="hljs-params">(Function&lt;String,R&gt; function)</span>&#123;    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1235&quot;</span>;    <span class="hljs-type">R</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> function.apply(str);    <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> typeConver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;String, Integer&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">apply</span><span class="hljs-params">(String s)</span> &#123;            <span class="hljs-keyword">return</span> Integer.valueOf(s);        &#125;    &#125;);    System.out.println(result);&#125;</code></pre></div><p>Lambda写法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> typeConver((String s)-&gt;&#123;    <span class="hljs-keyword">return</span> Integer.valueOf(s);&#125;);System.out.println(result);</code></pre></div><h4 id="例五">例五</h4><p>现有方法定义如下，其中IntConsumer是一个接口。先使用匿名内部类的写法调用该方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foreachArr</span><span class="hljs-params">(IntConsumer consumer)</span>&#123;    <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr) &#123;        consumer.accept(i);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    foreachArr(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IntConsumer</span>() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;            System.out.println(value);        &#125;    &#125;);&#125;</code></pre></div><p>Lambda写法：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    foreachArr((<span class="hljs-type">int</span> value)-&gt;&#123;        System.out.println(value);    &#125;);&#125;</code></pre></div><h3 id="省略规则">2.4 省略规则</h3><ul><li>参数类型可以省略</li><li>方法体只有一句代码时大括号、return和唯一一句代码的分号可以省略</li><li>方法只有一个参数时小括号可以省略</li><li>以上这些规则都记不住也可以省略不记</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601102040478-2024-6-110:20:53.png"alt="image-20240601102040478" /><figcaption aria-hidden="true">image-20240601102040478</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601102217951-2024-6-110:22:18.png"alt="image-20240601102217951" /><figcaption aria-hidden="true">image-20240601102217951</figcaption></figure><h2 id="三stream流">三、Stream流</h2><h3 id="概述-1">3.1 概述</h3><p>​Java8的Stream使用的是函数式编程模式，如同它的名字一样，它可以被用来对<strong>集合或数组</strong>进行链状流式的操作。可以更方便的让我们对集合或数组操作。</p><p>特点：</p><ul><li>惰性求值：如果没有终结操作，没有中间操作是不会得到执行的</li><li>流是一次性的：一旦一个流对象经过一个终结操作后。这个流就不能再被使用</li><li><u><strong>非破坏性</strong></u>：Stream API设计为对数据源进行一系列操作（如过滤、映射、排序等），然后生成一个新的流或结果，而不会更改原始数据</li></ul><h3 id="案例数据准备">3.2 案例数据准备</h3><p><a href="https://github.com/cmyk359/JavaStream_demo">Demo地址</a></p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@EqualsAndHashCode</span><span class="hljs-comment">//用于后期的去重使用</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Author</span> &#123;    <span class="hljs-comment">//id</span>    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-comment">//姓名</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">//年龄</span>    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-comment">//简介</span>    <span class="hljs-keyword">private</span> String intro;    <span class="hljs-comment">//作品</span>    <span class="hljs-keyword">private</span> List&lt;Book&gt; books;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@NoArgsConstructor</span><span class="hljs-meta">@EqualsAndHashCode</span><span class="hljs-comment">//用于后期的去重使用</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;    <span class="hljs-comment">//id</span>    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-comment">//书名</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">//分类</span>    <span class="hljs-keyword">private</span> String category;    <span class="hljs-comment">//评分</span>    <span class="hljs-keyword">private</span> Integer score;    <span class="hljs-comment">//简介</span>    <span class="hljs-keyword">private</span> String intro;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Author&gt; <span class="hljs-title function_">getAuthors</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//数据初始化</span>    <span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Author</span>(<span class="hljs-number">1L</span>,<span class="hljs-string">&quot;蒙多&quot;</span>,<span class="hljs-number">33</span>,<span class="hljs-string">&quot;一个从菜刀中明悟哲理的祖安人&quot;</span>,<span class="hljs-literal">null</span>);    <span class="hljs-type">Author</span> <span class="hljs-variable">author2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Author</span>(<span class="hljs-number">2L</span>,<span class="hljs-string">&quot;亚拉索&quot;</span>,<span class="hljs-number">15</span>,<span class="hljs-string">&quot;狂风也追逐不上他的思考速度&quot;</span>,<span class="hljs-literal">null</span>);    <span class="hljs-type">Author</span> <span class="hljs-variable">author3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Author</span>(<span class="hljs-number">3L</span>,<span class="hljs-string">&quot;易&quot;</span>,<span class="hljs-number">14</span>,<span class="hljs-string">&quot;是这个世界在限制他的思维&quot;</span>,<span class="hljs-literal">null</span>);    <span class="hljs-type">Author</span> <span class="hljs-variable">author4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Author</span>(<span class="hljs-number">3L</span>,<span class="hljs-string">&quot;易&quot;</span>,<span class="hljs-number">14</span>,<span class="hljs-string">&quot;是这个世界在限制他的思维&quot;</span>,<span class="hljs-literal">null</span>);    <span class="hljs-comment">//书籍列表</span>    List&lt;Book&gt; books1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    List&lt;Book&gt; books2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    List&lt;Book&gt; books3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();    books1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">1L</span>,<span class="hljs-string">&quot;刀的两侧是光明与黑暗&quot;</span>,<span class="hljs-string">&quot;哲学,爱情&quot;</span>,<span class="hljs-number">88</span>,<span class="hljs-string">&quot;用一把刀划分了爱恨&quot;</span>));    books1.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">2L</span>,<span class="hljs-string">&quot;一个人不能死在同一把刀下&quot;</span>,<span class="hljs-string">&quot;个人成长,爱情&quot;</span>,<span class="hljs-number">99</span>,<span class="hljs-string">&quot;讲述如何从失败中明悟真理&quot;</span>));    books2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">3L</span>,<span class="hljs-string">&quot;那风吹不到的地方&quot;</span>,<span class="hljs-string">&quot;哲学&quot;</span>,<span class="hljs-number">85</span>,<span class="hljs-string">&quot;带你用思维去领略世界的尽头&quot;</span>));    books2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">3L</span>,<span class="hljs-string">&quot;那风吹不到的地方&quot;</span>,<span class="hljs-string">&quot;哲学&quot;</span>,<span class="hljs-number">85</span>,<span class="hljs-string">&quot;带你用思维去领略世界的尽头&quot;</span>));    books2.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">4L</span>,<span class="hljs-string">&quot;吹或不吹&quot;</span>,<span class="hljs-string">&quot;爱情,个人传记&quot;</span>,<span class="hljs-number">56</span>,<span class="hljs-string">&quot;一个哲学家的恋爱观注定很难把他所在的时代理解&quot;</span>));    books3.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">5L</span>,<span class="hljs-string">&quot;你的剑就是我的剑&quot;</span>,<span class="hljs-string">&quot;爱情&quot;</span>,<span class="hljs-number">56</span>,<span class="hljs-string">&quot;无法想象一个武者能对他的伴侣这么的宽容&quot;</span>));    books3.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">6L</span>,<span class="hljs-string">&quot;风与剑&quot;</span>,<span class="hljs-string">&quot;个人传记&quot;</span>,<span class="hljs-number">100</span>,<span class="hljs-string">&quot;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&quot;</span>));    books3.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-number">6L</span>,<span class="hljs-string">&quot;风与剑&quot;</span>,<span class="hljs-string">&quot;个人传记&quot;</span>,<span class="hljs-number">100</span>,<span class="hljs-string">&quot;两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？&quot;</span>));    author.setBooks(books1);    author2.setBooks(books2);    author3.setBooks(books3);    author4.setBooks(books3);    List&lt;Author&gt; authorList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(author,author2,author3,author4));    <span class="hljs-keyword">return</span> authorList;&#125;</code></pre></div><h3 id="快速入门">3.3 快速入门</h3><h4 id="需求">需求</h4><p>​我们可以调用getAuthors方法获取到作家的集合。现在需要打印所有年龄小于18的作家的名字，并且要注意去重。</p><h4 id="实现">实现</h4><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//打印所有年龄小于18的作家的名字，并且要注意去重</span>List&lt;Author&gt; authors = getAuthors();authors.stream()<span class="hljs-comment">//把集合转换成流</span>        .distinct()<span class="hljs-comment">//先去除重复的作家</span>        .filter(author -&gt; author.getAge()&lt;<span class="hljs-number">18</span>)<span class="hljs-comment">//筛选年龄小于18的</span>        .forEach(author -&gt; System.out.println(author.getName()));<span class="hljs-comment">//遍历打印名字</span></code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601154243071-2024-6-115:42:46.png"alt="image-20240601154243071" /><figcaption aria-hidden="true">image-20240601154243071</figcaption></figure><h3 id="常用操作">3.4 常用操作</h3><h4 id="创建流">创建流</h4><p>单列集合： <code>集合对象.stream()</code></p><div class="code-wrapper"><pre><code class="hljs java">      List&lt;Author&gt; authors = getAuthors();Stream&lt;Author&gt; stream = authors.stream();</code></pre></div><p>数组：<code>Arrays.stream(数组)</code>或者使用<code>Stream.of</code>来创建</p><div class="code-wrapper"><pre><code class="hljs JAVA">Integer[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;Stream&lt;Integer&gt; stream = Arrays.stream(arr);Stream&lt;Integer&gt; stream2 = Stream.of(arr);</code></pre></div><p>双列集合：转换成单列集合后再创建</p><div class="code-wrapper"><pre><code class="hljs java">Map&lt;String,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();map.put(<span class="hljs-string">&quot;蜡笔小新&quot;</span>,<span class="hljs-number">19</span>);map.put(<span class="hljs-string">&quot;黑子&quot;</span>,<span class="hljs-number">17</span>);map.put(<span class="hljs-string">&quot;日向翔阳&quot;</span>,<span class="hljs-number">16</span>);<span class="hljs-comment">//map中的每个键值对封装在一个entry对象中，一个个entry对象保存在一个set中</span>map.entrySet()    .stream()     .filter(entry -&gt; entry.getValue() &gt; <span class="hljs-number">16</span>)     .forEach(entry -&gt; System.out.println(entry.getKey()+<span class="hljs-string">&quot; ---&quot;</span>+entry.getValue()));</code></pre></div><h4 id="中间操作">中间操作</h4><h5 id="filter">filter</h5><p>​可以对流中的元素进行条件过滤，<strong>符合过滤条件的才能继续留在流中</strong>。</p><p>例如：</p><p>​ 打印所有姓名长度大于1的作家的姓名</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//打印所有姓名长度大于1的作家的姓名</span>List&lt;Author&gt; authors = getAuthors();authors.stream()    .filter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Author&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-comment">//***返回一个布尔值，对流中的每个对象按条件进行筛选，符合条件的才保留***</span>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Author author)</span> &#123;             <span class="hljs-keyword">return</span> author.getName().length() &gt; <span class="hljs-number">1</span>;         &#125;    &#125;)    .forEach(author -&gt; System.out.println(author.getName()));==========================lambda表达式简化写法===============================List&lt;Author&gt; authors = getAuthors();authors.stream()    .filter(author -&gt; author.getName().length()&gt;<span class="hljs-number">1</span>)    .forEach(author -&gt; System.out.println(author.getName()));</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601155929817-2024-6-116:00:05.png"alt="image-20240601155929817" /><figcaption aria-hidden="true">image-20240601155929817</figcaption></figure><h5 id="map">map</h5><p>​ 可以把对流中的元素进行计算或转换。</p><p>例如：</p><p>1、对流中元素进行类型转化</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//打印所有作家的姓名</span>List&lt;Author&gt; authors = getAuthors();authors.stream()    <span class="hljs-comment">//传入的是Function接口的实现类，第一个泛型是流中对象的类型，第二个泛型是转化的目的类型</span>    .map(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Author, String&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(Author author)</span> &#123;            <span class="hljs-keyword">return</span> author.getName(); <span class="hljs-comment">//将流中的Author类型的对象，转化为String对象</span>        &#125;    &#125;)    .forEach(s -&gt; System.out.println(s));==========================lambda表达式简化写法===============================List&lt;Author&gt; authors = getAuthors();authors    .stream()    .map(author -&gt; author.getName())    .forEach(name-&gt;System.out.println(name));</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601161216170-2024-6-116:12:37.png"alt="image-20240601161216170" /><figcaption aria-hidden="true">image-20240601161216170</figcaption></figure><p>2、对流中元素进行运算</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//将所有作家年龄加10后输出</span>List&lt;Author&gt; authors = getAuthors();authors.stream()    .map(author -&gt; author.getAge())    .map(age-&gt;age+<span class="hljs-number">10</span>) <span class="hljs-comment">//运算</span>    .forEach(age-&gt; System.out.println(age));</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601161354857-2024-6-116:13:56.png"alt="image-20240601161354857" /><figcaption aria-hidden="true">image-20240601161354857</figcaption></figure><h5 id="maptoxxx">mapToXXX</h5><p>mapToXxx()可以直接映射为指定类型，如mapToInt、mapToLong、mapToDouble，得到指定类型的<strong>流</strong>。例如：<code>mapToInt()</code>方法接受一个 <code>ToIntFunction&lt;? super T&gt;</code>类型的参数，这是一个函数式接口，<strong>用于规定将流中的每个元素按何种规则转换为整数</strong>。</p><p>相比于map()，mapToXxx()还提供了该种类型的流的特有方法，比如数值型求和、<ahref="https://so.csdn.net/so/search?q=平均数&amp;spm=1001.2101.3001.7020">平均数</a>、最值</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;String&gt; list = Arrays. asList(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Grapes&quot;</span>);<span class="hljs-comment">//从list获取stream流，并将原来流中元素的长度作为新流返回</span><span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> list.stream().mapToInt(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ToIntFunction</span>&lt;String&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">applyAsInt</span><span class="hljs-params">(String s)</span> &#123;        <span class="hljs-keyword">return</span> s.length();    &#125;&#125;);intStream.forEach(System. out:: println);===========================简化写法=================================List&lt;String&gt; list = Arrays. asList(<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-string">&quot;Grapes&quot;</span>);<span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> list. stream().mapToInt(s -&gt; s.length());intStream.forEach(System. out:: println);<span class="hljs-comment">//将原来流中的元素 通过 Interger.valueOf方法 转化为 整数后返回。</span>List&lt;String&gt; list = Arrays. asList(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>);<span class="hljs-type">IntStream</span> <span class="hljs-variable">intStream</span> <span class="hljs-operator">=</span> list. stream(). mapToInt(s -&gt; Integer.valueOf(s));intStream.forEach(System. out:: println);</code></pre></div><h5 id="distinct">distinct</h5><p>​ 可以去除流中的重复元素。</p><p>例如：</p><p>​ 打印所有作家的姓名，并且要求其中不能有重复元素。</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();authors.stream()    .distinct()<span class="hljs-comment">//对流中的元素，两两调用equals方法判断是否为同一个，若是则从流中去除一个</span>    .forEach(author -&gt; System.out.println(author.getName()));</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601162902927-2024-6-116:29:05.png"alt="image-20240601162902927" /><figcaption aria-hidden="true">image-20240601162902927</figcaption></figure><p><strong>注意：distinct方法是依赖Object的equals方法来判断是否是相同对象的。所以需要注意重写equals方法。</strong>Object默认的equals方法中默认使用<code>==</code>判断两对象的地址是否相同来判断是否是同一个。而在业务中，当两个对象各个属性值都相同时，就可以判断为重复。</p><blockquote><p>可以在实体类中使用<code>ALT+G</code>，选择自动重写equals方法</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601162244629-2024-6-116:23:05.png"alt="image-20240601162244629" /><figcaption aria-hidden="true">image-20240601162244629</figcaption></figure><p>生成的结果为：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601162319873-2024-6-116:24:05.png"alt="image-20240601162319873" /><figcaption aria-hidden="true">image-20240601162319873</figcaption></figure><blockquote><p>也可以在实体类上添加LomBok注解<code>@EqualsAndHashCode</code>，会自动生成重写equals方法的代码</p></blockquote><h5 id="sorted">sorted</h5><p>​ 可以对流中的元素进行排序。</p><p>例如：</p><p>​ 对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</p><div class="code-wrapper"><pre><code class="hljs java">        List&lt;Author&gt; authors = getAuthors();<span class="hljs-comment">//        对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</span>        authors.stream()                .distinct()                .sorted()                 .forEach(author -&gt; System.out.println(author.getAge()));</code></pre></div><p><strong>注意：如果调用空参的sorted()方法，需要流中的元素是实现了Comparable接口，在其中的compareTo方法中定义排序策略。</strong></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601175756515-2024-6-117:58:05.png"alt="image-20240601175756515" /><figcaption aria-hidden="true">image-20240601175756515</figcaption></figure><p>使用有参的sort方法，传入比较器Comparator，重写compare方法，指定排序策略</p><div class="code-wrapper"><pre><code class="hljs java">authors.stream()    .distinct()    .sorted(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Author&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Author o1, Author o2)</span> &#123;            <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();        &#125;    &#125;) <span class="hljs-comment">//设置比较器，按升序排序</span>    .forEach(author -&gt; System.out.println(author.getAge()));==========================lambda表达式简化写法===============================authors.stream()    .distinct()    .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge()) <span class="hljs-comment">//设置比较器，按升序排序</span>    .forEach(author -&gt; System.out.println(author.getAge()));</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601182321786-2024-6-118:24:05.png"alt="image-20240601182321786" /><figcaption aria-hidden="true">image-20240601182321786</figcaption></figure><h5 id="limit">limit</h5><p>​ 可以设置流的最大长度，超出的部分将被抛弃。</p><p>例如：</p><p>​对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素,然后打印其中年龄最大的两个作家的姓名。</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();authors.stream()        .distinct()        .sorted()        .limit(<span class="hljs-number">2</span>)        .forEach(author -&gt; System.out.println(author.getName()));</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601183333481-2024-6-118:34:05.png"alt="image-20240601183333481" /><figcaption aria-hidden="true">image-20240601183333481</figcaption></figure><h5 id="skip">skip</h5><p>​ 跳过流中的<strong>前n个元素</strong>，返回剩下的元素</p><p>例如：</p><p>​打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。</span>        List&lt;Author&gt; authors = getAuthors();        authors.stream()                .distinct()                .sorted()                .skip(<span class="hljs-number">1</span>)                .forEach(author -&gt; System.out.println(author.getName()));</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601183516052-2024-6-118:35:56.png"alt="image-20240601183516052" /><figcaption aria-hidden="true">image-20240601183516052</figcaption></figure><h5 id="flatmap">flatMap</h5><p>​map只能把一个对象转换成另一个对象来作为流中的元素。而<strong>flatMap可以把一个对象转换成多个对象作为流中的元素</strong>。（1---&gt;多）</p><p>例一：</p><p>​ 打印所有书籍的名字。要求对重复的元素进行去重。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        打印所有书籍的名字。要求对重复的元素进行去重。</span>List&lt;Author&gt; authors = getAuthors();authors.stream()    .flatMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Author, Stream&lt;Book&gt;&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> Stream&lt;Book&gt; <span class="hljs-title function_">apply</span><span class="hljs-params">(Author author)</span> &#123;            <span class="hljs-keyword">return</span> author.getBooks().stream();        &#125;    &#125;)    .distinct()    .forEach(book -&gt; System.out.println(book.getName()));==========================使用lambda表达式简化写法===============================List&lt;Author&gt; authors = getAuthors();authors.stream()    .flatMap(author -&gt; author.getBooks().stream())    .distinct()    .forEach(book -&gt; System.out.println(book.getName()));</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601184215959-2024-6-118:43:05.png"alt="image-20240601184215959" /><figcaption aria-hidden="true">image-20240601184215959</figcaption></figure><p>例二：</p><p>​打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情     爱情</span>List&lt;Author&gt; authors = getAuthors();authors.stream()    .flatMap(author -&gt; author.getBooks().stream())<span class="hljs-comment">//将Author转化为book</span>    .distinct()<span class="hljs-comment">//book去重</span>    <span class="hljs-comment">//将book转化为String：将每本书的category按`,`分割为String数组，获取该数组的流对象作为目标流</span>    .flatMap(book -&gt; Arrays.stream(book.getCategory().split(<span class="hljs-string">&quot;,&quot;</span>)))    .distinct()<span class="hljs-comment">//分类去重</span>    .forEach(category-&gt; System.out.println(category));</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601190717948-2024-6-119:08:05.png"alt="image-20240601190717948" /><figcaption aria-hidden="true">image-20240601190717948</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601190844033-2024-6-119:09:05.png"alt="image-20240601190844033" /><figcaption aria-hidden="true">image-20240601190844033</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601190944564-2024-6-119:10:05.png"alt="image-20240601190944564" /><figcaption aria-hidden="true">image-20240601190944564</figcaption></figure><h5 id="flatmaptoxxx">flatMapToXXX</h5><p>同上面的 mapToXXX</p><h5 id="peek">peek</h5><p>​<code>peek</code>方法的主要作用是在流的每个元素上执行一个操作，比如打印元素的值、记录日志、调试等。它通常用于调试和观察流的中间状态，而不会对流的内容进行修改。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test23</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//使用reduce求所有作者年龄的和</span>    List&lt;Author&gt; authors = getAuthors();    <span class="hljs-type">Integer</span> <span class="hljs-variable">ageSum</span> <span class="hljs-operator">=</span> authors.stream()            .distinct()            .map(author -&gt; author.getAge())            .peek(System.out::println) <span class="hljs-comment">//查看当前流中的每个元素</span>            <span class="hljs-comment">//初始result值为0，两者相同加，再赋值给result，最后返回结果为result</span>            .reduce(<span class="hljs-number">0</span>, (result, element) -&gt; result + element);    System.out.println(ageSum);&#125;</code></pre></div><h4 id="终结操作">终结操作</h4><blockquote><p>必须要有终结操作，否则之前定义的中间操作就不会执行。</p><p>这些操作的返回值不再是stream类型，不能再进行链式编程</p></blockquote><h5 id="foreach">forEach</h5><p>​对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作。</p><p>例子：</p><p>​ 输出所有作家的名字</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        输出所有作家的名字</span>        List&lt;Author&gt; authors = getAuthors();        authors.stream()                .map(author -&gt; author.getName())                .distinct()                .forEach(name-&gt; System.out.println(name));</code></pre></div><h5 id="count">count</h5><p>​ 可以用来获取当前流中元素的个数。</p><p>例子：</p><p>​ 打印这些作家的所出书籍的数目，注意删除重复元素。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        打印这些作家的所出书籍的数目，注意删除重复元素。</span>        List&lt;Author&gt; authors = getAuthors();        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> authors.stream()                .flatMap(author -&gt; author.getBooks().stream())                .distinct()                .count();        System.out.println(count);</code></pre></div><h5 id="maxmin">max&amp;min</h5><p>​ 可以用来或者流中的最值。</p><p>例子：</p><p>​ 分别获取这些作家的所出书籍的最高分和最低分并打印。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        分别获取这些作家的所出书籍的最高分和最低分并打印。</span>        <span class="hljs-comment">//Stream&lt;Author&gt;  -&gt; Stream&lt;Book&gt; -&gt;Stream&lt;Integer&gt;  -&gt;求值</span>        List&lt;Author&gt; authors = getAuthors();        Optional&lt;Integer&gt; max = authors.stream()                .flatMap(author -&gt; author.getBooks().stream())                .map(book -&gt; book.getScore())            <span class="hljs-comment">//指定比较器，告诉JDK按什么规则排序来得到最大最小值</span>                .max((score1, score2) -&gt; score1 - score2);         Optional&lt;Integer&gt; min = authors.stream()                .flatMap(author -&gt; author.getBooks().stream())                .map(book -&gt; book.getScore())                .min((score1, score2) -&gt; score1 - score2);        System.out.println(max.get());        System.out.println(min.get());</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601192954475-2024-6-119:30:05.png"alt="image-20240601192954475" /><figcaption aria-hidden="true">image-20240601192954475</figcaption></figure><h5 id="toarray">toArray</h5><p><code>toArray()</code>：将流中的元素放入到一个数组中，默认为Object数组。他还有一个重载方法可以返回指定类型的数组</p><div class="code-wrapper"><pre><code class="hljs java">Object[] objects = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).toArray();Integer[] integers = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>).toArray(Integer[]::<span class="hljs-keyword">new</span>);</code></pre></div><p>如果想转换成其它集合类型，需要调用collect方法，利用Collectors.toXXX方法进行转换。</p><h5 id="collect">collect</h5><p>​ 收集操作，把当前流转换成一个集合。</p><p>例子：</p><p>​ 获取一个存放所有作者名字的List集合。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        获取一个存放所有作者名字的List集合。</span>        List&lt;Author&gt; authors = getAuthors();        List&lt;String&gt; nameList = authors.stream()                .map(author -&gt; author.getName())                .collect(Collectors.toList());        System.out.println(nameList);</code></pre></div><p>​ 获取一个所有书名的Set集合。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        获取一个所有书名的Set集合。</span>List&lt;Author&gt; authors = getAuthors();Set&lt;String&gt; bookSet = authors.stream()    .flatMap(author -&gt; author.getBooks().stream())    .map(book -&gt; book.getName())    .collect(Collectors.toSet());System.out.println(bookSet);</code></pre></div><p>​</p><p>获取一个Map集合，map的key为作者名，value为List<Book></p><p>Collectors.toMap方法有两个Function类型的参数，定义了要用当前流对象的哪个属性作为key，哪个属性作为value（这个参数与map中间操作的参数相同）</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601203246895-2024-6-120:33:05.png"alt="image-20240601203246895" /><figcaption aria-hidden="true">image-20240601203246895</figcaption></figure><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        获取一个Map集合，map的key为作者名，value为List&lt;Book&gt;</span>List&lt;Author&gt; authors = getAuthors();Map&lt;String, List&lt;Book&gt;&gt; map = authors.stream()    .distinct()    .collect(Collectors.toMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Author, String&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(Author author)</span> &#123; <span class="hljs-comment">//用Author对象的什么属性作为key</span>            <span class="hljs-keyword">return</span> author.getName();        &#125;    &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Author, List&lt;Book&gt;&gt;() &#123;<span class="hljs-comment">//用Author对象的什么属性作为value</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> List&lt;Book&gt; <span class="hljs-title function_">apply</span><span class="hljs-params">(Author author)</span> &#123;            <span class="hljs-keyword">return</span> author.getBooks();        &#125;    &#125;));</code></pre></div><p>lambda简化</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        获取一个Map集合，map的key为作者名，value为List&lt;Book&gt;</span>List&lt;Author&gt; authors = getAuthors();Map&lt;String, List&lt;Book&gt;&gt; map = authors.stream()    .distinct()    .collect(Collectors.toMap(author -&gt; author.getName(),                              author -&gt; author.getBooks()));System.out.println(map);</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601205542796-2024-6-120:55:51.png"alt="image-20240601205542796" /><figcaption aria-hidden="true">image-20240601205542796</figcaption></figure><p><code>Collectors.groupingBy</code></p><p>将List的数据按照指定字段分组，结果为一个Map，key为分组字段，value为每组的元素。通过遍历Map的entrySet获取每组的key和value。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//1、获取所有店铺</span>   List&lt;Shop&gt; shops = shopService.list();   <span class="hljs-comment">//2、根据Shop的typeID字段分组,typeId一致的放到一个集合</span>   Map&lt;Long, List&lt;Shop&gt;&gt; collect = shops.stream()       .collect(Collectors.groupingBy(Shop::getTypeId));   <span class="hljs-comment">//3、遍历entrySet</span>   <span class="hljs-keyword">for</span> (Map.Entry&lt;Long, List&lt;Shop&gt;&gt; entry : collect.entrySet()) &#123;       <span class="hljs-comment">//3.1 获取类型id</span>       <span class="hljs-type">Long</span> <span class="hljs-variable">typeId</span> <span class="hljs-operator">=</span> entry.getKey();       <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> SHOP_GEO_KEY + typeId;       <span class="hljs-comment">//3.2 获取对应店铺集合</span>       List&lt;Shop&gt; shopList = entry.getValue();   &#125;</code></pre></div><h5 id="查找与匹配">查找与匹配</h5><ol type="1"><li>anyMatch</li></ol><p>​可以用来判断<strong>是否有任意符合匹配条件</strong>的元素，结果为boolean类型。</p><p>例子：</p><p>​ 判断是否有年龄在29以上的作家</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        判断是否有年龄在29以上的作家</span>        List&lt;Author&gt; authors = getAuthors();        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> authors.stream()                .anyMatch(author -&gt; author.getAge() &gt; <span class="hljs-number">29</span>);        System.out.println(flag);</code></pre></div><ol start="2" type="1"><li>allMatch</li></ol><p>​可以用来判断是否<strong>都符合</strong>匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。</p><p>例子：</p><p>​ 判断是否所有的作家都是成年人</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        判断是否所有的作家都是成年人</span>        List&lt;Author&gt; authors = getAuthors();        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> authors.stream()                .allMatch(author -&gt; author.getAge() &gt;= <span class="hljs-number">18</span>);        System.out.println(flag);</code></pre></div><ol start="3" type="1"><li>noneMatch</li></ol><p>​可以判断流中的元素是否<strong>都不符合</strong>匹配条件。如果都不符合结果为true，否则结果为false</p><p>例子：</p><p>​ 判断作家是否都没有超过100岁的。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        判断作家是否都没有超过100岁的。</span>        List&lt;Author&gt; authors = getAuthors();        <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> authors.stream()                .noneMatch(author -&gt; author.getAge() &gt; <span class="hljs-number">100</span>);        System.out.println(b);</code></pre></div><ol start="4" type="1"><li>findAny</li></ol><p>​获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。</p><p>例子：</p><p>​ 获取任意一个年龄大于18的作家，如果存在就输出他的名字</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        获取任意一个年龄大于18的作家，如果存在就输出他的名字</span>        List&lt;Author&gt; authors = getAuthors();        Optional&lt;Author&gt; optionalAuthor = authors.stream()                .filter(author -&gt; author.getAge()&gt;<span class="hljs-number">18</span>)                .findAny();        optionalAuthor.ifPresent(author -&gt; System.out.println(author.getName()));</code></pre></div><ol start="5" type="1"><li>findFirst</li></ol><p>​ 获取流中的第一个元素。</p><p>例子：</p><p>​ 获取一个年龄最小的作家，并输出他的姓名。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        获取一个年龄最小的作家，并输出他的姓名。</span>        List&lt;Author&gt; authors = getAuthors();        Optional&lt;Author&gt; first = authors.stream()                .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge())                .findFirst();        first.ifPresent(author -&gt; System.out.println(author.getName()));</code></pre></div><h5 id="reduce归并">reduce归并</h5><p>​ 对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作）</p><p>​reduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。</p><blockquote><p>进行reduce操作前，一般会使用map将流对象转化为我们操作的类型。（称为map-reduce模式）</p><p>如：要求所有作者的年龄和，先把Author流对象通过map转化为Integer流，再进行reduce求和</p></blockquote><blockquote><p>​ reduce<strong>两个参数的重载形式</strong>,其内部的计算方式如下：</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> identity;<span class="hljs-keyword">for</span> (T element : <span class="hljs-built_in">this</span> stream)result = accumulator.apply(result, element)<span class="hljs-keyword">return</span> result;</code></pre></div><p>​其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算，也是我们通过方法参数来确定的。</p><p>例子：</p><p>​ 使用reduce求所有作者年龄的和</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        使用reduce求所有作者年龄的和</span>List&lt;Author&gt; authors = getAuthors();<span class="hljs-type">Integer</span> <span class="hljs-variable">ageSum</span> <span class="hljs-operator">=</span> authors.stream()    .distinct()    .map(author -&gt; author.getAge())    .reduce(<span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryOperator</span>&lt;Integer&gt;() &#123;<span class="hljs-comment">//初始result值为0</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">apply</span><span class="hljs-params">(Integer result, Integer element)</span> &#123;            <span class="hljs-keyword">return</span> result + element;<span class="hljs-comment">//两者相同加，再赋值给result，最后返回结果为result</span>        &#125;    &#125;);System.out.println(ageSum);==========================使用lambda表达式简化写法===============================List&lt;Author&gt; authors = getAuthors();<span class="hljs-type">Integer</span> <span class="hljs-variable">ageSum</span> <span class="hljs-operator">=</span> authors.stream()    .distinct()    .map(author -&gt; author.getAge())    <span class="hljs-comment">//初始result值为0，两者相同加，再赋值给result，最后返回结果为result</span>    .reduce(<span class="hljs-number">0</span>, (result, element) -&gt; result + element);System.out.println(ageSum);</code></pre></div><p>​ 使用reduce求所有作者中年龄的最大值</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        使用reduce求所有作者中年龄的最大值</span>List&lt;Author&gt; authors = getAuthors();<span class="hljs-type">Integer</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> authors.stream()    .map(author -&gt; author.getAge())    .reduce(Integer.MIN_VALUE,             (result, element) -&gt; result &lt; element ? element : result);System.out.println(max);</code></pre></div><p>​ 使用reduce求所有作者中年龄的最小值</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        使用reduce求所有作者中年龄的最小值</span>        List&lt;Author&gt; authors = getAuthors();        <span class="hljs-type">Integer</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> authors.stream()                .map(author -&gt; author.getAge())                .reduce(Integer.MAX_VALUE, (result, element) -&gt; result &gt; element ? element : result);        System.out.println(min);</code></pre></div><blockquote><p>​ reduce<strong>一个参数的重载形式</strong>，其内部的计算</p></blockquote><p>该逻辑为：将流中<strong>第一个元素作为初始值</strong>，然后按照指定计算方式和后续的流对象进行计算，将最终结果封装在Optional对象中并返回</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">foundAny</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;  <span class="hljs-keyword">for</span> (T element : <span class="hljs-built_in">this</span> stream) &#123;      <span class="hljs-keyword">if</span> (!foundAny) &#123;          foundAny = <span class="hljs-literal">true</span>;          result = element;      &#125;      <span class="hljs-keyword">else</span>          result = accumulator.apply(result, element);  &#125;  <span class="hljs-keyword">return</span> foundAny ? Optional.of(result) : Optional.empty();</code></pre></div><p>​ 如果用一个参数的重载方法去求最小值代码如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        使用reduce求所有作者中年龄的最小值</span>List&lt;Author&gt; authors = getAuthors();Optional&lt;Integer&gt; minOptional = authors.stream()        .map(author -&gt; author.getAge())        .reduce((result, element) -&gt; result &gt; element ? element : result);minOptional.ifPresent(age-&gt; System.out.println(age));</code></pre></div><h2 id="四optional">四、Optional</h2><h3 id="概述-2">4.1 概述</h3><p>​我们在编写代码的时候出现最多的就是空指针异常。所以在很多情况下我们需要做各种非空的判断。</p><p>​ 例如：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> getAuthor();<span class="hljs-keyword">if</span>(author!=<span class="hljs-literal">null</span>)&#123;    System.out.println(author.getName());&#125;</code></pre></div><p>​ 尤其是对象中的属性还是一个对象的情况下。这种判断会更多。</p><p>​ 而过多的判断语句会让我们的代码显得臃肿不堪。</p><p>​所以在JDK8中引入了Optional,养成使用Optional的习惯后你可以写出更优雅的代码来<strong>避免空指针异常</strong>。</p><p>​并且在很多函数式编程相关的API中也都用到了Optional，如果不会使用Optional也会对函数式编程的学习造成影响。</p><h3 id="使用">4.2 使用</h3><h4 id="创建对象">创建对象</h4><p>​Optional就好像是包装类，可以把我们的具体数据封装Optional对象内部。然后我们去使用Optional中封装好的方法操作封装进去的数据，就可以非常优雅的避免空指针异常。</p><p>​我们一般使用<strong>Optional</strong>的<code>静态方法ofNullable</code>来把数据封装成一个Optional对象。无论传入的参数是否为null都不会出现问题。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240601230809882-2024-6-123:08:22.png"alt="image-20240601230809882" /><figcaption aria-hidden="true">image-20240601230809882</figcaption></figure><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> getAuthor();Optional&lt;Author&gt; authorOptional = Optional.ofNullable(author);</code></pre></div><p>​你可能会觉得还要加一行代码来封装数据比较麻烦。但是如果改造下getAuthor方法，让其的返回值就是封装好的Optional的话，我们在使用时就会方便很多。</p><p>​而且在实际开发中我们的数据很多是从数据库获取的。Mybatis从3.5版本可以也已经支持Optional了。我们可以直接把dao方法的返回值类型定义成Optional类型，MyBastis会自己把数据封装成Optional对象返回。封装的过程也不需要我们自己操作。</p><p>​如果你<strong>确定一个对象不是空</strong>的则可以使用<strong>Optional</strong>的<strong>静态方法of</strong>来把数据封装成Optional对象。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Author</span>();Optional&lt;Author&gt; authorOptional = Optional.of(author);</code></pre></div><p>​但是一定要注意，如果使用of的时候传入的参数<strong>必须不为null</strong>。（尝试下传入null会出现什么结果）</p><p>​如果一个方法的返回值类型是Optional类型。而如果我们经判断发现某次计算得到的返回值为null，这个时候就需要把null封装成Optional对象返回。这时则可以使用<strong>Optional</strong>的<strong>静态方法empty</strong>来进行封装。</p><div class="code-wrapper"><pre><code class="hljs java">Optional.empty()</code></pre></div><p>​</p><p>​ 所以最后你觉得哪种方式会更方便呢？<strong>ofNullable</strong></p><h4 id="安全消费值">安全消费值</h4><p>​我们获取到一个Optional对象后肯定需要对其中的数据进行使用。这时候我们可以使用其<code>ifPresent</code>方法对来消费其中的值。</p><p>​<u>这个方法会判断其内封装的数据是否为空，不为空时才会执行具体的消费代码。</u>这样使用起来就更加安全了。</p><p>​ 例如,以下写法就优雅的避免了空指针异常。</p><div class="code-wrapper"><pre><code class="hljs java">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());authorOptional.ifPresent(author -&gt; System.out.println(author.getName()));</code></pre></div><h4 id="获取值">获取值</h4><p>​如果我们想获取值自己进行处理可以使用get方法获取，但是不推荐。因为当Optional内部的数据为空的时候会出现异常。</p><h4 id="安全获取值">安全获取值</h4><p>​如果我们期望安全的获取值。我们不推荐使用get方法，而是使用Optional提供的以下方法。</p><ul><li><p><code>orElseGet</code></p><p><strong>获取数据并且设置数据为空时的默认值</strong>。如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建对象作为默认值返回。</p><div class="code-wrapper"><pre><code class="hljs java">Optional&lt;Author&gt; authorOptional = getAuthor();<span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> authorOptional.orElseGet(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Supplier</span>&lt;Author&gt;() &#123;    <span class="hljs-meta">@Override</span>  <span class="hljs-comment">//如果该optional对象内部封装的数据为null时，返回方法内声明的数据</span>    <span class="hljs-keyword">public</span> Author <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Author</span>(<span class="hljs-number">1L</span>, <span class="hljs-string">&quot;叶枕眠&quot;</span>, <span class="hljs-number">33</span>, <span class="hljs-string">&quot;一个从菜刀中明悟哲理的祖安人&quot;</span>, <span class="hljs-literal">null</span>);    &#125;&#125;);=============================lambda简化写法===================================Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());<span class="hljs-type">Author</span> <span class="hljs-variable">author1</span> <span class="hljs-operator">=</span> authorOptional.orElseGet(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Author</span>());</code></pre></div></li><li><p>orElseThrow</p><p>获取数据，如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建异常抛出。（可以在spring中对这些异常进行捕获处理）</p><div class="code-wrapper"><pre><code class="hljs java">Optional&lt;Author&gt; authorOptional = getAuthor();<span class="hljs-keyword">try</span> &#123;    <span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> authorOptional.orElseThrow(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Supplier</span>&lt;Throwable&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> Throwable <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//抛出自定义异常</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;author为空&quot;</span>);        &#125;    &#125;);  System.out.println(author.getName());&#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;    throwable.printStackTrace();&#125;==========================lambda简化写法======================================Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());<span class="hljs-keyword">try</span> &#123;    <span class="hljs-type">Author</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> authorOptional.orElseThrow(        () -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;author为空&quot;</span>));    System.out.println(author.getName());&#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;    throwable.printStackTrace();&#125;</code></pre></div></li></ul><h4 id="过滤">过滤</h4><p>​我们可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据的Optional对象。</p><div class="code-wrapper"><pre><code class="hljs java">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());authorOptional    .filter(author -&gt; author.getAge()&gt;<span class="hljs-number">100</span>)<span class="hljs-comment">//对optional内封装的数据进行过滤</span>    .ifPresent(author -&gt; System.out.println(author.getName()));<span class="hljs-comment">//过滤后再消费</span></code></pre></div><h4 id="判断">判断</h4><p>​我们可以使用<code>isPresent</code>方法进行是否存在数据的判断。如果为空返回值为false,如果不为空，返回值为true。但是这种方式并不能体现Optional的好处，<strong>更推荐使用ifPresent方法</strong>。</p><div class="code-wrapper"><pre><code class="hljs java">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());<span class="hljs-keyword">if</span> (authorOptional.isPresent()) &#123;    System.out.println(authorOptional.get().getName());&#125;</code></pre></div><h4 id="数据转换">数据转换</h4><p>​Optional还提供了map可以让我们的对数据进行转换，并且转换得到的数据也还是被Optional包装好的，保证了我们的使用安全。</p><p>例如我们想获取作家的书籍集合。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMap</span><span class="hljs-params">()</span> &#123;    Optional&lt;Author&gt; authorOptional = getAuthor();    authorOptional            .map(author -&gt; author.getBooks())            .ifPresent(books -&gt; System.out.println(books));&#125;</code></pre></div><h2 id="五函数式接口">五、函数式接口</h2><h3 id="概述-3">5.1 概述</h3><p>​ <strong>只有一个抽象方法</strong>的接口我们称之为函数接口。</p><p>​ JDK的函数式接口都加上了<strong><span class="citation"data-cites="FunctionalInterface">@FunctionalInterface</span></strong>注解进行标识。但是无论是否加上该注解只要接口中只有一个抽象方法，都是函数式接口。</p><h3 id="常见函数式接口">5.2 常见函数式接口</h3><ul><li><p>​ Consumer 消费接口</p><p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数进行消费。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20211028145622163-16354041894551-2024-6-201:42:30.png"alt="image-20211028145622163" /><figcaption aria-hidden="true">image-20211028145622163</figcaption></figure></li><li><p>​ Function 计算转换接口</p><p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数计算或转换，把结果返回</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20211028145707862-16354042291112-2024-6-201:42:32.png"alt="image-20211028145707862" /><figcaption aria-hidden="true">image-20211028145707862</figcaption></figure></li><li><p>​ Predicate 判断接口</p><p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中对传入的参数条件判断，返回判断结果</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20211028145818743-16354043004393-2024-6-201:42:33.png"alt="image-20211028145818743" /><figcaption aria-hidden="true">image-20211028145818743</figcaption></figure></li><li><p>​ Supplier 生产型接口</p><p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中创建对象，把创建好的对象返回</p></li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20211028145843368-16354043246954-2024-6-201:42:34.png"alt="image-20211028145843368" /><figcaption aria-hidden="true">image-20211028145843368</figcaption></figure><h3 id="常用的默认方法">5.3 常用的默认方法</h3><ul><li><p>and</p><p>我们在使用Predicate接口时候可能需要进行判断条件的拼接。而and方法相当于是使用&amp;&amp;来拼接两个判断条件</p><p>例如：</p><p>打印作家中年龄大于17并且姓名的长度大于1的作家。</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();Stream&lt;Author&gt; authorStream = authors.stream();authorStream.filter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Author&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Author author)</span> &#123;        <span class="hljs-keyword">return</span> author.getAge()&gt;<span class="hljs-number">17</span>;    &#125;&#125;.and(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Author&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Author author)</span> &#123;        <span class="hljs-keyword">return</span> author.getName().length()&gt;<span class="hljs-number">1</span>;    &#125;&#125;)).forEach(author -&gt; System.out.println(author));</code></pre></div></li><li><p>or</p><p>我们在使用Predicate接口时候可能需要进行判断条件的拼接。而or方法相当于是使用||来拼接两个判断条件。</p><p>例如：</p><p>打印作家中年龄大于17或者姓名的长度小于2的作家。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        打印作家中年龄大于17或者姓名的长度小于2的作家。</span>        List&lt;Author&gt; authors = getAuthors();        authors.stream()                .filter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Author&gt;() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Author author)</span> &#123;                        <span class="hljs-keyword">return</span> author.getAge()&gt;<span class="hljs-number">17</span>;                    &#125;                &#125;.or(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Author&gt;() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Author author)</span> &#123;                        <span class="hljs-keyword">return</span> author.getName().length()&lt;<span class="hljs-number">2</span>;                    &#125;                &#125;)).forEach(author -&gt; System.out.println(author.getName()));</code></pre></div></li><li><p>negate</p><p>Predicate接口中的方法。negate方法相当于是在判断添加前面加了个!表示取反</p><p>例如：</p><p>打印作家中年龄不大于17的作家。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//        打印作家中年龄不大于17的作家。</span>        List&lt;Author&gt; authors = getAuthors();        authors.stream()                .filter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>&lt;Author&gt;() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Author author)</span> &#123;                        <span class="hljs-keyword">return</span> author.getAge()&gt;<span class="hljs-number">17</span>;                    &#125;                &#125;.negate()).forEach(author -&gt; System.out.println(author.getAge()));</code></pre></div></li></ul><h2 id="六-方法引用">六、 方法引用</h2><blockquote><p>在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案:拿什么参数做什么操作。</p><p>那么考虑一种情况:如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑?如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。</p><p>函数式接口是 Lambda 的基础，而方法引用是 Lambda 的孪生兄弟。</p></blockquote><p>我们在使用lambda时，<strong>如果方法体中只有一个方法的调用的话</strong>（包括构造方法）,我们可以用方法引用进一步简化代码。</p><p>例如：map操作的参数是一个lambda表达式且方法体重只有一个方法的调用，此时就可以使用方法引用来进一步简化</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test14</span><span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//获取一个存放所有作者名字的List集合。</span>    List&lt;Author&gt; authors = getAuthors();    List&lt;String&gt; nameList = authors.stream()            <span class="hljs-comment">//.map(author -&gt; author.getName())</span>        .map(Author::getName)            .distinct()            .collect(Collectors.toList());    System.out.println(nameList);&#125;</code></pre></div><h3 id="推荐用法">6.1 推荐用法</h3><p>​我们在使用lambda时不需要考虑什么时候用方法引用，用哪种方法引用，方法引用的格式是什么。我们只需要在写完lambda方法发现方法体只有一行代码，并且是方法的调用时使用快捷键尝试是否能够转换成方法引用即可。</p><p>​ 当我们方法引用使用的多了慢慢的也可以直接写出方法引用。</p><h3 id="基本格式-1">6.2 基本格式</h3><p>​ 类名或者对象名::方法名</p><h3 id="语法详解了解">6.3 语法详解(了解)</h3><h4 id="引用类的静态方法">引用类的静态方法</h4><p>​ 其实就是引用类的静态方法</p><h4 id="格式">格式</h4><div class="code-wrapper"><pre><code class="hljs java">类名::方法名</code></pre></div><h4 id="使用前提">使用前提</h4><ol type="1"><li>如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong></li><li>并且这行代码是<strong>调用了某个类的静态方法</strong></li><li>并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个静态方法中</strong></li></ol><p>这个时候我们就可以引用类的静态方法。</p><p>​</p><p>例如：</p><p>如下代码就可以用方法引用进行简化</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();Stream&lt;Author&gt; authorStream = authors.stream();authors.stream()    .map(author -&gt; author.getAge())    .map(age-&gt;String.valueOf(age));==========================其对应的匿名内部类写法如下=================================    List&lt;Author&gt; authors = getAuthors();authors.stream()    .map(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Author, Integer&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">apply</span><span class="hljs-params">(Author author)</span> &#123;            <span class="hljs-keyword">return</span> author.getAge(); <span class="hljs-comment">//并没有调用静态方法，也没有传递抽象方法的参数,不能简化</span>        &#125;    &#125;)    .map(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Integer, String&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(Integer age)</span> &#123;            <span class="hljs-keyword">return</span> String.valueOf(age); <span class="hljs-comment">//调用String的静态方法，且将抽象方法的参数传递进去</span>        &#125;    &#125;);</code></pre></div><blockquote><p>注意，如果我们所重写的方法是没有参数的，调用的方法也是没有参数的也相当于符合以上规则。</p></blockquote><p>优化后如下：</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();Stream&lt;Author&gt; authorStream = authors.stream();authorStream.map(author -&gt; author.getAge())        .map(String::valueOf);</code></pre></div><h4 id="引用对象的实例方法">引用对象的实例方法</h4><p>格式</p><div class="code-wrapper"><pre><code class="hljs java">对象名::方法名</code></pre></div><p>使用前提</p><ol type="1"><li>如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong></li><li>并且这行代码是<strong>调用了某个对象的成员方法</strong></li><li>并且我们把要重写的<strong>抽象方法中所有的参数都按照顺序传入了这个成员方法中</strong></li></ol><p>这个时候我们就可以引用对象的实例方法</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();Stream&lt;Author&gt; authorStream = authors.stream();<span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();authorStream.map(author -&gt; author.getName())    .forEach(name-&gt;sb.append(name));==========================其对应的匿名内部类写法如下=================================List&lt;Author&gt; authors = getAuthors();Stream&lt;Author&gt; authorStream = authors.stream();<span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();authorStream    .map(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;Author, String&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">apply</span><span class="hljs-params">(Author author)</span> &#123;            <span class="hljs-keyword">return</span> author.getName(); <span class="hljs-comment">//调用了author对象的成员方法，但没有传递抽象方法的参数，不能简化</span>        &#125;    &#125;)    .forEach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;String&gt;() &#123;        <span class="hljs-meta">@Override</span>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(String name)</span> &#123;            sb.append(name);<span class="hljs-comment">//调用了sb对象的成员方法，且将抽象方法的参数传递进去,可以简化</span>        &#125;    &#125;);</code></pre></div><p>优化后：</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();Stream&lt;Author&gt; authorStream = authors.stream();<span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();authorStream.map(author -&gt; author.getName())        .forEach(sb::append);</code></pre></div><h4 id="引用类的实例方法">引用类的实例方法</h4><p>格式</p><div class="code-wrapper"><pre><code class="hljs java">类名::方法名</code></pre></div><p>使用前提</p><ol type="1"><li>如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong></li><li>并且这行代码是<strong>调用了第一个参数的成员方法</strong></li><li>并且我们把要<strong>重写的抽象方法中剩余的所有的参数都按照顺序传入了这个成员方法中</strong></li></ol><p>这个时候我们就可以引用类的实例方法。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs java">   <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UseString</span>&#123;       String <span class="hljs-title function_">use</span><span class="hljs-params">(String str,<span class="hljs-type">int</span> start,<span class="hljs-type">int</span> length)</span>;   &#125;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">subAuthorName</span><span class="hljs-params">(String str, UseString useString)</span>&#123;       <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;       <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;       <span class="hljs-keyword">return</span> useString.use(str,start,length);   &#125;   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;       subAuthorName(<span class="hljs-string">&quot;三更草堂&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UseString</span>() &#123;           <span class="hljs-meta">@Override</span>           <span class="hljs-keyword">public</span> String <span class="hljs-title function_">use</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> length)</span> &#123;               <span class="hljs-keyword">return</span> str.substring(start,length);           &#125;       &#125;);&#125;</code></pre></div><p>优化后如下：</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;    subAuthorName(<span class="hljs-string">&quot;三更草堂&quot;</span>, String::substring);&#125;</code></pre></div><h4 id="构造器引用">构造器引用</h4><p>​ 如果方法体中的一行代码是构造器的话就可以使用构造器引用。</p><p>格式</p><div class="code-wrapper"><pre><code class="hljs java">类名::<span class="hljs-keyword">new</span></code></pre></div><p>使用前提</p><ol type="1"><li>如果我们在重写方法的时候，方法体中<strong>只有一行代码</strong></li><li>并且这行代码是<strong>调用了某个类的构造方法</strong></li><li>并且我们把<strong>要重写的抽象方法中的所有的参数都按照顺序传入了这个构造方法中</strong></li></ol><p>这个时候我们就可以引用构造器。</p><p>例如：</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();authors.stream()        .map(author -&gt; author.getName())        .map(name-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(name))        .map(sb-&gt;sb.append(<span class="hljs-string">&quot;-三更&quot;</span>).toString())        .forEach(str-&gt; System.out.println(str));</code></pre></div><p>优化后：</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();authors.stream()    .map(author -&gt; author.getName())    .map(StringBuilder::<span class="hljs-keyword">new</span>)    .map(sb-&gt;sb.append(<span class="hljs-string">&quot;-三更&quot;</span>).toString())    .forEach(str-&gt; System.out.println(str));======================进一步简化===========================&gt;List&lt;Author&gt; authors = getAuthors();authors.stream()    .map(Author::getName)    .map(StringBuilder::<span class="hljs-keyword">new</span>)    .map(sb-&gt;sb.append(<span class="hljs-string">&quot;-三更&quot;</span>).toString())    .forEach(System.out::println);</code></pre></div><h2 id="七高级用法">七、高级用法</h2><h3 id="基本数据类型优化">7.1 基本数据类型优化</h3><p>​我们之前用到的很多Stream的方法由于都使用了泛型。所以涉及到的参数和返回值都是引用数据类型。</p><p>​即使我们操作的是整数小数，但是实际用的都是他们的包装类。JDK5中引入的自动装箱和自动拆箱让我们在使用对应的包装类时就好像使用基本数据类型一样方便。但是你一定要知道装箱和拆箱肯定是要消耗时间的。虽然这个时间消耗很下。但是在大量的数据不断的重复装箱拆箱的时候，你就不能无视这个时间损耗了。</p><p>​所以为了让我们能够对这部分的时间消耗进行优化。Stream还提供了很多专门针对基本数据类型的方法。</p><p>​例如：mapToInt、mapToLong、mapToDouble、flatMapToInt、flatMapToDouble等。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test27</span><span class="hljs-params">()</span> &#123;    List&lt;Author&gt; authors = getAuthors();    authors.stream()            .map(author -&gt; author.getAge())            .map(age -&gt; age + <span class="hljs-number">10</span>)            .filter(age-&gt;age&gt;<span class="hljs-number">18</span>)            .map(age-&gt;age+<span class="hljs-number">2</span>)            .forEach(System.out::println);    authors.stream()            .mapToInt(author -&gt; author.getAge())<span class="hljs-comment">//****转化为int类型再操作</span>            .map(age -&gt; age + <span class="hljs-number">10</span>)            .filter(age-&gt;age&gt;<span class="hljs-number">18</span>)            .map(age-&gt;age+<span class="hljs-number">2</span>)            .forEach(System.out::println);&#125;</code></pre></div><h3 id="并行流">7.2 并行流</h3><p>​当流中有大量元素时，我们可以使用并行流去提高操作的效率。其实并行流就是把任务分配给多个线程去完全。如果我们自己去用代码实现的话其实会非常的复杂，并且要求你对并发编程有足够的理解和认识。而如果我们使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮我们实现，从而提高效率。</p><p>​ parallel方法可以把串行流转换成并行流。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test28</span><span class="hljs-params">()</span> &#123;    Stream&lt;Integer&gt; stream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);    <span class="hljs-type">Integer</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> stream.parallel()            .peek(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>&lt;Integer&gt;() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Integer num)</span> &#123;                    System.out.println(num+Thread.currentThread().getName());                &#125;            &#125;)            .filter(num -&gt; num &gt; <span class="hljs-number">5</span>)            .reduce((result, ele) -&gt; result + ele)            .get();    System.out.println(sum);&#125;</code></pre></div><p>​ 也可以通过parallelStream直接获取并行流对象。</p><div class="code-wrapper"><pre><code class="hljs java">List&lt;Author&gt; authors = getAuthors();authors.parallelStream()        .map(author -&gt; author.getAge())        .map(age -&gt; age + <span class="hljs-number">10</span>)        .filter(age-&gt;age&gt;<span class="hljs-number">18</span>)        .map(age-&gt;age+<span class="hljs-number">2</span>)        .forEach(System.out::println);</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Stream流</tag>
      
      <tag>函数式编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL（三）</title>
    <link href="/f07c622d/"/>
    <url>/f07c622d/</url>
    
    <content type="html"><![CDATA[<meta name = "referrer", content = "no-referrer"/><h1 id="sql练习"><u><ahref="https://www.bilibili.com/video/BV1q4411G7Lw">SQL练习</a></u></h1><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/v2-86fd263583a6cead51675982c1735e68_r-2024-9-1211:39:45.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><blockquote><p>**1*、查询编号为01的课程比02的课程成绩高的所有学生的学号**</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 1、使用带有EXISTS谓词的子查询</span><span class="hljs-keyword">SELECT</span> s_id <span class="hljs-keyword">FROM</span> score s1 <span class="hljs-keyword">WHERE</span> s1.c_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;01&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">EXISTS</span> ( <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> score s2 <span class="hljs-keyword">WHERE</span> s1.s_id <span class="hljs-operator">=</span> s2.s_id <span class="hljs-keyword">AND</span> s2.c_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;02&#x27;</span> <span class="hljs-keyword">AND</span> s1.s_score <span class="hljs-operator">&gt;</span> s2.s_score );<span class="hljs-comment">-- 2、基于派生表的查询，期望构建出一张表，其中包含，学生的id，01课程的成绩，02课程的成绩，然后通过简单的比较，得出结果</span><span class="hljs-keyword">SELECT</span> s1.s_id <span class="hljs-string">&#x27;Sno&#x27;</span>,s1.s_score <span class="hljs-string">&#x27;grade_01&#x27;</span>, s2.s_score <span class="hljs-string">&#x27;grade_02&#x27;</span><span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> s_id, c_id, s_score <span class="hljs-keyword">FROM</span> score  <span class="hljs-keyword">WHERE</span> c_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;01&#x27;</span>)  <span class="hljs-keyword">AS</span> s1<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> s_id, c_id, s_score <span class="hljs-keyword">FROM</span> score  <span class="hljs-keyword">WHERE</span> c_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;02&#x27;</span>) <span class="hljs-keyword">AS</span> s2 <span class="hljs-keyword">ON</span> s1.s_id <span class="hljs-operator">=</span> s2.s_id<span class="hljs-keyword">WHERE</span> s1.s_score <span class="hljs-operator">&gt;</span> s2.s_score;<span class="hljs-comment">-- 构造派生表练习：</span><span class="hljs-comment">-- 找出每个学生超过他自己选修课程平均成绩的课程号和成绩</span><span class="hljs-keyword">SELECT</span> s_id, c_id, s_score, s1.avg_grade <span class="hljs-keyword">FROM</span> score, (<span class="hljs-keyword">SELECT</span> s_id, <span class="hljs-built_in">AVG</span>(s_score) <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> s_id) <span class="hljs-keyword">AS</span> s1(avg_s_id, avg_grade) <span class="hljs-keyword">WHERE</span> score.s_id <span class="hljs-operator">=</span> s1.avg_s_id <span class="hljs-keyword">AND</span> score.s_score <span class="hljs-operator">&gt;</span>s1.avg_grade;</code></pre></div><p>==注：每个派生表都必须指定一个别名，在其中可以定义查询出字段的名字==</p><p>总结：对于一个查询，思考能否将所需要的字段纳入到一张表中，然后通过在这个表中进行简单查找就能得出答案</p><blockquote><p><strong>2、查询平均成绩大于60分的学生的学号和平均成绩</strong></p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--思路：1、期望得到一张表，其中包含学号和平均成绩，直接从中选择平均成绩大于60的即可</span><span class="hljs-keyword">SELECT</span> s1.s_id, s1.avg_grade <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> s_id, <span class="hljs-built_in">AVG</span>(s_score) <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> s_id) <span class="hljs-keyword">AS</span> s1(s_id, avg_grade) <span class="hljs-keyword">WHERE</span> s1.avg_grade <span class="hljs-operator">&gt;</span> <span class="hljs-number">60</span>;<span class="hljs-comment">--思路：2、使用group by 对score表进行分组，再使用avg计算每组的平均值，最后使用having 选出平均值大于60的</span><span class="hljs-comment">-- 注：聚集函数只能用于select和having子句中，不能直接用与where子句；</span><span class="hljs-keyword">SELECT</span> s_id, <span class="hljs-built_in">AVG</span>(s_score) <span class="hljs-keyword">FROM</span> score<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> s_id;<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(s_score) <span class="hljs-operator">&gt;</span> <span class="hljs-number">60</span></code></pre></div><blockquote><p><strong>3、查询所有学生的学号、姓名、选课数、总成绩</strong></p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 这些信息涉及的表有：student和score，</span><span class="hljs-comment">--1、由于要查询所有的学生选课及分数，连接时必须使用左连接，若使用inner join所求的是交集，没选课的学生信息将不包含在内。</span><span class="hljs-comment">-- 2、分组后统计个数用count，求和用sum</span><span class="hljs-comment">-- 3、使用 CASE WHEN语句做判断，当成绩为null时，返回0</span><span class="hljs-keyword">SELECT</span>    s.s_id <span class="hljs-string">&#x27;学号&#x27;</span>,    s.s_name <span class="hljs-string">&#x27;姓名&#x27;</span>,    sc.count <span class="hljs-string">&#x27;选课数&#x27;</span>,    sc.sum <span class="hljs-string">&#x27;总成绩&#x27;</span><span class="hljs-keyword">FROM</span> student s    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span>    (<span class="hljs-keyword">SELECT</span>         s_id,         <span class="hljs-built_in">COUNT</span>(c_id),         <span class="hljs-built_in">SUM</span>(IF(s_score <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>, <span class="hljs-number">0</span>, s_score))       <span class="hljs-comment">-- IF(condition, true_value, false_value)</span>     <span class="hljs-keyword">FROM</span> score     <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> s_id) <span class="hljs-keyword">AS</span> sc(s_id,count,sum)    <span class="hljs-keyword">ON</span> s.s_id <span class="hljs-operator">=</span> sc.s_id;</code></pre></div><blockquote><p>4、查询姓侯的老师的人数</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 首先用like查出所有姓侯的老师，再用count统计个数</span><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(t_id)<span class="hljs-keyword">FROM</span> teacher<span class="hljs-keyword">WHERE</span> t_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;侯%&#x27;</span></code></pre></div><blockquote><p>5*、查询没学过张三老师课的学生的学号和姓名（<strong>先做逆命题</strong>）</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 首先考虑这个问题的逆命题：先查学过张三老师课的学生的学号，最后查student表，返回不属于这个集合的学生即为所求</span><span class="hljs-comment">--思路一：一步步嵌套查询得到结果</span><span class="hljs-comment">-- 3、返回没有选张三老师课的学生的学号和姓名</span><span class="hljs-keyword">SELECT</span> st.s_id, st.s_name<span class="hljs-keyword">FROM</span> student st<span class="hljs-keyword">WHERE</span> st.s_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-comment">-- 2、返回选了张三老师课的学生id</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> s.s_id<span class="hljs-keyword">FROM</span> score s <span class="hljs-keyword">WHERE</span> s.c_id <span class="hljs-keyword">IN</span> (<span class="hljs-comment">-- 1、连接course表和teacher表，从中选出张三老师教的所有课的c_id</span><span class="hljs-keyword">SELECT</span> c.c_id <span class="hljs-keyword">FROM</span>course c<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> teacher t <span class="hljs-keyword">ON</span> ( c.t_id <span class="hljs-operator">=</span> t.t_id <span class="hljs-keyword">AND</span> t.t_name <span class="hljs-operator">=</span> &quot;张三&quot; ) ));<span class="hljs-comment">-- 思路二：通过构建一个派生表，包含（s_id,c_id,t_id,t_name）即可从中选出学习了张三老师课的学生，最后得出没选的学生</span><span class="hljs-comment">-- 2、返回没有选张三老师课的学生的学号和姓名</span><span class="hljs-keyword">SELECT</span> st.s_id, st.s_name<span class="hljs-keyword">FROM</span> student st<span class="hljs-keyword">WHERE</span> st.s_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-comment">-- 1、查出学习了张三老师课的学生id</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> s.s_id<span class="hljs-keyword">FROM</span>score s <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> course c <span class="hljs-keyword">ON</span> s.c_id <span class="hljs-operator">=</span> c.c_id<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> teacher t <span class="hljs-keyword">ON</span> t.t_id <span class="hljs-operator">=</span> c.t_id<span class="hljs-keyword">WHERE</span> t.t_name <span class="hljs-operator">=</span> &quot;张三&quot;)</code></pre></div><blockquote><p>6*、查询学过张三老师课的学生的学号和姓名</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 思路：通过表间连接，得到一张包含（学号，姓名，所学课程，任课老师）的表</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> st.s_id, st.s_name<span class="hljs-keyword">FROM</span><span class="hljs-comment">-- 由于只找选了张三老师课的学生，故直接用inner join即可</span>student st<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> score s <span class="hljs-keyword">on</span> st.s_id <span class="hljs-operator">=</span> s.s_id<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> course c <span class="hljs-keyword">on</span> s.c_id <span class="hljs-operator">=</span> c.c_id<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> teacher t <span class="hljs-keyword">on</span> (c.t_id <span class="hljs-operator">=</span> t.t_id <span class="hljs-keyword">AND</span> t.t_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张三&#x27;</span>);</code></pre></div><blockquote><p>7*、查询学过编号为01的课程并且学过编号为02的课程的学生的学号和姓名</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 思路一：先查学过01课程的学生学号，再查学过02课程的学生学号，再求两个的交集即可（通过inner join求结果集的交集）</span><span class="hljs-keyword">SELECT</span> s_id,s_name<span class="hljs-keyword">FROM</span> student<span class="hljs-keyword">WHERE</span> s_id <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>    <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> s_id <span class="hljs-keyword">FROM</span> score  <span class="hljs-keyword">WHERE</span> c_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;01&#x27;</span>) <span class="hljs-keyword">AS</span> sc1         <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span>         (<span class="hljs-keyword">SELECT</span> s_id <span class="hljs-keyword">FROM</span> score  <span class="hljs-keyword">WHERE</span> c_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;02&#x27;</span>) <span class="hljs-keyword">AS</span> sc2    )<span class="hljs-comment">-- 思路二：在score表中筛选出选修了01课程的学生，同时对应选出的元组使用EXISTS谓词筛选选修了02课程的</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><span class="hljs-keyword">FROM</span> student st<span class="hljs-keyword">WHERE</span> st.s_id <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> sc1.s_id    <span class="hljs-keyword">FROM</span> score sc1    <span class="hljs-keyword">WHERE</span> c_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;01&#x27;</span> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">EXISTS</span>(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> score sc2 <span class="hljs-keyword">WHERE</span> sc1.s_id <span class="hljs-operator">=</span> sc2.s_id <span class="hljs-keyword">AND</span>  sc2.c_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;02&#x27;</span>)    );    <span class="hljs-comment">--思路三：查询score表，将课程号是01或02的元组保留，并按学号分组，查询每组的元组个数，若为2则为选修了01和02 的学生</span><span class="hljs-keyword">SELECT</span> st.s_id, st.s_name<span class="hljs-keyword">FROM</span> score s <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> student st <span class="hljs-keyword">ON</span> s.s_id <span class="hljs-operator">=</span> st.s_id<span class="hljs-keyword">WHERE</span> s.c_id <span class="hljs-keyword">IN</span> (&quot;01&quot;,&quot;02&quot;)<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> s.s_id<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(s.s_id) <span class="hljs-operator">=</span> <span class="hljs-number">2</span></code></pre></div><blockquote><p>8、查询课程编号为02的总成绩</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 选出课程编号为02记录，统计其中分数的总和</span><span class="hljs-keyword">SELECT</span> c_id,<span class="hljs-built_in">SUM</span>(s_score)<span class="hljs-keyword">FROM</span> score<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> c_id<span class="hljs-keyword">HAVING</span> c_id <span class="hljs-operator">=</span> &quot;02&quot;<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">SUM</span>(s_score)<span class="hljs-keyword">FROM</span> score<span class="hljs-keyword">WHERE</span> c_id <span class="hljs-operator">=</span> &quot;02&quot;</code></pre></div><blockquote><p>9、查询所有课程成绩小于60分的学生的学号和姓名</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 使用内连接</span><span class="hljs-keyword">SELECT</span>st.s_id, st.s_name, s.c_id, s.s_score<span class="hljs-keyword">FROM</span> score s <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> student st <span class="hljs-keyword">on</span> s.s_id <span class="hljs-operator">=</span> st.s_id<span class="hljs-keyword">WHERE</span> s.s_score <span class="hljs-operator">&lt;</span> <span class="hljs-number">60</span><span class="hljs-comment">--使用子查询</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> s_id,s_name<span class="hljs-keyword">FROM</span> student<span class="hljs-keyword">WHERE</span> s_id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> s_id<span class="hljs-keyword">FROM</span> score<span class="hljs-keyword">WHERE</span> s_score <span class="hljs-operator">&lt;</span> <span class="hljs-number">60</span>)</code></pre></div><blockquote><p>10*、查询没有学全所有课的学生的学号和姓名</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 思路一：查询所有课程的总数，将score表和student表连接后按照学号分组，若某组的总数小于总的课程数，即为没学全所有课程的学生。</span><span class="hljs-keyword">SELECT</span> st.s_id, st.s_name<span class="hljs-keyword">FROM</span> student st    <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> score s        <span class="hljs-keyword">ON</span> st.s_id <span class="hljs-operator">=</span> s.s_id<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> st.s_id<span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(c_id) <span class="hljs-operator">&lt;</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(c_id)    <span class="hljs-keyword">FROM</span> course    );</code></pre></div><blockquote><p>11*、查询至少有一门课与学号为01的学生所学课程相同的学生的学号和姓名</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 思路：1、学号为01的学生学了哪些课  2、直接将student表和score表连接，从中选出符合条件的学生</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> student.s_id,s_name<span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> student<span class="hljs-keyword">WHERE</span> c_id <span class="hljs-keyword">IN</span> (    <span class="hljs-keyword">SELECT</span> c_id    <span class="hljs-keyword">FROM</span> score    <span class="hljs-keyword">WHERE</span> s_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;01&#x27;</span>    )     <span class="hljs-keyword">AND</span> s_id <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;01&#x27;</span>;    <span class="hljs-comment">-- 其他写法 </span> <span class="hljs-keyword">SELECT</span> s_id, s_name<span class="hljs-keyword">FROM</span> student<span class="hljs-keyword">WHERE</span> s_id <span class="hljs-keyword">IN</span> ( <span class="hljs-comment">--使用IN</span>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> s_id    <span class="hljs-keyword">FROM</span> score    <span class="hljs-keyword">WHERE</span> c_id <span class="hljs-keyword">IN</span> (                <span class="hljs-keyword">SELECT</span> c_id                <span class="hljs-keyword">FROM</span> score                <span class="hljs-keyword">WHERE</span> s_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;01&#x27;</span>                )        <span class="hljs-keyword">AND</span> s_id <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;01&#x27;</span>    )    <span class="hljs-keyword">SELECT</span> a.s_id, a.s_name<span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> a<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-comment">-- 用INNER JOIN代替 IN,数据量较大时比IN的效率高</span>    (        <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> s_id        <span class="hljs-keyword">FROM</span> score        <span class="hljs-keyword">WHERE</span> c_id <span class="hljs-keyword">IN</span> (            <span class="hljs-keyword">SELECT</span> c_id            <span class="hljs-keyword">FROM</span> score            <span class="hljs-keyword">WHERE</span> s_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;01&#x27;</span>            )            <span class="hljs-keyword">AND</span> s_id <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;01&#x27;</span>    ) <span class="hljs-keyword">AS</span> b<span class="hljs-keyword">ON</span> a.s_id <span class="hljs-operator">=</span> b.s_id;</code></pre></div><blockquote><p>12*、查询与学号为01的学生所学课程<strong>完全相同</strong>的学生的学号和姓名</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 思路：1、查询出学号为01的学生学了哪些课 </span><span class="hljs-comment">--2、从score表中将有与学号为01同学选课重叠的记录都保留下来，如01同学选了课程号为01,02,03的   课程，使用谓词IN从score表中将选课编号包含在内的记录都保留下来，按照学号分组，统计每组的个数，保留选课数量与01同学选课数量相同的组，即找到了与其所选课程完全相同的学生学号</span><span class="hljs-comment">--3、可以使用谓词IN或INNNER JOIN从student表中得到学号和姓名</span><span class="hljs-keyword">SELECT</span> a.s_id, a.s_name<span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> a<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-comment">-- 3、INNER JOIN代替 IN</span>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> s_id    <span class="hljs-keyword">FROM</span> score    <span class="hljs-keyword">WHERE</span> c_id <span class="hljs-keyword">IN</span> ( <span class="hljs-comment">--1、筛选所选课程编号在01同学选课编号集合中的记录</span>        <span class="hljs-keyword">SELECT</span> c_id <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> s_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;01&#x27;</span>        )        <span class="hljs-keyword">AND</span> s_id <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;01&#x27;</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> s_id <span class="hljs-comment">--2、按学号分组，统计每组的选课数</span>    <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(c_id) <span class="hljs-operator">=</span> (        <span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(c_id) <span class="hljs-keyword">FROM</span> score <span class="hljs-keyword">WHERE</span> s_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;01&#x27;</span>        )) <span class="hljs-keyword">AS</span> b<span class="hljs-keyword">ON</span> a.s_id <span class="hljs-operator">=</span> b.s_id;</code></pre></div><blockquote><p>15**、查询两门及以上不及格课程的学生的学号姓名及平均成绩</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 思路：先使用WHERE语句筛选出课程不及格的记录，再按照学号分组，统计每组的记录数，将总数大于等于2的分组保留，返回每组对应的学号和平均成绩。再使用INNER/RIGHT JOIN与student表做连接，最终得到满足条件的学生的学号，姓名以及平均成绩</span><span class="hljs-keyword">SELECT</span> st.s_id, st.s_name, temp.avg_grade<span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> st<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> s_id, <span class="hljs-built_in">AVG</span>(s_score)    <span class="hljs-keyword">FROM</span> score    <span class="hljs-keyword">WHERE</span> s_score <span class="hljs-operator">&lt;</span> <span class="hljs-number">60</span>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> s_id    <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">2</span>) <span class="hljs-keyword">AS</span> temp(s_id, avg_grade)<span class="hljs-keyword">ON</span> st.s_id <span class="hljs-operator">=</span> temp.s_id;</code></pre></div><blockquote><p>16、检索01课程分数小于60，按分数降序排列的学生信息</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> st.s_id,       st.s_name,       temp.c_id,       temp.s_score<span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> st<span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> (    <span class="hljs-keyword">SELECT</span> s_id,c_id,s_score    <span class="hljs-keyword">FROM</span> score    <span class="hljs-keyword">WHERE</span> c_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;01&#x27;</span>        <span class="hljs-keyword">AND</span> s_score <span class="hljs-operator">&lt;</span> <span class="hljs-number">60</span>) <span class="hljs-keyword">AS</span> temp<span class="hljs-keyword">ON</span> st.s_id <span class="hljs-operator">=</span> temp.s_id<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> temp.s_score <span class="hljs-keyword">DESC</span> ;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL（二）</title>
    <link href="/bd62c17f/"/>
    <url>/bd62c17f/</url>
    
    <content type="html"><![CDATA[<meta name = "referrer", content = "no-referrer"/><h2 id="一事务">一、事务</h2><p><strong>事务(transaction)</strong>，是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</p><p>只有<strong>DML</strong>语句（<code>insert、delete、update</code>）才会有事务这一说，其它语句和事务无关！！！因为只有以上的三个语句是数据库表中数据进行增、删、改的。只要你的操作一旦涉及到数据的增、删、改，那么就一定要考虑安全问题。</p><h3 id="事务的原理">1.1、事务的原理</h3><p>InnoDB存储引擎：提供一组用来记录<strong>事务性活动的日志文件</strong>（类似于缓存）</p><div class="code-wrapper"><pre><code class="hljs mysql">事务开启了：insertinsertinsertdeleteupdateupdateupdate事务结束了！</code></pre></div><p>在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中，此时不会真正修改磁盘上的数据。</p><p>在事务的执行过程中，我们可以提交事务，也可以回滚事务。（提交和回滚是事务的<strong>两个终结操作</strong>）</p><p>提交事务？清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。提交事务标志着，事务的结束。并且是一种<strong>全部成功</strong>的结束。</p><p>回滚事务？ 将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件回滚事务标志着，事务的结束。并且是一种<strong>全部失败</strong>的结束。</p><h3 id="提交事务回滚事务">1.2、提交事务、回滚事务</h3><p>事务通常以 <code>start transaction</code>开始，以<code>commit</code>或<code>rollback</code>结束。</p><ul><li><code>COMMIT</code>表示提交，即提交事务的所有操作。将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束。</li><li><code>ROLLBACK</code>表示回滚，即在事务运行过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始的状态。</li></ul><p>​在MySQL默认情况下是支持自动提交事务的，即每执行一条DML语句，则提交一次。这种自动提交实际上是不符合我们的开发习惯，因为一个业务通常是需要多条DML语句共同执行才能完成的，为了保证数据的安全，必须要求同时成功之后再提交，所以不能执行一条就提交一条。执行<code>start transaction</code>关闭自动提交机制，开启真正的事务机制。</p><p><strong>代码演示</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">演示事务：  ---------------------------------回滚事务----------------------------------------  mysql&gt; use bjpowernode;  Database changed  mysql&gt; select * from dept_bak;  Empty set (0.00 sec)  mysql&gt; start transaction;  Query OK, 0 rows affected (0.00 sec)  mysql&gt; insert into dept_bak values(10,&#x27;abc&#x27;, &#x27;tj&#x27;);  Query OK, 1 row affected (0.00 sec)  mysql&gt; insert into dept_bak values(10,&#x27;abc&#x27;, &#x27;tj&#x27;);  Query OK, 1 row affected (0.00 sec)  mysql&gt; select * from dept_bak;  +--------+-------+------+  | DEPTNO | DNAME | LOC  |  +--------+-------+------+  |     10 | abc   | tj   |  |     10 | abc   | tj   |  +--------+-------+------+  2 rows in set (0.00 sec)  mysql&gt; rollback;  Query OK, 0 rows affected (0.00 sec)  mysql&gt; select * from dept_bak;  Empty set (0.00 sec)  ---------------------------------提交事务----------------------------------------  mysql&gt; use bjpowernode;  Database changed  mysql&gt; select * from dept_bak;  +--------+-------+------+  | DEPTNO | DNAME | LOC  |  +--------+-------+------+  |     10 | abc   | bj   |  +--------+-------+------+  1 row in set (0.00 sec)  mysql&gt; start transaction;  Query OK, 0 rows affected (0.00 sec)  mysql&gt; insert into dept_bak values(20,&#x27;abc&#x27;)  Query OK, 1 row affected (0.00 sec)  mysql&gt; insert into dept_bak values(20,&#x27;abc&#x27;)  Query OK, 1 row affected (0.00 sec)  mysql&gt; insert into dept_bak values(20,&#x27;abc&#x27;)  Query OK, 1 row affected (0.00 sec)  mysql&gt; commit;  Query OK, 0 rows affected (0.01 sec)  mysql&gt; select * from dept_bak;  +--------+-------+------+  | DEPTNO | DNAME | LOC  |  +--------+-------+------+  |     10 | abc   | bj   |  |     20 | abc   | tj   |  |     20 | abc   | tj   |  |     20 | abc   | tj   |  +--------+-------+------+  4 rows in set (0.00 sec)  mysql&gt; rollback;  Query OK, 0 rows affected (0.00 sec)  mysql&gt; select * from dept_bak;  +--------+-------+------+  | DEPTNO | DNAME | LOC  |  +--------+-------+------+  |     10 | abc   | bj   |  |     20 | abc   | tj   |  |     20 | abc   | tj   |  |     20 | abc   | tj   |  +--------+-------+------+  4 rows in set (0.00 sec)</code></pre></div><h3 id="事务四个特性acid">1.3、事务四个特性（ACID）</h3><p>A：原子性（Automicity） 说明事务是最小的工作单元。不可再分。</p><p>C：一致性（Consistency）在同一个事务当中，所有操作必须同时成功，或者同时失败，以保证数据的一致性。事务的执行结果必须是使数据库从一个一致性状态边到另一个一致性状态。</p><p>I：隔离性（Isolation）一个事务的执行不能被其他事务干扰。A事务和B事务之间具有一定的隔离。</p><p>D：持久性（Durability）事务一旦提交，相当于将没有保存到硬盘上的数据保存到硬盘上，它对数据库中数据的改变就是永久性的。</p><h3 id="事务的隔离性等级">1.4、事务的隔离性等级</h3><p>有关多个事务的并发控制</p><p><strong>多事务并发执行的问题</strong></p><ul><li><p><strong>脏读</strong>：一个事务读取了另一个事务未提交的数据，这些数据可能会被回滚，从而导致读取到无效数据</p></li><li><p><strong>不可重复读</strong>：一个事务在两次读取同一数据时，因其他事务的提交导致数据发生了变化，从而无法获得一致的结果。</p></li><li><p><strong>幻读</strong>：一个事务读取多条记录后，因其他事务的插入或删除，导致再次读取时获得的记录集发生变化。</p></li></ul><p>事务隔离性存在隔离级别，理论上隔离级别包括<code>4</code>个：</p><ol type="1"><li>读未提交： <code>read uncommitted</code>（最低的隔离级别，没有提交就读到了）<ul><li>含义： 事务A可以读取到事务B未提交的数据</li><li>存在问题：脏读现象！(Dirty Read)</li></ul></li><li>读已提交：<code>read committed</code> (提交之后才能读到)<ul><li>含义：事务A只能读取到事务B提交之后的数据。</li><li>解决的问题：解决了脏读的现象。</li><li>存在的问题： 不可重复读取数据。<ul><li>在事务开启之后，第一次读到的数据是3条，当前事务还没有结束，可能第二次再读取的时候，读到的数据是4条，称为不可重复读取。（做不到事务从开始到结束查询到的数据是一样的）</li><li>这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。</li></ul></li></ul></li><li>可重复读：<code>repeatable read</code>(提交之后也读不到，永远读取的都是刚开启事务时的数据)<ul><li>含义：一个事务在执行期间读取到的数据始终保持一致，不受其他事务的影响</li><li>解决的问题：解决了不可重复读取数据。</li><li>存在的问题：可以会出现幻影读。每一次读取到的数据都是幻象。不够真实！</li></ul></li><li>序列化/串行化：<code>serializable</code>（最高的隔离级别）<ul><li>这是最高隔离级别，效率最低。解决了所有的问题。这种隔离级别表示事务排队，不能并发！每一次读取到的数据都是最真实的，并且效率是最低的。</li></ul></li></ol><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240424102156449-2024-12-823:54:55.png"alt="image-20240424102156449" /><figcaption aria-hidden="true">image-20240424102156449</figcaption></figure><p>oracle数据库默认的隔离级别是：读已提交。mysq1数据库默认的隔离级别是：可重复读。</p><div class="code-wrapper"><pre><code class="hljs mysql">#测试隔离级别设置全局事务隔离级别：mysql&gt; set global transaction isolation level read uncommitted;Query OK, 0 rows affected (0.00 sec)查看隔离级别：SELECT @@tx_isolation+-----------------+| @@tx_isolation  |+-----------------+| REPEATABLE-READ |+-----------------+mysql默认的隔离级别</code></pre></div><h2 id="二存储引擎">二、存储引擎</h2><h3 id="存储引擎体系结构">2.1、存储引擎体系结构</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240711100432572-2024-7-1110:04:51.png" alt="image-20240711100432572" style="zoom:80%;" /></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240711100551721-2024-7-1110:05:52.png"alt="image-20240711100551721" /><figcaption aria-hidden="true">image-20240711100551721</figcaption></figure><h3 id="存储引擎简介">2.2、存储引擎简介</h3><blockquote><p>什么是存储引擎，有什么用呢？</p></blockquote><p>存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）</p><ul><li>存储引擎就是存储/组织数据、建立索引、更新/查询数据等技术的实现方式。</li><li>存储引擎是基于<code>表</code>的，而不是基于库的，所以存储引擎也可被称为表类型。</li><li>不同的存储引擎，表存储数据的方式不同。</li></ul><p>可以在建表的时候给表指定存储引擎。<code>ENGINE</code>来指定存储引擎，<code>CHARSET</code>来指定这张表的字符编码方式。</p><p>查看MySQL支持哪些存储引擎，命令： <code>show engines;</code></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240711101623788-2024-7-1110:17:12.png"alt="image-20240711101623788" /><figcaption aria-hidden="true">image-20240711101623788</figcaption></figure><h3 id="myisam存储引擎">2.3、MyISAM存储引擎</h3><p>它管理的表具有以下特征：</p><p>特点</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li><li>可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。</li></ul><p>文件组织结构</p><ul><li>使用三个文件表示每个表：</li><li>格式文件 — 存储表结构的定（mytable.sdi）</li><li>数据文件 — 存储表行的内（mytable.MYD）</li><li>索引文件 —存储表上索引（mytable.MYI）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。</li></ul><h3 id="innodb存储引擎">2.4、InnoDB存储引擎</h3><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5之后，InnoDB是默认的 MySQL 存储引擎。</p><ul><li><p>特点</p><ul><li>DML操作遵循ACID模型，支持<code>事务</code>；</li><li><code>行级锁</code>，提高并发访问性能；</li><li>支持<code>外键</code> FOREIGNKEY约束，保证数据的完整性和正确性，包括级联删除和更新；</li><li>支持数据库崩溃后自动恢复机制，非常安全。</li></ul></li><li><p>文件</p><p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件。存储该表的<strong>表结构</strong>（frm、sdi）、<strong>数据</strong>和<strong>索引</strong>。参数：innodb_file_per_table：是否每张InnoDB的表对应一个表空间文件，默认开启</p></li></ul><p>InnoDB的逻辑存储结构</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240711104512418-2024-7-1110:45:17.png"alt="image-20240711104512418" /><figcaption aria-hidden="true">image-20240711104512418</figcaption></figure><h3 id="memory存储引擎">2.5、MEMORY存储引擎</h3><p>Memory引擎的表数据时存储在<code>内存</code>中的，，且行的长度固定。由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</p><ul><li><p>特点</p><ul><li>数据和索引存放在内存中</li><li>支持hash索引</li><li>支持表锁</li></ul></li><li><p>文件结构</p><p>每个表对应一个 xxxx.sdi 格式的文件，保存表结构信息</p></li></ul><p>MEMORY 存储引擎以前被称为HEAP 引擎。</p><p>MEMORY引擎优点：查询效率 是最高的。不需要和硬盘交互。</p><p>MEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。</p><h3 id="存储引擎的对比与选择">2.6、存储引擎的对比与选择</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240712095425856-2024-7-1209:54:46.png" alt="image-20240712095425856" style="zoom:120%;" /></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712100104224-2024-7-1210:01:29.png"alt="image-20240712100104224" /><figcaption aria-hidden="true">image-20240712100104224</figcaption></figure><h2 id="三索引index">三、索引（index）</h2><h3 id="索引概述">3.1、索引概述</h3><p>​索引（index）是帮助MySQL<strong>高效获取数据</strong>的<strong>数据结构</strong>（有序）,是为了提高查询效率存在的一种机制。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><ul><li>MySQL在查询方面主要就是两种方式： 第一种方式：全表扫描 (性能低)第二种方式：根据索引检索。</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712104938469-2024-7-1210:49:55.png"alt="image-20240712104938469" /><figcaption aria-hidden="true">image-20240712104938469</figcaption></figure><h3 id="索引的数据结构">3.2、索引的数据结构</h3><p>索引是在MySQL体系结构的存储引擎层实现的，不同的存储引擎可以对应不同的索引结构。主要包含以下几种：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712105833956-2024-7-1210:58:58.png"alt="image-20240712105833956" /><figcaption aria-hidden="true">image-20240712105833956</figcaption></figure><p>Full-text索引是基于倒排索引实现的。<ahref="https://b11et3un53m.feishu.cn/wiki/LDLew5xnDiDv7Qk2uPwcoeNpngf">参考ES的倒排索引</a></p><p>各存储引擎对上述索引结构的支持情况：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712105941293-2024-7-1210:59:41.png"alt="image-20240712105941293" /><figcaption aria-hidden="true">image-20240712105941293</figcaption></figure><blockquote><p>B+ tree</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712112351760-2024-7-1211:24:03.png"alt="image-20240712112351760" /><figcaption aria-hidden="true">image-20240712112351760</figcaption></figure><p>B+树的每个结点都是存储在一个页中的，对应于InnoDB存储引擎逻辑结构中的page</p><p><strong>为什么InnoDB存储引擎使用B+tree作为索引结构：</strong></p><ul><li>在相同结点数量下，B+树比二叉树的层级更少，查询一个元素所需的次数更少，搜索效率高。并且当元素顺序插入时，二叉树高度为结点数量，查询效率低。</li><li>树的每个结点保存在一个磁盘块中，从根节点开始查询某关键字需要，将路径上的所有磁盘块读入内存，由于磁盘块大小固定，在B+树中，非叶节点不包含该关键字对应记录的存储地址，只起到索引作用。可以使每个磁盘块包含更多的关键字，使得B+树的阶更大，树高更小，读取磁盘次数更少，查找更快。相比于B树，每个结点中都包含了关键字对应记录的信息，使得每个磁盘块存储的关键字个数变少，树高增大，查找速度变慢。</li><li>相对于Hash索引，其只支持精确匹配，而B+树还支持范围匹配及排序操作</li></ul><blockquote><p>Hash索引</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712113933352-2024-7-1211:39:55.png"alt="image-20240712113933352" /><figcaption aria-hidden="true">image-20240712113933352</figcaption></figure><p>Hash索引的特点：</p><ul><li>Hash索引只能用于对等比较（=，in），不支持范围查询（between，&gt;，&lt;，...）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于B+tree索引</li></ul><p>在MySQL中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。</p><h3 id="索引分类">3.3、索引分类</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712150609091-2024-7-1215:06:27.png"alt="image-20240712150609091" /><figcaption aria-hidden="true">image-20240712150609091</figcaption></figure><blockquote><p>在InnoDB存储引擎中，根据<strong>索引存储形式</strong>，又可分为以下两种</p></blockquote><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712150912890-2024-7-1215:09:13.png"alt="image-20240712150912890" /><figcaption aria-hidden="true">image-20240712150912890</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712151114687-2024-7-1215:11:15.png"alt="image-20240712151114687" /><figcaption aria-hidden="true">image-20240712151114687</figcaption></figure><p>注：二级索引中不仅仅有该字段对应的聚集索引id，还有索引字段本身的值。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712151257432-2024-7-1215:13:03.png"alt="image-20240712151257432" /><figcaption aria-hidden="true">image-20240712151257432</figcaption></figure><p>由此可知：当id为主键，且name字段设置了索引的情况下，第一条sql的执行效率更高</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> &quot;jack&quot;;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712151950425-2024-7-1215:20:03.png"alt="image-20240712151950425" /><figcaption aria-hidden="true">image-20240712151950425</figcaption></figure><p>由此可知，对应两千多万条记录的表，其聚集索引对应的B+树的树高不会超过3，查找效率很高</p><h3 id="sql性能分析">3.4、SQL性能分析</h3><h4 id="sql执行频率">SQL执行频率</h4><p>MySQL客户端连接成功后，通过show[session|global]status命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：</p><div class="code-wrapper"><pre><code class="hljs mysql">show global status like &quot;Com_______&quot;;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712154433897-2024-7-1215:45:03.png"alt="image-20240712154433897" /><figcaption aria-hidden="true">image-20240712154433897</figcaption></figure><h4 id="慢查询日志">慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。通过慢查询日志定位执行较慢的sql语句，针对这些慢sql进行优化。</p><p>MySQL的慢查询日志默认没有开启</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712154859197-2024-7-1215:49:03.png"alt="image-20240712154859197" /><figcaption aria-hidden="true">image-20240712154859197</figcaption></figure><p>需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712154916297-2024-7-1215:50:03.png"alt="image-20240712154916297" /><figcaption aria-hidden="true">image-20240712154916297</figcaption></figure><p>当出现慢sql时会记录在localhost-slow.log中，其中对一条慢SQL的记录内容如下</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712160914148-2024-7-1216:09:35.png"alt="image-20240712160914148" /><figcaption aria-hidden="true">image-20240712160914148</figcaption></figure><h4 id="profile详情">profile详情</h4><p>show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了，查看各个sql语句的执行耗时</p><ul><li><p>查看是否支持profile操作</p><div class="code-wrapper"><pre><code class="hljs mysql">select @@have_profiling;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712165548802-2024-7-1216:56:01.png"alt="image-20240712165548802" /><figcaption aria-hidden="true">image-20240712165548802</figcaption></figure></li><li><p>查看是否开启profile功能</p><div class="code-wrapper"><pre><code class="hljs mysql">select @@profiling;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712165651959-2024-7-1216:56:52.png"alt="image-20240712165651959" /><figcaption aria-hidden="true">image-20240712165651959</figcaption></figure></li><li><p>开启profile功能</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> profiling <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712165738387-2024-7-1216:57:38.png"alt="image-20240712165738387" /><figcaption aria-hidden="true">image-20240712165738387</figcaption></figure></li></ul><div class="code-wrapper"><pre><code class="hljs mysql"># 查看每条sql的耗时基本情况show profiles;#查看指定query_id的SQL语句各个阶段的耗时情况show profile for query query_id;#查看指定query_id的SQL语句的cpu使用情况show profile cpu for query query_id;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712171227231-2024-7-1217:12:27.png"alt="image-20240712171227231" /><figcaption aria-hidden="true">image-20240712171227231</figcaption></figure><h4 id="explain执行计划">explain执行计划</h4><p>使用<code>explain</code>查看指定sql语句的执行计划，了解MySQL如何处理该SQL语句，表的加载顺序，表是如何连接，以及索引使用情况。是SQL优化的重要工具，主要用于分析查询语句或表结构的性能瓶颈。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712220857971-2024-7-1222:09:03.png"alt="image-20240712220857971" /><figcaption aria-hidden="true">image-20240712220857971</figcaption></figure><p>explain 出来的信息有10列，分别是：</p><p>id:选择标识符 select_type:表示查询的类型。 table:输出结果集的表partitions:匹配的分区 type:表示表的连接类型possible_keys:表示查询时，可能使用的索引 key:表示实际使用的索引key_len:索引字段的长度 ref:列与索引的比较 rows:扫描出的行数(估算的行数)filtered:按表条件过滤的行百分比 Extra:执行情况的描述和说明</p><ol type="1"><li><p><code>id</code></p><p>select查询的序列号，表示查询中<strong>执行select子句或者是操作表</strong>的<u>顺序</u></p><ul><li>id相同执行顺序由上到下</li><li>如果是子查询，id的序号会递增。在所有组中，id值越大，优先级越高，越先执行</li></ul><p>例如：查询没有选张三老师课的学生的学号和姓名（见最下SQL练习的第五题）</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 3、返回没有选张三老师课的学生的学号和姓名SELECT st.s_id, st.s_nameFROM student stWHERE st.s_id NOT IN (-- 2、返回选了张三老师课的学生idSELECT DISTINCT s.s_idFROM score s WHERE s.c_id IN (-- 1、连接course表和teacher表，从中选出张三老师教的所有课的c_idSELECT c.c_id FROMcourse cINNER JOIN teacher t ON ( c.t_id = t.t_id AND t.t_name = &quot;张三&quot; ) ));</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240712223235874-2024-7-1222:32:46.png"alt="image-20240712223235874" /><figcaption aria-hidden="true">image-20240712223235874</figcaption></figure><p>从中可以看出内部的多个子查询的id都为2，外部的查询id为1。并且在多个子查询中，操作表的顺序是从内到外的，先是teacher表，再是course表，最后是score表。</p></li><li><p>select_type</p><p>表示查询的类型。</p><ol type="1"><li><p>SIMPLE(简单SELECT，不使用UNION或子查询等)</p></li><li><p>PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)</p></li><li><p>SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)</p></li><li><p>DEPENDENTSUBQUERY(子查询中的第一个SELECT，依赖于外部查询)</p></li><li><p>DERIVED(派生表的SELECT, FROM子句的子查询)</p></li><li><p>UNCACHEABLESUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)</p></li><li><p>UNION(UNION中的第二个或后面的SELECT语句)</p></li><li><p>DEPENDENTUNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)</p></li><li><p>UNIONRESULT(UNION的结果，union语句中第二个select开始后面所有select)</p></li></ol></li><li><p>table</p><p>显示数据来自于哪个表，有时不是真实的表的名字,可能是简称，例如上面的t，c，也可能是第几步执行的结果的简称。</p></li><li><p>partitions</p></li><li><p><code>type</code></p><p>表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all。</p><ul><li><p>all：Full Table Scan， MySQL将遍历全表以找到匹配的行</p></li><li><p>index: Full IndexScan，all和index都是读全表，但index是从索引中检索的，而all是从硬盘中检索的。index类型只遍历索引树</p></li><li><p>range:只检索给定范围的行，一般条件查询中出现了&gt;、&lt;、in、between等查询，使用一个索引来选择行</p></li><li><p>ref: 使用<u>非唯一行索引</u>进行查询</p></li><li><p>eq_ref:类似ref，区别就在使用的索引是<u>唯一索引</u>。简单来说，就是多表连接中使用primarykey或者 unique key作为关联条件</p></li><li><p>const:当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量</p></li><li><p>system是const类型的特例，当查询的表只有一行的情况下，使用system</p></li><li><p>NULL:MySQL在优化过程中分解语句，<u>令其执行时甚至不用访问表或索引</u></p></li></ul></li><li><p><code>possible_keys</code></p><p>显示可能应用在这张表中的索引，但<strong>不一定被查询实际使用</strong></p></li><li><p><code>key</code></p><p>实际使用的索引，如果为NULL，则没有使用索引。</p></li><li><p><code>key_len</code></p><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。一般来说，索引长度越长表示精度越高，效率偏低；长度越短，效率高，但精度就偏低。并不是真正使用索引的长度，是个预估值。</p></li><li><p>ref</p><p>哪些列或常量被用于查找索引列上的值</p></li><li><p>rows</p><p>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</p></li><li><p>filtered</p><p>表示返回结果的行数占需读取行数的百分比，filtered的值越大越好。</p></li><li><p><code>Extra</code></p><p>一些重要的额外信息</p><ul><li><strong>Usingfilesort</strong>：使用外部的索引排序，而不是按照表内的索引顺序进行读取。（一般需要优化）</li><li><strong>Usingtemporary</strong>：使用了临时表保存中间结果。常见于排序orderby和分组查询group by（最好优化）</li><li><strong>Usingindex</strong>：表示select语句中使用了覆盖索引，直接从索引中取值，而不需要回表查询（从磁盘中取数据）</li><li>Using where：使用了where过滤</li><li>Using indexcondition：表示查询的列有非索引的列，需要进行回表查询</li><li>Using join buffer：使用了连接缓存</li><li>impossible where： where子句的值总是false</li></ul></li></ol><h3 id="索引使用规则">3.5、索引使用规则</h3><h4 id="验证索引的效率">验证索引的效率</h4><div class="code-wrapper"><pre><code class="hljs mysql">-- 在user表中插入100万数据，再查询其中一条数据，感受加不加索引的区别CREATE TABLE `app_user` (`id` BIGINT(20) UNSIGNED NOT NULL AUTO_INCREMENT,`name` VARCHAR(50) DEFAULT &#x27;&#x27;,`email` VARCHAR(50) NOT NULL,`phone` VARCHAR(20) DEFAULT &#x27;&#x27;,`gender` TINYINT(4) UNSIGNED DEFAULT &#x27;0&#x27;,`password` VARCHAR(100) NOT NULL DEFAULT &#x27;&#x27;,`age` TINYINT(4) DEFAULT NULL,`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,`update_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8-- SET GLOBAL log_bin_trust_function_creators = 1;-- 开启创建函数功能/*  第一个语句 delimiter 将 mysql 解释器命令行的结束符由”;” 改成了”$$”，  让存储过程内的命令遇到”;” 不执行*/DELIMITER $$CREATE FUNCTION mock_data()RETURNS INTBEGINDECLARE num INT DEFAULT 1000000;DECLARE i INT DEFAULT 0;WHILE i&lt;num DOINSERT INTO `app_user`(`name`,`email`,`phone`,`gender`)VALUES(CONCAT(&#x27;用户&#x27;,i),&#x27;19224305@qq.com&#x27;,&#x27;123456789&#x27;,FLOOR(RAND()*2));SET i=i+1;END WHILE;RETURN i;END;$$SELECT mock_data()$$ -- 执行此函数 生成一百万条数据-- 不加索引查询SELECT * FROM `app_user` WHERE `name` = &#x27;用户99999&#x27;&gt; OK&gt; 时间: 0.332s-- 添加索引后查询CREATE INDEX index_app_user_name ON app_user ( `name` );SELECT * FROM `app_user` WHERE `name` = &#x27;用户99999&#x27;&gt; OK&gt; 时间: 0.001s</code></pre></div><h4 id="最左前缀法则">最左前缀法则</h4><p>如果索引了多列（联合索引），要遵守最左前缀法则。</p><p><strong>最左前缀法则</strong>指的是在查询时，必须从联合索引的最左边开始，并且不能跳过索引中的列。</p><ul><li><p>如果查询条件中缺失最左侧的索引字段，则后面的字段查询都不会使用索引。</p></li><li><p>如果跳跃某一列，则该列后面的字段索引失效（部分失效）</p></li></ul><p>例如：在tb_user表中，已对profession、age、status建立了联合索引，现验证最左前缀法则</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713171404644-2024-7-1317:14:16.png"alt="image-20240713171404644" /><figcaption aria-hidden="true">image-20240713171404644</figcaption></figure><p><code>explain select * from tb_user where profession =·软件工程'and age = 31 and status = '0';</code>该sql语句符合最左前缀法则，索引已生效，联合索引字段长度为54</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713171720088-2024-7-1317:17:20.png"alt="image-20240713171720088" /><figcaption aria-hidden="true">image-20240713171720088</figcaption></figure><p><code>explain select * from tb_user where age = 31 and status = '0';</code>此sql语句中最左侧索引字段缺失，该语句未使用索引</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713172401186-2024-7-1317:24:42.png"alt="image-20240713172401186" /><figcaption aria-hidden="true">image-20240713172401186</figcaption></figure><p><code>explain select * from tb_user where profession = 软件工程'and age = 31；</code>此sql语句中索引最左侧字段存在，且中间没有缺失其他索引字段，故索引也生效，此时索引长度为49</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713172135947-2024-7-1317:21:42.png"alt="image-20240713172135947" /><figcaption aria-hidden="true">image-20240713172135947</figcaption></figure><p><code>explain select * from tb user where profession ='软件工程'；</code>此sql语句中索引最左侧字段存在，且中间没有缺失其他索引字段，故索引也生效。此时索引长度为47，即profession索引字段长度为47</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713172320284-2024-7-1317:23:42.png"alt="image-20240713172320284" /><figcaption aria-hidden="true">image-20240713172320284</figcaption></figure><p><code>explain select * from tb_user where profession =·软件工程'and status = '0';</code></p><p>该sql语句中，只提供了联合索引中的profession和status字段，中间的age字段缺失，此时索引部分生效，索引字段长度为47，只有profession的查询使用了索引，但status没有使用索引</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713172650355-2024-7-1317:27:42.png"alt="image-20240713172650355" /><figcaption aria-hidden="true">image-20240713172650355</figcaption></figure><h4 id="索引失效情况">索引失效情况</h4><ol type="1"><li><p>索引列运算</p><p>不要在索引列上进行运算操作，<code>索引将失效</code>。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713174016271-2024-7-1317:40:42.png"alt="image-20240713174016271" /><figcaption aria-hidden="true">image-20240713174016271</figcaption></figure></li><li><p>字符串不加引号</p><p>字符串类型字段使用时未加引号，会进行隐式类型转换造成<code>索引将失效</code>。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713174559698-2024-7-1317:46:42.png"alt="image-20240713174559698" /><figcaption aria-hidden="true">image-20240713174559698</figcaption></figure></li><li><p>模糊查询</p><p>如何仅仅是尾部模糊匹配，索引仍会生效。但如果是头部模糊匹配，索引失效。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713175107252-2024-7-1317:51:42.png"alt="image-20240713175107252" /><figcaption aria-hidden="true">image-20240713175107252</figcaption></figure></li><li><p>or连接的条件</p><p>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。（前边有索引但后边没有，则索引不会生效；两边都有索引时，索引才会生效）</p><p>例如：在tb_user表中，age字段没有建立索引。执行<code>select * from tb_user where id = 10 or age = 23;</code>时，由于id为主键，存在主键索引，但age没有索引，执行过程中索引不会生效。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713175731784-2024-7-1317:57:42.png"alt="image-20240713175731784" /><figcaption aria-hidden="true">image-20240713175731784</figcaption></figure><p>为age字段建立索引后，再执行该语句</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713180018863-2024-7-1318:00:42.png"alt="image-20240713180018863" /><figcaption aria-hidden="true">image-20240713180018863</figcaption></figure></li><li><p>数据分布</p><p>如果MySQL评估使用索引比全表扫描更慢，则不使用索引。</p><p>比如在一张表中已对某个字段建立了索引，但使用该索引字段查询到的结果<u>基本上是整张表的数据，或是整张表的大部分数据</u>，经过MySQL评估后，不会使用索引而是进行全表扫描（<code>避免进行回表查询</code>）。但若是主键索引，即使查询结果时整张表的数据，但还是一定会使用主键索引。</p><p>例：tb_user表中，已对phone字段建立了索引，且表中phone的最小值为"17799990000"。执行</p><p><code>select * from tb_user where phone &gt;= '17799990000';</code>得到的结果为整张表的数据，查看该sql的执行计划可知，索引不会生效</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713181911044-2024-7-1318:19:42.png"alt="image-20240713181911044" /><figcaption aria-hidden="true">image-20240713181911044</figcaption></figure><p>但若是主键索引一定会生效，如：dish表中id最小为46，执行<code>select * from dish where id &gt;= 46</code>得到的也是整张表的数据，但主键索引还是生效了</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713182126019-2024-7-1318:21:42.png"alt="image-20240713182126019" /><figcaption aria-hidden="true">image-20240713182126019</figcaption></figure></li></ol><h4 id="sql提示">SQL提示</h4><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713183235664-2024-7-1318:32:42.png"alt="image-20240713183235664" /><figcaption aria-hidden="true">image-20240713183235664</figcaption></figure><h4 id="覆盖索引">覆盖索引</h4><p>覆盖索引是指：查询使用了索引，并且需要返回的列，在该索引中已经能全部找到。</p><blockquote><p>尽量使用覆盖索引，减少使用select *</p></blockquote><p>例：在tb_user表中，已经对profession，age，status建立了联合索引，分别执行以下sql，查看其执行计划。</p><p>1、<code>select id, profession,age,status from tb_user where profession = '软件工程' and age = 31 and status = '0';</code>其执行计划中Extra列的信息为：<u>Usingwhere; Using index</u></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713185911831-2024-7-1318:59:42.png"alt="image-20240713185911831" /><figcaption aria-hidden="true">image-20240713185911831</figcaption></figure><p>2、<code>select id, profession,age,status, name from tb_user where profession = '软件工程' and age = 31 and status = '0';</code>相比于上一条sql，这条sql的查询结果中需要返回的列多了一个name字段。其执行计划的Extra列的信息为：<u>Usingindex condition</u></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713185952078-2024-7-1319:00:42.png"alt="image-20240713185952078" /><figcaption aria-hidden="true">image-20240713185952078</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713190303548-2024-7-1319:03:04.png"alt="image-20240713190303548" /><figcaption aria-hidden="true">image-20240713190303548</figcaption></figure><p>由于对profession、age、status建立的联合索引索引二级索引（辅助索引），在二级索引的叶子结点中不仅包含了对应索引字段的值，还包括该记录对应的聚集索引的id（一般是主键id）。</p><p>故对应第一条sql语句，其需要返回的字段在二级索引树上全部都能查到，直接返回结果，一次索引扫描即可，不需要回表查询。但对于第二条sql，其返回结果中多出了二级索引树上没有的name字段，此时需要根据当前的聚集索引id，在聚集索引中进行回表查询，得到完整的记录，从中得到name字段，整合后返回。</p><p>图示如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713190928026-2024-7-1319:09:42.png"alt="image-20240713190928026" /><figcaption aria-hidden="true">image-20240713190928026</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713191033317-2024-7-1319:10:42.png"alt="image-20240713191033317" /><figcaption aria-hidden="true">image-20240713191033317</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240713191436663-2024-7-1319:14:42.png"alt="image-20240713191436663" /><figcaption aria-hidden="true">image-20240713191436663</figcaption></figure><h4 id="前缀索引">前缀索引</h4><p>一、前缀索引 当字段类型为字符串（ varchar ， text ， longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘 IO ，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。1. 语法</p><p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_xxxx <span class="hljs-keyword">on</span> table_name(<span class="hljs-keyword">column</span>(n)) ;</code></pre></div></p><p>示例:</p><p>为 tb_user 表的 email 字段，建立长度为 5 的前缀索引。</p><p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index index_email <span class="hljs-keyword">on</span> tb_user(email(<span class="hljs-number">5</span>));</code></pre></div></p><figure><imgsrc="https://img-blog.csdnimg.cn/direct/315660d9baf0456db40d15ffd11f4475.png"alt="前缀索引-1" /><figcaption aria-hidden="true">前缀索引-1</figcaption></figure><ol start="2" type="1"><li>如何选择前缀长度可以根据索引的<code>选择性</code>来决定，而选择性是指<code>不重复的索引值（基数）</code>和<code>数据表的记录总数</code>的<strong>比值</strong>，索引选择性越高则查询效率越高，唯一索引的选择性是1 ，这是最好的索引选择性，性能也是最好的。</li></ol><p>下面这里我们看一下案例：</p><p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> email)<span class="hljs-operator">/</span><span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user;</code></pre></div></p><figure><imgsrc="https://img-blog.csdnimg.cn/direct/12ffdc72e70f42eeb16dc585ab7bb7aa.png"alt="前缀索引-2" /><figcaption aria-hidden="true">前缀索引-2</figcaption></figure><p>可以看到上面显示的是1，也就是说所有的email字段的数据都没有出现重复，下面我们去从email字段数据去截取前5个字符比较试试看：</p><p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-built_in">substring</span>(email,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user ;</code></pre></div></p><figure><imgsrc="https://img-blog.csdnimg.cn/direct/12ffdc72e70f42eeb16dc585ab7bb7aa.png"alt="前缀索引-3" /><figcaption aria-hidden="true">前缀索引-3</figcaption></figure><p>这里我们可以看出出现重复了，但是非重复率还是有0.9583的，如果我们截取前4个或者前6个字符再试试看重复率：</p><p><div class="code-wrapper"><pre><code class="hljs sql">#截取前四个<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-built_in">substring</span>(email,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user ;</code></pre></div></p><figure><imgsrc="https://img-blog.csdnimg.cn/direct/f673ce33855541d498f0e8c8d7e5ade5.png"alt="前缀索引-4" /><figcaption aria-hidden="true">前缀索引-4</figcaption></figure><p><div class="code-wrapper"><pre><code class="hljs sql">#截取前<span class="hljs-number">6</span>个<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-built_in">substring</span>(email,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user ;</code></pre></div></p><figure><imgsrc="https://img-blog.csdnimg.cn/direct/85b0f173fd704df1aab543ea750dfec3.png"alt="前缀索引-5" /><figcaption aria-hidden="true">前缀索引-5</figcaption></figure><p>上面这两个对比就知道，截取前4个的话重复率变大了，而截取前6个的话重复率不变，故最优解就是截取前面前5个即可。</p><ol start="3" type="1"><li>前缀索引的查询流程前缀索引的查询流程基本上跟前面讲到过的是差不多的，这里会通过我们选择好的前缀去建立一个辅助索引，在辅助索引上面去找到相对应的索引目标，如果出现重复的话就会先找到第一个重复的索引数据，然后再去进行回表查询得到对应行完整的数据，如果完整数据中的对应字段与查询条件相同，则返回改行数据；反之继续遍历下一个重复的结果。</li></ol><figure><imgsrc="https://img-blog.csdnimg.cn/direct/5914eaa0180445c6b12f2c8ebc41c2ee.png"alt="前缀索引-6" /><figcaption aria-hidden="true">前缀索引-6</figcaption></figure><h4 id="单列索引联合索引">单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列。</p><p>联合索引：即一个索引包含了多个列。</p><p>查看当前tb_user表中建立的索引情况：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240719100709418-2024-7-1910:07:44.png"alt="image-20240719100709418" /><figcaption aria-hidden="true">image-20240719100709418</figcaption></figure><p>在tb_user表中已经针对phone和name分别建立了单列索引，此时执行一条sql，以phone和name为查询条件，查看其执行计划</p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,phone,name <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> phone<span class="hljs-operator">=</span><span class="hljs-string">&#x27;17799990000&#x27;</span> <span class="hljs-keyword">and</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;吕布&#x27;</span>;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240719101022564-2024-7-1910:10:22.png"alt="image-20240719101022564" /><figcaption aria-hidden="true">image-20240719101022564</figcaption></figure><p>可能用到的索引为index_phone和index_name，但实际上在执行这条sql时MySQL只用到了其中的一个索引index_phone。在针对phone建立的索引树中并没有name字段，故还要进行回表查询。</p><p>对phone和name建立联合索引后，执行该sql，再次查询执行计划</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> index idx_user_phone_name <span class="hljs-keyword">on</span> tb_user(phone,name);explain <span class="hljs-keyword">select</span> id,phone,name <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> phone<span class="hljs-operator">=</span><span class="hljs-string">&#x27;17799990000&#x27;</span> <span class="hljs-keyword">and</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;吕布&#x27;</span>;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240719101448693-2024-7-1910:14:52.png"alt="image-20240719101448693" /><figcaption aria-hidden="true">image-20240719101448693</figcaption></figure><p>发现此时，MySQL使用的还是index_phone。<u>在多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。</u></p><p>此时可以通过SQL提示，建议MySQL使用联合索引，而在联合索引中包含phone、name的信息，在叶子节点下挂的是对应的主键id，所以查询是无需回表查询的。</p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,phone,name <span class="hljs-keyword">from</span> tb_user use index(idx_user_phone_name)<span class="hljs-keyword">where</span> phone<span class="hljs-operator">=</span><span class="hljs-string">&#x27;17799990010&#x27;</span> <span class="hljs-keyword">and</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;韩信&#x27;</span>;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240719101848501-2024-7-1910:18:52.png"alt="image-20240719101848501" /><figcaption aria-hidden="true">image-20240719101848501</figcaption></figure><blockquote><p><strong>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</strong></p></blockquote><p>如果查询使用的是联合索引，具体的结构示意图如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240719102106348-2024-7-1910:21:52.png"alt="image-20240719102106348" /><figcaption aria-hidden="true">image-20240719102106348</figcaption></figure><p>根据索引定义顺序，在B+树中先按照phone进行排序，phone相同再按照name进行排序。注意联合索引使用时要遵循<code>最左前缀法则</code>。</p><h3 id="索引设计原则">3.6、索引设计原则</h3><p>针对什么表建立索引？针对表中的那些字段建立索引？建立什么类型的索引？</p><blockquote><ol type="1"><li>针对于数据量较大，且<strong>查询比较频繁</strong>的表建立索引。</li><li>针对于常作为查询条件（where）、排序（order by）、分组（groupby）操作的字段建立索 引。</li><li>尽量选择区<strong>分度高的列</strong>作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li><strong>尽量使用联合索引，减少单列索引</strong>，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。注意联合索引使用时要遵循<code>最左前缀法则</code>。</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li><li>如果索引列不能存储NULL值，请在创建表时使用NOTNULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol></blockquote><h2 id="四sql优化">四、SQL优化</h2><h3 id="插入数据">4.1、插入数据</h3><p>平时我们插入数据的时候一般都是一个语句插一个数据，如下所示：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;tom&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;cat&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;jerry&#x27;</span>);.....</code></pre></div><p>每条insert语执行时都需要和MySQL建立/释放连接，开启和提交事务，执行SQL语句，进行数据传输，当时数据量较大时效率很低。</p><p>如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p><ol type="1"><li><p>insert插入的优化方案</p><p>（1）优化方案一：<strong>批量插入</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">Insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);</code></pre></div><p>相较于一条语句插入一个数据，一次性插入批量数据效率必然是更高的，这就不需要多次开启和提交事务了，节约时间。</p><p>（2）优化方案二：<strong>手动提交事务</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">start</span> transaction;<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> tb_test <span class="hljs-keyword">values</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&#x27;Tom&#x27;</span>),(<span class="hljs-number">8</span>,<span class="hljs-string">&#x27;Cat&#x27;</span>),(<span class="hljs-number">9</span>,<span class="hljs-string">&#x27;Jerry&#x27;</span>);<span class="hljs-keyword">commit</span>;</code></pre></div><p>手动控制事务，其实这个语句的就是方法1的本质，也就是通过一次事务去提交，避免多次开启事务的情况。</p><p>（3）优化方案三：<strong>主键顺序插入</strong></p><p>主键顺序插入，性能要高于乱序插入。这个应该没什么好多说了，排序肯定是需要耗时间的。</p><div class="code-wrapper"><pre><code class="hljs bash">主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89</code></pre></div></li><li><p>大批量插入数据 如果一次性需要插入大批量数据 ( 比如 : 几百万的记录) ，使用 insert 语句插入性能较低，此时可以使用 MySQL数据库提供的<code>load指令</code>进行插入(<strong>在load时，主键顺序插入性能高于乱序插入</strong>)。操作如下：<imgsrc="https://img-blog.csdnimg.cn/direct/8cdd02cbdfb64c6c9d181e69ec7d6e9b.png"alt="load指令" /></p><p>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 客户端连接服务端时，加上参数 -–local-infilemysql –-local-infile -u root -p -- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关set global local_infile = 1; -- 执行load指令将准备好的数据，加载到表结构中load data local infile &#x27;/root/sql1.log&#x27; into table tb_user fieldsterminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27; ;</code></pre></div><p>补充：对于load指令的语句中，fields terminatedby意思是每一个字段之间间隔符号用什么</p><p>lines terminated by意思是每一行间距是用什么。</p></li></ol><h3 id="主键优化">4.2、主键优化</h3><p>在上面，我们提到，主键顺序插入的性能是要高于乱序插入的。这一小节，就来介绍一下具体的原因，然后再分析一下主键又该如何设计。</p><ol type="1"><li><p><strong>数据组织方式</strong></p><p>在 InnoDB存储引擎中，<strong>表数据都是根据主键顺序组织存放的</strong>，这种存储方式的表称为索引组织表(indexorganized table IOT)</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093108993-2024-7-2009:31:12.png"alt="image-20240720093108993" /><figcaption aria-hidden="true">image-20240720093108993</figcaption></figure><p>行数据，都是存储在聚集索引的叶子节点上的。而根据 InnoDB的逻辑结构图：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240711104512418-2024-7-1110:45:17.png"alt="image-20240711104512418" /><figcaption aria-hidden="true">image-20240711104512418</figcaption></figure><p>在 InnoDB 引擎中，数据行是记录在逻辑结构 page页中的，而每一个页的大小是固定的，默认 16K 。那也就意味着，一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不下，将会存储到下一个页中，页与页之间会通过指针连接。</p></li><li><p><strong>页分裂</strong></p><p>页可以为空，也可以填充一半，也可以填充 100% 。每个页包含了 2-N 行数据( 如果一行数据过大，会行溢出) ，根据主键排列。</p><blockquote><p>主键顺序插入效果</p></blockquote><p>① . 从磁盘中申请页， 主键顺序插入</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093553745-2024-7-2009:35:54.png"alt="image-20240720093553745" /><figcaption aria-hidden="true">image-20240720093553745</figcaption></figure><p>②. 第一个页没有满，继续往第一页插入</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093614767-2024-7-2009:36:23.png"alt="image-20240720093614767" /><figcaption aria-hidden="true">image-20240720093614767</figcaption></figure><p>③ . 当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093649301-2024-7-2009:37:23.png"alt="image-20240720093649301" /><figcaption aria-hidden="true">image-20240720093649301</figcaption></figure><p>④. 当第二页写满了，再往第三页写入</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093735297-2024-7-2009:38:24.png"alt="image-20240720093735297" /><figcaption aria-hidden="true">image-20240720093735297</figcaption></figure><blockquote><p>主键乱序插入效果</p></blockquote><p>① . 当1#,2#页都已经写满了，存放了如图所示的数据</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093843413-2024-7-2009:39:23.png"alt="image-20240720093843413" /><figcaption aria-hidden="true">image-20240720093843413</figcaption></figure><p>② . 此时再插入 id 为 50 的记录，我们来看看会发生什么现象</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093908409-2024-7-2009:40:23.png"alt="image-20240720093908409" /><figcaption aria-hidden="true">image-20240720093908409</figcaption></figure><p>会再次开启一个页，写入新的页中吗？答案是不会。因为，索引结构的叶子节点是有顺序的。按照顺序，应该存储在47 之后。但是47所在的1#页，已经写满了，存储不了50对应的数据了。那么此时会开辟一个新的页 3#</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720093956540-2024-7-2009:41:23.png"alt="image-20240720093956540" /><figcaption aria-hidden="true">image-20240720093956540</figcaption></figure><p>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720094028985-2024-7-2009:42:16.png"alt="image-20240720094028985" /><figcaption aria-hidden="true">image-20240720094028985</figcaption></figure><p>此时，这三个页之间的数据顺序是有问题的。 1# 的下一个页，应该是3# ，3# 的下一个页是 2# 。 所以，此时，需要重新设置链表指针。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720094114446-2024-7-2009:42:19.png"alt="image-20240720094114446" /><figcaption aria-hidden="true">image-20240720094114446</figcaption></figure><p>上述的这种现象，称之为"<code>页分裂</code>"，是比较耗费性能的操作。</p></li><li><p>页合并</p><p>目前表中已有数据的索引结构 ( 叶子节点)如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720094212022-2024-7-2009:42:20.png"alt="image-20240720094212022" /><figcaption aria-hidden="true">image-20240720094212022</figcaption></figure><p>当我们对已有数据进行删除时，具体的效果如下 :</p><p>当删除一行记录时<u>，实际上记录并没有被物理删除，只是记录被标记（flaged ）为删除并且它的空间变得允许被其他记录声明使用。</u></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720094328067-2024-7-2009:43:28.png"alt="image-20240720094328067" /><figcaption aria-hidden="true">image-20240720094328067</figcaption></figure><p>继续删除2#的内容，当页中删除的记录达到 MERGE_THRESHOLD （默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720094843818-2024-7-2009:49:18.png"alt="image-20240720094843818" /><figcaption aria-hidden="true">image-20240720094843818</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720094915435-2024-7-2009:49:19.png"alt="image-20240720094915435" /><figcaption aria-hidden="true">image-20240720094915435</figcaption></figure><p>这个里面所发生的合并页的这个现象，就称之为"<code>页合并</code>"</p></li><li><p><strong>主键设计原则</strong></p><ul><li>满足业务需求的情况下，尽量降低主键的长度。（<u>在二级索引的叶子结点中保存着主键，如果主键过长，二级索引较多，会占用较大的磁盘空间，且在搜索时会进行大量的磁盘IO</u>）</li><li>插入数据时，尽量选择顺序插入。（<u>乱序插入可能会导致页分裂，插入效率低</u>）</li><li>选择使用AUTO_INCREMENT自增主键，尽量不要使用UUID做主键或者是其他自然主键，如身份证号。（<u>这些是无序的，且长度较长</u>）</li><li>业务操作时，避免对主键的修改。（<u>还要修改二级索引的内容</u>）</li></ul></li></ol><h3 id="order-by优化">4.3、order by优化</h3><p>MySQL 的排序，有两种方式：</p><ul><li>Using filesort :通过表的索引或全表扫描，读取满足条件的数据行，然后在<u>排序缓冲区sortbuffer中完成排序操作</u>，所有不是通过索引直接返回排序结果的排序都叫FileSort 排序。（如果缓冲区满了，会进一步在磁盘中进行排序）</li><li>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要 额外排序，操作效率高。</li></ul><p><strong>对于以上的两种排序方式，Using index的性能高，而Usingfilesort的性能低，我们在优化排序操作时，尽量要优化为Usingindex。</strong></p><p>SQL排序使用了哪种方式，可以通过<code>explain</code>在SQL语句执行计划的Extra字段查看</p><blockquote><p>测试索引对排序的效果</p></blockquote><p>1、在tb_user表中，删除age和phone的索引，再根据这两个字段进行排序，查看其执行计划.</p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id ,age ,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720101450542-2024-7-2010:14:50.png"alt="image-20240720101450542" /><figcaption aria-hidden="true">image-20240720101450542</figcaption></figure><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age, phone ;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720101228160-2024-7-2010:12:33.png"alt="image-20240720101228160" /><figcaption aria-hidden="true">image-20240720101228160</figcaption></figure><p>由于 age, phone 都没有索引，所以此时再排序时，出现Using filesort，排序性能较低。</p><p>2、创建索引后，再次进行排序，查看执行计划</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建索引</span><span class="hljs-keyword">create</span> index idx_age_phone <span class="hljs-keyword">on</span> tb_user(age,phone);</code></pre></div><blockquote><p>默认age和phone都是升序建立的索引</p></blockquote><p>A. 根据age, phone进行<strong>升序排序</strong></p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720101717524-2024-7-2010:17:17.png"alt="image-20240720101717524" /><figcaption aria-hidden="true">image-20240720101717524</figcaption></figure><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age , phone;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720101747424-2024-7-2010:18:10.png"alt="image-20240720101747424" /><figcaption aria-hidden="true">image-20240720101747424</figcaption></figure><p>B. 根据age，phone进行<strong>降序排序</strong></p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">desc</span> , phone <span class="hljs-keyword">desc</span> ;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720102255101-2024-7-2010:22:55.png"alt="image-20240720102255101" /><figcaption aria-hidden="true">image-20240720102255101</figcaption></figure><blockquote><p>注：由于age和phone都是升序建立的索引，当排序时两者都是升序，排序方式是Usingindex；当两者都是降序时，Extra中也是Using index，但多了 Backward indexscan，这个代表反向扫描索引，因为在 MySQL中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序时，是从大到小，所以，在扫描时，就是反向扫描，就会出现Backward index scan 。</p></blockquote><ol start="3" type="A"><li><strong>对于排序使用联合索引的情况，排序时 , 也需要满足最左前缀法则, 否则也会出现 filesort 。</strong>因为在创建索引的时候， age是第一个字段， phone是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Usingfilesort。</li></ol><p>D. 排序时<strong>根据age升序排序，根据phone降序排序</strong></p><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> id,age,phone <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">asc</span> ,phone <span class="hljs-keyword">desc</span> ;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720102448603-2024-7-2010:25:15.png"alt="image-20240720102448603" /><figcaption aria-hidden="true">image-20240720102448603</figcaption></figure><p>因为创建索引时，如果未指定顺序，默认都是按照升序排序的（A是表示升序asc，D的话是表示降序desc），而<strong>查询时，一个升序，一个降序，此时就会出现Usingfilesort</strong> 。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720102604013-2024-7-2010:26:04.png"alt="image-20240720102604013" /><figcaption aria-hidden="true">image-20240720102604013</figcaption></figure><p>为了解决上述问题，为了解决上述的问题，我们可以创建一个索引，这个联合索引中age 升序排序， phone 倒序排序。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index idx_age_phone_ad <span class="hljs-keyword">on</span> tb_user(age <span class="hljs-keyword">asc</span> ,phone <span class="hljs-keyword">desc</span>);</code></pre></div><p>再次执行上述排序SQL,查看其执行计划，其中排序方法为Using index</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240720103026285-2024-7-2010:30:34.png"alt="image-20240720103026285" /><figcaption aria-hidden="true">image-20240720103026285</figcaption></figure><p><strong>由上述的测试,我们得出order by优化原则:</strong></p><p>A. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p><p>B. 尽量使用覆盖索引。（以上排序方法为Using index的前提是使用覆盖索引，否则要进行回表查询，得到数据后在排序缓冲区中进行排序，效率低）</p><p>C. 多字段排序 ,一个升序一个降序，此时需要注意联合索引在创建时的规则（ ASC/DESC ）。</p><p>D. 如果不可避免的出现 filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认 256k)。</p><h3 id="group-by优化">4.4、group by优化</h3><p>在分组操作时，可以通过索引来提高效率 （尽量建立联合索引）。</p><ol type="A"><li>在没有索引的情况下，执行如下 SQL ，查询执行计划：</li></ol><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> profession , <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> profession ;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721100347253-2024-7-2110:03:50.png"alt="image-20240721100347253" /><figcaption aria-hidden="true">image-20240721100347253</figcaption></figure><p>B. 针对于 profession ， age ， status创建一个联合索引后执行相同的SQL，查看执行计划</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建联合索引</span><span class="hljs-keyword">create</span> index idx_user_pro_age_sta <span class="hljs-keyword">on</span> tb_user(profession , age , status);<span class="hljs-comment">--执行上述SQL</span>explain <span class="hljs-keyword">select</span> profession , <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> profession ;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721100608323-2024-7-2110:06:09.png"alt="image-20240721100608323" /><figcaption aria-hidden="true">image-20240721100608323</figcaption></figure><blockquote><p><strong>注：在Group By中使用联合索引也要遵循最左前缀法则</strong></p></blockquote><h3 id="limit优化">4.5、limit优化</h3><p><strong>对应limit分页操作，在大数据的情况下，分页内容越靠后效率越低</strong>。如：limit2000000，10，此时需要MySQL排序前2000010记录，仅仅返回2000000-2000010的记录，其他记录丢弃，查询排序的代价非常大。</p><p>优化策略：<strong>覆盖索引 + 子查询</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--在 tb_sku表中查询 2000000 ~ 2000010范围内的数据</span><span class="hljs-comment">-- 使用覆盖索引，先查询到该范围内记录的id，再将查询到的id作为临时表</span><span class="hljs-keyword">select</span> t.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_sku t, (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">2000000</span>,<span class="hljs-number">10</span>) a<span class="hljs-keyword">where</span> t.id <span class="hljs-operator">=</span> a.id;</code></pre></div><h3 id="count优化">4.6、count优化</h3><div class="code-wrapper"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user ;</code></pre></div><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721102724886-2024-7-2110:27:49.png"alt="image-20240721102724886" /><figcaption aria-hidden="true">image-20240721102724886</figcaption></figure><p>优化思路：<strong>自己计数</strong>，利用key-value内存级别的数据库，如Redis，在其中设置一个字段total保存表中记录数。当在表中新增一条记录时，total加1；当在表中删除一条记录时，total减一。</p><p><strong>常见count的几种用法和其效率的对比：</strong></p><blockquote><p><strong>count（）是一个聚合函数，对于返回的结果集，一行行地判断，如果count 函数的参数不是 NULL，累计值就加1，否则不加，最后返回累计值。</strong></p></blockquote><ul><li><p>count（主键）</p><p>InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加（主键不可能为null）。</p></li><li><p>count（字段）</p><p>没有not null约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。</p><p>有not null 约束：InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</p></li><li><p>count（数字）</p><p>InnoDB引擎遍历整张表，但<strong>不取值</strong>。服务层对于返回的每一行，放一个数字（如0,-1,1等）进去，直接按行进行累加。</p></li><li><p>count（*）</p><p>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，<strong>不取值</strong>，服务层直接按行进行累加。</p></li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721103622142-2024-7-2110:36:26.png"alt="image-20240721103622142" /><figcaption aria-hidden="true">image-20240721103622142</figcaption></figure><h3 id="update优化">4.7、update优化</h3><blockquote><p><strong>InnoDB的行锁是针对<u>索引</u>加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</strong></p></blockquote><p>在执行update语句时要根据索引字段进行选择，否则行锁就会升级为表锁，降低并发性能。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721104513524-2024-7-2110:45:49.png"alt="image-20240721104513524" /><figcaption aria-hidden="true">image-20240721104513524</figcaption></figure><h3 id="总结">总结</h3><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721105139164-2024-7-2110:51:49.png"alt="image-20240721105139164" /><figcaption aria-hidden="true">image-20240721105139164</figcaption></figure><h2 id="五视图存储过程触发器">五、视图/存储过程/触发器</h2><h3 id="视图">5.1、视图</h3><p><ahref="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=97&amp;vd_source=51d78ede0a0127d1839d6abf9204d1ee">参考视频</a></p><p>什么是视图？</p><p>视图：站在不同的角度去看待同一份数据。</p><h4 id="视图创建和删除">视图创建和删除</h4><p>创建视图对象：</p><p><div class="code-wrapper"><pre><code class="hljs mysql">create view dept2_view as select * from dept2;</code></pre></div></p><blockquote><p>注意：</p><p>只有DQL语句才能以view的形式创建。<code>create view view_name as</code> 这里的语句必须是DQL语句;</p></blockquote><p>删除视图对象：</p><div class="code-wrapper"><pre><code class="hljs mysql">drop view dept2_view;</code></pre></div><h4 id="视图的用途">视图的用途</h4><p>方便，简化开发，利于维护。我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）</p><div class="code-wrapper"><pre><code class="hljs mysql">//面向视图查询select * from dept2_view; // 面向视图插入insert into dept2_view(deptno,dname,loc) values(60,&#x27;SALES&#x27;, &#x27;BEIJING&#x27;);// 查询原表数据mysql&gt; select * from dept2;+--------+------------+----------+| DEPTNO | DNAME      | LOC      |+--------+------------+----------+|     10 | ACCOUNTING | NEW YORK ||     20 | RESEARCH   | DALLAS   ||     30 | SALES      | CHICAGO  ||     40 | OPERATIONS | BOSTON   ||     60 | SALES      | BEIJING  |+--------+------------+----------+// 面向视图删除mysql&gt; delete from dept2_view;// 查询原表数据mysql&gt; select * from dept2;Empty set (0.00 sec)</code></pre></div><p>​假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？可以把这条复杂的SQL语句以视图对象的形式新建。在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要修改视图对象所映射的SQL语句。</p><p>​我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。可以对视图进行增删改查等操作。视图不是在内存当中，视图对象也是存储在硬盘上的，不会消失。</p><h3 id="存储过程">5.2、存储过程</h3><p><ahref="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=102&amp;vd_source=51d78ede0a0127d1839d6abf9204d1ee">参考视频</a></p><h3 id="触发器">5.3、触发器</h3><p><ahref="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=116&amp;vd_source=51d78ede0a0127d1839d6abf9204d1ee">参考视频</a></p><h2 id="六锁">六、锁</h2><h3 id="概述">6.1、概述</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM，I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>分类：MySQL中的锁，按照锁的粒度分，分为以下三类：</p><ul><li>全局锁：锁定数据库中的所有表。</li><li>表级锁：每次操作锁住整张表。</li><li>行级锁：每次操作锁住对应的行数据。</li></ul><h3 id="全局锁">6.2、全局锁</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于<strong>只读状态</strong>，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 添加全局锁flush tables with read lock;-- 释放全局锁unlock tables;</code></pre></div><p>其典型的使用场景是<strong>做全库的逻辑备份</strong>，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。其过程如下：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721111958996-2024-7-2111:20:02.png"alt="image-20240721111958996" /><figcaption aria-hidden="true">image-20240721111958996</figcaption></figure><p>注：在终端命令行中运行 mysqldump命令，不要登录了MySQL再用。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721113057150-2024-7-2111:31:35.png"alt="image-20240721113057150" /><figcaption aria-hidden="true">image-20240721113057150</figcaption></figure><h3 id="表级锁">6.3、表级锁</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM，InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为一下三类：</p><ul><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li></ul><h4 id="表锁">表锁</h4><p>​ <imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721183519013-2024-7-2118:35:49.png"alt="image-20240721183519013" /></p><h4 id="元数据锁">元数据锁</h4><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721185606540-2024-7-2118:56:11.png"alt="image-20240721185606540" /><figcaption aria-hidden="true">image-20240721185606540</figcaption></figure><h4 id="意向锁">意向锁</h4><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721191002372-2024-7-2119:10:25.png"alt="image-20240721191002372" /><figcaption aria-hidden="true">image-20240721191002372</figcaption></figure><p><strong>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</strong>添加意向锁后，再添加表锁，直接根据意向锁以及意向锁的类型，判断当前表锁能否添加成功，不用再逐行检查。</p><blockquote><p><strong>意向锁分类以及和表锁的兼容情况</strong></p></blockquote><p><strong>意向锁的分类</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20240721191411802-2024-7-2119:14:12.png" alt="image-20240721191411802"  /></p><p><strong>与表锁的兼容情况</strong></p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721191539971-2024-7-2119:15:49.png"alt="image-20240721191539971" /><figcaption aria-hidden="true">image-20240721191539971</figcaption></figure><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><div class="code-wrapper"><pre><code class="hljs mysql">select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks;</code></pre></div><h3 id="行级锁">6.4、行级锁</h3><p>行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p><strong>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的</strong>锁。对于行级锁，主要分为以下三类：</p><p>1.行锁（RecordLock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</p><p><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721192230333-2024-7-2119:22:49.png"alt="image-20240721192230333" />2.间隙锁（GapLock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。</p><p><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721192259087-2024-7-2119:23:49.png"alt="image-20240721192259087" />3.临键锁（Next-KeyLock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721192315885-2024-7-2119:24:49.png"alt="image-20240721192315885" /><figcaption aria-hidden="true">image-20240721192315885</figcaption></figure><h4 id="行锁">行锁</h4><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721192932330-2024-7-2119:29:49.png"alt="image-20240721192932330" /><figcaption aria-hidden="true">image-20240721192932330</figcaption></figure><p>常见数据库操作语句锁添加的锁的类型：</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240721193132992-2024-7-2119:31:49.png"alt="image-20240721193132992" /><figcaption aria-hidden="true">image-20240721193132992</figcaption></figure><h2 id="七数据库设计三范式">七、数据库设计三范式</h2><p>​数据库设计范式是符合某一种级别的关系模式的集合。设计关系数据库时，遵从不同的规范要求，可以设计出合理的关系型数据库。这些规范要求被称为不同的范式，越高的范式数据库冗余越小。满足这些规范的数据库是简洁的、结构明晰的，同时不会发生插入、删除和更新操作异常。</p><p>数据结构范式的种类：</p><ol type="1"><li><p>‌<strong>第一范式（1NF）</strong>‌：要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。</p><p>第一范式，最核心，最重要的范式，所有表的设计都需要满足</p><div class="code-wrapper"><pre><code class="hljs mysql">学生编号 学生姓名 联系方式------------------------------------------1001张三zs@gmail.com,13599999991002李四ls@gmail.com,136999999991001王五ww@163.net,13488888888以上是学生表，不满足第一范式，第一：没有主键。第二：联系方式可以分为邮箱地址和电话学生编号(pk) 学生姓名邮箱地址联系电话----------------------------------------------------1001张三zs@gmail.com13599999991002李四ls@gmail.com136999999991003王五ww@163.net13488888888</code></pre></div></li><li><p>‌<strong>第二范式（2NF）</strong>‌：在第一范式的基础上，要求表中的所有非主键字段完全依赖于主键。</p><div class="code-wrapper"><pre><code class="hljs mysql">学生编号 学生姓名   教师编号 教师姓名----------------------------------------------------1001张三001王老师1002李四002赵老师1003王五001王老师1001张三002赵老师这张表描述了学生和老师的关系：（1个学生可能有多个老师，1个老师有多个学生),这是非常典型的：多对多关系！以上的表不满足第一范式，应改为学生编号+教师编号(pk)学生姓名  教师姓名----------------------------------------------------1001001张三王老师1002002李四赵老师1003001王五王老师1001002张三赵老师学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号），经过修改之后，以上的表满足了第一范式。但是不满足第二范式，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。产生部分依赖会导致数据冗余，空间浪费。为了让以上的表满足第二范式，需要这样设计  学生表  学生编号(pk)学生名字  ------------------------------------  1001张三  1002李四  1003王五    教师表  教师编号(pk)教师姓名  --------------------------------------  001王老师  002赵老师  学生教师关系表  id(pk)学生编号(fk)教师编号(fk)  ------------------------------------------------------  11001001  21002002  31003001  41001002口诀：多对多，三张表，关系表两个外键</code></pre></div></li><li><p>‌<strong>第三范式（3NF）</strong>‌：在第二范式的基础上，要求表中的每个非主键字段不依赖于其他非主键字段。</p><div class="code-wrapper"><pre><code class="hljs mysql">学生编号（PK） 学生姓名 班级编号  班级名称---------------------------------------------------------  1001张三01一年一班  1002李四02一年二班  1003王五03一年三班  1004赵六03一年三班以上表的设计是描述：班级和学生的关系。很显然是1对多关系，一个教室中有多个学生。以上表满足第一范式，有主键。以上表满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。但是不满足第三范式，第三范式要求：不要产生传递依赖！一年一班依赖01，01依赖1001，产生了传递依赖。不符合第三范式的要求。产生了数据的冗余。那么应该怎么设计一对多呢？  班级表：一  班级编号(pk)班级名称  ----------------------------------------  01一年一班  02一年二班  03一年三班  学生表：多  学生编号（PK） 学生姓名 班级编号(fk)  -------------------------------------------  1001张三01  1002李四02  1003王五03  1004赵六03  口诀：一对多，两张表，多的表加外键</code></pre></div></li><li><p>‌<strong>巴斯-科德范式（BCNF）</strong>‌：进一步减少数据冗余，确保每个决定因素只依赖于主键。</p></li><li><p>‌<strong>第四范式（4NF）</strong>‌：解决多值依赖问题，确保每个决定因素不依赖于其他非主键字段。</p></li><li><p>‌<strong>第五范式（5NF）</strong>‌：又称完美范式，进一步减少数据冗余，确保每个决定因素不依赖于其他非主键字段。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
      <tag>InnoDB存储引擎</tag>
      
      <tag>索引</tag>
      
      <tag>SQL优化</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL（一）</title>
    <link href="/8d742da7/"/>
    <url>/8d742da7/</url>
    
    <content type="html"><![CDATA[<meta name = "referrer", content = "no-referrer"/><h2 id="一数据库">一、数据库</h2><blockquote><p>什么是数据库？什么是数据库管理系统？什么是SQL？他们之间的关系是什么？</p></blockquote><ul><li>数据库：英文单词DataBase，简称DB。按照一定格式存储数据的一些文件的组合。顾名思义：存储数据的仓库，实际上就是一堆文件。这些文件中存储了具有特定格式的数据</li><li>数据库管理系统： DataBaseManagement，简称DBMS。数据库管理系统是专门用来管理数据库中数据的，数据库管理系统可以对数据库当中的数据进行增删改查。</li></ul><p>常见的数据库管理系统： MySQL、Oracle、MSSqlServer、DB2、Sybase等....</p><h3 id="关于sql语句的分类">关于SQL语句的分类</h3><p>DXL（数据库X语言）:其中D代表数据库，X是语言的功能，如定义、管理、查询、控制。</p><ul><li><p>DDL： 数据定义语言 凡是带有create、drop、alter的都是DDL。DDL主要操作的是<strong>表的结构</strong>。不是表中的数据。create：新建，等同于增 drop：删除 alter：修改这个增删改和DML不同，这个主要是对表结构进行操作。</p></li><li><p>DML： 数据操作语言（凡是对表当中的数据进行增删改的都是DML）insert delete update insert 增 delete 删 update 改这个主要是操作<strong>表中的数据</strong>。<br /></p></li><li><p>DQL： 数据查询语言（凡是带有select关键字的都是查询语句）select...</p></li><li><p>DCL： 是数据控制语言。例如：授权grant、撤销权限revoke....</p></li><li><p>TCL： 是事务控制语言 包括： 事务提交：commit;事务回滚：rollback;</p></li></ul><h3 id="操作数据库">操作数据库</h3><p>1、创建数据库</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> school;  <span class="hljs-comment">--IF NOT EXISTS 当不存在该数据库时才创建</span></code></pre></div><p>2、删除数据库</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE IF <span class="hljs-keyword">EXISTS</span> xxxx;  <span class="hljs-comment">--如果存在该数据库则删除</span></code></pre></div><p>3、查看数据库</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES;</code></pre></div><p>4、使用某个数据库</p><div class="code-wrapper"><pre><code class="hljs sql">USE  `xxx`;  <span class="hljs-comment">--如果你的表名或者字段名是一个特殊字符，就需要带``</span></code></pre></div><p>5、查看当前使用的数据库</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> DATABASE();</code></pre></div><p>6、查看数据库下的表</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TABLES;</code></pre></div><h2 id="二数据定义">二、数据定义</h2><h3 id="模式的定义与删除">2.1、模式的定义与删除</h3><p>在MySQL中，模式（schema）是数据库的组织和结构，它定义了数据库的表、视图、存储过程等对象。</p><ul><li><p>模式的定义语句</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE　SCHEM &lt;模式名&gt;AUTHORIZATION &lt;用户名&gt;;</code></pre></div><p>要创建模式需要拥有管理员的权限或者获得了数据库管理员授予的CREATE <ahref="https://so.csdn.net/so/search?q=SCHEMA&amp;spm=1001.2101.3001.7020">SCHEMA</a>的权限。</p></li><li><p>删除模式</p><div class="code-wrapper"><pre><code class="hljs mysql">DROP SCHEMA&lt;模式名&gt;CASCADE |RESTRICT&gt;;</code></pre></div><p>其中<code>CASCADE</code>和<code>RESTRICT</code>两者必选其一。 CASCADE（级联），表示在删除模式的同时把该模式中所有的数据库对象全部删除；RESTRICT（限制），表示如果该模式中已经定义了下属的数据库对象（如表、视图等），则拒绝删除语句的执行，只有当该模式中没有任何下属的对象时才能执行语句。</p></li></ul><h3 id="基本表的定义删除和修改">2.2、基本表的定义、删除和修改</h3><h4 id="定义基本表">定义基本表</h4><p>​ 建表的语法格式：(建表属于DDL语句，DDL包括：create drop alter)</p><div class="code-wrapper"><pre><code class="hljs mysql">create table 表名(字段名1 数据类型, 字段名2 数据类型, 字段名3 数据类型);create table 表名(  字段名1 数据类型,   字段名2 数据类型,   字段名3 数据类型);表名：建议以t_ 或者 tbl_开始，可读性强。见名知意。字段名：见名知意。表名和字段名都属于标识符。</code></pre></div><p>添加主键：在最后一行 添加<code>primary key (字段名)</code></p><p>添加外键</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 创建表时添加： FOREIGN KEY(&lt;列名&gt;)REFERENCES &lt;主表名&gt; (&lt;列名&gt;); -- 修改表添加：ALTER TABLE &lt;数据表名&gt; ADD FOREIGN KEY(&lt;列名&gt;) REFERENCES &lt;主表名&gt; (&lt;列名&gt;);</code></pre></div><p>创建两个基本表 <code>t_student</code>和<code>t_grade</code></p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `t_student` (  `ID` int(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;学号&#x27;,  `NAME` varchar(30) NOT NULL DEFAULT &#x27;匿名&#x27; COMMENT &#x27;姓名&#x27;,  `PWD` varchar(20) NOT NULL DEFAULT &#x27;123456&#x27; COMMENT &#x27;密码&#x27;,  `SEX` varchar(2) NOT NULL DEFAULT &#x27;女&#x27; COMMENT &#x27;性别&#x27;,  `BIRTHDAY` datetime DEFAULT NULL COMMENT &#x27;出生日期&#x27;,  `ADDRESS` varchar(100) DEFAULT NULL COMMENT &#x27;住址&#x27;,  `EMAIL` varchar(50) DEFAULT NULL COMMENT &#x27;邮箱&#x27;,  PRIMARY KEY (`ID`)) ENGINE=InnoDB DEFAULT CHARSET=utf8  CREATE TABLE `t_grade` (`gradeId` INT(4) NOT NULL AUTO_INCREMENT COMMENT &#x27;年级id&#x27;,`gradeName` VARCHAR(50) NOT NULL COMMENT &#x27;年级名称&#x27;,PRIMARY KEY(`gradeId`))ENGINE=INNODB DEFAULT CHARSET=UTF8</code></pre></div><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> DATABASE school; <span class="hljs-comment">--查看数据库定义语句</span><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_student; <span class="hljs-comment">--查看数据表定义语句</span><span class="hljs-keyword">DESC</span> t_student; <span class="hljs-comment">--查看数据表的结构</span></code></pre></div><h5 id="mysql中的数据类型">MySQL中的数据类型</h5><blockquote><p>数值</p></blockquote><table><thead><tr class="header"><th style="text-align: center;">类型</th><th style="text-align: center;">描述</th><th style="text-align: center;">大小</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">tinyint</td><td style="text-align: center;">十分小的数据</td><td style="text-align: center;">1个字节</td></tr><tr class="even"><td style="text-align: center;">smallint</td><td style="text-align: center;">较小的数据</td><td style="text-align: center;">2个字节</td></tr><tr class="odd"><td style="text-align: center;">mediumint</td><td style="text-align: center;">中等大小的数据</td><td style="text-align: center;">3个字节</td></tr><tr class="even"><td style="text-align: center;"><strong>int</strong></td><td style="text-align: center;"><strong>标准的整数</strong></td><td style="text-align: center;"><strong>4个字节</strong></td></tr><tr class="odd"><td style="text-align: center;">bigint</td><td style="text-align: center;">较大的数据</td><td style="text-align: center;">8个字节</td></tr><tr class="even"><td style="text-align: center;">float</td><td style="text-align: center;">浮点数</td><td style="text-align: center;">4个字节</td></tr><tr class="odd"><td style="text-align: center;">double</td><td style="text-align: center;">浮点数</td><td style="text-align: center;">8个字节</td></tr><tr class="even"><td style="text-align: center;">decimal</td><td style="text-align: center;">定点型（字符串形式的浮点数）</td><td style="text-align: center;">精度高</td></tr></tbody></table><blockquote><p>字符串</p></blockquote><table><thead><tr class="header"><th style="text-align: center;">类型</th><th style="text-align: center;">描述</th><th style="text-align: center;">大小</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">char</td><td style="text-align: center;">字符串固定大小</td><td style="text-align: center;">0~255</td></tr><tr class="even"><td style="text-align: center;"><strong>varchar</strong></td><tdstyle="text-align: center;"><strong>可变字符串（相当于String、常用）</strong></td><td style="text-align: center;"><strong>0~65535</strong></td></tr><tr class="odd"><td style="text-align: center;">tinytext</td><td style="text-align: center;">微型文本</td><td style="text-align: center;"><span class="math inline">\(2^8 -1\)</span></td></tr><tr class="even"><td style="text-align: center;"><strong>text</strong></td><td style="text-align: center;"><strong>文本串,保存大文本</strong></td><td style="text-align: center;"><strong><spanclass="math inline">\(2^{16}-1\)</span></strong></td></tr></tbody></table><blockquote><p>时间日期</p></blockquote><table><thead><tr class="header"><th>类型</th><th style="text-align: right;">描述</th></tr></thead><tbody><tr class="odd"><td>date</td><td style="text-align: right;">YYYY-MM-DD，日期格式</td></tr><tr class="even"><td>time</td><td style="text-align: right;">HH：mm：ss,时间格式</td></tr><tr class="odd"><td>year</td><td style="text-align: right;">年份表示</td></tr><tr class="even"><td><strong>datetime</strong></td><td style="text-align: right;"><strong>YYYY-MM-DDHH：mm：ss,最常用的时间格式</strong></td></tr><tr class="odd"><td><strong>timestamp</strong></td><tdstyle="text-align: right;"><strong>时间戳，1970.1.1到现在的毫秒数，唯一</strong></td></tr></tbody></table><blockquote><p>null</p></blockquote><ul><li>没有值</li><li>注意，不要使用NULL进行运算，结果为NULL</li></ul><h5 id="约束">约束</h5><p>什么是约束？ 约束对应的英语单词：constraint。在创建表的时候，可以给表中的字段加上一些约束，来保证这个表中数据的完整性、有效性。</p><p>约束的作用就是为了保证<strong>表中的数据有效</strong>。</p><p>约束包括哪些？</p><p>​ 非空约束：not null</p><p>​ 唯一性约束: unique</p><p>​ 主键约束: primary key （简称PK）</p><p>​ 外键约束：foreign key（简称FK）</p><p>​ 检查约束：check（<strong>mysql不支持</strong>，oracle支持）</p><ul><li><strong>非空约束：not null</strong></li></ul><div class="code-wrapper"><pre><code class="hljs mysql">drop table if exists t_vip;create table t_vip(  id int,  name varchar(255) not null  // not null只有列级约束，没有表级约束！);</code></pre></div><ul><li><strong>唯一性约束: unique</strong></li></ul><blockquote><p>唯一性约束unique约束的字段不能重复，但是可以为NULL。</p></blockquote><div class="code-wrapper"><pre><code class="hljs mysql">drop table if exists t_vip;create table t_vip(  id int,  name varchar(255) unique,  email varchar(255));</code></pre></div><p>如何做到联合唯一约束</p><div class="code-wrapper"><pre><code class="hljs mysql">drop table if exists t_vip;-- name和email两个字段联合起来唯一create table t_vip(  id int,  name varchar(255),  email varchar(255),  unique(name,email) // 约束没有添加在列的后面，这种约束被称为 **表级约束**。);</code></pre></div><ul><li><strong>主键约束: primary key</strong></li></ul><p>主键约束的相关术语？</p><p>​ 主键字段：该字段上添加了主键约束，这样的字段叫做：主键字段</p><p>​主键值：主键字段中的每一个值都叫做：主键值。<strong>主键值是每一行记录的唯一标识。</strong></p><blockquote><p>主键的特征：<strong>not null +unique</strong>（主键值不能是NULL，同时也不能重复！）</p><p>注：在MySQL当中，如果一个字段同时被notnull和unique约束的话，该字段自动变成主键字段。</p></blockquote><p>给一张表添加主键约束</p><div class="code-wrapper"><pre><code class="hljs mysql">drop table if exists t_vip;// 1个字段做主键，叫做：单一主键create table t_vip(  id int primary key,  //列级约束  name varchar(255));</code></pre></div><p>​表级约束主要是给多个字段联合起来添加约束。在实际开发中不建议使用<strong>复合主键</strong>，建议使用<strong>单一主键</strong>。因为主键值存在的意义就是这行记录的身份证号，只要意义达到即可，单一主键可以做到。复合主键比较复杂，不建议使用。</p><div class="code-wrapper"><pre><code class="hljs mysql">drop table if exists t_vip;// id和name联合起来做主键：复合主键！！！！create table t_vip(  id int,  name varchar(255),  email varchar(255),  primary key(id,name));</code></pre></div><p>​主键值建议使用：int、bigint、char等类型。不建议使用：varchar来做主键。主键值一般都是数字，一般都是定长的！</p><p>主键除了：单一主键和复合主键之外，还可以分为：</p><ul><li>自然主键：主键值是一个自然数，和业务没关系。</li><li>业务主键：主键值和业务紧密关联，例如拿银行卡账号做主键值。这就是业务主键！</li></ul><p>​在实际开发中使用自然主键使用比较多，因为主键只要做到不重复就行，不需要有意义。业务主键不好，因为主键一旦和业务挂钩，那么当业务发生变动的时候，可能会影响到主键值，所以业务主键不建议使用。尽量使用自然主键。</p><p>在MySQL当中，可以在主键后添加<code>auto_increment</code>帮助我们自动维护主键值。</p><ul><li><strong>外键约束：foreign key</strong></li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/8ce084247b4b46a1b0e12459e3cc8232-2024-12-823:09:58.png"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure><p><strong>创建外键的两种方式：</strong><strong>方式一</strong>：在创建表的时候进行添加</p><div class="code-wrapper"><pre><code class="hljs mysql">[CONSTRAINT &lt;外键约束名称&gt;] FOREIGN KEY（从表的某个字段) references 主表名(被参考字段)</code></pre></div><p>表一：</p><div class="code-wrapper"><pre><code class="hljs mysql">create table stuInfo(Scode int primary key,   --学生的学号Sname char(10),    --学生的姓名Saddress varchar(50),    --学生的住址Sgrade int,    --学生所在班级Semail varchar(50),    --学生的邮箱地址Sbrith date)DEFAULT CHARSET=&#x27;utf8&#x27;;</code></pre></div><p>表二：</p><div class="code-wrapper"><pre><code class="hljs mysql">create table score(studentIDint,coureseID int,score int,scoreID int primary key,foreignkey(studentID) references stuInfo(Scode)  --添加外键 )DEFAULT charset=&#x27;utf8&#x27;;</code></pre></div><p><strong>方式二</strong>：表已经创建好了，继续修改表的结构来添加外键。</p><div class="code-wrapper"><pre><code class="hljs mysql">ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY(外键字段名)REFERENCES 外表表名(主键字段名)[ON DELETE &#123;RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT&#125;][ON UPDATE &#123;RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT&#125;]</code></pre></div><table><thead><tr class="header"><th style="text-align: left;">参数</th><th style="text-align: left;">意义</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">RESTRICT</td><tdstyle="text-align: left;">限制外表中的外键改动（默认值，也是最安全的设置）</td></tr><tr class="even"><td style="text-align: left;">CASCADE</td><td style="text-align: left;">跟随外键改动</td></tr><tr class="odd"><td style="text-align: left;">SET NULL</td><td style="text-align: left;">设为null值</td></tr><tr class="even"><td style="text-align: left;">NO ACTION</td><td style="text-align: left;">无动作</td></tr><tr class="odd"><td style="text-align: left;">SET DEFAULT</td><td style="text-align: left;">设为默认值</td></tr></tbody></table><div class="code-wrapper"><pre><code class="hljs mysql">alter table stuInfoadd foreign key (scode) references score(studentID);</code></pre></div><ul><li><p>触发限制使用默认值 RESTRICT 的情况下</p><ul><li>从表插入新行，外键值不在主表中，被阻止</li><li>从表修改外键值，新值不是主表的主键值，阻止修改</li><li>主表删除行，其主键值在从表里存在便阻止删除(要想删除，必须先删除从表的相关行)</li><li>主表修改主键值，旧值在从表里存在便阻止修改（要想修改，必须先删除从表的相关行）</li></ul></li><li><p>更改事件触发限制为 CASCADE</p><ul><li>当主表修改主键值，从表中相关行的外键值将一起修改</li><li>如果主表删除行，从表中的相关行将一起被删除</li></ul></li></ul><p><strong>删除外键约束</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">ALTER TABLE 表名 DROP FOREIGN KEY 外键名; ALTER TABLE student_score DROP FOREIGN KEY s_id;</code></pre></div><p>以上的操作都是物理外键，<u>数据库级别的外键</u>，<u><strong>不建议使用</strong></u>！（避免数据库过多造成困扰，了解即可）</p><p><strong>最佳实践</strong>:不使用外键，采用业务逻辑关联的方式，来模拟这种外键</p><ul><li>数据库就是单纯的表，只用来存数据，只有行（数据）和列（字段）</li><li>我们想使用多张表的数据，想使用外键（程序去实现）</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240911151117915-2024-9-1115:12:23.png"alt="image-20240911151117915" /><figcaption aria-hidden="true">image-20240911151117915</figcaption></figure><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20240911151138728-2024-9-1115:12:27.png"alt="image-20240911151138728" /><figcaption aria-hidden="true">image-20240911151138728</figcaption></figure><ul><li><strong>检查约束：check</strong></li></ul><p>MySQL不支持</p><ul><li><strong>默认值约束：default</strong></li></ul><p>给某个字段/某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值</p><h4 id="修改基本表">修改基本表</h4><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">--修改表名：ALTER TABLE 旧表名 RENAME AS 新表名</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `t_teacher` RENAME <span class="hljs-keyword">AS</span>`t_teacher1`;<span class="hljs-comment">--增加表的字段：ALTER TABLE 表名 ADD 字段名 列属性 [约束];</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `t_teacher1` <span class="hljs-keyword">ADD</span> `job` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;职工&#x27;</span>;<span class="hljs-comment">--修改表的字段</span><span class="hljs-comment">--ALTER TABLE 表名 MODIFY 字段名 列属性 [约束];</span><span class="hljs-comment">--ALTER TABLE 表名 CHANGE 字段名 列属性 [约束];</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `t_teacher1` MODIFY age <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">--修改列属性</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `t_teacher1` CHANGE `age` `age1` <span class="hljs-type">INT</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">---列重命名</span><span class="hljs-comment">--删除表的字段：ALTER TABLE 表名 DROP 字段名 [CASCADE|RESTRICT];</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `t_teacher1` <span class="hljs-keyword">DROP</span> `age1` CASCADE;</code></pre></div><h4 id="删除基本表">删除基本表</h4><div class="code-wrapper"><pre><code class="hljs mysql">-- 一般格式drop table&lt;表名&gt;[restrict|cascade]</code></pre></div><ul><li>若选择<u>restrict</u>，则该表的删除是有限制条件的。欲删除的基本表<u>不能被其他的约束所引用（如CHECK，FOREIGNKEY等），不能有视图，不能有触发器，不能有存储过程或函数等</u>。如果存在这些依赖该表的对象，则此表不能被删除</li><li>若选择<u>cascade</u>，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖对象都将一起被删除。</li><li>默认情况时是 restrict。</li></ul><h3 id="索引的建立与删除">2.3、索引的建立与删除</h3><h4 id="建立索引">建立索引</h4><p>语法：</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span>][FULLTEXT] INDEX <span class="hljs-operator">&lt;</span>索引名<span class="hljs-operator">&gt;</span><span class="hljs-keyword">ON</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span> (<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>[<span class="hljs-operator">&lt;</span>次序<span class="hljs-operator">&gt;</span>] [,<span class="hljs-operator">&lt;</span>列名<span class="hljs-operator">&gt;</span>[<span class="hljs-operator">&lt;</span>次序<span class="hljs-operator">&gt;</span>]]...)</code></pre></div><ul><li>索引可以建立在该表的一列或多列上，各列用逗号分隔。每个<列名>后可以使用<次序>指定索引值的排列次序，可选ASC（升序）或DESC（降序），默认为ASC；</li></ul><div class="code-wrapper"><pre><code class="hljs mysql">#为student、course、和sc建立索引。其中Student按学号升序建立唯一索引，course按课程号升序建立唯一索引，sc阿铭学号升序和课程号降序建立唯一索引create unique index Stusno on student(Sno);create unique index Coucno on course(Cno);create unique index SCno on sc(Sno ASC, Cno DESC);</code></pre></div><ul><li><p>表中的主键和具有unique约束的字段会自动添加唯一索引</p></li><li><p>什么时候考虑给字段添加索引？（满足什么条件）</p><ul><li>数据量庞大。（根据客户的需求，根据线上的环境）</li><li>该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护）</li><li>该字段经常出现在where子句中。（经常根据哪个字段查询）</li></ul></li></ul><h4 id="查看索引">查看索引</h4><div class="code-wrapper"><pre><code class="hljs mysql">#查看索引信息SHOW INDEX FROM sc;#查询一个sql语句是否使用索引检索  explain + sql语句,根据type和rows判断explain select * from sc where cno = &#x27;2&#x27;;</code></pre></div><h4 id="删除索引">删除索引</h4><div class="code-wrapper"><pre><code class="hljs mysql">DROP INDEX &lt;索引名&gt; on &lt;表名&gt;</code></pre></div><blockquote><p>更多索引相关内容，见另一篇文章 “MySQL（二）”</p></blockquote><h2 id="三数据查询">三、数据查询</h2><blockquote><p>select语句的一般格式</p></blockquote><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> [<span class="hljs-keyword">ALL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DISTINCT</span>]&#123;<span class="hljs-operator">*</span> <span class="hljs-operator">|</span> table.<span class="hljs-operator">*</span> <span class="hljs-operator">|</span> [ table. field1[ <span class="hljs-keyword">as</span> alias1][, table. field2[ <span class="hljs-keyword">as</span> alias2]][,...]]&#125;<span class="hljs-keyword">FROM</span> table_name [<span class="hljs-keyword">as</span> table_alias][<span class="hljs-keyword">left</span> outr <span class="hljs-operator">|</span> <span class="hljs-keyword">right</span> <span class="hljs-keyword">outer</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> table_name2]  <span class="hljs-comment">--连接查询</span>[<span class="hljs-keyword">WHERE</span> ...] <span class="hljs-comment">--返回结果需满足的条件</span>[<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> ...] <span class="hljs-comment">--返回结果按照哪几个字段来分组</span>[<span class="hljs-keyword">HAVING</span>]  <span class="hljs-comment">--过滤分组的记录必须满足的条件</span>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> ...]  <span class="hljs-comment">--指定查询记录按照一个或多个条件排序</span>[LIMIT &#123;[<span class="hljs-keyword">offset</span>,]row_count  <span class="hljs-operator">|</span> row_countOffset <span class="hljs-keyword">offset</span>&#125;] <span class="hljs-comment">--指定查询的记录从哪几条到哪几条</span><span class="hljs-comment">--注意：[]括号代表可选的，&#123;）括号代表必选得</span></code></pre></div><h3 id="单表查询">3.1、单表查询</h3><h4 id="选择表中的若干列">选择表中的若干列</h4><ul><li><p>查询全部列</p><ul><li><p>第一种方式：可以把每个字段都写上</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> a,b,c,d,e,f... <span class="hljs-keyword">from</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>;</code></pre></div></li><li><p>第二种方式：可以使用 *</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-operator">&lt;</span>表名<span class="hljs-operator">&gt;</span>;</code></pre></div></li></ul></li><li><p>查询指定列</p><ul><li><目标表达式>中的各个列的先后顺序可以和表中的顺序不一致</li><li>可以对<目标表达式>中的列 <u>通过 as起别名</u>（也可以给表起别名）</li></ul></li><li><p>查询经过计算的值</p><ul><li><p>select子句的<目标列表达式>不仅可以是表中的属性列，也可以是<u>表达式，字符串常量，函数</u>等。</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> `StudentName` <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,  <span class="hljs-number">2024</span> <span class="hljs-operator">-</span> DATE_FORMAT(`borndate`,<span class="hljs-string">&#x27;%Y&#x27;</span>) <span class="hljs-keyword">AS</span> <span class="hljs-string">&#x27;年龄&#x27;</span> <span class="hljs-keyword">FROM</span> `student`;</code></pre></div></li><li><p>常见单行处理函数：<strong>注意不要对存在索引的列进行函数运算，会使查询过程中索引失效</strong>。</p><div class="code-wrapper"><pre><code class="hljs mysql">#字符串处理:lower #转换小写mysql&gt; select lower(ename) as ename from emp;upper #转换大写mysql&gt; select upper(name) as name from t_student;substr #取子串（substr(被截取的字符串, 起始下标,截取的长度)）mysql&gt; select substr(ename, 1, 1) as ename from emp;起始下标从1开始concat #函数进行字符串的拼接mysql&gt; select concat(empno,ename) from emp;char_length #包含的字符数mysql&gt; select char_length(ename) enamelength from emp;replace #在原串中，用一个字符串替换指定的串 replace(str,from_str, to_str)mysql&gt; select replace(CName,&#x27;Design&#x27;,&#x27;design&#x27;) from course  where Cno = 7;insert # insert (str, pos, len, newstr)，从pos位置开始，将其后的len个字符，插入为newstrmysql&gt; select insert(CName,4,3,&#x27;*******&#x27;) from course  where Cno = 7;+-----------------------------+| insert(CName,4,3,&#x27;*******&#x27;) |+-----------------------------+| DB_*******ign               |+-----------------------------+reverse #反转字符串mysql&gt; select reverse(&#x27;hello world&#x27;);+------------------------+| reverse(&#x27;hello world&#x27;) |+------------------------+| dlrow olleh            |+------------------------+trim #去空格mysql&gt;select * from emp where ename = trim(&#x27;   KING&#x27;);</code></pre></div><p><div class="code-wrapper"><pre><code class="hljs mysql">#日期相关SELECT CURRENT_DATE（）---获取当前日期SELECT CURDATE（）--获取当前日期SELECT NOW（）--获取当前的时间SELECT LOCALTIME（）--本地时间SELECT SYSDATE（）--系统时间SELECT YEAR（NOW（））SELECT MONTH（NOW（））str_to_date 将字符串转换成日期str_to_date函数可以把字符串varchar转换成日期date类型数据。通常使用在插入insert方面，因为插入的时候需要一个日期类型的数据，语法格式：  str_to_date(&#x27;字符串日期&#x27;, &#x27;日期格式&#x27;)mysql的日期格式：  %Y年  %m    月  %d    日  %h时  %i分  %s秒insert into t_user(id,name,birth) values(1, &#x27;zhangsan&#x27;, str_to_date(&#x27;01-10-1990&#x27;,&#x27;%d-%m-%Y&#x27;));mysql默认的日期格式：&#x27;%Y-%m-%d&#x27;，如果所提供的日期字符串是这个格式，str_to_date函数就不需要了！！！insert into t_user(id,name,birth) values(2, &#x27;lisi&#x27;, &#x27;1990-10-01&#x27;);date_format 格式化日期查询的时候可以使用date_format将日期类型转换成特定格式的字符串展示语法格式：  date_format(日期类型数据, &#x27;日期格式&#x27;)这个函数通常使用在查询日期方面。设置展示的日期格式。  select id,name,date_format(birth, &#x27;%m/%d/%Y&#x27;) as birth from t_user;+------+----------+------------+| id   | name     | birth      |+------+----------+------------+|    1 | zhangsan | 10/01/1990 ||    2 | lisi     | 10/01/1990 |+------+----------+------------+</code></pre></div></p><p><div class="code-wrapper"><pre><code class="hljs mysql">#数学运算select abs(-10)  #绝对值select CEILING(9.4) #向上取整select FLOOR(9.4)#向下取整select SIGN(10)#判断一个数的符号，0返回0，正数返回1，负数返回-1round #四舍五入mysql&gt; select round(1236.567, 0) as result ; //保留整数位。mysql&gt; select round(1236.567, 1) as result ; //保留1个小数mysql&gt; select round(1236.567, 2) as result ; //保留2个小数mysql&gt; select round(1236.567, -1) as result; // 保留到十位。rand() #生成0~1之间的随机数  mysql&gt; select round(rand()*100,0) from emp; // 100以内的随机数</code></pre></div></p></li></ul></li></ul><h4 id="选择表中的若干元组">选择表中的若干元组</h4><ul><li><p>消除重复的行</p><ul><li><p>使用 <u>DISTINCT <列名></u>,消除查询结果中重复的列。</p><div class="code-wrapper"><pre><code class="hljs sql"> <span class="hljs-comment">--studentno，由于同一个学生由于同一个学生有多门考试成绩，得到的studentno有重复</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> `studentno` <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;学号&#x27;</span> <span class="hljs-keyword">FROM</span> `<span class="hljs-keyword">result</span>`</code></pre></div></li><li><p>原表数据不会被修改，只是查询结果去重。如果没有指定DISTINCT关键词，则默认为ALL，即保留结果表中取值重复的行</p></li></ul></li></ul><h4 id="where子句">where子句</h4><p>查询满足条件的元组</p><ul><li><table><thead><tr class="header"><th>查询条件</th><th>谓词</th></tr></thead><tbody><tr class="odd"><td>比较</td><td>=,&lt;,&gt;,&gt;=,&lt;=,!=,&lt;&gt;,!&gt;,!&lt;; NOT+上述比较符</td></tr><tr class="even"><td>确定范围</td><td>between and, not between and</td></tr><tr class="odd"><td>确定集合</td><td>in, not in</td></tr><tr class="even"><td>字符匹配</td><td>like, not like</td></tr><tr class="odd"><td>空值</td><td>is null, is not null</td></tr><tr class="even"><td>多重条件（逻辑运算）</td><td>and, or , not</td></tr></tbody></table></li></ul><p>示例</p><ul><li><p>比较大小</p><p>其中，!=或&lt;&gt;（不等于）、!&gt;（不大于）、!&lt;（不小于）</p></li><li><p>确定范围</p><p><code>between...and...</code>和<code>not between... and...</code></p></li></ul><div class="code-wrapper"><pre><code class="hljs sql">#查询年龄在<span class="hljs-number">20</span><span class="hljs-operator">~</span><span class="hljs-number">30</span>岁之间（包括<span class="hljs-number">20</span>和<span class="hljs-number">30</span>）的学生的姓名，系别和年龄<span class="hljs-keyword">select</span> Sname, Sage, Sdept <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> Sage <span class="hljs-keyword">between</span> <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> <span class="hljs-number">30</span>;<span class="hljs-comment">--------------------------------------------------------------------</span><span class="hljs-operator">+</span><span class="hljs-comment">--------+------+-------+</span><span class="hljs-operator">|</span> Sname  <span class="hljs-operator">|</span> Sage <span class="hljs-operator">|</span> Sdept <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">--------+------+-------+</span><span class="hljs-operator">|</span> 小红   <span class="hljs-operator">|</span>   <span class="hljs-number">20</span> <span class="hljs-operator">|</span> CS    <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">--------+------+-------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre></div><ul><li>确定集合</li></ul><p>谓词IN可以查找属性值属于指定集合的元组,与之对应的是NOTIN。(<u>IN实际上是多个OR运算符的缩写</u>)</p><div class="code-wrapper"><pre><code class="hljs sql">#查询既不是计算机科学系，也不是数学系的学生姓名和性别。<span class="hljs-keyword">select</span> Sname, Ssex <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> Sdept <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;CS&#x27;</span>,<span class="hljs-string">&#x27;MA&#x27;</span>);<span class="hljs-comment">--------------------------------------------------------------------</span><span class="hljs-operator">+</span><span class="hljs-comment">--------+------+</span><span class="hljs-operator">|</span> Sname  <span class="hljs-operator">|</span> Ssex <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">--------+------+</span><span class="hljs-operator">|</span> 小雅   <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">--------+------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre></div><ul><li><p>字符匹配</p><p>谓词LIKE可以用来进行字符串的匹配。</p><ul><li>"%"代表任意长度的字符串。例如a%b，代表以a开头，以b结尾的任意长度的字符串。</li><li>"_"代表任意单个字符。 例如a_b，表示以a开头，以b结尾的长度为3的任意字符串。</li></ul><p>当要查询的字符串中含有特殊字符 %或_时，需要<u>使用<code>\</code>进行转义</u>，将其转变为普通字符。</p></li></ul><div class="code-wrapper"><pre><code class="hljs sql">#查询名字中包含 美的学生的姓名和年龄<span class="hljs-keyword">select</span> Sname, Sage <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> Sname <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%美%&#x27;</span>;<span class="hljs-operator">+</span><span class="hljs-comment">--------+------+</span><span class="hljs-operator">|</span> Sname  <span class="hljs-operator">|</span> Sage <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">--------+------+</span><span class="hljs-operator">|</span> 小美   <span class="hljs-operator">|</span>   <span class="hljs-number">19</span> <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">--------+------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)#查询第二个为亮的学生的姓名和年龄<span class="hljs-keyword">select</span> Sname, Sage <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> Sname <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;_亮%&#x27;</span>;<span class="hljs-operator">+</span><span class="hljs-comment">--------+------+</span><span class="hljs-operator">|</span> Sname  <span class="hljs-operator">|</span> Sage <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">--------+------+</span><span class="hljs-operator">|</span> 小亮   <span class="hljs-operator">|</span>   <span class="hljs-number">18</span> <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">--------+------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec) #查询名字中带有_的学生的信息<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> Sname <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%\_%&#x27;</span>;<span class="hljs-operator">+</span><span class="hljs-comment">-----------+----------+------+------+-------+</span><span class="hljs-operator">|</span> Sno       <span class="hljs-operator">|</span> Sname    <span class="hljs-operator">|</span> Ssex <span class="hljs-operator">|</span> Sage <span class="hljs-operator">|</span> Sdept <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-----------+----------+------+------+-------+</span><span class="hljs-operator">|</span> <span class="hljs-number">201215121</span> <span class="hljs-operator">|</span> 小红_a   <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span>   <span class="hljs-number">20</span> <span class="hljs-operator">|</span> CS    <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-----------+----------+------+------+-------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre></div><ul><li><p>涉及空值的查询</p><div class="code-wrapper"><pre><code class="hljs sql">#查询选了课但没有考试的学生，即选课成绩为<span class="hljs-number">0</span>的学生的信息<span class="hljs-keyword">select</span> Sname, student.Sno <span class="hljs-keyword">from</span> student, sc <span class="hljs-keyword">where</span> sc.Sno <span class="hljs-operator">=</span> student.Sno <span class="hljs-keyword">and</span> sc.Grade <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<span class="hljs-operator">+</span><span class="hljs-comment">--------+-----------+</span><span class="hljs-operator">|</span> Sname  <span class="hljs-operator">|</span> Sno       <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">--------+-----------+</span><span class="hljs-operator">|</span> 小亮   <span class="hljs-operator">|</span> <span class="hljs-number">201215123</span> <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">--------+-----------+</span><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre></div></li><li><p>多重条件查询</p><p>逻辑运算符AND和OR可以用来连接多个查询条件。<strong>AND的优先级高于OR，但可以通过加括号来改变优先级</strong>。</p></li></ul><h4 id="order-by子句">ORDER BY子句</h4><p>​ 用户可可以使用ORDERBY子句<strong>对查询结果</strong>按照<strong>一个或多个</strong>属性列的升序(<strong>ASC</strong>)或降序(<strong>DESC</strong>)排列，<strong>默认为升序</strong>;</p><div class="code-wrapper"><pre><code class="hljs sql">#查询选修了<span class="hljs-number">6</span>号课程的学生的学号,姓名及其成绩，查询结果按分数的降序排列#连结查询<span class="hljs-keyword">select</span> student.Sno, Sname, Grade <span class="hljs-keyword">from</span> student, sc <span class="hljs-keyword">where</span> student.Sno <span class="hljs-operator">=</span> sc.Sno <span class="hljs-keyword">and</span> sc.Cno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;6&#x27;</span><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> Grade <span class="hljs-keyword">DESC</span>;#嵌套查询......<span class="hljs-operator">+</span><span class="hljs-comment">-----------+--------+-------+</span><span class="hljs-operator">|</span> Sno       <span class="hljs-operator">|</span> Sname  <span class="hljs-operator">|</span> Grade <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-----------+--------+-------+</span><span class="hljs-operator">|</span> <span class="hljs-number">201215124</span> <span class="hljs-operator">|</span> 小雅   <span class="hljs-operator">|</span>    <span class="hljs-number">90</span> <span class="hljs-operator">|</span><span class="hljs-operator">|</span> <span class="hljs-number">201215121</span> <span class="hljs-operator">|</span> 小红   <span class="hljs-operator">|</span>    <span class="hljs-number">83</span> <span class="hljs-operator">|</span><span class="hljs-operator">|</span> <span class="hljs-number">201215122</span> <span class="hljs-operator">|</span> 小美   <span class="hljs-operator">|</span>    <span class="hljs-number">83</span> <span class="hljs-operator">|</span><span class="hljs-operator">|</span> <span class="hljs-number">201215123</span> <span class="hljs-operator">|</span> 小亮   <span class="hljs-operator">|</span>  <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-----------+--------+-------+</span><span class="hljs-number">4</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)#可以看出mysql中将空值做最小值处理#按照多个属性排序# 查询全体学生信息，查询结果按所在系号升序排列，同一系中的学生按年龄降序排列mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> student    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> Sdept, Sage <span class="hljs-keyword">DESC</span>;<span class="hljs-operator">+</span><span class="hljs-comment">-----------+--------+------+------+-------+</span><span class="hljs-operator">|</span> Sno       <span class="hljs-operator">|</span> Sname  <span class="hljs-operator">|</span> Ssex <span class="hljs-operator">|</span> Sage <span class="hljs-operator">|</span> Sdept <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-----------+--------+------+------+-------+</span><span class="hljs-operator">|</span> <span class="hljs-number">201215126</span> <span class="hljs-operator">|</span> 张三   <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span>   <span class="hljs-number">21</span> <span class="hljs-operator">|</span> CS    <span class="hljs-operator">|</span><span class="hljs-operator">|</span> <span class="hljs-number">201215121</span> <span class="hljs-operator">|</span> 小红   <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span>   <span class="hljs-number">20</span> <span class="hljs-operator">|</span> CS    <span class="hljs-operator">|</span><span class="hljs-operator">|</span> <span class="hljs-number">201215122</span> <span class="hljs-operator">|</span> 小美   <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span>   <span class="hljs-number">19</span> <span class="hljs-operator">|</span> CS    <span class="hljs-operator">|</span><span class="hljs-operator">|</span> <span class="hljs-number">201215125</span> <span class="hljs-operator">|</span> 小文   <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span>   <span class="hljs-number">20</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">IS</span>    <span class="hljs-operator">|</span><span class="hljs-operator">|</span> <span class="hljs-number">201215124</span> <span class="hljs-operator">|</span> 小雅   <span class="hljs-operator">|</span> 女   <span class="hljs-operator">|</span>   <span class="hljs-number">19</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">IS</span>    <span class="hljs-operator">|</span><span class="hljs-operator">|</span> <span class="hljs-number">201215123</span> <span class="hljs-operator">|</span> 小亮   <span class="hljs-operator">|</span> 男   <span class="hljs-operator">|</span>   <span class="hljs-number">18</span> <span class="hljs-operator">|</span> MA    <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-----------+--------+------+------+-------+</span><span class="hljs-number">6</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)</code></pre></div><h4 id="聚集函数">聚集函数</h4><div class="code-wrapper"><pre><code class="hljs mysql">count# 计数sum# 求和avg# 平均值max# 最大值min# 最小值聚集函数[distinct|all] &lt;列名&gt; 加上distinct在计算时不计入指定列中的重复值</code></pre></div><p><strong>注意：</strong></p><ol start="2" type="1"><li><p>聚集函数中count(*)和count(具体字段)有什么区别？</p><p>count(具体字段)：表示统计该字段下所有不为NULL的元素的总数。</p><p>count(*)：统计表当中的总行数。（只要有一行数据count则++）</p><blockquote><p>因为每一行记录不可能都为NULL，一行数据中有一列不为NULL，则这行数据就是有效的。</p></blockquote></li><li><p><strong>聚集函数不能够直接使用在where子句中。聚集函数只能用于SELECT子句和GROUPBY中的HAVING子句。</strong></p></li><li><p>所有的聚集函数可以组合起来一起用。</p></li></ol><div class="code-wrapper"><pre><code class="hljs sql"># 查询选了课的学生人数 必须加<span class="hljs-keyword">distinct</span><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> Sno) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;选课人数&#x27;</span> <span class="hljs-keyword">from</span> sc;#计算选修了<span class="hljs-number">6</span>号课程的平均成绩<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(Grade) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;平均成绩&#x27;</span> <span class="hljs-keyword">from</span> sc <span class="hljs-keyword">where</span> Cno <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;6&#x27;</span>;#查询学生<span class="hljs-number">201215121</span>选修课的总学分数<span class="hljs-keyword">select</span> <span class="hljs-built_in">sum</span>(Ccredit) <span class="hljs-keyword">as</span> <span class="hljs-string">&#x27;总学分&#x27;</span> <span class="hljs-keyword">from</span> course,sc <span class="hljs-keyword">where</span> sc.Cno <span class="hljs-operator">=</span> course.Cno <span class="hljs-keyword">and</span> sc.Sno <span class="hljs-operator">=</span><span class="hljs-string">&#x27;201215121&#x27;</span>;<span class="hljs-operator">+</span><span class="hljs-comment">-----------+</span><span class="hljs-operator">|</span> 总学分    <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-----------+</span><span class="hljs-operator">|</span>        <span class="hljs-number">13</span> <span class="hljs-operator">|</span><span class="hljs-operator">+</span><span class="hljs-comment">-----------+</span></code></pre></div><h4 id="group-by子句">GROUP BY子句</h4><div class="code-wrapper"><pre><code class="hljs mysql">语法格式：select      ...    from      ...    group by      ...     [having ...]</code></pre></div><ul><li>GROUPBY子句将<strong>查询结果</strong>按某一列或多列的值分组，<strong>值相等的为一组</strong>；</li><li>对查询结构分组的目的是为了<strong>细化聚集函数的作用对象</strong></li><li><strong>如果未对查询结果分组，聚集函数将作用到整个查询结果。分组后聚集函数将作用于每一个组，每个组都有一个聚集函数</strong></li><li><strong>在一条select语句当中，如果有groupby语句的话，select后面只能跟：<u>参加分组的字段，以及聚集函数。其它的一律不能跟。</u></strong></li><li>若要对分组后的结构进行进一步筛选，可以使用<code>HAVING</code>短语指定筛选条件，最终只输出满足指定条件的<strong>组</strong>。</li></ul><div class="code-wrapper"><pre><code class="hljs mysql">#查询各个课程号及其相应的选课人数select Cno, count(Sno) from scgroup by(Cno);#该语句对查询结果按Cno的值分组，所有具有相同Cno的值为一组，然后对每一组作用聚集函数COUNT进行计算，以求得该组的学生人数</code></pre></div><div class="code-wrapper"><pre><code class="hljs mysql">#查询选了三门课以上的学生学号select Sno from sc group by Snohaving count(*) &gt; 3;#查询选了三门课以上的学生学号: 先用GROUP BY子句按 Sno分组，**值相等的为一组**，再用聚集函数COUNT对每一组计数，将总数大于3的组选出来。</code></pre></div><p><strong>WHERE子句和HVING短语的区别</strong></p><ul><li>两者作用的对象不同。WHERE子句作用于<strong>视图或基本表</strong>，从中选择满足条件的元组。HAVING短语作用于<strong>组</strong>，从中选择满足条件的组。</li><li>WHERE子句中不能用聚集函数作为条件表达式，HAVING短语中可以用；HAVING不能单独使用，HAVING必须和groupby联合使用。</li></ul><h3 id="连接查询">3.2、连接查询</h3><blockquote><p>多张表联合起来查询数据，被称为连接查询。</p></blockquote><p>连接查询思路：</p><ol type="1"><li>分析需求，分析查询的字段来自哪些表</li><li>确定使用哪种连接查询，确定交叉点（在两张表中哪个字段是相同的），得到连接的条件</li></ol><p>根据表连接的方式分类：</p><ul><li><p>内连接： 等值连接 非等值连接 自连接</p></li><li><p>外连接：外连接、 左外连接（左连接） 右外连接（右连接）</p></li></ul><h4 id="内连接">内连接</h4><div class="code-wrapper"><pre><code class="hljs mysql">SQL99语法：  select     ...  from    a  inner join    b  on    a和b的连接条件  where    筛选条件# inner可以省略（带着inner可读性更好！！！一眼就能看出来是内连接）</code></pre></div><p>两张表时用inner join连接查询之后生成的笛卡尔积数据中很多数据都是无意义的，我们如何消除无意义的数据呢？--添加进行连接查询的条件</p><ul><li>使⽤where设置过滤条件：先⽣成笛卡尔积再从笛卡尔积中过滤数据（<strong>效率很低</strong>）</li><li>使用 <strong>on</strong>设置两张表连接查询的匹配条件：先判断连接条件是否成⽴，如果成⽴两张表的数据进⾏组合⽣成⼀条结果记录</li></ul><h5 id="等值连接和非等值连接">等值连接和非等值连接</h5><p>​ 当连接运算符为=时，称为等值连。使用其他运算符称为非等值连接。</p><div class="code-wrapper"><pre><code class="hljs mysql">select * from sc inner join student on sc.Sno = student.Sno;#有两个Sno列+-----------+-----+-------+-----------+--------+------+------+-------+| Sno       | Cno | Grade | Sno       | Sname  | Ssex | Sage | Sdept |+-----------+-----+-------+-----------+--------+------+------+-------+| 201215121 | 1   |    92 | 201215121 | 小红   | 女   |   20 | CS    || 201215121 | 2   |    85 | 201215121 | 小红   | 女   |   20 | CS    || 201215121 | 3   |    95 | 201215121 | 小红   | 女   |   20 | CS    || 201215121 | 6   |    83 | 201215121 | 小红   | 女   |   20 | CS    || 201215122 | 2   |    91 | 201215122 | 小美   | 女   |   19 | CS    || 201215122 | 3   |    95 | 201215122 | 小美   | 女   |   19 | CS    || 201215122 | 6   |    83 | 201215122 | 小美   | 女   |   19 | CS    || 201215123 | 6   |  NULL | 201215123 | 小亮   | 男   |   18 | MA    || 201215124 | 6   |    90 | 201215124 | 小雅   | 女   |   19 | IS    |+-----------+-----+-------+-----------+--------+------+------+-------+</code></pre></div><h5 id="自然连接">自然连接</h5><p>​自然连接是一种特殊的等值连接。它要求两个关系中进行比较的分量<strong>必须有同名的属性组</strong>，并且会<strong><u>在结果中把重复的属性列去掉</u>。</strong></p><p>​<strong>自然连接会自动去查找两个表中是否有相同的字段（<u>字段名相同、字段类型也相同</u>，这样的字段可以不止一个，有多少个这样的字段就会生成多少个等值条件），找到后自动完成等值连接。如果连接的表中，没有相同字段，会返回一个空结果。</strong></p><p>​一般的连接操作时从行的角度进行运算，但自然连接还需要取消重复列，所以是同时从行和列的角度进行运算。</p><div class="code-wrapper"><pre><code class="hljs mysql">#此 SQL 语句中没有使用 where 字句 和 on，也没有出现连接符，但是也达到了等值连接的效果。#通过两个表中相同的Sno属性连接，并将结果中重复的Sno去掉select * from sc natural join student;+-----------+-----+-------+--------+------+------+-------+| Sno       | Cno | Grade | Sname  | Ssex | Sage | Sdept |+-----------+-----+-------+--------+------+------+-------+| 201215121 | 1   |    92 | 小红   | 女   |   20 | CS    || 201215121 | 2   |    85 | 小红   | 女   |   20 | CS    || 201215121 | 3   |    95 | 小红   | 女   |   20 | CS    || 201215121 | 6   |    83 | 小红   | 女   |   20 | CS    || 201215122 | 2   |    91 | 小美   | 女   |   19 | CS    || 201215122 | 3   |    95 | 小美   | 女   |   19 | CS    || 201215122 | 6   |    83 | 小美   | 女   |   19 | CS    || 201215123 | 6   |  NULL | 小亮   | 男   |   18 | MA    || 201215124 | 6   |    90 | 小雅   | 女   |   19 | IS    |+-----------+-----+-------+--------+------+------+-------+9 rows in set (0.00 sec)</code></pre></div><h5 id="自连接">自连接</h5><p>自身连接。连接操作不仅可以在两个表之间进行，也可以是一个表与其自己连接。</p><p><strong>核心：一张表拆为两张一样的表，并分别起别名</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">#查询每门课的间接先修课#course表中只有当前课程的直接先修课，需要和另一个course连接查询select c1.Cname as &#x27;课程&#x27;,c2.Cname as &#x27;先修课程&#x27; from course c1 inner join course c2 on c1.Cpno = c2.Cno;+--------------+--------------+| 课程         | 先修课程     |+--------------+--------------+| 数据库       | 数据结构     || 信息系统     | 数据库       || 操作系统     | 数据处理     || 数据结构     | DB_Design    || DB_Design    | 数据处理     |+--------------+--------------+</code></pre></div><h4 id="外连接">外连接</h4><p>​两个关系R和S（两个表）做连接操作时，选择两个关系在公共属性上相等的元组构成新的关系（得到结果表)。</p><p>​在关系R中的某些元组可能在S中不存在公共属性上值相等的元组，关系S中同样也可能存在着这样的元组，从而在操作时将这些元组舍弃了，这些被舍弃的元组称为<u>悬浮元组</u>。</p><p>如果把悬浮元组保存在结果关系中，而在其他属性上填上空值NULL，这种连接就叫<strong>外连接</strong>；</p><p>只保留左边关系R中的悬浮元组就叫做<strong>左外连接</strong></p><p>只保留右边关系S中的悬浮元组就叫做<strong>右外连接</strong></p><p><code>左外连接，以左表为主，会从左表返回所有的元组，即使其中一些元组在右表表没有匹配（这些元组所包含的右表的属性用NULL填充）；右外连接同理。</code></p><p>外连接的查询结果条数一定是 &gt;= 内连接的查询结果条数</p><div class="code-wrapper"><pre><code class="hljs mysql"> select    ... from   aright[left] outer join   b on   a和b的连接条件 where   筛选条件</code></pre></div><h5 id="全外连接">全外连接</h5><p>​ MySql是没有全外连接的(MySql中没有full outerjoin关键字)，想要达到全外连接的效果，可以使用union关键字连接左外连接和右外连接。UNION会自动去除重复行，如果不喜欢去除重复行可以用UNIONALL。</p><h5 id="左外连接">左外连接</h5><p>左外连接以左边的表为主，<strong>左边表的内容都会查出来</strong>，匹配到就组成新的元组，匹配不到就在多出来的属性用NULL填充。</p><div class="code-wrapper"><pre><code class="hljs mysql">#查询每个学生的选课情况及其选课成绩（以student表为主）select student.Sno,Sname,Sdept,Cno,Grade from student  left outer  join sc on student.Sno = sc.Sno;+-----------+--------+-------+------+-------+| Sno       | Sname  | Sdept | Cno  | Grade |+-----------+--------+-------+------+-------+| 201215121 | 小红   | CS    | 1    |    92 || 201215121 | 小红   | CS    | 2    |    85 || 201215121 | 小红   | CS    | 3    |    95 || 201215121 | 小红   | CS    | 6    |    83 || 201215122 | 小美   | CS    | 2    |    91 || 201215122 | 小美   | CS    | 3    |    95 || 201215122 | 小美   | CS    | 6    |    83 || 201215123 | 小亮   | MA    | 6    |  NULL || 201215124 | 小雅   | IS    | 6    |    90 || 201215125 | 小文   | IS    | NULL |  NULL || 201215126 | 张三   | CS    | NULL |  NULL |+-----------+--------+-------+------+-------+#其中小文和张三没有选课，在sc表中没有他们的Sno，所以在左外连接的结果中，他们的选课号和成绩用NULL填充</code></pre></div><h5 id="右外连接">右外连接</h5><div class="code-wrapper"><pre><code class="hljs mysql">#查询已选课的学生的相关信息select student.Sno,Sname,Sdept,Cno,Grade from student  right outer  join sc on student.Sno = sc.Sno;+-----------+--------+-------+-----+-------+| Sno       | Sname  | Sdept | Cno | Grade |+-----------+--------+-------+-----+-------+| 201215121 | 小红   | CS    | 1   |    92 || 201215121 | 小红   | CS    | 2   |    85 || 201215121 | 小红   | CS    | 3   |    95 || 201215121 | 小红   | CS    | 6   |    83 || 201215122 | 小美   | CS    | 2   |    91 || 201215122 | 小美   | CS    | 3   |    95 || 201215122 | 小美   | CS    | 6   |    83 || 201215123 | 小亮   | MA    | 6   |  NULL || 201215124 | 小雅   | IS    | 6   |    90 |+-----------+--------+-------+-----+-------+</code></pre></div><p><strong>多表连接</strong>：一条SQL中内连接和外连接可以混合，都可以出现！可以进行多个表的连接。</p><div class="code-wrapper"><pre><code class="hljs mysql">#查询参加了考试的同学信息：学号、姓名、科目名、分数 （以sc表为主）SELECT sc.Sno, Sname, Cname, GradeFROM sc LEFT OUTER JOIN student sON sc.Sno = s.SnoINNER JOIN course c  #为了获得科目名，再连接course表ON sc.Cno = c.Cno;+-----------+--------+--------------+-------+| Sno       | Sname  | Cname        | Grade |+-----------+--------+--------------+-------+| 201215121 | 小红   | 数据库       |    92 || 201215121 | 小红   | 数学         |    85 || 201215121 | 小红   | 信息系统     |    95 || 201215121 | 小红   | 数据处理     |    83 || 201215122 | 小美   | 数学         |    91 || 201215122 | 小美   | 信息系统     |    95 || 201215122 | 小美   | 数据处理     |    83 || 201215123 | 小亮   | 数据处理     |  NULL || 201215124 | 小雅   | 数据处理     |    90 |+-----------+--------+--------------+-------+</code></pre></div><h3 id="嵌套查询">3.3、嵌套查询</h3><p>​在SQL语言中，一个SELECT-FROM-WHERE语句被称为一个查询块。将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为<strong>嵌套查询</strong>。</p><p>​上层的查询块称为<strong>外层查询或父查询</strong>，下层查询称为<strong>内层查询或子查询</strong>。</p><p>​ <strong>子查询的SELECT不能使用ORDER BY子句，ORDERBY子句只能对最终查询结果排序。</strong></p><h4 id="子查询">子查询</h4><p>子查询都可以出现的位置</p><div class="code-wrapper"><pre><code class="hljs mysql">select   ..(select).from  ..(select).where  ..(select).</code></pre></div><ol type="1"><li>where子句中的子查询:</li></ol><div class="code-wrapper"><pre><code class="hljs mysql">第一步：查询选修6号课程的平均分  select avg(Grade) from sc where Cno = &#x27;6&#x27;;+------------+| avg(Grade) |+------------+|    85.3333 |+------------+1 row in set (0.00 sec)第二步：找出高于平均分的  select * from emp where Grade &gt; avg(Grade);第三步：合并  select student.Sno, Sname ,Sdept, Grade  from sc right join student on sc.Sno = student.Sno  where Grade &gt; (  select avg(Grade) from sc where Cno = &#x27;6&#x27;  );      #执行顺序，先将两张表连接起来，再在其中选出成绩大于平均分的元组，最后使用select选出想要的列。+-----------+--------+-------+-------+| Sno       | Sname  | Sdept | Grade |+-----------+--------+-------+-------+| 201215121 | 小红   | CS    |    92 || 201215121 | 小红   | CS    |    95 || 201215122 | 小美   | CS    |    91 || 201215122 | 小美   | CS    |    95 || 201215124 | 小雅   | IS    |    90 |+-----------+--------+-------+-------+</code></pre></div><ol start="2" type="1"><li>from子句中的子查询: (基于派生表的查询)</li></ol><p>from后面的子查询，可以将子查询的查询结果当做一张<strong>临时表</strong>。每个派生表都必须指定一个别名，在其中可以定义查询出字段的名字</p><div class="code-wrapper"><pre><code class="hljs mysql">-- 找出每个学生超过他自己选修课程平均成绩的课程号和成绩SELECT s_id, c_id, s_score, s1.avg_grade FROM score, (SELECT s_id, AVG(s_score) FROM score GROUP BY s_id) AS s1(avg_s_id, avg_grade) WHERE score.s_id = s1.avg_s_id AND score.s_score &gt;s1.avg_grade;</code></pre></div><h5 id="带有in谓词的子查询">带有IN谓词的子查询</h5><p>在嵌套查询中，子查询的结果往往是一个集合，所以谓词IN是嵌套查询中最经常使用的谓词</p><div class="code-wrapper"><pre><code class="hljs mysql">#查询与小美在同一个系学习的学生#嵌套查询select Sno, Sname, Sdept from student where Sdept in (select Sdept from student where Sname = &#x27;小美&#x27;    );#连接查询#先通过自连接将两个student中系别相同的连接起来，再通过where选出和小美同一个系的,最后通过select得到想要的列select s2.Sno,s2.Sname,s2.Sdept from student s1 inner join student s2 on s1.Sdept = s2.Sdeptwhere s1.Sname = &#x27;小美&#x27;;+-----------+--------+-------+| Sno       | Sname  | Sdept |+-----------+--------+-------+| 201215121 | 小红   | CS    || 201215122 | 小美   | CS    || 201215126 | 张三   | CS    |+-----------+--------+-------+</code></pre></div><div class="code-wrapper"><pre><code class="hljs mysql">#查询选修了课程名为 &quot;信息系统&quot;的学生姓名和学号#嵌套查询select Cno from course where Cname = &#x27;信息系统&#x27;;select Sno from sc where Cno = course.Cnoselect Sno, Sname from student where Sno = sc.Sno===================&gt;select Sno,Snamefrom student where Sno in (select Sno from scwhere Cno in (    select Cno    from course    where Cname = &#x27;信息系统&#x27;)); +-----------+--------+| Sno       | Sname  |+-----------+--------+| 201215121 | 小红   || 201215122 | 小美   |+-----------+--------+#连接查询select student.Sno, student.Sname from studentinner joinsc on sc.Sno = student.Snoinner join courseon sc.Cno = course.Cnowhere course.Cname = &#x27;信息系统&#x27;;select student.Sno, student.Sname from course, student, scwhere student.Sno = sc.Sno andSc.Cno = course.Cno andcourse.Cname = &#x27;信息系统&#x27;;</code></pre></div><p>有些嵌套查询可以用连接运算替代，有的 是不能替代的</p><h5 id="带有比较运算符的子查询">带有比较运算符的子查询</h5><p>父查询和子查询之间使用比较运算符进行连接。</p><p>当知道内存查询返回的是<strong>单个值</strong>时，可以用比较运算符。</p><div class="code-wrapper"><pre><code class="hljs mysql">#找出每个学生超过他自己选修课平均成绩的课程号select Sno, Cno, Gradefrom sc s1where Grade &gt; (select avg(Grade)     from sc s2    where s2.Cno = s1.Cno #查询选课表中，每个学生对应已选课程的平均分);+-----------+-----+-------+| Sno       | Cno | Grade |+-----------+-----+-------+| 201215122 | 2   |    91 || 201215124 | 6   |    90 |+-----------+-----+-------+2 rows in set (0.00 sec)</code></pre></div><p><strong>相关子查询和不相关子查询</strong></p><ul><li>如果子查询的查询条件不依赖于父查询，这类子查询就称为<strong>不相关子查询</strong>。</li><li>如果子查询的查询条件依赖于父查询，这类子查询就称为<strong>相关子查询</strong>。整个查询语句就称为相关嵌套查询语句。如上</li></ul><p>求解相关子查询不能像求解不相关子查询那样一次将子查询求解出来，然后再求解父查询。内存查询由于与外层查询有关，因此必须反复求值。</p><h5 id="带有any或all谓词的子查询">带有ANY或ALL谓词的子查询</h5><p>子查询返回单值时可以用比较运算符，但返回<strong>多值</strong>时要用<strong>ANY</strong>(SOME)或<strong>ALL</strong>谓词修饰符，同时使用比较运算符。</p><div class="code-wrapper"><pre><code class="hljs mysql">#ANY 和 SOME是一样的#ANY ：对于子查询返回的列中的任一数值，只要有一个满足比较条件就为true#ALL ：对于子查询返回的列中的所有值，必须所有值均满足比较条件才为true&gt; ANY大于子查询结果的任一值 （只要比其中某个大就为true）&gt; ALL大于子查询结果的所有值（必须比其中的每个值都大才为true）&lt; ANY&lt; ALL&gt;= ANY&gt;= ALL&lt;= ANY&lt;= ALL= ANY= ALL!= (或 &lt;&gt;) ANY!= (或 &lt;&gt;) ALL</code></pre></div><div class="code-wrapper"><pre><code class="hljs mysql">#查询非计算机科学系中比计算机科学系 任意一个学生年龄小的 学生姓名和年龄select Sname, Sage, Sdeptfrom studentwhere Sdept != &#x27;CS&#x27; and Sage &lt; any (select Sage from student);+--------+------+-------+| Sname  | Sage | Sdept |+--------+------+-------+| 小亮   |   18 | MA    || 小雅   |   19 | IS    || 小文   |   20 | IS    |+--------+------+-------+3 rows in set (0.00 sec)#首先处理子查询，找出CS系中所有学生的年龄，构成一个集合&lt;19,20,21&gt;;然后处理父查询，找出不是CS系其年龄比集合中某个值小的学生。#使用聚集函数实现：找出CS系中年龄的最大值，只要比其小即可。select Sname, Sage, Sdept from studentwhere Sage &lt; (select max(Sage)from student) and Sdept != &#x27;CS&#x27;;#查询非计算机科学系中比计算机科学系 所有学生 年龄都小的学生姓名及年龄。#使用 &lt; all#使用聚集函数  &lt; min(Sage)</code></pre></div><p>事实上，<strong>使用聚集函数实现子查询通常比直接使用ANY或ALL查询效率要高。</strong></p><p>ANY、ALL和聚集函数的对应关系</p><table><thead><tr class="header"><th></th><th>=</th><th>&lt;&gt; 或 !=</th><th>&lt;</th><th>&lt;=</th><th>&gt;</th><th>&gt;=</th></tr></thead><tbody><tr class="odd"><td>ANY</td><td>IN</td><td>--</td><td>&lt; MAX</td><td>&lt;= MAX</td><td>&gt; MIN</td><td>&gt;= MIN</td></tr><tr class="even"><td>ALL</td><td>--</td><td>NOT IN</td><td>&lt; MIN</td><td>&lt;= MIN</td><td>&gt; MAX</td><td>&gt;=MAX</td></tr></tbody></table><p>如：= ANY 等价于IN谓词，&lt; ANY 等价于 &lt; MAX, &lt; ALL 等价于&lt; MIN;</p><h5 id="带有exists谓词的子查询">带有EXISTS谓词的子查询</h5><ul><li><p>EXISTS代表量词 ∃。</p></li><li><p>带有EXISTS谓词的子查询<strong>不返回任何数据</strong>，只产生逻辑真值<strong>true或</strong>逻辑假值<strong>false</strong></p></li><li><p>使用存在量词EXISTS后，<strong>若内存查询结果非空</strong>，则外层的WHERE子句返回真值，否则返回假值</p></li><li><p>由EXISTS引出的子查询，其目标列表达式通常用*****,因为带EXISTS的子查询只返回真值或假值，给出列名无实际意义。</p></li><li><p>与EXISTS对应的是NOT EXISTS。使用存在量词<u>NOTEXISTS</u>后，<strong>若内层查询结果为空</strong>，则外层的WHERE子句返回真值，否则返回假值</p></li></ul><div class="code-wrapper"><pre><code class="hljs mysql">#查询所有选修了2号课程的学生姓名select Snamefrom student swhere exists (select *from scwhere sc.Sno = s.Sno and sc.Cno = &#x27;2&#x27;);+--------+| Sname  |+--------+| 小红   || 小美   |+--------+2 rows in set (0.00 sec)</code></pre></div><p>该<u>相关子查询的执行过程</u>为：</p><ul><li>首先执行一次外层查询，取student表中的第一个元组，缓存结果</li><li>将其带入子查询中作为条件进行查询，根据它与内层查询相关属性（Sno)处理内层查询。</li><li>若子查询有返回结果，则EXISTS子句返回true，将这个元组的Sname放入结果表，否则不放入。</li><li>然后取Student表的下一个元组，重复这一过程直至外层Student表全部检查完为止。</li></ul><p>一些带EXSITS或NOTEXISTS的子查询不能被其他形式的子查询等价替换。<strong>但所有使用IN谓词、比较运算符、ANY和ALL谓词的子查询都能使用带EXISTS谓词的子查询等价替换。</strong></p><div class="code-wrapper"><pre><code class="hljs mysql">#查询与小美在同一个系学习的学生#使用EXISTS替换INselect Sno, Sname, Sdept from student s1where exists (select * from student s2where s2.Sname = &#x27;小美&#x27; and s1.Sdept = s2.Sdept);+-----------+--------+-------+| Sno       | Sname  | Sdept |+-----------+--------+-------+| 201215121 | 小红   | CS    || 201215122 | 小美   | CS    || 201215126 | 张三   | CS    |+-----------+--------+-------+3 rows in set (0.00 sec)</code></pre></div><h3 id="集合查询">3.4、集合查询</h3><h5 id="并操作union">并操作UNION</h5><div class="code-wrapper"><pre><code class="hljs mysql">案例：查询工作岗位是MANAGER和SALESMAN的员工select ename,job from emp where job = &#x27;MANAGER&#x27; or job = &#x27;SALESMAN&#x27;;select ename,job from emp where job in(&#x27;MANAGER&#x27;,&#x27;SALESMAN&#x27;);+--------+----------+| ename  | job      |+--------+----------+| ALLEN  | SALESMAN || WARD   | SALESMAN || JONES  | MANAGER  || MARTIN | SALESMAN || BLAKE  | MANAGER  || CLARK  | MANAGER  || TURNER | SALESMAN |+--------+----------+select ename,job from emp where job = &#x27;MANAGER&#x27;unionselect ename,job from emp where job = &#x27;SALESMAN&#x27;;+--------+----------+| ename  | job      |+--------+----------+| JONES  | MANAGER  || BLAKE  | MANAGER  || CLARK  | MANAGER  || ALLEN  | SALESMAN || WARD   | SALESMAN || MARTIN | SALESMAN || TURNER | SALESMAN |+--------+----------+</code></pre></div><p>​union的效率要高一些。对于表连接来说，每连接一次新表，则匹配的次数满足笛卡尔积，成倍的翻。但是union可以减少匹配的次数。在减少匹配次数的情况下，还可以完成两个结果集的拼接。</p><p>a 连接 b 连接 c，a 10条记录，b 10条记录，c 10条记录。</p><p>匹配次数是：1000，a 连接 b一个结果：10 * 10 --&gt; 100次，a 连接c一个结果：10 * 10 --&gt; 100次。 使用union的话是：100次 + 100次 =200次。（union把乘法变成了加法运算）</p><p>union在使用的时候的注意事项</p><div class="code-wrapper"><pre><code class="hljs mysql">//错误的：union在进行结果集合并的时候，要求两个结果集的列数相同。select ename,job from emp where job = &#x27;MANAGER&#x27;unionselect ename from emp where job = &#x27;SALESMAN&#x27;;// MYSQL可以，oracle语法严格 ，不可以，报错。要求：结果集合并时列和列的数据类型也要一致。select ename,job from emp where job = &#x27;MANAGER&#x27;unionselect ename,sal from emp where job = &#x27;SALESMAN&#x27;;</code></pre></div><h5 id="交操作intersect">交操作INTERSECT</h5><p>​MySQL不支持该操作（但是<code>Inner Join</code>有求两张表交集的功能）</p><h5 id="差操作except">差操作EXCEPT</h5><p>​ MySQL不支持该操作</p><h2 id="四数据更新">四、数据更新</h2><h3 id="插入数据insert">4.1、插入数据insert</h3><p>语法格式：</p><div class="code-wrapper"><pre><code class="hljs mysql">#插入一行insert into 表名(属性列1,属性2,属性列3...)  values(常量1,常量2,常量3);  #其功能是将新元组插入指定 表中，其中新元组的属性列的值为常量1、属性列2的值为常量2.....    #插入多行insert into 表名(属性列1,属性2,属性列3...) values(常量1,常量2,常量3),(常量1,常量2,常量3),....    例：INSERT INTO `t_grade`(`gradeName`) VALUES(&#x27;大三&#x27;),(&#x27;大二&#x27;),(&#x27;大一&#x27;);INSERT INTO `t_student`(`NAME`,`SEX`,`BIRTHDAY`,`ADDRESS`,`EMAIL`)VALUES (&#x27;李四&#x27;,&#x27;男&#x27;,&#x27;2023-03-02&#x27;,&#x27;安徽省合肥市屯溪路193号&#x27;,&#x27;3357625240@qq.com&#x27;),   (&#x27;王五&#x27;,&#x27;男&#x27;,&#x27;2021-04-18&#x27;,&#x27;安徽省合肥市屯溪路193号&#x27;,&#x27;4357625240@qq.com&#x27;);</code></pre></div><p>规则：</p><ul><li>INTO子句中没有出现的属性列，新元组在这些列上取空值。（对应有notnull约束的字段会出错）</li><li>其中属性列的顺序可以和创建表时的顺序不一样</li><li>当只指出表名，没有指出属性名时，默认插入全部属性，且属性和给定值按照创建表时的顺序一一对应。</li></ul><p>补：</p><p><code>str_to_date</code>：将字符串varchar类型转换成date类型，通常使用在插入insert方面，因为插入的时候需要一个日期类型的数据，语法格式：<code>str_to_date('字符串日期', '日期格式')</code>。</p><p><code>date_format</code>：将date类型转换成具有一定格式的varchar字符串类型。</p><div class="code-wrapper"><pre><code class="hljs mysql">mysql的日期格式：  %Y年  %m    月  %d    日  %h时  %i分  %s秒insert into t_user(id,name,birth) values(1, &#x27;zhangsan&#x27;, str_to_date(&#x27;01-10-1990&#x27;,&#x27;%d-%m-%Y&#x27;));mysql默认的日期格式：&#x27;%Y-%m-%d&#x27;，如果所提供的日期字符串是这个格式，str_to_date函数就不需要了！！！insert into t_user(id,name,birth) values(2, &#x27;lisi&#x27;, &#x27;1990-10-01&#x27;);</code></pre></div><p>查询的时候可以使用date_format将日期类型转换成特定格式的字符串展示。</p><p>语法格式：<code>date_format(日期类型数据, '日期格式')</code>，这个函数通常使用在查询日期方面。设置展示的日期格式。</p><div class="code-wrapper"><pre><code class="hljs mysql">select id,name,date_format(birth, &#x27;%m/%d/%Y&#x27;) as birth from t_user;+------+----------+------------+| id   | name     | birth      |+------+----------+------------+|    1 | zhangsan | 10/01/1990 ||    2 | lisi     | 10/01/1990 |+------+----------+------------+</code></pre></div><h3 id="修改update">4.2、修改update</h3><p>语法格式：</p><div class="code-wrapper"><pre><code class="hljs mysql">update 表名 set 字段名1=值1,[字段名2=值2,字段名3=值3... ][where 条件;]</code></pre></div><p>注： 1、没有条件限制会导致所有数据全部更新。2、其中的值可以是一个变量</p><div class="code-wrapper"><pre><code class="hljs mysql">例子:UPDATE `t_student`SET `NAME` =  &#x27;小红&#x27;, `SEX` = &#x27;女&#x27;, `BIRTHDAY` = &#x27;2013-02-01&#x27;WHERE `ID` = 1;UPDATE `t_student`SET  `BIRTHDAY` = CURRENT_DATE  #value是一个变量WHERE `ID` = 5;</code></pre></div><h3 id="删除数据-delete">4.3、删除数据 delete</h3><p>语法格式:</p><div class="code-wrapper"><pre><code class="hljs sql">语法格式？  <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名 [<span class="hljs-keyword">where</span> 条件];注意：没有条件，整张表的数据会全部删除！例：<span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> `t_student` <span class="hljs-keyword">WHERE</span> `id` <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</code></pre></div><blockquote><p>删除表中数据 delete 和 truncate</p></blockquote><p>测试：</p><div class="code-wrapper"><pre><code class="hljs mysql">CREATE TABLE `t_test` (`id` INT(10)  AUTO_INCREMENT PRIMARY KEY,`coll` VARCHAR(20) NOT NULL) ENGINE=INNODB DEFAULT CHARSET=UTF8; INSERT INTO`t_test`(`coll`) VALUES (&#x27;1&#x27;),(&#x27;2&#x27;),(&#x27;3&#x27;); DELETE FROM `t_test`;#不会影响自增字段TRUNCATE TABLE `t_test`;#自增字段归零#区分DROP TABLE `t_test`; #不是删除表中数据，而是删除整个表</code></pre></div><p><code>delete</code>和<code>truncate</code>的区别:</p><ul><li>使用delete删除表，表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放；使用truncate删除表，表被一次截断，物理删除。</li><li>delete删除表，支持回滚；truncate删除表不支持回滚。</li><li>delete删除效率比较低；truncate删除快</li></ul><p>补充：使用delete删除表中数据，重启数据库后</p><ul><li>对于InnoDB，自增列会重1开始（存在内存当中的，断电即失）</li><li>对于MyISAM，继续从上一个自增量开始（存在文件中的，不会丢失）</li></ul><h2 id="五mysql语法补充">五、MySQL语法补充</h2><h3 id="case-when-的语法">5.1、case when 的语法</h3><p><a href="https://www.cnblogs.com/chenduzizhong/p/9590741.html">casewhen语法</a></p><h3 id="分页">5.2、分页</h3><p>语法：<code>limit 查询起始值，页面大小</code></p><p>主要参数</p><ul><li>pageSize :页面大小</li><li>n:当前页</li><li>(n-1)*pageSize:第n页起始值</li><li>数据总数/页面大小 = 总页数</li></ul><p>limit作用：将查询结果集的一部分取出来。通常使用在分页查询当中。分页的作用是为了提高用户的体验，因为一次全部都查出来，用户体验差。</p><p>limit的使用：完整用法：<code>limit startIndex, length</code>，其中startIndex 是起始下标，length是长度。起始下标从0开始。</p><div class="code-wrapper"><pre><code class="hljs mysql">#页面大小pagesize = 5#第一页  limit 0,5;   (1-1)*5#第二页  limit 5,5;(2-1)*5#第三页  limit 10,5;(3-1)*5...#第N页   limit (N-1)*pageSize, pageSize;每页显示3条记录第1页：limit 0,3[0 1 2]第2页：limit 3,3[3 4 5]第3页：limit 6,3[6 7 8]第4页：limit 9,3[9 10 11]每页显示pageSize条记录第pageNo页：limit (pageNo - 1) * pageSize  , pageSize</code></pre></div><p>记公式：<code>limit (pageNo-1)*pageSize , pageSize</code></p><blockquote><p>注意：MySQL当中limit在order by之后执行</p></blockquote><h3 id="md5加密">5.3、MD5加密</h3><p><code>MD5(pwd),使用内置的MD5()函数对数据进行加密</code></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>测试MD5加密 <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `testmd5(`id` <span class="hljs-type">INT</span>（<span class="hljs-number">4</span>）<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,`name` <span class="hljs-type">VARCHAR</span>（<span class="hljs-number">20</span>）<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,`pwd` <span class="hljs-type">VARCHAR</span>（<span class="hljs-number">50</span>）<span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">PRIMARY</span> KEY（`id`）)ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<span class="hljs-comment">--明文密码</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> testmd5 <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;zhangsan&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;lisi&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;wangwu&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>);<span class="hljs-comment">--加密</span><span class="hljs-keyword">UPDATE</span> testmd5 <span class="hljs-keyword">SET</span> pwd<span class="hljs-operator">=</span>MD5(pwd) <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">UPDATE</span> testmd5 <span class="hljs-keyword">SET</span> pwd<span class="hljs-operator">=</span>MD5(pwd)  <span class="hljs-comment">--加密全部的密码</span><span class="hljs-comment">--插入的时候加密</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> testmd5 <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;xiaoming&#x27;</span>,MD5(<span class="hljs-string">&#x27;123456&#x27;</span>));<span class="hljs-comment">--如何校验：将用户传递进来的密码，进行md5加密，然后比对加密后的值</span><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> testmd5 <span class="hljs-keyword">WHERE</span><span class="hljs-string">&#x27;name=&#x27;</span>xiaoming<span class="hljs-string">&#x27;AND pwd=MD5(&#x27;</span><span class="hljs-number">123456</span><span class="hljs-string">&#x27;);</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八、排序</title>
    <link href="/978a1655/"/>
    <url>/978a1655/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="一排序的基本概念">一、排序的基本概念</h2><p>排序：就是重新排列表中元素，使表中的元素满足按关键字有序的过程。</p><blockquote><p>拓扑排序不满足排序的定义，虽然也是在内存中进行的，但不属于内部排序的范畴</p></blockquote><p>​算法的稳定性：待排序表中<strong>关键字相同的元素</strong>，排序后保持原顺序中<strong>相对位置不变</strong>。算法是否具有稳定性并不能衡量一个算法的优劣，它主要是对算法的性质进行描述。</p><p>​在排序过程中，根据数据元素是否完全在内存中，可将排序算法分为两类：内部排序和外部排序</p><p>​一般情况下，内部排序算法执行过程中都有进行两种操作：<strong>比较</strong>和<strong>移动</strong>。并非所有的内部排序算法都要基于比较操作，如基数排序就不基于比较。</p><p>​内部排序算法的性能取决于其时间复杂度和空间复杂度，而<strong>时间复杂度一般是由比较和移动次数决定的</strong></p><blockquote><p>1、对任意n个关键字基于比较的排序，关键字比较次数至少为 <spanclass="math inline">\(\lceil log_2{(n!)} \rceil\)</span></p><p>2、在基于比较的排序方法中，每次比较两个关键字大小之后，仅出现两种可能的转移，因此可以用一棵二叉树来描述比较判定过程，由此可以证明：当文件的n个<u>关键字随机分布时</u>，任何借助“比较”的排序算法，至少需要 <spanclass="math inline">\(O(nlog_2n)\)</span>的时间</p></blockquote><h2 id="二内部排序">二、内部排序</h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241208160558500-2024-12-816:06:01.png" alt="image-20241208160558500" style="zoom:80%;" /></p><h3 id="插入排序">2.1、插入排序</h3><p>​思想：<strong>每次将一个待排序的记录按其关键字的大小插入到前面已经排好序的序列中，直到全部记录插入完成。</strong></p><blockquote><p><strong>插入排序每趟插入元素的位置，不一定是该元素的最终位置。</strong></p></blockquote><h4 id="直接插入排序">直接插入排序</h4><p>​使用<strong>顺序查找</strong>的方式，在前面有序的序列中找到当前记录的插入位置（将大于当前记录的元素都往后移，最后将该记录插入即可）</p><p>适用于<u>顺序表、链表</u></p><p>在直接插入排序过程中，会将待排序序列分为<strong>有序</strong>和<strong>无序</strong>两部分。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230403154509387-2024-12-817:06:51.png" alt="image-20230403154509387" style="zoom: 70%;" /></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><p>时间复杂度：主要来源于关键字对比、移动元素。若有n个元素，则需n-1趟处理。</p><ul><li><p>最好情况：所有元素顺序排列时，n-1趟处理，每趟只需对比关键字1次，不用移动元素。最好时间复杂度为<span class="math inline">\(O(n)\)</span></p></li><li><p>最坏情况：所有元素逆序排列时，n-1趟处理，需 <spanclass="math inline">\(1+2+...+(n-1) =\frac{n(n-1)}{2}\)</span>次比较，<spanclass="math inline">\(3+4+...+(n+1) =\frac{(n-1)(n+4)}{2}\)</span>次移动，故最坏时间复杂度为 <spanclass="math inline">\(O(n^2)\)</span></p></li><li><p>平均时间复杂度：<spanclass="math inline">\(O(n^2)\)</span></p></li></ul><p>算法稳定性：<strong>稳定</strong></p><blockquote><p>在待排序的元素序列<strong>基本有序</strong>的情况下，效率最高的是<u>直接插入排序</u>，但希尔排序比直接插入排序更快</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//直接插入排序</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> i, j, temp;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123; <span class="hljs-comment">//将第一个元素看做已经排好序的子序列，将A[1]~A[n]插入其中</span>        <span class="hljs-keyword">if</span> (A[i] &lt; A[i<span class="hljs-number">-1</span>]) &#123;<span class="hljs-comment">//若A[i]小于前驱，将其插入有序表</span>          temp = A[i];          <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; A[j] &gt; temp; j--) &#123;              A[j + <span class="hljs-number">1</span>] = A[j]; <span class="hljs-comment">//依次后移 </span>          &#125;           A[j + <span class="hljs-number">1</span>] = temp;  <span class="hljs-comment">//最后执行了一次 j--，插入位置应在 j+1。</span>    &#125;            <span class="hljs-comment">// 带哨兵方式</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">//A[0]存放哨兵，记录从A[1]开始</span>        <span class="hljs-keyword">if</span> (A[i] &lt; A[i - <span class="hljs-number">1</span>]) &#123;            A[<span class="hljs-number">0</span>] = A[i]; <span class="hljs-comment">//复制为哨兵</span>            <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; A[j] &gt; A[<span class="hljs-number">0</span>]; j--) &#123;                A[j + <span class="hljs-number">1</span>] = A[j];            &#125;            A[j + <span class="hljs-number">1</span>] = A[<span class="hljs-number">0</span>];        &#125;    &#125;&#125;</code></pre></div><p>补充：单链表的插入排序</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 带头结点的单链表L,将其中元素按递增方式就地排序</span><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">InsertSort</span><span class="hljs-params">(LinkList L)</span> </span>&#123;    <span class="hljs-comment">//q用于遍历有序链表寻找插入位置；pre是q的前驱；p指向要插入的结点，u是临时变量</span>    LinkList p, q, pre, u;    p = L-&gt;next;    L-&gt;next = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;        pre = L;        q = L-&gt;next;        <span class="hljs-comment">//寻找插入位置，最终将p插入在q的前面</span>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">NULL</span> &amp;&amp; q-&gt;data &lt;= p-&gt;data) &#123;            pre = q;            q = q-&gt;next;        &#125;        u = p-&gt;next; <span class="hljs-comment">//保存待比较的下一个结点</span>        pre-&gt;next = p; <span class="hljs-comment">//插入节点</span>        p-&gt;next = q;        p = u; <span class="hljs-comment">//p指向下一个待比较结点</span>    &#125;&#125;</code></pre></div><h4 id="折半插入排序">折半插入排序</h4><p>先用折半查找找到应该插入的位置，再移动元素。</p><p>使用带哨兵的方式：</p><ul><li><p>当 A[mid] = A[<spanclass="math inline">\(0\)</span>]时，为了保证算法稳定性，<u>折半查找不会停止</u>，继续在mid所指位置右边寻找插入位置。</p></li><li><p><u>当low&gt;high时折半查找停止</u>，此时[low, i-1]内的元素都比A[i]大，将[low,i-1]内的元素全部右移，再将A[i]复制到low所指位置。</p></li></ul><p>相比于直接插入排序，<strong>比较关键字的次数减少，但移动元素的次数没变</strong>，整体来看时间复杂度仍是<spanclass="math inline">\(O(n^2)\)</span></p><p>算法稳定性：<strong>稳定</strong></p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertSort</span> <span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-type">int</span> i, j, low, high, mid;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;        <span class="hljs-keyword">if</span> (A[i] &lt; A[i - <span class="hljs-number">1</span>]) &#123;        A[<span class="hljs-number">0</span>] = A[i];        low = <span class="hljs-number">1</span>; high = i - <span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;            mid = (low + high) / <span class="hljs-number">2</span>;            <span class="hljs-keyword">if</span> (A[mid] &gt; A[<span class="hljs-number">0</span>])                high = mid - <span class="hljs-number">1</span>;            <span class="hljs-keyword">else</span>   <span class="hljs-comment">// 在 A[mid] = A[0]和 A[mid] &lt; A[0]时，都在mid右边继续寻找</span>                low = mid + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= low; j--)             A[j + <span class="hljs-number">1</span>] = A[j];        A[low] = A[<span class="hljs-number">0</span>];           &#125;    &#125;&#125;</code></pre></div><h4 id="希尔排序">希尔排序</h4><p>​若初始时待排序序列<strong>已经基本有序</strong>，则直接插入排序也能有很好的执行效率。故先追求表中元素部分有序，再逐渐逼近全局有序。</p><p>​ 思路：先将待排序表分割成若干形如 <spanclass="math inline">\(L[i,i+d,i+2d,...,i+kd]\)</span>的特殊子表，对各个子表分别进行<strong><u>直接插入排序</u></strong>。不断缩小增量<spanclass="math inline">\(d\)</span>的值，直至<spanclass="math inline">\(d=1\)</span>为止。 （推荐：d1 = n/2，此后每次将增量缩小一半）</p><p>​ 空间复杂度：<span class="math inline">\(O(1)\)</span></p><p>​时间复杂度：和增量序列的选择有关，目前无法用数学手段证明确切的时间复杂度。但当d1= 1时，退化为直接插入排序，其最坏时间复杂度为 <spanclass="math inline">\(O(n^2)\)</span>;当n在某个范围内时，可达<spanclass="math inline">\(O(n^{1.3})\)</span></p><p>算法稳定性：<strong>不稳定</strong></p><p>由于要根据增量d随机访问数组元素，故希尔排序<u>只适用于顺序表，不适用于链表</u>。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> i, j, d;<span class="hljs-keyword">for</span> (d = n / <span class="hljs-number">2</span>; d &gt;= <span class="hljs-number">1</span>; d = d / <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">//步长变化</span><span class="hljs-comment">//从当前子表的第二个元素开始处理，即1+d，从下标1开始存放元素</span><span class="hljs-comment">//每次循环结束后 i++，这会切换到另一个子表中继续执行，而不是一次将一个子表处理完再处理下一个子表</span><span class="hljs-comment">// A[0]只是暂存单元，不是哨兵</span><span class="hljs-keyword">for</span> (i = d + <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-keyword">if</span> (A[i] &lt; A[i - d]) &#123; <span class="hljs-comment">//A[i]小于子表中的前驱</span>A[<span class="hljs-number">0</span>] = A[i];<span class="hljs-keyword">for</span> (j = i - d; j &gt; <span class="hljs-number">0</span> &amp;&amp; A[j] &gt; A[<span class="hljs-number">0</span>]; j -= d) &#123;A[j + d] = A[j]; <span class="hljs-comment">//后移步长d个单位</span>&#125;A[j + d] = A[<span class="hljs-number">0</span>];&#125;&#125;&#125;&#125;</code></pre></div><h3 id="交换排序">2.2、交换排序</h3><p>基于“交换”的排序：根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。</p><blockquote><p><strong>交换排序每趟处理将一个元素放到了序列的最终位置。</strong></p></blockquote><h4 id="冒泡排序">冒泡排序</h4><p>​思想：从后往前（或从前往后）两两比较相邻元素的值，若为逆序，则交换它们，直到序列比较完。称这样的过程为一趟冒泡，其结果确定了一个元素在序列中的最终位置。<u>下一趟冒泡时，已经确定位置的元素不再参与比较。</u>若有一趟冒泡没有发生交换，则说明表已经有序。</p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><p>时间复杂度：主要来源于比较、移动元素。</p><ul><li>最好时间复杂度：当元素<strong>顺序排列</strong>时，比较次数 = n -1；交换次数 = <spanclass="math inline">\(0\)</span>，故最好时间复杂度为<spanclass="math inline">\(O(n)\)</span></li><li>最坏时间复杂度：当元素<strong>逆序排列</strong>时，<u>比较次数 =交换次数</u>（调用swap函数次数，不是<strong>移动元素次数</strong>，每次swap移动元素3次）=<span class="math inline">\((n-1)+(n-2)+...+1 =\frac{n(n-1)}{2}\)</span>，故最坏时间复杂度为<spanclass="math inline">\(O(n^2)\)</span></li><li>平均时间复杂度： <span class="math inline">\(O(n^2)\)</span></li></ul><p>算法稳定性：<strong>稳定</strong></p><p><u>适用于顺序表和链表</u></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-type">int</span> i, j;    <span class="hljs-type">bool</span> flag; <span class="hljs-comment">//表示本趟冒泡是否发生交换</span>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        flag = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span> (j = n - <span class="hljs-number">1</span>; j &gt; i; j--) &#123; <span class="hljs-comment">// j &gt; i;表示已经确定位置的元素不再参与比较 </span>            <span class="hljs-keyword">if</span> (A[j] &lt; A[j - <span class="hljs-number">1</span>]) &#123; <span class="hljs-comment">//只有 A[j-1] &gt; A[j]时才交换，所有算法是稳定的</span>                <span class="hljs-built_in">swap</span>(A[j], A[j - <span class="hljs-number">1</span>]);                flag = <span class="hljs-literal">true</span>;            &#125;        &#125;        <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">false</span>)             <span class="hljs-keyword">return</span>;    <span class="hljs-comment">//本趟冒泡没有发生交换，说明表已有序</span>    &#125;&#125;</code></pre></div><h4 id="快速排序">快速排序</h4><p>​ 快速排序的基本思想是基于分治法的</p><p>​ 算法思想：在待排序表 <spanclass="math inline">\(L[1...n]\)</span>中任取一个元素pivot作为枢纽（或基准，通常取首元素），通过一趟排序将待排序表<strong>划分</strong>为独立的两部分<span class="math inline">\(L[1...{k-1}]\)</span>和<spanclass="math inline">\(L[k+1,...,n]\)</span>，使得<spanclass="math inline">\(L[1...{k-1}]\)</span>中元素都比pivot小，<spanclass="math inline">\(L[k+1,...,n]\)</span>中元素都比pivot大，则pivot放在了其最终位置<spanclass="math inline">\(L[k]\)</span>上。这个过程称为一次“划分”。然后递归地对两个子表重复上述过程，直至每部分内只有一个元素或为空为止，即所有元素放在了其最终位置上。</p><p>​由于快排是递归地进行，排序过程类似于树形结构，所以<u>递归的深度和树的高度相同</u>。而n个结点的二叉树最小高度为<span class="math inline">\(\lfloor log_2n\rfloor+1\)</span>，最大高度为n。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230615211549474-2024-12-817:07:10.png"alt="image-20230615211549474" /><figcaption aria-hidden="true">image-20230615211549474</figcaption></figure><p>空间复杂度：<span class="math inline">\(O(递归层数)\)</span></p><ul><li>最好空间复杂度为 <spanclass="math inline">\(O(log_2n)\)</span>，最坏空间复杂度为 <spanclass="math inline">\(O(n)\)</span></li></ul><p>时间复杂度：<span class="math inline">\(O(n*递归层数)\)</span></p><ul><li>最好时间复杂度为 <spanclass="math inline">\(O(nlog_2n)\)</span>：若每次选中的“枢纽”能将待排序列划分为均匀的两部分，则递归深度最小，算法效率最高。</li><li>最坏时间复杂度为 <spanclass="math inline">\(O(n^2)\)</span>：即每次划分的两个部分很不均匀，算法效率最差。当初始序列<strong>有序或逆序</strong>，则快排性能最差（每次选择的都是最靠边的元素）</li><li>平均时间复杂度：<span class="math inline">\(O(nlog_2n)\)</span></li></ul><p>​快排优化思路：快排的关键在于划分，故尽量选择能把数据均分的枢纽元素，如选头、中、尾三个位置元素，取中间值作为枢纽元素；随机选取一个元素作为枢纽等。</p><p>​ 算法稳定性：<strong>不稳定</strong></p><blockquote><p>1、快速排序是所有内部排序算法中平均性能最优的排序算法</p><p>2、在快排中，并不产生有序子序列，但每趟排序后都会将枢纽元素放到其最终位置上。</p><p>3、为减少快排的<strong>递归深度</strong>，<u>应每次优先处理长度较短的那部分</u>。如果按长的优先递归的话，每次都会将短的部分存入栈中，使栈的深度越来越大，直至长的处理完。</p><p>4、快排的<strong>递归次数</strong>与各元素的<u>初始排列顺序有关，与分区处理顺序无关</u>。若每次划分后分区较平衡，则递归次数少；若分区不平衡，则递归次数多。</p><p>5、排序过程中，对尚未确定最终位置的所有元素进行一遍处理称为一"趟"。第一趟，确定一个枢轴的位置，将待排序表分成左右两个子表；第二趟，对左右子表分别进行一次快排，分别确定两个子表枢轴的位置。第二趟如果只对一个子表进行了快排，而未处理另一个子表，就不能算是完整的一趟。<strong>只有当一个枢轴最终位置在边界时，两趟快排只会确定两个元素的最终位置。</strong></p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-type">int</span> pivotPosition = <span class="hljs-built_in">partition</span>(A, low, high); <span class="hljs-comment">//划分</span>        <span class="hljs-comment">//递归地处理两个子表</span>        <span class="hljs-built_in">quickSort</span>(A, low, pivotPosition - <span class="hljs-number">1</span>);        <span class="hljs-built_in">quickSort</span>(A, pivotPosition + <span class="hljs-number">1</span>, high);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;    <span class="hljs-type">int</span> pivot = A[low]; <span class="hljs-comment">//取表中第一个元素做枢纽</span>    <span class="hljs-keyword">while</span> (low &lt; high) &#123;        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot)  high--;        <span class="hljs-comment">//此时 A[high] &lt; pivot，将小的元素放在low位置</span>        A[low] = A[high];        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot)   low++;        <span class="hljs-comment">//此时 A[low] &gt; pivot，大的元素放在high位置</span>        A[high] = A[low];    &#125;    <span class="hljs-comment">//此时low和high指向同一位置，已经将其余元素都扫描了一遍</span>    A[low] = pivot;    <span class="hljs-keyword">return</span> low;&#125;</code></pre></div><h3 id="选择排序">2.3、选择排序</h3><p>思想：每一趟在<u>待排序元素中</u>选取关键字最小的元素加入有序子序列。</p><h4 id="简单选择排序">简单选择排序</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230404152332750-2024-12-817:07:17.png" alt="image-20230404152332750" style="zoom: 60%;" /></p><p>​n个元素的简单选择排序需要n-1趟处理，每趟从后面选择一个最小的元素A[min]和A[i]互换，每一趟可以确定一个元素的最终位置（对比插入排序），经过n-1趟排序就可使得整个排序表有序。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> n)</span> </span>&#123;<span class="hljs-type">int</span> i, j, min_index;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">//进行n-1趟</span><span class="hljs-comment">//for (j = i + 1; j &lt; n; j++)</span><span class="hljs-comment">//if (A[j] &lt; A[i]) &#123;</span><span class="hljs-comment">//swap(A[j], A[i]);</span><span class="hljs-comment">//&#125;</span>        <span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;            <span class="hljs-keyword">if</span> (A[i] &lt; A[j])                <span class="hljs-built_in">swap</span>(A[j],A[i]); <span class="hljs-comment">//这种方法会多做几次交换</span>        &#125;&#125;&#125;</code></pre></div><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p><p>时间复杂度：<spanclass="math inline">\(O(n^2)\)</span>，主要来源于关键字对比次数和移动元素次数。</p><ul><li>每趟处理都要确定一个元素的最终位置，都要交换元素一次，使用swap函数，移动关键字3次，故最多交换元素(n-1)次，移动元素3(n-1)次。元素间的比较次数和序列的初始状态无关，无论有序、逆序还是乱序都需要n-1趟处理，共需对比关键字<spanclass="math inline">\((n-1)+(n-2)+...+1=\frac{(n-1)n}{2}\)</span>次。故时间复杂度为<spanclass="math inline">\(O(n^2)\)</span></li></ul><p>算法稳定性：不稳定</p><p>​ 适用于<u>顺序表和链表</u>。</p><h4 id="堆排序">堆排序</h4><p>堆：若n个关键字序列<spanclass="math inline">\(L[1,...,n]\)</span>满足下面某条特性，则称为堆(Heap)</p><ul><li>若满足 <span class="math inline">\(L[i] \ge L[2i]\)</span>且<spanclass="math inline">\(L[i]\ge L[2i+1]\)</span> <spanclass="math inline">\((1\le i\le n/2)\)</span>，称为大根堆，即根 <spanclass="math inline">\(\ge\)</span>左、右</li><li>若满足 <span class="math inline">\(L[i] \le L[2i]\)</span>且<spanclass="math inline">\(L[i]\le L[2i+1]\)</span> <spanclass="math inline">\((1\le i\le n/2)\)</span>，称为小根堆，即根 <spanclass="math inline">\(\le\)</span>左、右</li></ul><p>​堆，相当于<strong>顺序存储的“完全二叉树”</strong>（<u>逻辑上是一棵完全二叉树，但它不是完全二叉树而是顺序表）。</u>结点i的左孩子是2i，右孩子是2i+1，父节点是<spanclass="math inline">\(\lfloor i/2\rfloor\)</span>。编号<spanclass="math inline">\(\le \lfloorn/2\rfloor\)</span>的都是分支结点。</p><p>​堆排序是选择排序的一种，每次要从待排序列中选取最大或最小的元素。若能将待排序列整合为堆的形式，则<strong>每次只需选择堆顶元素即可</strong>，便于进行选择排序。</p><p>算法思想：以大根堆为例</p><ol type="1"><li>建堆：将初始待排序列组成为大根堆的形式，把所有<strong>非终端结点</strong>（编号<spanclass="math inline">\(i\le \lfloorn/2\rfloor\)</span>）<strong>自底向上</strong>都检查一遍，判断是否满足大根堆的要求：根<spanclass="math inline">\(\ge\)</span>左、右。若不满足，将当前结点与更大的一个孩子互换（<strong>左右孩子相同时，优先换<u>左孩子</u></strong>）。若互换破坏了下一级的堆，则采用相同的方法继续往下调整。（<strong>小元素不断下坠</strong>）</li><li>排序：进行n-1趟选择排序，每一趟将堆顶元素加入有序子序列。将堆顶元素与<strong>待排序序列</strong>中的最后一个元素互换（<u>此时堆顶元素的最终位置已经确定，不再属于待排序序列</u>），并将待排序列再次调整为大根堆（小元素不断下坠）。</li></ol><p>基于<strong>大根堆</strong>的堆排序得到的是<strong>递增序列</strong>，基于小根堆的堆排序得到的是递减序列。</p><p>算法效率分析：</p><ul><li>时间复杂度：<span class="math inline">\(O(nlog_2n)\)</span></li></ul><p>​建堆和排序主要依靠堆调整函数headAdjust，其中一个结点下坠一层，<u>最多</u>比较关键字2次（先左右孩子对比，更大的再和根对比）。若树高为h，某结点在第i层，则最多下坠h-i层，关键字对比最多2(h-i)次。n个结点的完全二叉树树高<span class="math inline">\(h =\lfloorlog_2n\rfloor+1\)</span>，第i层最多有 <spanclass="math inline">\(2^{i-1}\)</span>个结点，且只有[1,h-1]层的结点才需要下坠。故<strong>将整棵树调整为大根堆，关键字比较次数不超过4n，其时间复杂度为</strong><span class="math inline">\(O(n)\)</span></p><p><span class="math display">\[1*2(h-1)+2^1*2(h-2)+...+2^{h-2}*2=\]</span><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230404165743943-2024-12-817:07:31.png" alt="image-20230404165743943" style="zoom: 67%;" /></p><p>​将初始待排元素建堆后，进行n-1趟处理，每趟处理堆顶元素和堆底元素交换后，都需要将<u>根结点</u>进行下坠调整。根结点最多下坠h-1层，每次下坠最多比较两次，故每趟排序时间复杂度不超过<spanclass="math inline">\(O(h)=O(log_2n)\)</span>，共n-1趟，所以总的<strong>时间复杂度为 <spanclass="math inline">\(O(nlog_2n)\)</span></strong></p><p><span class="math inline">\(\therefore\)</span> 堆排序时间复杂度 =<span class="math inline">\(O(n)\)</span> +<spanclass="math inline">\(O(nlog_2n)\)</span> = <spanclass="math inline">\(O(nlog_2n)\)</span></p><ul><li>空间复杂度：<span class="math inline">\(O(1)\)</span></li></ul><p>算法稳定性： <strong>不稳定</strong></p><blockquote><p>1、堆排序适合处理关键字较多的情况（如n&gt;1000）。通<strong>常，取一大堆数据中的k个最大（最小）的元素时，都优先采用堆排序。</strong>例如，在1亿个数中选出前100个最小的数，首先使用一个大小为100的数组，读入前100个数，建立<strong>大根堆</strong>（得到递增的序列--大根堆），而后依次读入余下的数，若大于堆顶元素则舍弃，否则用该数替代堆顶元素并重新调整堆，待数据读取完毕，堆中100个数即为所求。实现见下。</p><p>2、一个小根堆值最大的（大根堆最小的）元素只可能在叶子结点</p><p>3、堆是一个顺序存储的无序表。用于查找时效率很低。想</p></blockquote><p>堆排序</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//将以k为根的子树调整的大根堆</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapAdjust</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> len)</span> </span>&#123;A[<span class="hljs-number">0</span>] = A[k]; <span class="hljs-comment">//A[0]暂存该子树的根节点</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> * k; i &lt;= len; i = i * <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">//i *= 2 直接指向下一轮根节点的左孩子</span><span class="hljs-comment">//比较左右孩子谁大，优先换左孩子；i &lt; len 保证有右孩子</span>        <span class="hljs-keyword">if</span> (i &lt; len &amp;&amp; A[i] &lt; A[i + <span class="hljs-number">1</span>]) i++;<span class="hljs-keyword">if</span> (A[<span class="hljs-number">0</span>] &gt;= A[i]) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//满足大根堆要求</span><span class="hljs-keyword">else</span> &#123;A[k] = A[i];  <span class="hljs-comment">//将更大的孩子与双亲结点互换</span>k = i; <span class="hljs-comment">//修改k值，继续向下判断A[k]放在i位置是否也满足大根堆要求</span>&#125;&#125;<span class="hljs-comment">//k是最终存放A[0]的位置,将A[0]放在k位置满足大根堆要求</span>A[k] = A[<span class="hljs-number">0</span>];&#125;<span class="hljs-comment">//建立大根堆</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bulidMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> len)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--) <span class="hljs-comment">//从第一个非终端结点开始，从后往前调整所有非终端结点</span><span class="hljs-built_in">heapAdjust</span>(A, i, len);&#125;<span class="hljs-comment">//堆排序</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> len)</span> </span>&#123;<span class="hljs-comment">//建堆</span><span class="hljs-built_in">bulidMaxHeap</span>(A, len);<span class="hljs-comment">//进行n-1趟选择排序</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len; i &gt; <span class="hljs-number">1</span>; i--) &#123;<span class="hljs-built_in">swap</span>(A[i], A[<span class="hljs-number">1</span>]); <span class="hljs-comment">//堆顶元素存放在A[1]，和堆底元素互换</span>        <span class="hljs-comment">//重新调整为大根堆，此时调整[1,i-1]内的元素即可，i位置的元素位置已确定</span><span class="hljs-built_in">heapAdjust</span>(A, <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span> ); &#125;&#125;</code></pre></div><p>​补充：<strong>使用最小堆，在N个整数中找出最大的K个数</strong>（N&gt;K）。首先，用前K个数构造容量为K的最小堆。然后将后N-K个数依次与堆顶元素比较，若比堆顶元素大，则替换堆顶元素并调整最小堆结构；若比堆顶元素小，则继续比较下一个元素。最终，最小堆存储的就是最大的K个数，堆顶元素是最大的K个数中最小的一个。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapAdjust</span><span class="hljs-params">(<span class="hljs-type">int</span>* heap, <span class="hljs-type">int</span> beginIndex, <span class="hljs-type">int</span> endIndex)</span> </span>&#123;heap[<span class="hljs-number">0</span>] = heap[beginIndex];<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span> * beginIndex; i &lt;= endIndex; i *= <span class="hljs-number">2</span>) &#123;<span class="hljs-keyword">if</span> (i &lt; endIndex &amp;&amp; heap[i] &gt; heap[i + <span class="hljs-number">1</span>])i++;<span class="hljs-keyword">if</span> (heap[<span class="hljs-number">0</span>] &lt;= heap[i]) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//满足小根堆的定义</span><span class="hljs-keyword">else</span> &#123;heap[beginIndex] = heap[i];beginIndex = i;&#125;&#125;heap[beginIndex] = heap[<span class="hljs-number">0</span>];&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>* heap, <span class="hljs-type">int</span> k)</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--)<span class="hljs-built_in">heapAdjust</span>(heap, i, k);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getMaxK</span><span class="hljs-params">(<span class="hljs-type">int</span>* heap, <span class="hljs-type">int</span> K, <span class="hljs-type">int</span> N)</span> </span>&#123;<span class="hljs-type">int</span> i;<span class="hljs-built_in">buildHeap</span>(heap, K); <span class="hljs-comment">//建立容量为K的小根堆</span><span class="hljs-keyword">for</span> (i = K + <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<span class="hljs-keyword">if</span> (heap[i] &gt; heap[<span class="hljs-number">1</span>]) &#123; heap[<span class="hljs-number">1</span>] = heap[i];<span class="hljs-built_in">heapAdjust</span>(heap, <span class="hljs-number">1</span>, K);&#125;&#125;        cout &lt;&lt; <span class="hljs-string">&quot;最大的K个数如下：&quot;</span> &lt;&lt; endl;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= K; i++) &#123;        cout &lt;&lt; heap[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;    &#125;&#125;</code></pre></div><p><strong>堆的插入和删除</strong></p><ul><li>插入：将新元素放到表尾（堆底），根据大/小根堆的要求，新元素不断上升，直到无法上升为止，时间复杂度为<spanclass="math inline">\(O(log_2n)\)</span>。<ul><li>每次上升调整只需对比关键字1次，<strong>注意最后一次上升时，上升失败，这次比较也要算上。</strong></li></ul></li><li>删除：被删除元素用表尾（堆底）元素替代，根据大/小根堆的要求，替代元素不断下坠，直到无法下坠为止，时间复杂度为<spanclass="math inline">\(O(log_2n)\)</span>。<ul><li>每次下坠调整，可能要对比关键字2次，也可能对比1次（看当前子树有几个孩子）。<strong>注意最后一次下降时，下降失败，这次比较也要算上。</strong></li></ul></li></ul><h3 id="归并排序">2.4、归并排序</h3><p>​归并的含义：将两个或两个以上的<u>有序表</u>组合成一个新的有序表。</p><p>​2路归并：假定待排序表含有n个记录，则可将其视为n个有序子表，每个子表长度为1，然后两两归并，得到<span class="math inline">\(\lceiln/2\rceil\)</span>个长度为2或1的有序表；继续两两归并.....如此重复，直到合并成一个长度为n的有序表为止。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230404183815830-2024-12-817:07:47.png" alt="image-20230404183815830" style="zoom:40%;" /></p><p>​ 归并过程类似一棵倒立的二叉树，称为2路归并的归并树</p><p>​其核心操作是把数组内两个<strong>相邻的有序表</strong>合并为一个。设有两段有序表A[low...mid]和A[mid+1...high],放在同一顺序表的相邻位置，先将他们复制到辅助数组B中。每次从B中的两个段中取出一个记录进行关键字的比较，将较小的放入A中。当数组B中有一段的下标超出其对应的表长（即该段所有元素都已复制到A中）时，将另一段的剩余部分直接复制到A中。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230404184021817-2024-12-817:07:52.png" alt="image-20230404184021817" style="zoom:40%;" /></p><p>时间复杂度：<span class="math inline">\(O(nlog_2n)\)</span></p><p>​对于二路归并的归并树，所有待排序元素在第h层，总共进行h-1趟排序。二叉树的第h层有<spanclass="math inline">\(2^{h-1}\)</span>个结点，故 <spanclass="math inline">\(n \le 2^{h-1}\)</span>，<spanclass="math inline">\(h-1=\lceil log_2n\rceil\)</span>，所以归并趟数为<span class="math inline">\(\lceil log_2n\rceil\)</span>。每趟归并时间复杂度为 <spanclass="math inline">\(O(n)\)</span>,则算法时间复杂度为 <spanclass="math inline">\(O(nlog_2n)\)</span></p><blockquote><p>n个元素进行 k路归并排序时，归并趟数 = <spanclass="math inline">\(\lceil log_kn\rceil\)</span></p><p>一个有序表有m个元素，另一个有序表有n个元素，<strong>n&gt;m</strong>，将两个有序表合并成一个有序表，最少比较m次，最多比较n+m-1次。</p><p>时间复杂度为<spanclass="math inline">\(O(log_2n)\)</span>且稳定的排序算法是归并排序算法</p></blockquote><p>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，主要来自于辅助数组B，递归栈的空间不超出<spanclass="math inline">\(O(h)\)</span></p><p>算法稳定性：<strong>稳定</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//归并左右相邻的两个有序表</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span> </span>&#123;    <span class="hljs-type">int</span>* B = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n]; <span class="hljs-comment">//  int *B = (int *)malloc(sizeof(int)*n);</span>    <span class="hljs-type">int</span> i, j, k;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;  <span class="hljs-comment">//将A中的所有元素复制到B中</span>        B[i] = A[i];    &#125;    i = low, j = mid + <span class="hljs-number">1</span>, k = i;    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;        <span class="hljs-comment">//比较B的左右两段中的元素，将较小的复制到A中</span>        <span class="hljs-keyword">if</span> (B[i] &lt;= B[j]) <span class="hljs-comment">//两个值相等时，优先让左边的归并，保证算法的稳定性</span>            A[k++] = B[i++];        <span class="hljs-keyword">else</span>            A[k++] = B[j++];       &#125;    <span class="hljs-keyword">while</span> (i &lt;= mid) A[k++] = B[i++]; <span class="hljs-comment">//若第一个表未检测完，复制</span>    <span class="hljs-keyword">while</span> (j &lt;= high) A[k++] = B[j++];<span class="hljs-comment">//若第二个表未检测完，复制</span>&#125;<span class="hljs-comment">//归并排序</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">mergeSort</span>(A, low, mid);       <span class="hljs-comment">//对左侧子序列进行递归排序</span>        <span class="hljs-built_in">mergeSort</span>(A, mid + <span class="hljs-number">1</span>, high);  <span class="hljs-comment">//对右侧子序列进行递归排序</span>        <span class="hljs-built_in">merge</span>(A, low, mid, high); <span class="hljs-comment">//归并</span>    &#125;&#125;</code></pre></div><h3 id="基数排序">2.5、基数排序</h3><p>​基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。为实现多关键字排序，通常有两种方法：<u>最高位优先法</u>和<u>最低位优先法</u>。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230404213454918-2024-12-817:07:59.png" alt="image-20230404213454918" style="zoom: 67%;" /></p><p><strong>由于要得到递减的序列，先从权重高的队列开始收集；要得到递增的序列，则需从权重低的队列开始收集。只是<u>收集时</u>顺序不同而已</strong></p><p>​ 例如：初始序列是有n = 11个结点的线性表，每个结点的关键字可以分为 d =3元组，分别表示个、十、百位，该元组中每个关键字 <spanclass="math inline">\(\in[0,r-1]\)</span> ,基数r =10。(有n个关键字，把每个关键字拆成d部分，每部分取得r个值)</p><p>得到递减序列的过程如下：</p><p>第一趟：按个位进行分配收集，得到按个位递减排序的序列。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230615211642124-2024-12-816:49:28.png"alt="image-20230615211642124" /><figcaption aria-hidden="true">image-20230615211642124</figcaption></figure><p>第二趟：按十位进行分配收集，得到按“十位”递减排序的序列，“十位”相同的按“个位”递减排序</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230615211710210-2024-12-816:48:28.png"alt="image-20230615211710210" /><figcaption aria-hidden="true">image-20230615211710210</figcaption></figure><p>第三趟：第三趟按“百位”分配、收集：得到一个按“百位”递减排列的序列，若“百位”相同则按“十位”递减排列，若“十位”还相同则按“个位”递减排列。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230615211733092-2024-12-816:50:28.png"alt="image-20230615211733092" /><figcaption aria-hidden="true">image-20230615211733092</figcaption></figure><p>算法性能分析：</p><ul><li><p>空间复杂度：需要r个辅助队列，空间复杂度= <spanclass="math inline">\(O(r)\)</span></p></li><li><p>空间复杂度：<span class="math inline">\(O(d(n+r))\)</span></p><p>一趟分配时间复杂度为<spanclass="math inline">\(O(n)\)</span>，一趟收集时间复杂度为<spanclass="math inline">\(O(r)\)</span>，总共d趟分配、收集。收集每个队列时，只需让链表最后一个结点的next指向队列的对头即可，时间开销为<spanclass="math inline">\(O(1)\)</span>，共要收集r个队列，所以一趟收集的时间复杂度为<spanclass="math inline">\(O(r)\)</span></p></li></ul><p>算法稳定性：稳定（基你太稳）</p><p>基数排序通常基于<strong>链式</strong>存储实现。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230404215549092-2024-12-817:08:26.png" alt="image-20230404215549092" style="zoom: 67%;" /></p><p>​在该例中，每个关键字可以被拆成三部分：年、月、日，并且每部分的基数并不相同，每一趟分配收集时设置的辅助队列也不同。使用基数排序处理该问题，比其他内部排序的效率都要高。</p><p>适合用基数排序处理的情况：</p><ul><li>数据元素的关键字可以方便的拆分为的组，且d较小。</li><li>每组关键字的取值范围不大，即r较小。</li><li>数据元素个数n较大。</li></ul><h3 id="各种内部排序算法的比较">2.6、各种内部排序算法的比较</h3><p>基于三个因素进行对比：时间复杂度、空间复杂度、算法的过程特征</p><ul><li>时间复杂度和空间复杂度</li></ul><table style="width:100%;"><thead><tr class="header"><th>排序方法</th><th></th><th>时间复杂度</th><th></th><th>空间复杂度</th><th>稳定性</th><th>实现</th></tr></thead><tbody><tr class="odd"><td></td><td>最好情况</td><td>平均情况</td><td>最坏情况</td><td>平均情况</td><td></td><td></td></tr><tr class="even"><td>直接插入排序</td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>稳定</td><td>顺序表、 链表</td></tr><tr class="odd"><td>希尔排序</td><td></td><td></td><td></td><td><span class="math inline">\(O(1)\)</span></td><td>不稳定</td><td>顺序表</td></tr><tr class="even"><td>冒泡排序</td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>稳定</td><td>顺序表、链表</td></tr><tr class="odd"><td>快速排序</td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(log_2n)\)</span> 最坏<spanclass="math inline">\(O(n)\)</span></td><td>不稳定</td><td>顺序表</td></tr><tr class="even"><td>简单选择排序</td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>不稳定</td><td>顺序表、链表</td></tr><tr class="odd"><td>堆排序</td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>不稳定</td><td>顺序表</td></tr><tr class="even"><td>2路归并排序</td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(n)\)</span></td><td>稳定</td><td>顺序表、链表</td></tr><tr class="odd"><td>基数排序</td><td><span class="math inline">\(O(d(n+r))\)</span></td><td><span class="math inline">\(O(d(n+r))\)</span></td><td><span class="math inline">\(O(d(n+r))\)</span></td><td><span class="math inline">\(O(r)\)</span></td><td>稳定</td><td>链表</td></tr></tbody></table><p>算法过程特征</p><ul><li><p>选择、交换排序每趟都可以确定一个元素的最终位置，但插入、归并、基数排序不行。故给出一趟排序后的结果，观察这趟排序有没有确定某个元素的最终位置，从而判断是否为选择和交换排序。</p></li><li><p>给出某种算法两趟排序后的结果：插入排序（直接和折半）2趟排序后前三个元素有序；选择排序和冒泡排序2趟排序后，最值和次值的最终位置已经确定；快速排序2趟排序后，产生两个（有一个枢轴最终位置在边界）或三个分界线，界内可以无序，但界间有序（可以和最终序列对比找到这些界）</p></li><li><p>排序趟数与初始状态<strong>有关</strong>的：交换类排序（冒泡、快排）</p></li><li><p>元素总比较次数与初始状态无关的：选择排序、基数排序</p></li><li><p>元素总移动次数与初始状态无关的：归并排序、基数排序</p></li></ul><h2 id="三外部排序">三、外部排序</h2><p>​外部排序是指待排序文件较大，内存中放不下，需存放在外存的文件的排序。</p><p>​文件通常是按块存储在磁盘上的，操作系统也是按块对磁盘上的信息进行读写的。外部排序通常采用归并排序法，包括两个过程：</p><ol type="1"><li><p>生成初始归并段</p><p>根据内存缓冲区的大小，将外存中的文件块读入内存并利用内部排序算法对其进行排序，并将排序后得到的有序块重新写回外存，得到初始归并段。</p></li><li><p>对归并段进行归并排序</p><p>对这些归并段进行逐趟归并排序，使归并段由小到大，直至整个文件有序为止。</p></li></ol><p>​ 所以，外部排序的时间 = <u>内部排序的时间</u>（过程1所需） +<u>外存信息读写时间 + 内部归并所需时间</u>（过程2所需）。</p><p>​外存信息的读写时间和读写磁盘的次数成正比，远远大于内部排序和内部归并的时间，因此应着力减少磁盘读写次数。</p><p>​ 若文件有m个块，则总的读写次数 = 2m + 2m * 归并趟数。<strong>只能通过<u>减少归并趟数</u>来优化外部排序。</strong></p><p>如何减少归并趟数？</p><p>​对r个初始归并段做k路归并，则归并树可以用k叉树表示。因为各归并段处于叶结点位置，若树高为h，则归并趟数=h-1=<strong><span class="math inline">\(\lceillog_kr\rceil\)</span></strong>。故可<strong>通过增大归并路数k，减少归并段数量r</strong>来减少归并趟数。</p><ul><li>增大归并路数k。k不能太大，k路归并需要在内存中开辟k个输入缓冲区，内存开销增大；同时每条选一个最小的关键字需要k-1次对比，内部归并开销增大（<strong>可通过败者树解决</strong>）。</li><li>减少归并段数量r。生成初始归并段的工作区越大，初始归并段越长，归并段数量越少。但会增加内存开销（<strong>可通过置换选择排序解决</strong>）。</li></ul><p>​补：k路平衡归并：1、最多只能有k个归并段归并为一个。2、每趟归并中，若有m个归并段参与归并，则经过这趟处理得到<spanclass="math inline">\(\lceil\frac{m}{k}\rceil\)</span>个新的归并段。如图，在这个4路归并排序中，第一趟排序有8个归并段参与，最后生成了3个新的归并段，故不是4路平衡归并排序。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230408222741513-2024-12-817:08:38.png" alt="image-20230408222741513" style="zoom: 40%;" /></p><p><strong>败者树</strong></p><p>​败者树是树形选择排序的一种变体，可视为一棵完全二叉树。k个叶结点分别存放k个归并段在归并过程中当前参加比较的记录，内部节点用来记忆左右子树中的失败者（只保存其所在归并段的编号），而让胜者往上继续比较，一直到根结点。若比较两个数，大的为失败者，小的为胜者，则根结点指向的数为最小数。</p><p>其中，这些叶子结点是虚拟的，只用长度为5的数组保存败者树中失败者和冠军的编号。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230408214935590-2024-12-817:08:41.png" alt="image-20230408214935590" style="zoom:67%;" /><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230408215030596-2024-12-817:19:51.png" alt="image-20230408215030596" style="zoom:50%;" /></p><p>​第一次生成败者树后，从冠军处得到最小元素是3号归并段当前参与比较的元素6。选择下一个最小元素时，从3号归并段选取下一个元素参与比较，一直比到根结点为止，选出下一个冠军，即最小的元素。依次进行下去完成这趟归并。</p><p>对于k路归并，第一次构造败者树需要对比关键字k-1次。有了败者树，选出最小的元素只需<spanclass="math inline">\(\lceil log_2k\rceil\)</span>次。</p><p>​ 使用败者树后，每次选择一个最小元素的比较次数为败者树树高<spanclass="math inline">\(\lceillog_2k\rceil\)</span>，每趟归并n个元素需要做<spanclass="math inline">\((n-1)\lceillog_2k\rceil\)</span>对比，则总的比较次数为 <spanclass="math inline">\(\lceil log_kr\rceil (n-1)\lceil log_2k\rceil =(n-1) \lceil log_2r \rceil\)</span>。</p><p>​可见，使用败者树后，<u>内部归并的比较次数</u>与k无关了。但外部排序的效率仍与k有关，k并不是越大越好。</p><p><strong>置换选择排序</strong></p><p>​输入文件FI，输出文件FO，工作区WA，WA可容纳w个记录，算法步骤如下：</p><ol type="1"><li><p>从FI中读取w个元素到工作区WA中</p></li><li><p>从WA中选取关键字最小的记录k，即为 MiniMax = k</p></li><li><p>将MiniMax输入到FO中</p></li><li><p>若FI不空，则从FI中读取下一个记录到WA中</p></li><li><p>从WA中 大于MiniMax的元素中 选取最小的，记为新的MiniMax</p></li><li><p>重复3~5，直到在WA中找不出新的MiniMax为止，由此得到一个初始归并段。</p></li><li><p>重复 2~6，直到WA为空，由此得到全部的初始归并段。</p><p>通过置换选择排序得到的初始归并段的长度不是等长的，其平均长度为传统归并段长度的2倍，从而减少初始归并段数量。</p></li></ol><p><strong>最佳归并树</strong></p><p>​文件经过置换选择排序后，得到的是长度不等的初始归并段，如何对长度不等的初始归并段进行归并排序，使得I/O次数最少？</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230408223526244-2024-12-817:08:49.png" alt="image-20230408223526244" style="zoom:67%;" /></p><p>​对r个初始归并段进行k路平衡归并后得到一棵k路归并树（如图），以归并段的长度表示该结点的权值，树的带权路径长度WPL = <spanclass="math inline">\(2*1+（5+1+6+2）*3 = 44\)</span> = 读磁盘的次数 =写磁盘的次数。</p><p>​ 故，<strong>归并过程中磁盘I/O次数 = 归并树WPL *2</strong>。要让磁盘I/O次数最少，就要让归并树WPL最小。将<strong>哈夫曼树</strong>的思想推广到k叉树，在归并树中，让记录数少的初始归并段最先归并，记录数多的初始归并段最晚归并，就可以建立总的I/O次数最少的最佳归并树。</p><p>​对k叉归并，若初始归并段不足以构成严格k叉归并树，需添加一些<strong>长度为<spanclass="math inline">\(0\)</span></strong>的“虚段”，再进行k叉哈夫曼树的构造。对严格k叉树，只有度为<spanclass="math inline">\(0\)</span>和度为k的结点，由总结点数 = <spanclass="math inline">\(n_0 + n_k = k *n_k + 1\)</span> , 故 <spanclass="math inline">\(n_k = \frac{n_0-1}{k-1}\)</span>是一个整数。</p><ul><li>若 <span class="math inline">\((n_0 - 1) \% (k-1) =0\)</span>，则可以构成严格k叉树，不需要添加虚段</li><li>若 <span class="math inline">\((n_0 - 1) \% (k-1) =u\)</span>，则不能构成严格k叉树，需要添加 <spanclass="math inline">\((k-1) - u\)</span>个长度为<spanclass="math inline">\(0\)</span>的虚段。</li></ul><h2 id="四补充索引">四、补充：索引</h2><h3 id="索引">4.1、索引</h3><p>索引、索引项：一般将某个字段设置为索引，索引是将关键码与他对应的记录相关联的过程，一个索引隶属于某一文件，它由若干索引项构成；每一个索引项至少包含关键码、和关键码对应的记录在存储器中的位置等信息。</p><p>​索引并不需要重新排列记录在文件中的顺序，一个文件可能由多个相关的索引，每个索引往往支持一个关键码，并且通过改索引实现对文件中记录的快速访问。</p><p>特点简介：</p><p>索引文件比数据文件小，可以有效地装载到内存。通过对内存索引文件的查找定位到记录，然后通过一次磁盘对象读取操作就可以获取到需要搜索的对象。</p><p>静态索引：是指在文件创建时生成索引结构，一旦生成就固定下来，只有当文件在组织是才发生变化；动态索引：是指文件创建时生成的索引结构，在文件执行插入、删除等操作时，索引结构本身随之发生变化；</p><h3 id="静态索引结构">4.2、静态索引结构</h3><p>1）线性索引 （主键索引）（索引数组存储）</p><ul><li><p>稠密索引：</p><p><strong>一个索引项对应数据表中的一个对象</strong>。当对象在外存中按添加的顺序而不是按关键码有序存放的时候必须采用稠密索引。</p></li><li><p>稀疏索引（索引顺序结构、分块查找）：</p><p>数据对象在外存中按关键码（主键）分块有序存放，每个子块中的对象可以是有序，也可以是无序。（<strong>块间有序，块内有序或无序</strong>）有序的话子块中可以使用折半查找，提高查找速度，但是添加记录也会慢些。对索引顺序结构进行查找时，根据关键码先在索引中定位对象所在的数据子块，然后在子块中定位查找的对象。</p></li></ul><p>2）倒排表</p><p>​在许多情况下，在对文件进行查找时，不仅需要对主关键码进行查找，还可能需要对<strong>次关键码</strong>进行查找，如果索引表中只有主关键码索引，则对这样的查找，还需建立一系列的次关键码索引。</p><p>​主键索引能唯一地标识对象，也叫主索引。主键只有一个，日常应用中也需要对其它熟悉列进行搜索，所以，除了主关键码外，也有必要把其它常用的搜索属性设定为<strong>次关键码</strong>，建立次索引表。次索引列因为属性值不是唯一的，所以在次索引中，建立一个所有值的一个列表，对每个取值建立一个具有相同属性值的对象的存放有序或主键有序的顺序链表。次索引中存放对象地址的指针可以用主键来表示，这样在非主键属性列查找中，可以先在次索引中查找到对象主键，然后在主键索引中找到对象的地址。</p><p>3）m路<strong>静态</strong>搜索树（多级索引）</p><p>m路搜索树：</p><p>​当数据量很庞大的时候，索引块也会非常大，一次性无法读入所有的索引块到内存，这个时候就要考虑多级索引，最高一级的索引常驻内存就可以了，每一级中的字索引块有自己最大主关键码值。多级索引中，每个索引块大小一样，<strong>每个索引块最大存放m个索引项，每个索引项给出各子树节点最大关键码和存放地址</strong>，这样形成了m叉树，这种利用m叉树实现的多级索引，就是m路搜索树。m叉树中m意思是每个索引块中最大存放的索引项数目，跟索引级数没有关系。m叉树中叶节点中个索引项给出数据表中对象的关键码和存放地址。</p><p>4.3、动态索引结构（动态m路搜索树）</p><p>​ 动态调整的目的一般就是保持搜索树的平衡性。</p><p>1）B树</p><p>​定义见上。B树中每个节点包含了键值和键值对于的数据对象存放地址指针，所以成功搜索一个对象可以不用到达树的叶节点。成功搜索包括节点内搜索和沿某一路径的搜索，成功搜索时间取决于关键码所在的层次以及节点内关键码的数量。在B树中查找给定关键字的方法是：首先把根结点取来，在根结点所包含的关键字K1,…,kj查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查的关键字在某个Ki或Ki+1之间，于是取Pi所指的下一层索引节点块继续查找，直到找到，或指针Pi为空时查找失败。</p><p>2）B+树</p><p>​B树的变种。B+树非叶节点中存放的关键码并不指示数据对象的地址指针，非也节点只是索引部分。所有的叶节点在同一层上，包含了全部关键码和相应数据对象的存放地址指针，且叶节点按关键码从小到大顺序链接。如果实际数据对象按加入的顺序存储而不是按关键码次数存储的话，叶节点的索引必须是稠密索引，若实际数据存储按关键码次序存放的话，叶节点索引时稀疏索引。B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p><p>所以 B+树有两种搜索方法：</p><p>​ 一种是按叶节点自己拉起的链表顺序搜索。</p><p>​一种是从根节点开始搜索，和B树类似，不过如果非叶节点的关键码等于给定值，搜索并不停止，而是继续沿右指针，一直查到叶节点上的关键码。所以无论搜索是否成功，都将走完树的所有层。B+树中，数据对象的插入和删除仅在叶节点上进行。</p><p>这两种处理索引的数据结构的不同之处：</p><p>ØB树中同一键值不会出现多次，并且它有可能出现在叶结点，也有可能出现在非叶结点中。而B+树的键一定会出现在叶结点中，并且有可能在非叶结点中也有可能重复出现，以维持B+树的平衡。</p><p>Ø因为B树键位置不定，且在整个树结构中只出现一次，虽然可以节省存储空间，但使得在插入、删除操作复杂度明显增加。B+树相比来说是一种较好的折中。</p><p>ØB树的查询效率与键在树中的位置有关，最大时间复杂度与B+树相同(在叶结点的时候)，最小时间复杂度为1(在根结点的时候)。而B+树的时候复杂度对某建成的树是固定的。</p><h3 id="hash索引">4.3、hash索引</h3><p>​<strong>hash索引只支持精确查找，不支持范围查找</strong>。hash算法函数有可能不能保证哈希值的唯一性，即使是crc32这样的函数。所以可能有<u>哈希碰撞</u>问题（不同的串得到相同的hash值），md5()和sha1()是强加密函数，不会产生哈希碰撞。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>直接插入排序</tag>
      
      <tag>希尔排序</tag>
      
      <tag>冒泡排序</tag>
      
      <tag>快速排序</tag>
      
      <tag>简单选择排序</tag>
      
      <tag>堆排序</tag>
      
      <tag>归并排序</tag>
      
      <tag>基数排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>七、查找</title>
    <link href="/24d4ba7c/"/>
    <url>/24d4ba7c/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230316184247777-2024-12-811:15:42.png" alt="image-20230316184247777" style="zoom: 60%;" /></p><h2 id="一查找的基本概念">一、查找的基本概念</h2><p><strong>查找表</strong>：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，可以是一个数组或链表等数据类型。</p><ul><li>静态查找表：只进行查找操作，无须动态地修改的查找表称为静态查找表。<ul><li>适合静态查找表的查找方法：顺序查找、折半查找、散列查找等</li></ul></li><li>动态查找表：不仅要进行查找，还需要动态地插入或删除的查找表称为动态查找表。<ul><li>特点：表结构本身是在查找过程中动态生成的，即对于给定的key，若表中存在关键字等于key的记录，则查找成功；否则插入关键字为key的记录。</li><li>数个动态查找表的查找方法：二叉排序树的查找、散列查找、<u>二叉平衡树、B树、B+树</u>（其都是二叉排序树的改进）等。</li></ul></li></ul><p><strong>关键字</strong>：<strong>唯一标识</strong>数据元素的数据项。</p><p>查找算法的效率评价：</p><p>​<strong>平均查找长度是衡量查找算法效率最主要的指标，其数量级反映了算法的时间复杂度。</strong></p><p>​ 平均查找长度（<strong>ASL</strong>）：在查找过程中，一次查找长度是指需要比较的关键字次数，而平均查找长度是指所有查找过程中进行关键字的比较次数的平均值，记为<span class="math inline">\(ASL = \sum_{i=1}^{n} P_iC_i\)</span>。 -n是查找表的长度 - <span class="math inline">\(P_i\)</span>是查找第<spanclass="math inline">\(i\)</span>个元素的概率。一般认为每个数据元素的查找概率相等，即<spanclass="math inline">\(P_i = \frac{1}{n}\)</span> - <spanclass="math inline">\(C_i\)</span>是找到第<spanclass="math inline">\(i\)</span>个元素所要进行比较的次数。</p><p>通常考虑查找成功和查找失败两种情况下的ASL（<spanclass="math inline">\(ASL_{成功}\)</span>和 <spanclass="math inline">\(ASL_{失败}\)</span>）</p><h2 id="二线性结构查找方法">二、线性结构查找方法</h2><h3 id="顺序查找">2.1、顺序查找</h3><p>顺序查找又称线性查找，分为对一般的无序线性表的顺序查找和对关键字有序的顺序表的查找</p><p><strong>一般线性表的查找</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">//查找表</span>    ElemType *elem; <span class="hljs-comment">//元素存储空间基址</span>    <span class="hljs-type">int</span> TableLen; <span class="hljs-comment">//表的长度</span>&#125;SSTable;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search_Seq</span><span class="hljs-params">(SSTable ST, ElemType key)</span> </span>&#123;    ST.elem[<span class="hljs-number">0</span>] = key; <span class="hljs-comment">// 哨兵</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ST.TableLen; ST.elem[i] != key; --i); <span class="hljs-comment">//从后往前找</span>    <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//若i = 0 表示查找失败</span>&#125;</code></pre></div><p>对于有n个元素的表，给定值key与表中第i个元素相等，即定位第i个元素时，需要进行n-i+1次比较，当每个元素的查找概率相等时，<spanclass="math inline">\(ASL_{成功}\)</span> = <spanclass="math inline">\(\frac{1+2+3+...+n}{n} = \frac{n+1}{2}\)</span>,<span class="math inline">\(ASL_{失败} = n+1\)</span>。其时间复杂度为<span class="math inline">\(O(n)\)</span></p><p><strong>有序表的顺序查找</strong></p><p>若查找表中的关键字是有序的，则查找失败时可以不用再比较到表的另一端，就能返回查找失败的信息，从而<strong>降低查找失败时的平均查找长度<spanclass="math inline">\(ASL_{失败}\)</span></strong>，<spanclass="math inline">\(ASL_{成功}\)</span>和查找表无序时相同。</p><p>如在查找表(10,20,30,40)中查找25，该<strong>查找判定树</strong>如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-03-16_21-18-09-2024-12-811:16:15.png" alt="Snipaste_2023-03-16_21-18-09" style="zoom: 45%;" /></p><p>由判定树可得： <span class="math inline">\(ASL_{失败} =\frac{1+2+..+n+n}{n+1} =\frac{n}{2}+\frac{n}{n+1}\)</span>（西电课件上：<spanclass="math inline">\(ASL_{失败} = \frac{n}{2}+1\)</span>）</p><p>在一棵查找判定树中：</p><ul><li>n个元素，有 n+1种查找失败的情况（对应n+1个空链域）</li><li><strong>一个成功结点的查找长度 = 自身所在的层数</strong>(在折半查找中也是一样)</li><li><strong>一个失败结点的查找长度 = 其父节点所在的层数</strong>(在折半查找中也是一样)</li></ul><h3 id="折半查找">2.2、折半查找</h3><p>折半查找仅适用于<u><strong>有序的顺序表</strong></u>。</p><p>思想：默认顺序表为升序</p><ul><li>初始时，low = <span class="math inline">\(0\)</span>, high =len-1，mid。</li><li>当 low &lt;= high时, mid = <span class="math inline">\(\lfloor (low+ high)/2\rfloor\)</span><ul><li>若 elem[mid] = key, 则已找到指定元素，返回key</li><li>若 elem[mid] &lt; key，则key在mid的右侧， <strong>low = mid +1</strong>，继续查找</li><li>若elem[mid] &gt; key， 则key在mid的左侧，<strong>high = mid-1</strong>，继续查找</li></ul></li><li>当 low &gt; high 时，查找失败。</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Binary_Search</span><span class="hljs-params">(SeqList L, ElemType key)</span> </span>&#123;    <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>, high = L.TableLen - <span class="hljs-number">1</span>, mid;    <span class="hljs-keyword">while</span> (low &lt;= high) &#123;        mid = （low + high) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (L.elem[mid] == key)            <span class="hljs-keyword">return</span> mid;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (L.elem[mid] &lt; key)            low = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span>            high = mid - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">//查找失败返回-1</span>&#125;<span class="hljs-comment">//递归形式</span>...</code></pre></div><p>对在查找表(7,10,13,16,19,29,32,33,37,41,43)中查找值为11和值为32的过程，可以用其判定树来描述。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230316213850597-2024-12-811:19:51.png" alt="image-20230316213850597" style="zoom:80%;" /></p><p>对于11个成功的结点,当每个结点的查找概率相同，<spanclass="math inline">\(ASL_{成功} = (1*1+2*2+3*4+4*4)/11 = 3\)</span></p><p>对于12个查找失败的结点，假设每个结点的查找概率相同，<spanclass="math inline">\(ASL_{失败} = (3*4+4*8)/12 =\frac{11}{3}\)</span></p><p>该判定树只有最下层是不满的，高度和完全二叉树相同，故折半查找判定树的树高<span class="math inline">\(h = \lceillog_{2}{(n+1)}\rceil\)</span>（<strong>不包含失败结点</strong>），所以折半查找的时间复杂度为<span class="math inline">\(O(log_2n)\)</span></p><p>折半查找的判定树</p><ul><li><p>当 mid = <span class="math inline">\(\lfloor (low +high)/2\rfloor\)</span>时</p><ul><li>若共有奇数个元素，mid分割后 左右子树元素个数相等</li><li>若有偶数个元素，mid分割后右子树比比左子树多一个元素</li></ul><p>在该判定树中，若 mid = <span class="math inline">\(\lfloor (low +high)/2\rfloor\)</span>，则对任何一个结点，必有：<u>右子树结点数-左子树结点数 = <span class="math inline">\(0\)</span>或<spanclass="math inline">\(1\)</span>。</u></p></li><li><p>当mid = <span class="math inline">\(\lceil (low +high)/2\rceil\)</span>时，在折半查找的判定树中，对任何一个结点，必有：<u>左子树结点数- 右子树结点数= <span class="math inline">\(0\)</span>或<spanclass="math inline">\(1\)</span></u></p></li><li><p>折半查找的判定树一定是<strong><u>平衡二叉树</u></strong></p></li><li><p>在该判定树中，只有最后一层是不满的， 树高 h= <spanclass="math inline">\(\lceil log_2{(n+1)}\rceil\)</span>或 <spanclass="math inline">\(\lfloor log_2n\rfloor + 1\)</span>。</p></li><li><p>判定树中的关键字，左&lt;中&lt;右，满足<u>二叉排序树</u>的定义。</p></li><li><p>失败结点的个数为 <spanclass="math inline">\(n+1\)</span>，即空链域的个数。</p></li></ul><p><strong>构造查找判定树</strong>（构造n个结点的平衡二叉树）</p><ul><li><p>mid = <span class="math inline">\(\lfloor (low +high)/2\rfloor\)</span>时，右子树结点数- 左子树结点数 = <spanclass="math inline">\(0\)</span>或<spanclass="math inline">\(1\)</span>。每次先在右子树上插入，之后再在左子树中<u>同样的位置</u>插入，依次进行。注意不能破坏不能破坏左右子树中结点数量的关系。</p></li><li><p>mid = <span class="math inline">\(\lceil (low +high)/2\rceil\)</span>时，左子树结点数 - 右子树结点数= <spanclass="math inline">\(0或1\)</span>。每次先在左子树上插入，之后再在右子树中<u>同样的位置</u>插入，依次进行。注意不能破坏不能破坏左右子树中结点数量的关系。</p></li></ul><p>给定n个元素，构造其查找判定树时，先按某个mid取值方法，构造出n个结点的判定树的形状，再按<strong>中序遍历</strong>填入各个元素。（<strong>记得加上失败节点</strong>）</p><blockquote><p>1、折半查找平均情况下比顺序查找的效率高，但折半查找并不一定比顺序查找快</p><p>2、由于该判定树只有最下层是不满的，失败结点最早出现在第 <spanclass="math inline">\(h-1\)</span>层结点的左右子树中，最迟出现在叶子结点的左右子树中，故使用二分查找算法查找一个不存在的元素，比较次数至少为<span class="math inline">\(h-1\)</span>,至多为 <spanclass="math inline">\(h\)</span></p><p>3、折半查找失败时，low &gt; high,此时low所指的是大于key的最小值，即第一个大于key的元素，low之后的元素都大于key；high所指的是小于key的最大值，即第一个小于key的值，high之前的元素都小于key。</p></blockquote><p>在n个关键字的有序的顺序表中，使用折半查找时，<spanclass="math inline">\(ASL_{成功}\)</span>和<spanclass="math inline">\(ASL_{失败}\)</span></p><ol type="1"><li><p>n个关键字，其判定树树高 <span class="math inline">\(h = \lceillog_2(n+1)\rceil\)</span> ，叶子结点个数 <span class="math inline">\(K =n - (2^{h-1}-1)\)</span></p><p>故 <span class="math inline">\(ASL_{成功} =\frac{1*1+2*2+2^2*3+...+2^{h-2}*(h-1)+K*h}{n}\)</span></p><p><span class="math inline">\(ASL_{失败} =\frac{(h-1)*(2^{h-1}-K)+h*2K}{n+1}\)</span></p></li><li><p>构造n个关键字的查找判定树，根据判定树确定<spanclass="math inline">\(ASL_{成功}\)</span>和<spanclass="math inline">\(ASL_{失败}\)</span>。</p></li></ol><p>不论mid取值的方法如何，选用一种进行判定树的构造，对计算平均查找长度没有影响。</p><h3 id="分块查找">2.3、分块查找</h3><p>分块查找又称 <strong>索引顺序查找</strong>。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-03-16_22-19-50-2024-12-811:32:47.png" alt="Snipaste_2023-03-16_22-19-50" style="zoom:80%;" /></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241208112949836-2024-12-811:29:56.png" alt="image-20241208112949836" style="zoom:67%;" /></p><p>思想：将查找表分为若干子块，<strong>块内元素可以无序，但块间有序</strong>。再建立索引表，索引表中每个元素包括<u>各块中元素的最大值</u>和<u>每个块的第一个元素地址</u>，其中索引表按关键字有序排列。</p><p>分块查找的步骤：先查索引表（顺序查找或折半查找），再对分块内进行顺序查找。</p><p><strong>ASL = 查找索引表的查找长度 + 查分块的查找长度</strong></p><p>用折半查找查索引表时，<strong>若待查记录不在索引表中</strong>，折半查找失败，此时low&gt;high，应在<strong>low</strong>所指的块中查找。<strong>此时查索引表的查找长度是折半查找的判定树中该失败结点的父节点所在的层数</strong>，若最终low超出索引表的范围，则查找失败。</p><blockquote><p>此时low所指的是大于关键字的最小值，应在该块对应的范围内再寻找。</p><p>而high所指的是小于关键字的最大值，high对应的块其范围内的元素都比关键字小。</p></blockquote><p>若n个元素的查找表被分成b块，每块s个元素，在每个元素查找概率相同的情况下：</p><ul><li><p>顺序查找索引表：<span class="math inline">\(ASL_{成功}\)</span>=L1 + L2 = <spanclass="math inline">\(\frac{1+2+...+b}{b}+\frac{1+2+...+s}{s} ={\frac{b+1}{2}+\frac{s+1}{2}} = \frac{s^2+2s+n}{2}\)</span>，当 <spanclass="math inline">\(s = \sqrt{n}\)</span>时，<spanclass="math inline">\(ASL_{成功}\)</span> 取得最小值$ +1$。</p></li><li><p>折半查找索引表：<span class="math inline">\(ASL_{成功} = L1+L2 =\lceil log_2(b+1)\rceil + \frac{s+1}{2}\)</span></p></li></ul><h2 id="三树形结构查找方法">三、树形结构查找方法</h2><h3 id="二叉排序树bst">3.1、二叉排序树（BST）</h3><p>1、<strong>二叉排序树的定义</strong></p><p>二叉排序树，又称二叉查找树（BST，Binary SearchTree）一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p><ul><li>左子树上所有结点的关键字均小于根结点的关键字；</li><li>右子树上所有结点的关键字均大于根结点的关键字。</li><li>左子树和右子树又各是一棵二叉排序树。</li></ul><p>根据二叉排序树的定义，左子树结点值 &lt; 根结点值&lt;右子树结点值，对其进行一次<strong>中序遍历</strong>，可以得到一个递增的有序序列。</p><blockquote><ol type="i"><li><p>若已知一个二叉排序树的先序/后序/层序遍历序列，可以得到其中序序列，进而可以构造出这棵二叉排序树，其中序序列为递增有序的序列。</p></li><li><p>利用二叉排序树进行查找时，要画上失败结点。</p></li><li><p>成功和失败查找长度的计算与折半查找判定树中对应查找长度的计算方法相同。</p></li></ol></blockquote><p>2、<strong>二叉排序树的查找</strong></p><p>二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//非递归算法</span><span class="hljs-function">BSTNode* <span class="hljs-title">search</span><span class="hljs-params">(BiTree T, ElemType key)</span> </span>&#123;    <span class="hljs-keyword">while</span> (T != <span class="hljs-literal">NULL</span> &amp;&amp; key != T-&gt;data) &#123;        <span class="hljs-keyword">if</span> (key &lt; T-&gt;data)             T = T-&gt;lchild;        <span class="hljs-keyword">else</span>            T = T-&gt;rchild;    &#125;    <span class="hljs-keyword">return</span> T;&#125;<span class="hljs-comment">//递归算法</span><span class="hljs-function">BSTNode* <span class="hljs-title">search</span><span class="hljs-params">(BiTree T, ElemType key)</span></span>&#123;    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">if</span> (key == T-&gt;data) <span class="hljs-keyword">return</span> T;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; T-&gt;data)          <span class="hljs-keyword">return</span> <span class="hljs-built_in">search</span>(T-&gt;lchild, key);    <span class="hljs-keyword">else</span>         <span class="hljs-keyword">return</span> <span class="hljs-built_in">search</span>(T-&gt;rchild, key);&#125;</code></pre></div><p>3、二叉排序树的插入</p><p>二叉排序树作为一个动态树表，该树的结构不是一次生成的，而是在查找过程中，当树中不存在关键字值等于给定值的节点时再进行插入的。</p><p>插入过程：若原二叉排序树为空，则直接插入结点；否则，若关键字k小于根结点的值，则插入到左子树，若关键字k大于根结点值，则插入到右子树。</p><p>插入的结点一定是一个新添加的<strong>叶结点</strong>，且是查找失败时的查找路径上最后一个结点的左孩子或右孩子。</p><p>当插入序列有序时，树的高度最大。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//非递归算法</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BST_Insert</span><span class="hljs-params">(BiTree T, ElemType key)</span> </span>&#123;    BSTNode *p = T,*q;<span class="hljs-comment">//p用于遍历，q保存p的父节点。</span>    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//寻找插入位置</span>        q = p; <span class="hljs-comment">//保存父节点</span>        <span class="hljs-keyword">if</span> (key == p-&gt;data)            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//插入失败</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; p-&gt;data)            p = p-&gt;lchild;        <span class="hljs-keyword">else</span>            p = p-&gt;rchild;    &#125;    <span class="hljs-comment">//若在树中没有找到key，最终该结点要插在q所指结点的左孩子或右孩子处</span>    BSTNode* node = (BiTree) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BSTNode));    node-&gt;data = key;    node-&gt;lchild = <span class="hljs-literal">NULL</span>; node-&gt;rchild = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">if</span> (key &lt; q-&gt;data)         q-&gt;lchild = node;    <span class="hljs-keyword">else</span>        q-&gt;rchild = node;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//插入成功</span>&#125;<span class="hljs-comment">//递归算法</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BST_Insert</span><span class="hljs-params">(BiTree &amp;T, ElemType key)</span> </span>&#123;    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//若原树为空，则创建一个新结点插入。最终一定会插入到叶子结点的位置</span>        T = (BiTree) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BSTNode));        T-&gt;data = key;        T-&gt;lchild = <span class="hljs-literal">NULL</span>; T-&gt;rchild = <span class="hljs-literal">NULL</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//返回1，插入成功</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key == T-&gt;data) <span class="hljs-comment">//在树中找到该结点，插入失败</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &lt; T-&gt;data)  <span class="hljs-comment">//在左子树中插入</span>        <span class="hljs-built_in">BST_Insert</span>(T-&gt;lchild, key);    <span class="hljs-keyword">else</span>        <span class="hljs-built_in">BST_Insert</span>(T-&gt;rchild, key);&#125;<span class="hljs-comment">//构造二叉排序树</span><span class="hljs-comment">//从一棵空树出发，依次输入元素，将其插入二叉排序树中合适的位置</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BST_Creat</span><span class="hljs-params">(BiTree &amp;T, ElemType str[], <span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-comment">//按照str[]中的关键字序列建立二叉排序树</span>    T = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//初始时T为空树</span>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt; n) &#123;        <span class="hljs-built_in">BST_Insert</span>(T, str[i]);        i++;    &#125;&#125;</code></pre></div><p>4、<strong>二叉排序树的删除</strong></p><p>删除某结点后要保持二叉排序树的特性不变，即 左&lt;根&lt;右。</p><p>对于被删除的结点Z，有三种情况</p><ol type="1"><li>Z是叶节点，则直接删除</li><li>Z只有左子树或右子树，则删除结点Z，并让Z的子树成为Z的父节点的子树，替代Z的位置</li><li>Z同时有左子树和右子树<ul><li><p>方案一：<strong>用左子树中值最大的结点代替Z的位置</strong>。该结点是Z左子树的中序遍历序列的最后一个结点，即用<strong>左子树最右下的结点代替Z</strong>，再删除该结点。而该结点一定没有右子树，对该结点的删除转化为第1.2中情况下的删除。</p></li><li><p>方案二：<strong>用右子树中值最小的结点代替Z的位置。</strong>该结点是Z右子树的中序遍历序列的第一个结点，即用<strong>右子树最左下的结点代替Z</strong>，再删除该结点。而该结点一定没有左子树，对该结点的删除转化为第1.2中情况下的删除。</p></li><li><p>方案三：令<em>p的左子树为 </em>f 的左子树（若 *p 是 *f的左孩子），而*p 的右子树为 *s 的右子树（*s 是对 *p的左子树进行中序遍历的最后一个结点 ，即让 *p的右孩子连接到左子树中最大元素的右孩子处）</p><p>或者，令 *p 的右子树为 *f的右子树（若 *p 是 *f 的右孩子），而*p的左子树为 *s 的左子树（*s 是对 *p 的右子树进行中序遍历的第一个结点，即让 *p 的左孩子连接到右子树中最小元素的左孩子上）</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241208115345730-2024-12-811:53:54.png"alt="image-20241208115345730" /><figcaption aria-hidden="true">image-20241208115345730</figcaption></figure></li></ul></li></ol><p><strong>删除并插入结点v</strong></p><ul><li><p>在<u>二叉排序树</u>中，<strong>删除并插入</strong>某结点时，由于插入位置一定在叶子结点处，所以当被该结点<strong>不是叶子结点</strong>时，删除插入操作完成后二叉排序树结构将发生改变。</p></li><li><p>在<u>二叉平衡树</u> <spanclass="math inline">\(T_1\)</span>中，删除一个结点v后得到新的AVL树<spanclass="math inline">\(T_2\)</span>，再将该结点插回得到新的AVL树<spanclass="math inline">\(T_3\)</span>。</p><ul><li>v是叶结点：若删除操作没有导致<spanclass="math inline">\(T_1\)</span>失去平衡，不会发生调整，再插入此结点得到的AVL树<spanclass="math inline">\(T_3\)</span>和<spanclass="math inline">\(T_1\)</span>相同。若删除操作后<spanclass="math inline">\(T_1\)</span>失去平衡而发生调整，再插入该结点后得到的<spanclass="math inline">\(T_3\)</span>和<spanclass="math inline">\(T_1\)</span>有<strong>可能不同</strong>。</li><li>v不是叶结点：<span class="math inline">\(T_1\)</span>和<spanclass="math inline">\(T_3\)</span>有可能相同，也有可能不同。</li></ul></li></ul><p>5、<strong>二叉排序树的查找效率分析</strong></p><p>二叉排序树查找效率。主要取决于树高。对n个结点的二叉排序树，高度最大为n，最低为<span class="math inline">\(\lfloor log_2n \rfloor +1\)</span></p><h3 id="平衡二叉树-avl">7.3.2、平衡二叉树 （AVL）</h3><p>平衡二叉树（balanced BinaryTree）简称平衡树(AVL树)，树上任一结点的左子树和右子树的高度之差不超过1</p><p>结点的平衡因子 = 左子树高度 - 右子树高度</p><p><strong>平衡二叉树的插入</strong></p><p>平衡二叉树的插入过程前半部分与二叉排序树相同，但在新结点插入后，若造成查找路径上的某个结点不再平衡，则需要做出相应的调整。每次调整的都是<strong>最小不平衡子树</strong>，即以插入路径上离插入结点最近的平衡因子绝对值大于1的结点作为根的子树。只要将最小不平衡子树调整平衡，则其他祖先结点都会回复平衡。调整的规律如下：</p><p>调整最小不平衡子树A</p><ul><li><p>LL：在A的左孩子的左子树中插入导致不平衡（<strong>A的左孩子右上旋</strong>）</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230318204512157-2024-12-811:54:28.png" alt="image-20230318204512157" style="zoom:80%;" /></p><p>将A的左孩子B向右旋转代替A成为根结点，A结点向下旋转成为B的右孩子，同时B的原右子树作为A的左子树。</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//若F是A的父节点，A是左孩子，则代码思路为：</span>A-&gt;lchild = B-&gt;rchild;F-&gt;lchild = B;B-&gt;rchild = A;</code></pre></div></li><li><p>RR：在A的右孩子的右子树中插入导致不平衡（<strong>A的右孩子左上旋</strong>）</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230318204722921-2024-12-811:54:46.png" alt="image-20230318204722921" style="zoom:80%;" /></p><p>将A的右孩子B向左旋转代替A成为根结点，A结点向下旋转成为B的左孩子，同时B的原左子树作为A的右子树。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//若F是A的父节点，A为右孩子，则代码实现为</span>A-&gt;rchild = B-&gt;lchild;F-&gt;rchild = B;B-&gt;lchild = A;</code></pre></div></li><li><p>LR：在A的左孩子的右子树中插入导致不平衡（<strong>A左孩子的右孩子先左上旋再右上旋</strong>）</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230318205430184-2024-12-811:34:20.png"alt="image-20230318205430184" /><figcaption aria-hidden="true">image-20230318205430184</figcaption></figure><p>在A左孩子的右子树C中插入结点导致了不平衡，可能插入在C的左子树或右子树上。</p><p>调整：将C左旋加右旋，调整到A的位置。<u>即让C代替A的位置，B做C的左孩子，A做C的右孩子，C的左子树做B的右子树，C的右子树做A的左子树，一步调整完成。</u></p></li><li><p>RL：在A的右孩子的左子树中插入导致不平衡（<strong>A右孩子的左孩子先右上旋再左上旋</strong>）</p></li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-03-18_21-01-04-2024-12-811:55:02.png" alt="Snipaste_2023-03-18_21-01-04" style="zoom:80%;" /></p><p>同上。</p><p><strong>查找效率分析</strong></p><p>若树高为h，则最坏情况下，查找一个关键字最多需要对比h次，即查找操作的时间复杂度不可能超过<span class="math inline">\(O(h)\)</span>。</p><p>假设以<span class="math inline">\(n_h\)</span>表示深度为<spanclass="math inline">\(h\)</span>的平衡树中含有的<strong>最少</strong>结点数，则有<spanclass="math inline">\(n_0 = 0,n_1 = 1,n_2 = 2\)</span>，并且<u>有<spanclass="math inline">\(n_h = n_{h-1}+n_{h-2}+1\)</span></u>。由下图可知，<span class="math inline">\(T_h =T_{h-1}+T_{h-2}+1\)</span>即为递推公式。此时平衡二叉树的结点个数最少，<strong>每个非叶结点的平衡因子都是<spanclass="math inline">\(1\)</span>。</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230323160202508-2024-12-811:55:23.png" alt="image-20230323160202508" style="zoom: 80%;" /></p><p>一个平衡二叉树有9个结点，因为<span class="math inline">\(n_4 = 7,n_5=12\)</span>，9&lt;12，所以其最大深度为4。<strong>含有n个结点的平衡二叉树的最大深度为<spanclass="math inline">\(O(log_2n)\)</span>，</strong>所以平衡二叉树的平均查找长度为<spanclass="math inline">\(O(log_2n)\)</span>。</p><h3 id="红黑树brt">7.3.3、红黑树（BRT）</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230320161057030-2024-12-811:56:35.png" alt="image-20230320161057030" style="zoom:80%;" /></p><p>平衡二叉树和红黑树对比</p><ul><li>平衡二叉树AVL：插入和删除很容易破坏“平衡”特性，需要频繁调整树的形态。如：插入操作导致不平衡，则需要先计算平衡因子，找到最小不平衡子树（时间开销大），再进行LL/LR/RR/RL调整。</li><li>红黑树RBT：插入和删除很多时候并不会破坏"红黑"特性，无需频繁调整树的形态。即便需要调整也可以在常数级时间内完成。</li></ul><p>平衡二叉树适用于以查为主、很少进行插入/删除的场景；红黑树：适用于频繁插入/删除的场景，实用性更强。二者在查找、插入、删除方面的时间复杂度都为<spanclass="math inline">\(O(log_2n)\)</span>。</p><p><strong>定义和性质</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230320150715631-2024-12-811:56:43.png" alt="image-20230320150715631" style="zoom: 67%;" /></p><p>红黑树是二叉排序树，满足左子树结点值 &lt; 根结点值 &lt;右子树结点值。和普通BST相比，还需要满足以下特性：<strong><u>(左根右，根叶黑，不红红，黑路同)</u></strong></p><ul><li>每个结点或是红色的，或是黑色的。</li><li>根结点是黑色的</li><li>叶结点 (外部结点、NULL结点、失败节点)均是黑色的。</li><li>不存在两个相邻的红色结点（不存在父节点是红色，子女结点也是红色的情况）</li><li>对每一个结点，从该结点到任一叶子结点的简单路径上，所含黑结点的数目相同。如图中，13到所有叶结点的路径上都有两个黑结点。</li></ul><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RBNode</span>&#123;</span> <span class="hljs-comment">//红黑树结点定义</span>    <span class="hljs-type">int</span> key;    RBNode* parent;    RBNode* lChild;    RBNode* rChild;    <span class="hljs-type">int</span> color;<span class="hljs-comment">//结点颜色，如：可以用0/1表示红/黑</span>&#125;;</code></pre></div><p>性质：</p><ul><li><p>结点的<strong><u>黑高</u></strong>：从某结点出发（不包含该结点）到达任一空叶结点的路径上黑结点总数。</p></li><li><p>根结点黑高为h的红黑树，内部关键字最少有<spanclass="math inline">\(2^h-1\)</span>个</p><p>内部结点数最少的情况：所有结点都是黑色，且是高为h的满二叉树时内部结点最少。当所有结点都为黑色时，只有该树是满二叉树时才能保证，所有叶结点在同一层，进而满足<u>黑路同</u>的特性。高度为h的满二叉树中有<span class="math inline">\(2^h-1\)</span>个结点。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230320153438409-2024-12-811:56:48.png" alt="image-20230320153438409" style="zoom:50%;" /></p></li><li><p>从根结点到叶结点的<u>最长路径</u>不大于<u>最短路径</u>的2倍</p><p>由于从根结点到任何一个叶结点的路径上黑结点数量相同，而路径上不能连续出现两个红结点，所以最长路径只能是红结点只能穿插在各个黑结点之间。</p></li><li><p>有n个内部节点的红黑树高度 <span class="math inline">\(h \le2log_2(n+1)\)</span>，故红黑树查找操作时间复杂度 = <spanclass="math inline">\(O(log_2n)\)</span>。</p><p>若红黑树总高度为h，则根结点黑高 <span class="math inline">\(\geh/2\)</span>（此时红结点穿插在查找失败路径上各个黑结点之间，根结点黑高最小，路径最长），则内部结点数<span class="math inline">\(n \ge 2^{h/2}-1\)</span>，进而得 <spanclass="math inline">\(h \le 2log_2(n+1)\)</span>。</p></li></ul><p><strong>红黑树的查找</strong></p><p>​ 和二叉排序树的查找相同。</p><p><strong>红黑树的插入</strong></p><ol type="1"><li><p>先查找，确定插入位置，插入新结点（和二叉排序树相同）</p><ul><li>新结点是 <strong>根</strong> -- 染为<strong>黑色</strong></li><li>新结点 <strong>非根</strong> -- 染为<strong>红色</strong>（保证黑路同的特性）</li></ul></li><li><p>若插入新结点后依然满足红黑树的定义，则插入结束。</p></li><li><p>若插入新结点后不满足红黑树的定义，需要<u><strong>调整</strong></u>，使其重新满足红黑树的定义。</p><p>对于插入的<u>非根</u>结点，被染成红色，此时<strong>只可能</strong>会破坏红黑树特性中的<strong><u>不红红</u></strong>，其他几个都没有影响</p><p>调整策略有新插入结点的叔叔结点的颜色决定。（<strong><u>看其叔叔的脸色行事</u></strong>）</p><ul><li><p>黑叔：<strong>旋转+染色</strong>（旋转操作和平衡二叉树的调整方法完全相同）</p><ul><li><p>LL型：右单旋，父换爷+染色</p><p>LL型即新结点插在了爷结点左孩子的左边；父换爷+染色，即<u>右单旋后</u>，其效果为父节点和爷结点位置互换，同时要将两者颜色变为与原来相反，红变黑，黑变红。</p></li><li><p>RR型：左单旋，父换爷+染色</p></li><li><p>LR型：左、右双旋，儿换爷+染色</p></li><li><p>RL型：右、左双旋，儿换爷+染色</p></li></ul></li><li><p>红叔：<strong>染色+变新</strong></p><ul><li>叔父爷染色，爷变为新结点。（爷成为新结点后，回到第一步，若是根节点则染为黑色，若是非根结点染为红色，再看是否破坏了红黑树定义，继续处理）</li></ul></li></ul></li></ol><h3 id="b树">7.3.4、B树</h3><p><strong>定义</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230320174149811-2024-12-811:57:00.png" alt="image-20230320174149811" style="zoom:80%;" /></p><p>B树，又称多路平衡查找树（所有结点的平衡因子都为<spanclass="math inline">\(0\)</span>，<strong>绝对平衡</strong>），B树中所有结点的孩子个数的最大值称为B树的阶。</p><p>一棵m阶B树或为空树，或为满足如下特性的m叉树：</p><ul><li><p>树中每个结点至多有m棵子树，即至多含有m-1个关键字</p></li><li><p>若根节点不是终端节点，则至少有两棵子树。（保证所有结点都绝对平衡）</p></li><li><p>除根结点外（树中可能就只有1个结点，达不到<spanclass="math inline">\(\lceilm/2\rceil\)</span>的要求），所有非叶结点至少有<spanclass="math inline">\(\lceil m/2\rceil\)</span>棵子树，即至少含有<spanclass="math inline">\(\lceilm/2\rceil-1\)</span>个关键字（保证查找效率）</p></li><li><p>所有非叶结点结构如下：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230320164537682-2024-12-811:57:04.png" alt="image-20230320164537682" style="zoom: 45%;" /></p><p>其中<span class="math inline">\(K_i\)</span>为关键字，<spanclass="math inline">\(P_i\)</span>为指向子树的指针。<strong>非叶节点内关键字有序</strong>，即<spanclass="math inline">\(K_1&lt;K_2&lt;...&lt;K_n\)</span>。<spanclass="math inline">\(K_i\)</span>左侧指针<spanclass="math inline">\(P_{i-1}\)</span>所指子树中所有结点的关键字都比<span class="math inline">\(K_i\)</span>小，右边的都比<spanclass="math inline">\(K_i\)</span>大</p></li><li><p>所有叶结点都出现在最后一层，并且不带信息。（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。</p><p><u>n个关键字的m阶B树，必定有n+1个叶子结点。</u>（相当于n个关键字将负无穷到正无穷分成了n+1个区间，每个区间对应一个失败结点，即叶子结点）</p></li></ul><blockquote><p>对一棵5阶B树，除根结点外，只要其结点内的关键字个数在[2,4]之间，都满足5阶B树的定义。</p></blockquote><p><strong>m阶B树的核心特性</strong>：</p><ul><li><p><strong>根结点</strong>的子树个数 <spanclass="math inline">\(\in[2,m]\)</span>，关键字个数 <spanclass="math inline">\(\in[1,m-1]\)</span>;</p><p><strong>其他结点</strong>的子树个数<spanclass="math inline">\(\in[\lceilm/2\rceil,m]\)</span>，关键字个数个数<spanclass="math inline">\(\in[\lceil m/2\rceil-1,m-1]\)</span></p></li><li><p>对任一结点，其所有子树高度都相同，绝对平衡。</p></li><li><p>关键字的值：子树0&lt;关键字1&lt;子树1&lt;关键字2&lt;子树2...（类比二叉查找树左&lt;中&lt;右）</p></li></ul><p><strong>B树的高度</strong></p><p>含有n个关键字的m阶B树的最大高度和最小高度：（不包含叶子结点）</p><ul><li><p>最小高度：<span class="math inline">\(log_m(n+1)\)</span></p><p>要让高度最小，须让每个结点尽可能地满，每个结点有m-1个关键字，则<spanclass="math inline">\(n \le(m-1)(1+m+m^2+...+m^{h-1})=m^h-1\)</span>，故<spanclass="math inline">\(h\ge log_m(n+1)\)</span></p></li><li><p>最大高度：<span class="math inline">\(log_{\lceil m/2\rceil}(\frac{n+1}{2})+1\)</span></p><p>要让高度最大，让各层的分叉尽可能少。根节点有两个分叉，其余结点有<spanclass="math inline">\(\lceilm/2\rceil\)</span>个分叉。第一层有1个结点，第二层有2个结点，第三层有<spanclass="math inline">\(2\lceil m/2\rceil\)</span>个结点，第四层有<spanclass="math inline">\(2\lceil m/2\rceil^2\)</span>,第h层有<spanclass="math inline">\(2\lceil m/2\rceil^{h-2}\)</span>。</p><ul><li><p>第h+1层共有叶结点(失败节点)<span class="math inline">\(2\lceilm/2\rceil^{h-1}\)</span>个，而有n个关键字的m阶B树必定有n+1个叶结点，所以<span class="math inline">\(n+1 \ge 2\lceil m/2\rceil^{h-1}\)</span>,即<span class="math inline">\(h \le log_{\lceil m/2\rceil}(\frac{n+1}{2})+1\)</span></p></li><li><p>记<span class="math inline">\(k=\lceilm/2\rceil\)</span>，h层的m阶B树至少包含关键字总数<spanclass="math inline">\(1+2(k-1)(k^0+k^1+...+k^{h-1})=1+2(k^{h-1}-1)\)</span>,若关键字总数少于这个值，则高度一定小于h，故<spanclass="math inline">\(n \ge 1+2(k^{h-1}-1)=2k^{h-1} -1\)</span> ，所以<span class="math inline">\(h \lelog_k(\frac{n+1}{2})+1\)</span></p></li></ul></li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-03-20_17-41-10-2024-12-811:57:10.png" alt="Snipaste_2023-03-20_17-41-10" style="zoom:80%;" /></p><p><strong>B树的插入</strong></p><p>新元素一定是插入到最底层“终端节点”中，用查找来确定插入位置。</p><p>在插入key后，若导致原结点关键字超出上限，则从中间位置 (<spanclass="math inline">\(\lceilm/2\rceil\)</span>)处将其中的关键字<strong>分为两部分</strong>，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置(<span class="math inline">\(\lceilm/2\rceil\)</span>)的关键字插入原结点的父节点中。若此时导致父节点中关键字个数也超过上限，则继续进行这种分裂操作，直至这个过程传到根节点为止，进而导致B树高度增加1。</p><p><strong>B树的删除</strong></p><ul><li><p>若被删除的关键字在<u>终端节点</u>，删除该关键字。</p><ul><li>若删除后结点内的关键字个数未低于下限，无需任何处理。</li><li>若低于下限<ul><li>若左兄弟够借，则用当前关键字的前驱和前驱的前驱依次顶替空缺</li><li>若右兄弟够借，则用当前关键字的后继和后继的后继依次顶替空缺</li><li>若左右兄弟都不够借时，则将关键字删除后与左兄弟（或右兄弟）结点及双亲结点中的关键字合并。在合并过程中，双亲结点中的关键字会减1。若双亲结点是根结点且关键字个数减少为<spanclass="math inline">\(0\)</span>，则直接将根结点删除，合并后的新结点成为根。若双亲结点不是根结点且其关键字个数减少到低于下限，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合B树要求为止。</li></ul></li></ul></li><li><p>若被删除的关键字在<u>非终端结点</u>，则直接用直接前驱或直接后继来替代被删除的关键字</p><ul><li>直接前驱：当前关键字左侧指针所指子树最右下的元素</li><li>直接后继：当前关键字右侧所指子树最左下的元素</li></ul><p><strong>对非终端结点关键字的删除，就转化为对终端节点中关键字的删除。</strong></p></li></ul><h3 id="b树-1">7.3.5、B+树</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230320180717857-2024-12-811:57:14.png" alt="image-20230320180717857" style="zoom:80%;" /></p><p><strong>定义</strong></p><p>一棵m阶B树需满足下列条件：</p><ul><li>每个分支结点最多有m棵子树</li><li><u>非叶根节点</u>至少有两棵子树，其他每个分支结点至少有<spanclass="math inline">\(\lceil m/2\rceil\)</span>棵子树</li><li><strong>结点的子树个数和关键字个数相等</strong> （与B树不同）</li><li>所有<strong>叶结点包含所有的关键字</strong>及指向相应记录的指针，<strong>叶结点中将关键字按大小顺序排列</strong>，并且<strong>相邻叶结点按大小顺序相互链接起来</strong>。（叶结点支持顺序查找）</li><li>所有分支结点中仅包含它的各个子结点中关键字的最大值及指向子结点的指针</li></ul><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230615210912913-2024-12-811:56:30.png"alt="image-20230615210912913" /><figcaption aria-hidden="true">image-20230615210912913</figcaption></figure><p>相同点 除根结点外，每个结点至少有 <span class="math inline">\(\lceilm/2 \rceil\)</span>个分叉；任何一个结点的子树都一样高；</p><p>B+树是应文件系统所需而产生的的B树的变形，前者比后者，前者的磁盘代价更低，查询效率更加稳定，更加适用于实际应用中的<strong>操作系统文件索引和数据库索引</strong>。</p><p>补：树中的每个结点保存在磁盘中的某个磁盘块中，从根结点开始查询某个关键字，要将该路径上的所有磁盘块读入内存，由于磁盘块大小是固定的，在B+树中，非叶结点不含有该关键字对应记录的存储地址。可以使一个磁盘块可以包含更多个关键字，使得B+树的阶更大，树高更矮，读磁盘次数更少，查找更快。相比较于B树，每个结点中还包含了关键字对应记录的信息，使得每个磁盘块存储的关键字个数变少，树高增大，查找速度变慢。</p><h2 id="四散列表">四、散列表</h2><h3 id="概念">4.1、概念</h3><ul><li>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr</li><li>冲突：散列函数可能会把两个或两个以上的不同关键字映射到同一地址，这种情况称为冲突</li><li>同义词：被散列函数映射到同一地址的不同关键字之间互为同义词</li><li>散列表：根据关键字而直接进行访问的数据结构。散列表建立了关键字和存储地址间的直接映射关系</li></ul><p>一方面设计得好的<strong>散列函数</strong>应尽量减少冲突的发生；另一方面，由于冲突不可避免，所以还要设计好<strong>处理冲突的方法</strong>。散列查找是一种用空间换时间的方法。</p><h3 id="散列函数的构造方法">4.2、散列函数的构造方法</h3><p>常用的散列函数如下</p><ul><li><p>直接定址法</p><ul><li>直接取关键字的某个线性函数值作为散列地址</li><li>散列函数：H(key) = key 或 H(key) = a * key + b</li><li>特点：计算最简单且不会发生冲突，适合关键字分布基本连续的情况，若关键字分布不连续，空位较多，会造成存储空间的浪费。</li></ul></li><li><p>除留余数法</p><ul><li>假定散列表表长为m，<strong>取一个不大于m但最接近或等于m的质数</strong>，利用其对关键字取余，将关键字转化为散列地址。（用这样的p取余，会使散列地址分布更均匀，冲突更少）</li><li>散列函数为：H(key) = key %p</li><li>特点：最简单，最常用的方法。关键是选好p。</li></ul></li><li><p>数学分析法</p><ul><li>设关键字是r进制数（如十进制数），而<strong>r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些</strong>，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，此时可<strong>选取数码分布较为均匀的若干位作为散列地址</strong>。</li><li>特点：这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。</li></ul></li><li><p>平方取中法</p><ul><li>取关键字的平方的中间几位作为散列地址。具体取多少位要视实际情况而定。<strong>这种方法得到的散列地址与关键字的每位都有关系</strong>，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。</li></ul></li></ul><h3 id="处理冲突的方法">4.3、处理冲突的方法</h3><p>处理冲突，即为产生冲突的关键字寻找下一个"空"的Hash地址</p><ul><li><p>开放定址法</p><p>空闲地址既向它的同义词开放，又向它的非同义词开放。</p><p>数学递推公式为：<span class="math inline">\(H_i =(H(key)+d_i)%m\)</span>。其中H(key)为散列函数，m为散列表表长，<spanclass="math inline">\(d_i\)</span>为增量序列</p><p><strong>增量<spanclass="math inline">\(d_i\)</span>的取值方法</strong></p><ul><li><p>线性探测法（线性探测再散列）</p><ul><li><p><span class="math inline">\(d_i =0,1,2,...,m-1\)</span>，当出现冲突时，就顺序地向下一个单元探测，直到没有单元发生冲突</p></li><li><p>线性探测法可能使第i个散列地址的同义词存入第i+1个散列地址，这样本应存入第i+1个散列地址的元素就会争夺第i+2个散列元素的地址.....从而导致大量元素在相邻的散列地址上<strong>堆积</strong>，大大降低了查找效率。（在解决冲突时可能会造成新的冲突）</p></li><li><p>查找：首先判断散列地址位置的元素是否为待查元素，若不是则依次向后判断，直到找到该元素，或<strong>遇到空位置</strong>时停止，此时查找失败。当其不在散列表中时，<strong>对空位置的判断也要算一次比较</strong>（冲突的次数应与查找时对比的次数相同)</p><blockquote><p>查找不成功时，设散列函数有m个取值，即共有m个查找失败的入口（0~m-1）,注意是散列函数有m个取值，而不是散列表长度为m。对每个入口依次计算，对每种可能，该位置为空（算作比较一次）或不空但不为正确的关键字，则一直向后找，直到找到一个空位置，即可确定查找失败，查找次数为该位置查找失败的查找长度。</p></blockquote></li><li><p>删除：<u>采用“开放定址法”时</u>，要删除元素，不能简单地将其从散列表中删掉该元素，这会导致该位置为空，将截断在它之后填入元素的查找路径。可以设置一个“删除标记”，<strong>进行逻辑删除</strong>。查找时遇到删除标记，直接跳过向后查找。<strong>遇到删除标记也算一次比较</strong>。</p></li></ul><blockquote><p>线性探测法解决冲突时线性地查找空闲位置，平均查找长度与表的大小m无关，只与所选取的哈希函数H、装填因子有关，<spanclass="math inline">\(ASL_{成功} \approx\frac{1}{2}(1+\frac{1}{1-\alpha})\)</span></p></blockquote></li><li><p>平方探测法（二次探测再散列）</p><ul><li>当<span class="math inline">\(d_i =0^2,1^2,-1^2,2^2,-2^2,...,k^2,-k^2\)</span>时，称为平方探测法，又称二次探测法，其中<spanclass="math inline">\(k \lem/2\)</span>。此时<u>散列表长度m，必须是可以表示为<spanclass="math inline">\(\underline{4j+3}\)</span>的素数</u>，这样才能通过平方探测法探测到所有位置。</li><li>特点：可以避免出现“堆积”问题。</li></ul></li><li><p>伪随机序列法（伪随机探测再散列）</p><ul><li><span class="math inline">\(d_i\)</span>是一个伪随机序列</li></ul></li></ul></li><li><p>再散列法</p><p>​除了原始的散列函数H（key）之外，多准备几个散列函数，当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止。</p><blockquote><p>当增量<span class="math inline">\(d_i =Hash_2(key)\)</span>时，称为再散列法。当通过第一个散列函数<spanclass="math inline">\(H(key)\)</span>得到的地址发生冲突时，再利用第二个散列函数<span class="math inline">\(Hash_2(key)%\)</span>计算该关键字的增量，即<spanclass="math inline">\(H_i=[H(key)+i*Hash_2(key)]\%m\)</span>。初始探测位置<span class="math inline">\(H_0=H(key)%m\)</span>，i是冲突的次数。在再散列法中，最多经过m-1次探测就会遍历表中所有位置，回到<spanclass="math inline">\(H_0\)</span></p></blockquote></li><li><p>拉链法（链地址法）</p><ul><li>把所有同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。此时散列表中存放的是指向链表的指针。当链表有序时可以提高查找效率</li><li><u>计算查找长度时，和空链域的对比<strong>不计入</strong>查找次数。</u></li><li>拉链法适用于经常进行插入和删除的情况</li></ul><p>例如：采用除留余数法，散列函数为：H(key) = key %13，采用拉链法处理冲突，对应的散列表如下，此时<spanclass="math inline">\(ASL_{成功} =\frac{1*6+2*4+3*1}{11}\)</span>，<span class="math inline">\(ASL_{失败}=\frac{1*2+2*3+3*1}{\color{red}13}\)</span></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230320213023659-2024-12-815:42:20.png" alt="image-20230320213023659" /></p><blockquote><p>查找失败时，某位置的查找长度的计算，<strong>按对应处理冲突方法的规则寻找空位置</strong>（并不都是依次向后寻找，这只是线性探测寻找空位置的方法），统计寻找的次数</p></blockquote></li></ul><h3 id="性能分析">4.4、性能分析</h3><p><strong>平均查找长度</strong>仍是其查找效率的度量。</p><p>散列表的查找效率取决于三个因素：<strong><u>散列函数</u>、<u>处理冲突的方法</u>和<u>装填因子</u></strong></p><ul><li>散列表的装填因子α = <spanclass="math inline">\(\frac{表中记录数n}{散列表长度m}\)</span>，其反映了这个表的装满程度。</li><li><strong>散列表的平均查找长度依赖于散列表的装填因子，而不直接依赖于n或m。</strong>α越大，表示装填的记录越满，发生冲突的可能性越大，反之发生冲突的可能性越小。</li></ul><blockquote><ol type="1"><li><p>散列查找不是只能在顺序表上进行，采用拉链法处理冲突时，采用的是顺序存储和链式存储相结合的方式。</p></li><li><p>在开放定址法中散列到同一地址而引起的“堆积”问题是由于<u>同义词之间</u>，或<u>非同义词之间</u>发生冲突引起的，造成该问题的原因是处理冲突的方法选择不当，直接影响到的是平均查找长度。</p></li><li><p>通过线性探测法解决冲突时，在查找某关键字时，所查找位置上的键值不一定都是同义词</p></li><li><p>链地址法处理冲突时将同义词放在一个链表中，不会引起聚集现象</p></li><li><p>负数求模运算：在利用平方探测法解决冲突时，在寻找无冲突位置和求查找失败时的平均查找长度时，会出现“负数 % 正数”的情况。</p><p>计算方法：先将负号提出去，直接求<span class="math inline">\(-(|m|\%n)\)</span>，最后再加上<span class="math inline">\(n\)</span> <spanclass="math display">\[例如：(4 - 3^2) \% 11 = -5 \% 11 \quad\rightarrow \quad -(5\%11) = -5 \quad -5+11 = 6 \; \therefore -5\%11=6\]</span></p></li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>查找</tag>
      
      <tag>二分查找</tag>
      
      <tag>分块查找</tag>
      
      <tag>二叉排序树</tag>
      
      <tag>平衡二叉树</tag>
      
      <tag>红黑树</tag>
      
      <tag>B树</tag>
      
      <tag>散列表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>六、图</title>
    <link href="/ce993eeb/"/>
    <url>/ce993eeb/</url>
    
    <content type="html"><![CDATA[<meta name = "referrer", content = "no-referrer"/><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230316183420877-2024-12-810:00:23.png" alt="image-20230316183420877" style="zoom:80%;" /></p><h2 id="一图的定义">一、图的定义</h2><p>​ 图G由顶点集V和边集E组成，记为G =(V,E)，其中V(G)表示图G中顶点的有限<strong>非空</strong>集,E(G)表示图G中顶点之间关系（边）的集合。用|V|表示图G中顶点的个数，也称图的阶；|E|表示图G中边的条数。<strong>图不能为空图，边集E可以为空，但顶点集V不能为空。</strong></p><p>无向图（无向边/边），有向图（有向边/<strong>弧</strong>）</p><p>顶点的度</p><p><strong>点到点的关系</strong>：</p><ul><li><strong>路径</strong>（两点之间的顶点序列）、<strong>回路</strong>（第一个顶点和最后一个顶点相同的路径）、<strong>简单路径</strong>（顶点不重复出现的路径）、<strong>简单回路</strong>（除第一个和最后一个顶点相同外，其余顶点不重复出现的回路）</li><li><strong>路径长度</strong>（路径上边的数目）</li><li>点到点的距离（两点之间的最短距离）</li><li>无向图顶点的<strong>连通性</strong>（两顶点间有路径存在）、<strong>连通图</strong>（任意两个顶点间都是连通的）</li><li>有向图顶点的<strong>强连通性</strong>（从顶点<spanclass="math inline">\(w\)</span>到<spanclass="math inline">\(v\)</span>和从<spanclass="math inline">\(v\)</span>到<spanclass="math inline">\(w\)</span>都有<u><strong>路径</strong></u>）、<strong>强连通图</strong>（任一对顶点都是强连通的）</li></ul><p><strong>图的局部</strong></p><ul><li>子图（首先是图）、生成子图（包含原图的所有结点，可以不包含所有边）</li><li>连通分量---极大连通子图：无向图中，子图必须连通，且包含尽可能多的顶点和边。<ul><li>连通图本身就是自己的连通分量，而非连通图的各个子部分均为其连通分量</li></ul></li><li>强连通分量---极大强连通子图：有向图中，子图是强连通的，且包含尽可能多的顶点和边。</li><li>连通无向图的生成树：包含全部顶点的极小连通子图（子图既要连通，又要边数最少），<strong>不唯一</strong></li><li>非连通图的生成森林：各个连通分量的生成树</li></ul><p><strong>几种特殊形态的图</strong></p><ul><li>完全图<ul><li>无向完全图：对于无向图，任意两个顶点之间都存在边。有<spanclass="math inline">\(C_n^2\)</span>条边。</li><li>有向完全图：对于有向图，任意两个顶点之间都存在方向相反的两条<u><strong>弧</strong></u>（对比强连通图）。有<spanclass="math inline">\(2C_n^2\)</span>条边。</li></ul></li><li>稠密图、稀疏图</li><li>树、森林、有向树</li></ul><p><strong>常见考点</strong></p><p>对有<span class="math inline">\(n\)</span>个顶点的无向图G</p><ul><li>所有顶点的度之和为 <spanclass="math inline">\(2|E|\)</span>（每条边贡献两个度）</li><li>若G是连通图，则最少有 <spanclass="math inline">\(n-1\)</span>条边（若<spanclass="math inline">\(|E|&gt; n-1\)</span>，则必有回路）最多有<spanclass="math inline">\(C_n^2\)</span>条边,为无向图完全图</li><li>若G是非连通图，则最少有 0条边，最多有 <spanclass="math inline">\(C_{n-1}^2\)</span>条边（取其中<spanclass="math inline">\(n-1\)</span>个顶点，两两相连构成完全图，共 <spanclass="math inline">\(C_{n-1}^2\)</span>条边，若剩下的一个顶点与完全图中任意一个相连就整体连通了，故最多为<span class="math inline">\(C_{n-1}^2\)</span>条边）</li><li>无向完全图共 <span class="math inline">\(C_n^2\)</span>条边</li><li>无向完全图一定是连通图，但连通图不一定是完全图</li><li>要保证<spanclass="math inline">\(n\)</span>个顶点的无向图，<strong>在任何条件下都是连通的，即确保其是连通的，而不是其可以是连通的</strong>，即<spanclass="math inline">\(n\)</span>个顶点的非连通图的最大边数加一。需要先由其中<spanclass="math inline">\(n-1\)</span>个顶点构成完全图，再用剩下的一个顶点和完全图中某个顶点相连，则必然是连通的，故需要<spanclass="math inline">\(C_{n-1}^2+1\)</span>条边。</li></ul><p>对有<span class="math inline">\(n\)</span>个顶点的有向图G</p><ul><li>所有顶点的度之和为 <span class="math inline">\(2|E|\)</span></li><li>所有顶点的入度之和 = 出度之和 = <spanclass="math inline">\(|E|\)</span></li><li>若G是强连通图，则最少有<spanclass="math inline">\(n\)</span>条边（构成一个简单回路）。<strong>最简单的强连通图就是一个环。</strong></li><li>有向完全图共 有<spanclass="math inline">\(2C_n^2\)</span>条边。</li><li>有向完全图一定是强连通图，但强连通图不一定是有向完全图<ul><li>强连通有向图的任何顶点到其他顶点都有路径</li><li>有向完全图的任何顶点到其他顶点都有弧</li></ul></li><li>要<u><strong>保证</strong></u>n个顶点的有向图是连通的，至少需要$2(C_{n-1}^2+ 1) $条边。</li></ul><p>具有<span class="math inline">\(n\)</span>个顶点的环，有<spanclass="math inline">\(n\)</span>棵生成树。（每去掉一条边就形成一棵生成树）</p><p><spanclass="math inline">\(n\)</span>个顶点的图，最少有一个连通分量，最多有<spanclass="math inline">\(n\)</span>个。</p><p>若无向图满足 <span class="math inline">\(n\)</span>个顶点 <spanclass="math inline">\(n-1\)</span>条边的无向连通图，则它是树</p><p>有回路的图一定不存在拓扑序列。拓扑序列相当于工程的安排顺序，而回路的存在相当于死锁。</p><p>求有向图中强连通分量的个数：</p><ul><li>在有向图中，当一个顶点只有入度没有出度，或者只有出度没有入度时，它无法和其他顶点构成强图连通分量，它自身就是一个强连通分量。从图中删除该顶点和其相连的边后继续判断。</li></ul><blockquote><ol type="i"><li><p>顶点数-边数=1时，刚好<u><strong>可以做</strong></u>到连通且无环（并不是一定连通且无环，也可能是不连通但有环），相对于此临界点，若顶点数偏多则必不连通；相对于此临界点，若边数偏多则必有环。</p></li><li><p>n个顶点的无向图，当边数至少为<spanclass="math inline">\(C_{n-1}^2 +1\)</span>时，才能<strong>保证</strong>该图是连通的。</p></li><li><p>n个顶点的无向图，至少需要$2(C_{n-1}^2 + 1)$条边，才能<strong>保证</strong>该图是连通的。其需要的边数是有向图的2倍，因为需要添加一条指向n-1个结点构成的有向完全图的弧，也要再添加一条从有向完全图指向该结点的弧。</p></li></ol></blockquote><h2 id="二图的存储结构">二、图的存储结构</h2><h3 id="邻接矩阵法">2.1、邻接矩阵法</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230303171403732-2024-12-810:10:59.png" alt="image-20230303171403732" style="zoom:67%;" />用一个一维数组存储图中的顶点信息，用一个二维数组存储图中边的信息。该二维数组称为邻接矩阵。</p><p>当两个顶点间有边相连时，矩阵中对应的值为1，否则为0；当为带权图时，矩阵中对应值保存权值信息。</p><p>在无向图的邻接矩阵中，第<spanclass="math inline">\(i\)</span>个顶点的度 = 第 <spanclass="math inline">\(i\)</span>行（或第<spanclass="math inline">\(i\)</span>列）的非零元素个数。边的信息会被保存两次，所以是一个对称矩阵。在有向图的邻接矩阵中，第<spanclass="math inline">\(i\)</span>个顶点的<strong>出度</strong> = 第<spanclass="math inline">\(i\)</span><strong>行</strong>非零元素的个数，第<spanclass="math inline">\(i\)</span>个元素的<strong>入度</strong> = 第<spanclass="math inline">\(i\)</span><strong>列</strong>非零元素的个数。求一个顶点的度的时间复杂度为<spanclass="math inline">\(O(|V|)\)</span>。</p><p>邻接矩阵法的空间复杂度 为$ O(|V| + |V|^2) = O(|V|^2)$，<strong>只与图中顶点数有关，和实际边数无关，</strong>故其适合存储稠密图。</p><p>一个图的邻接矩阵表示是唯一的。</p><blockquote><ol type="i"><li>设图G的邻接矩阵为 A（矩阵元素为<spanclass="math inline">\(1/0\)</span>）,则 <spanclass="math inline">\(A^n\)</span>的元素 <spanclass="math inline">\(A^n[i][j]\)</span>等于由顶点 <spanclass="math inline">\(i\)</span> 到顶点 <spanclass="math inline">\(j\)</span> 长度为 n的路径数目。</li></ol><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230303172900327-2024-12-810:11:11.png" alt="image-20230303172900327" style="zoom: 50%;" /></p><p>​ 如 <span class="math inline">\(A^2[1][4] = a_{11}a_{14} + a_{12}a_{24}+a_{13}a_{34}+a_{14}a_{44}\)</span> ,其中<spanclass="math inline">\(a_{12} = 1\)</span>表示存在边(A,B)，<spanclass="math inline">\(a_{24} =1\)</span> 表示存在边(B,D),则 <spanclass="math inline">\(a_{12}a_{24} =1\)</span>表示存在一条A到B，再从B到D的路径；而<spanclass="math inline">\(a_{13}a_{34}=0\)</span>表示不存在从A到C，再从C到D的路径。</p><ol start="2" type="i"><li>对无权图，表示两点间没有直接相连，邻接矩阵对应位置用 0 表示</li></ol><p>​ 对带权图，表示两点间没有直接相连，邻接矩阵对应位置用 <spanclass="math inline">\(\infty\)</span>表示</p></blockquote><h3 id="邻接表法">2.2、邻接表法</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230303173953520-2024-12-810:11:16.png" alt="image-20230303173953520" style="zoom: 67%;" /></p><p>对图G中的每个顶点<spanclass="math inline">\(v_i\)</span>建立一个单链表，第<spanclass="math inline">\(i\)</span>个单链表中的结点表示依附于顶点<spanclass="math inline">\(v_i\)</span>的边（对有向图则表示以<spanclass="math inline">\(v_i\)</span>为尾的弧），这个单链表就称为顶点<spanclass="math inline">\(v_i\)</span>的边表。边表的头指针和顶点的数据信息采用顺序存储。</p><p>特点：</p><ul><li><p>对有向图而言，每个结点邻接表中所含结点数即为该节点的出度。</p></li><li><p>若G为无向图，则所需的存储空间为 <spanclass="math inline">\(O(|V|+2|E|)\)</span>；若是有向图，则所需存储空间为<spanclass="math inline">\(O(|V|+|E|)\)</span></p></li><li><p>稀疏表适合用邻接表表示</p></li><li><p>在有向图的邻接表中，求一个顶点的出度只需计算其边表中结点的个数，但要求其入度时需要遍历整个邻接表。</p></li><li><p>图的邻接表表示并不唯一。由于每个顶点的边表中结点的次序是任意的</p></li></ul><h3 id="十字链表法表示有向图">2.3、十字链表法（表示有向图）</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230303175648773-2024-12-810:11:22.png" alt="image-20230303175648773" style="zoom:67%;" /></p><p>其空间复杂度为<span class="math inline">\(O(|V|+|E|)\)</span></p><p>找一个顶点的出边，沿着tlink向下找；找一个顶点的入边，沿着rlink向下找。</p><p>顶点之间是顺序存储的。图的十字链表表示是不唯一的，但一个十字链表表示确定的一个图。</p><h3 id="邻接多重表法存储无向图">2.4、邻接多重表法（存储无向图）</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230303175800794-2024-12-810:11:26.png" alt="image-20230303175800794" style="zoom:67%;" /></p><p>在邻接多重表中，所有依附于同一顶点的边串联在同一链表中，由于每条边依附于两个顶点，因此每个边结点同时链接在两个链表中。</p><p>对无向图而已，其邻接多重表和邻接表的差别仅在于，同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。</p><p>空间复杂度为 <spanclass="math inline">\(O(|V|+|E|)\)</span>，每条边之对应一份数据，删除边和结点的操作都很方便。</p><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20230615205554582-2024-12-810:15:48.png"alt="image-20230615205554582" /><figcaption aria-hidden="true">image-20230615205554582</figcaption></figure><ul><li>AOV网：用顶点表示活动，用有向边表示活动之间的顺序关系的图，称为用顶点表示活动的网络，记为AOV网。</li><li>AOE网：用顶点表示事件，用有向边表示活动，以边上的权值表示完成该活动的开销，称为用边表示活动的网络，简称AOE网。</li></ul><p>AOV网和AOE网都是有向无环图（DAG图），不同之处在于它们顶点和边所代表的含义不同，AOE网中的边有权值，而AOV网中的边无权值，仅表示</p><blockquote><p>若有向图的邻接矩阵的对角线以下元素均为<spanclass="math inline">\(0\)</span>，则该图的拓扑序列必定存在。（对角线以下元素均为<spanclass="math inline">\(0\)</span>,必不存在环，即拓扑序列一定存在，但并不能说明拓扑序列唯一）</p></blockquote><h2 id="三图的基本操作">三、图的基本操作</h2><figure><imgsrc="https://gitee.com/cmyk359/img/raw/master/img/image-20241208102024920-2024-12-810:20:28.png"alt="image-20241208102024920" /><figcaption aria-hidden="true">image-20241208102024920</figcaption></figure><h2 id="四图的遍历">四、图的遍历</h2><p>​图的遍历是指从图中某一顶点出发，按照某种搜索方法沿着图中的边对图中的所有顶点访问一次且仅访问一次。</p><p>​图和树相比，树不存在回路，搜索相邻结点时，不可能找到已经访问过的结点；而图中的任一顶点都可能和其余顶点相邻接，搜索相邻顶点时，有可能找到已经访问过的顶点。为避免同一顶点被访问多次，在遍历图的过程中，设置一个辅助数组visited[]，来标记顶点是否被访问过。</p><h3 id="图的广度优先遍历">4.1、图的广度优先遍历</h3><p><strong>广度优先搜素（BFS）类似于树的层序遍历</strong>。广度优先搜索遍历图的过程是以<span class="math inline">\(v\)</span>为起点，由近至远依次访问和 <spanclass="math inline">\(v\)</span>有路径相通且路径长度为<spanclass="math inline">\(1,2,...\)</span>的顶点。搜索过程和二叉树的层序遍历完全一致，是一种分层的查找过程，不是一个递归算法，需要设置辅助队列。</p><p>空间复杂度：<spanclass="math inline">\(O(|V|)\)</span>，主要是辅助队列的空间</p><p>时间复杂度：主要开销在于<strong>访问各个顶点</strong>和<strong>探索各条边</strong>。</p><ul><li>对于邻接矩阵存储的图，<span class="math inline">\(O(|V|+O(|V|^2)) =O(|V|^2)\)</span></li><li>对于邻接表存储的图，<span class="math inline">\(O(|V|)+O(|E|) =O(|V|+|E|)\)</span></li></ul><p>对于一个非连通图，需要多次调用BFS才能将图中所有顶点访问一次，调用次数= 连通分量个数。</p><p>在对一个<u>连通图</u>的广度遍历的过程中，可以得到一棵遍历树，称为<strong>广度优先生成树</strong>；对于一个<u>非连通图</u>，可以得到<strong>广度优先森林。</strong></p><blockquote><p>当各边的权值<strong>相等</strong>时，广度优先算法可以用来解决单源最短路径问题。</p><p>从某一顶点开始进行广度优先遍历，得到的广度优先生成树<u>一定是以该顶点为根的，高度最小的生成树</u></p></blockquote><h3 id="图的深度优先遍历">4.2、图的深度优先遍历</h3><p><strong>深度优先搜素（DFS）类似于树的先序遍历。</strong>其搜索策略时尽可能“深”地搜索一个图。</p><p>基本思想：首先访问图中某一起始顶点<spanclass="math inline">\(v\)</span>，然后从<spanclass="math inline">\(v\)</span>出发，访问与<spanclass="math inline">\(v\)</span>邻接且未被访问的任一顶点<spanclass="math inline">\(w_1\)</span>，再访问与<spanclass="math inline">\(w_1\)</span>邻接且未被访问的任一顶点<spanclass="math inline">\(w_2......\)</span>重复上述过程。当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有顶点未被访问过，则从该顶点开始继续上述搜索过程，直至图中所有顶点均被访问过为止。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">bool</span> visited[vertexNum]; <span class="hljs-comment">//记录顶点是否被访问过</span><span class="hljs-function"><span class="hljs-type">void</span>  <span class="hljs-title">DFSTraverse</span><span class="hljs-params">(Graph G)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.verxNum; i++)        visited[i] = <span class="hljs-literal">false</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.verxNum; i++) <span class="hljs-comment">//非连通图要在执行多次DFS</span>        <span class="hljs-keyword">if</span> (!visited[i])            <span class="hljs-built_in">DFS</span>(G, i);&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFS</span><span class="hljs-params">(Graph G, <span class="hljs-type">int</span> v)</span> </span>&#123;    <span class="hljs-built_in">visit</span>(v);             <span class="hljs-comment">//访问顶点v</span>    visited[v] = <span class="hljs-literal">true</span>;    <span class="hljs-comment">//标记该顶点v已访问</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w = G.<span class="hljs-built_in">firstNeighbor_martrix</span>(v); w &gt;= <span class="hljs-number">0</span>; w = G.<span class="hljs-built_in">nextNeighbor_martrix</span>(v,w)) &#123;        <span class="hljs-keyword">if</span> (!visited[w]) &#123; <span class="hljs-comment">//w与v邻接且没被访问过</span>            <span class="hljs-built_in">DFS</span>(G, w);        &#125;           &#125;&#125;</code></pre></div><p>DFS算法是一个递归算法，需要借助一个递归工作栈。</p><p>空间复杂度：<spanclass="math inline">\(O(|V|)\)</span>,主要是递归工作栈的空间。</p><p>时间复杂度：主要开销在于访问各个顶点和探索各条边。</p><ul><li>对于邻接矩阵存储的图，<span class="math inline">\(O(|V|+O(|V|^2)) =O(|V|^2)\)</span></li><li>对于邻接表存储的图，<span class="math inline">\(O(|V|)+O(|E|) =O(|V|+|E|)\)</span></li></ul><p>与广度优先搜索一样，深度优先搜索也会产生一棵<strong>深度优先生成树</strong>。对于非连通图，产生的是<strong>深度优先森林</strong>。</p><p>对于一个图，使用<u>邻接矩阵</u>存储时是唯一的，由此得到的广度/深度优先遍历序列是唯一的，故广度/深度优先生成树/森林也是唯一的；而当使用<u>邻接表</u>存储时是不唯一的，由此得到的遍历序列和生成树都是不唯一的。</p><blockquote><p>判断有向图中是否有回路，除了用拓扑排序外，还可以利用深度优先遍历算法</p><p>图的广度优先生成树的树高和深度优先生成树的树高相比<strong>小或相等</strong></p></blockquote><h3 id="图的遍历与图的连通性">4.3、图的遍历与图的连通性</h3><p>对一个<strong>无向图</strong>，进行广度/深度优先遍历，<u>调用BFS/DFS函数的次数=连通分量的个数</u>。对于一个连通图只需一次遍历，而若是非连通的，每次遍历只能访问到该顶点所在连通分量中的所有顶点。</p><p>对一个<strong>有向图</strong>，进行广度/深度优先遍历，调用BFS/DFS函数的次数要具体分析。</p><ul><li>若从一顶点到其他顶点都有路径，则只需调用一次。</li><li>一个连通的有向图分为强连通的和非强连通的，它的连通子图也分为强连通分量和非强连通分量。对于强连通图，只需一次；对于非强连通分量，一次调用BFS/DFS无法访问到该连通分量的所有顶点。</li></ul><h2 id="五图的应用">五、图的应用</h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307214411951-2024-12-810:26:16.png" alt="image-20230307214411951" style="zoom:67%;" /></p><h3 id="最小生成树">5.1、最小生成树</h3><p><strong>连通图</strong>的生成树是包含所有顶点的极小连通子图。</p><p>对一个<strong>带权 连通无向图</strong>G，G的所有生成树中，<u>权值之和最小的生成树</u>称为G的最小生成树（MST）.</p><p>性质：</p><ul><li><strong>最小生成树不是唯一的</strong>，但边的权值之和总是唯一且<u>是所有生成树中最小的。</u></li><li><u>当图G中的各边权值互不相等时，G的最小生成树是唯一的</u>；若G本身就是一棵树，则G的最小生成树就是其本身。</li><li><strong>最小生成树的边数 = 顶点数 -1</strong>。砍掉一条则不连通，增加一条边则会出现回路。</li></ul><blockquote><p>最小生成树中的n-1条边并不能保证是图中权值最小的n-1条边，因为权值最小的n-1条边并不一定能使图连通，某条边的权值可能超过未选边的权值。</p></blockquote><h4 id="prim算法">prim算法</h4><p><strong>从某个顶点开始构建生成树，每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。</strong></p><p>prim算法的代码实现思路：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307205707722-2024-12-810:49:44.png" alt="image-20230307205707722" style="zoom:67%;" /></p><p>从<span class="math inline">\(v_0\)</span>开始，首先初始化isJoin[]和lowCast[]数组。</p><ol type="1"><li>循环遍历所有顶点，找到其中未加入生成树且lowCast值最小的顶点<spanclass="math inline">\(v_i\)</span>，将其加入生成树。</li><li>再次循环遍历，更新还没加入的各个顶点的lowCast值。<ul><li><strong>由于树中加入了新的顶点<spanclass="math inline">\(v_i\)</span>，其他未加入的顶点可能通过<spanclass="math inline">\(v_i\)</span>加入树的代价比原来的要小</strong>，此时要更新lowCast。即<u>若未加入的顶点和<spanclass="math inline">\(v_i\)</span>之间有边，且边的权值比对应的lowCast值小，则更新lowCast值为权值</u>。</li></ul></li><li>重复 1,2直至所以顶点都加入树中。</li></ol><p>从<span class="math inline">\(v_0\)</span>开始进行了<spanclass="math inline">\(n-1\)</span>轮处理，每轮处理中既要遍历isJoin找到未加入且lowCast最低的顶点，又要更新还未加入的各个顶点的lowCast值，每轮时间复杂度为<span class="math inline">\(O(2n)\)</span>，故总体时间复杂度为<spanclass="math inline">\(O(n^2)\)</span>，即<spanclass="math inline">\(O(|V|^2)\)</span></p><p>时间复杂度：<span class="math inline">\(\color{red}O(|V|^2)\)</span>，适合用于<strong>边稠密图</strong></p><blockquote><p>当构造生成树过程中，每条边的选取都是唯一的，每条边不存在其他可替代的选择，此时构造的MST是唯一的。</p><p>当带权图中所有边的权值互不相同时，其MST是唯一的。（一个充分条件）</p></blockquote><h4 id="kruskal算法">Kruskal算法</h4><p><strong>每次选择权值最小的边，使这条边的两头连通（原本已经连通的就不选），直到所有顶点都连通。</strong></p><p>Kruskal算法的代码实现思路：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307212551551-2024-12-810:49:36.png" alt="image-20230307212551551" style="zoom:67%;" /></p><p>初始时，将每条边按权值排序，每个顶点都还未加入到生成树中，互相看做独立的|V|个集合。</p><p>按权值递增的顺序遍历各个边。处理一条边时，判断这条边连接的两个顶点是否属于一个集合，如果不属于同一集合，则选择该边，使两个顶点连通。已连通的顶点属于同一集合。如果属于同一集合，则跳过该边。</p><p>使用并查集来判断两顶点是否属于同一集合。共执行|E|轮，每轮判断两顶点是否属于同一集合，需要<spanclass="math inline">\(O(log_2{|E|})\)</span>，总时间复杂度为<spanclass="math inline">\(O(|E|log_{2}{|E|})\)</span>。</p><p>时间复杂度：<span class="math inline">\(\color{red}O(|E|log_{2}{|E|})\)</span>，适合用于边稀疏图</p><blockquote><p>补充：破圈法求最小生成树</p><p>基本思想：在给定图中任意找出一个环路，删除该环路中权值最大的边，然后在余下的图中再找出任意一个回路，再删去这个新找出的回路中权值最大的边......，一直重复上述过程，知道剩余的图中没有回路，剩余图便是最小生成树。</p></blockquote><h3 id="最短路径">5.2、最短路径</h3><h4id="bfs求无权图的单源最短路径问题">BFS求无权图的单源最短路径问题</h4><p>无权图可以看做一种特殊的带权图，只是权值都为1。</p><p>广度优先搜索总是按照距离的从近到远来遍历图中每个顶点的。利用这一特性，修改BFS算法，在visit一个顶点时，修改其最短路径长度d[],并在path[]记录前驱顶点。</p><p>设置两个辅助数组</p><ul><li>d[]：记录从源点<spanclass="math inline">\(v0\)</span>到其他各顶点当前的最短路径长度</li><li>path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点。</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307215844825-2024-12-810:49:26.png" alt="image-20230307215844825" style="zoom:50%;" /></p><p>初始状态：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307215910638-2024-12-810:49:21.png" alt="image-20230307215910638" style="zoom: 50%;" /><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307215937053-2024-12-810:49:15.png" alt="image-20230307215937053" style="zoom: 67%;" /></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//求顶点u到其他顶点的最短路径</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS_MIN_Distance</span><span class="hljs-params">(Graph G, <span class="hljs-type">int</span> u)</span> </span>&#123;    <span class="hljs-comment">//初始化</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++) &#123;        d[i] = INT_MAX; <span class="hljs-comment">//初始化路径长度</span>        path[i] = <span class="hljs-number">-1</span>; <span class="hljs-comment">//最短路径从哪个顶点过来的</span>    &#125;    d[u] = <span class="hljs-number">0</span>; <span class="hljs-comment">//到自身路径长度为0</span>    visited[u] = <span class="hljs-literal">true</span>;    <span class="hljs-built_in">EnQueue</span>(Q,u);    <span class="hljs-keyword">while</span> (! <span class="hljs-built_in">IsEmpty</span>(Q)) &#123;        <span class="hljs-built_in">DeQueue</span>(Q,u); <span class="hljs-comment">//队头元素出队</span>        <span class="hljs-keyword">for</span> (w = <span class="hljs-built_in">FirstNeighbor</span>(G, u); w &gt;= <span class="hljs-number">0</span>; w = <span class="hljs-built_in">NextNeighbor</span>(G, u, w)) &#123;            <span class="hljs-keyword">if</span> (!visited[w]) &#123; <span class="hljs-comment">//w为u尚未访问过的邻接顶点</span>                d[w] = d[u] + <span class="hljs-number">1</span>; <span class="hljs-comment">//路径长度加1</span>                path[w] = u; <span class="hljs-comment">//最短路径从 u 到 w</span>                <span class="hljs-built_in">EnQueue</span>(Q, w); <span class="hljs-comment">//w入队</span>                visited[w] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//设置w已访问标记</span>            &#125;<span class="hljs-comment">//if</span>        &#125;<span class="hljs-comment">//for</span>    &#125;<span class="hljs-comment">//while</span>&#125;</code></pre></div><p>如从2号顶点开始，求解到其他顶点的最短路径长度和最短路径。与2相邻还没被访问过的顶点有1、6，修改d[1]= d[2]+1; path[1] = 2，将1入队；修改d[6] = d[2]+1; path[6] =2，将6入队；1出队，与1相邻还没被访问过的顶点有 5，修改d[5] = d[1]+1;path[5] =1，5入队；6出队，与6相邻还没被访问过的顶点有3,7......，得到最终的d[]和path[]</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307222559788-2024-12-810:49:08.png" alt="image-20230307222559788" style="zoom:67%;" /></p><p>从2号到8号的最短路径长度为d[8] = 3，最短路径为 8←7←6←2</p><h4id="dijkstra算法求单源最短路径问题">Dijkstra算法求单源最短路径问题</h4><p>Dijkstra算法设置一个集合S记录已求得最短路径的顶点，初始时把源点<spanclass="math inline">\(v_0\)</span>放入S，集合S每并入一个新顶点<spanclass="math inline">\(v_i\)</span>，都要修改源点<spanclass="math inline">\(v_0\)</span>到集合V-S中顶点当前最短路径长度值。<strong>当加入一个顶点<spanclass="math inline">\(v_i\)</span>时，源点到未加入集合的顶点的距离可能通过<spanclass="math inline">\(v_i\)</span>作为中转点时，距离可能会更短，故每次加入时都要更新。</strong></p><p>设置三个辅助数组</p><ul><li>final[]（或s[]）：标记各顶点是否已经找到最短路径，初始时均为false</li><li>dist[] (或d[])：源点到各顶点当前的最短路径长度，初始时均为无穷</li><li>path[]：最短路径上的前驱，初始时均为-1</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307224800913-2024-12-810:49:00.png" alt="image-20230307224800913" style="zoom:67%;" /></p><p>初始时，若从<spanclass="math inline">\(v_0\)</span>开始，令final[<spanclass="math inline">\(0\)</span>] = true; dist[<spanclass="math inline">\(0\)</span>] = <spanclass="math inline">\(0\)</span>; 其余顶点<spanclass="math inline">\(v_k\)</span>，dist[k] = arcs[<spanclass="math inline">\(0\)</span>] [k]，path[k]= (arcs[<spanclass="math inline">\(0\)</span>] [k] == ∞) ? -1 :<spanclass="math inline">\(0\)</span>.</p><p>进行n-1轮处理：循环遍历所有顶点，找到还未确定最短路径，且dist值最小的顶点<spanclass="math inline">\(v_i\)</span>，令final[i] =true,将其加入最短路径中。并检查所有邻接自<spanclass="math inline">\(v_i\)</span>的顶点，若其final值为false，则更新其dist和path信息。若通过<spanclass="math inline">\(v_i\)</span>到达这些顶点比原来找到的路径更短，即dist[i]+ arcs[i] [j] &lt; dist[j]，则更新dist[j]的值，并修改path[j] = i;（arcs[i] [j] 表示<span class="math inline">\(v_i\)</span>到<spanclass="math inline">\(v_j\)</span>的弧的权值）</p><p>时间复杂度：<span class="math inline">\(O(|V|^2)\)</span></p><p>对比prim算法：prim算法中的lowCast数组和Dijkstra算法中的dist数组作用和类似。<strong>lowCast数组记录的是一个顶点加入到生成树中的最小代价；dist数组记录的是从当前顶点到达指定顶点的最短路径的值</strong>。与Prim算法一样，Dijkstra算法也是基于贪心策略的</p><blockquote><p>Dijkstra算法不适用于带负权值的带权图</p></blockquote><p>例题：利用Dijkstra算法求解从a到其他顶点的最短路径和最短路径长度</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230310174311557-2024-12-810:48:52.png" alt="image-20230310174311557" style="zoom:50%;" /></p><table><thead><tr class="header"><th></th><th>i = 1</th><th>i = 2</th><th>i = 3</th><th>i = 4</th><th>i = 5</th></tr></thead><tbody><tr class="odd"><td>b</td><td>2 <span class="math display">\[a \rightarrow b\]</span></td><td></td><td></td><td></td><td></td></tr><tr class="even"><td>c</td><td>5 <span class="math display">\[a\rightarrow c\]</span></td><td>3 <span class="math display">\[a\rightarrow b \rightarrowc\]</span></td><td></td><td></td><td></td></tr><tr class="odd"><td>d</td><td>∞</td><td>5 <span class="math display">\[a \rightarrow b \rightarrowd\]</span></td><td>5 <span class="math display">\[a \rightarrow b \rightarrowd\]</span></td><td>5 <span class="math display">\[a \rightarrow b \rightarrowd\]</span></td><td></td></tr><tr class="even"><td>e</td><td>∞</td><td>∞</td><td>7 <span class="math display">\[a \rightarrow b \rightarrow c\rightarrow e\]</span></td><td>7 <span class="math display">\[a \rightarrow b \rightarrow c\rightarrow e\]</span></td><td>6 <span class="math display">\[a \rightarrow b \rightarrow c\rightarrow d \rightarrow e\]</span></td></tr><tr class="odd"><td>f</td><td>∞</td><td>∞</td><td>4 <span class="math display">\[a \rightarrow b \rightarrow c\rightarrow f\]</span></td><td></td><td></td></tr><tr class="even"><td><span class="math inline">\(v_j\)</span></td><td>b</td><td>c</td><td>f</td><td>d</td><td>e</td></tr><tr class="odd"><td>集合 S</td><td>{a,b}</td><td>{a,b,c}</td><td>{a,b,c,f}</td><td>{a,b,c,f,d}</td><td>{a,b,c,f,d,e}</td></tr><tr class="even"><td>d[]</td><td>d[1] =2</td><td>d[2] = 3</td><td>d[3] = 4</td><td>d[4] = 5</td><td>d[5] = 6</td></tr></tbody></table><p>分析：以第一轮为例，选出路径最小值2，并将顶点b并入集合S，即已经找到从a到b的最短路径。当b加入S后，从a到V-S中可达顶点的最短路径长度可能会发生变化，因此更新其他未加入S的顶点的路径长度。第五轮结束后，所有顶点都已经包含在S中。S中的顶点序列是找到最短路径目标顶点的序列，即先找a到b的最短路径，再是a到c的最短路径.......</p><blockquote><p>每次判断初始点通过新加入的顶点到达其他尚未确定最短路径的点的距离会不会更短。</p></blockquote><h4id="floyd算法求各顶点之间最短路径问题">Floyd算法求各顶点之间最短路径问题</h4><p>Floyd算法使用了动态规划的思想。</p><p>对n个顶点的图，当想求任意一对顶点 $v_i $ →<spanclass="math inline">\(v_j\)</span>之间的最短距离，将问题分为如下几个阶段：</p><ul><li>初始时，从 $v_i $ 到<spanclass="math inline">\(v_j\)</span>不允许在其他顶点处中转，此时最短路径是多少</li><li>若允许在<spanclass="math inline">\(v_0\)</span>处中转，最短路径是否会进一步优化，此时最短路径是多少</li><li>若允许在<span class="math inline">\(v_0\)</span>，<spanclass="math inline">\(v_1\)</span>处中转，最短路径是否会进一步优化，此时最短路径是多少</li><li>......</li><li>若允许在<span class="math inline">\(v_0\)</span>,<spanclass="math inline">\(v_1\)</span>,.....<spanclass="math inline">\(v_{n-1}\)</span>处中转，最短路径是否会进一步优化，此时最短路径是多少</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307233700044-2024-12-810:48:40.png" alt="image-20230307233700044" style="zoom:50%;" /></p><p>在有向图G中，<spanclass="math inline">\(A^{(-1)}\)</span>记录原始图的信息，<spanclass="math inline">\(path^{(-1)}\)</span>初始值均为-1。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230307233745551-2024-12-810:48:45.png" alt="image-20230307233745551" style="zoom: 67%;" /></p><p>依次加入 <span class="math inline">\(v_0\)</span>,<spanclass="math inline">\(v_1\)</span>,...<spanclass="math inline">\(v_{n-1}\)</span>作为中转点，若路径更短，则更新A和path。</p><p>即若 <span class="math inline">\(A^{(k-1)}[i][j] &lt; A^{(k-1)}[i][k]+ A^{(k-1)}[k][j]\)</span>,</p><p>则 <span class="math inline">\(A^{(k)}[i][j] =A^{(k-1)}[i][k] +A^{(k-1)}[k][j]\)</span>，<span class="math inline">\(path^{(k)}[i][j] =k\)</span></p><p>否则 <span class="math inline">\(A^{(k)}\)</span>和<spanclass="math inline">\(path^{(k)}\)</span>保持不变</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k++) &#123; <span class="hljs-comment">// 允许以vk作为中转点</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123; <span class="hljs-comment">//遍历各个顶点</span>            <span class="hljs-keyword">if</span>(A[i][j] &lt; A[i][k] + A [k][j]) &#123;<span class="hljs-comment">//若以vk为中转点的路径更短</span>                A[i][j] = A[i][k] + A [k][j];<span class="hljs-comment">//更新最短路径长度</span>                path[i][j] = k;<span class="hljs-comment">//记录中转点k</span>            &#125;    &#125;&#125;</code></pre></div><p>时间复杂度 ：<span class="math inline">\(O(|V|^3)\)</span></p><blockquote><p>Floyd算法允许图中带有负权值的边，但不允许有包含带负权值边组成的回路</p></blockquote><h3 id="有向无环图描述表达式">5.3、有向无环图描述表达式</h3><p>有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230308145226726-2024-12-810:51:36.png" alt="image-20230308145226726" style="zoom:50%;" /></p><p>利用DAG图可以解决部分表达式在二叉树中重复出现的情况，实现对子式的共享，从而节省存储空间。</p><p>处理步骤如下：</p><ol type="1"><li>将各个操作数<strong>不重复地</strong>排成一排。（让最终顶点中不可能出现重复的操作数）</li><li>标出各个运算符生效的顺序。（顺序不同，最后的DAG图的形状可能不同，但其中结点数相同）</li><li>按顺序加入运算符，<strong>注意分层</strong>。当某个运算符要用到其他运算符的结果时，其位于更上一层。</li><li>从底向上检查<strong>同层</strong>运算符是否可以合体。若同一层中，两个运算符相同，左右操作数也相同，就可以合体，舍弃另一个。若一层中只有一个操作符，就用于考虑合体。</li></ol><p><img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-03-08_14-58-57-2024-12-810:51:42.png" alt="Snipaste_2023-03-08_14-58-57" style="zoom: 45%;" /></p><h3 id="拓扑排序">6.4.4、拓扑排序</h3><p><strong>AOV网</strong>：用DAG图表示一个工程，顶点表示活动，有向边表示活动之间的顺序关系的图，称为用顶点表示活动的网络，记为AOV网。（用顶点<strong>V</strong>ertex表示活动<strong>A</strong>ctivity）</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230308162229163-2024-12-810:51:54.png" alt="image-20230308162229163" style="zoom:50%;" /></p><p><strong>拓扑排序</strong>：即找到做事的先后顺序</p><p>在图论中，有一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序</p><ul><li>每个顶点出现且只出现一次。</li><li>若顶点A排在顶点B的前面，则在图中不存在从顶点B到顶点A的<u><strong>路径</strong></u>。</li></ul><p>或定义为：拓扑排序是对<u>有向无环图</u>顶点的一种排序，它使得若存在一条从顶点A顶点B的路径，则在排序序列中顶点B出现在顶点A的后面。</p><p><strong>每个AOV网都有一个或多个拓扑排序序列</strong>。若一个顶点有多个直接后继，则拓扑排序结果不唯一。若有向图的拓扑序列唯一，则图中必定只有一个顶点的入度为<spanclass="math inline">\(0\)</span>，只有一个顶的出度为<spanclass="math inline">\(0\)</span>。</p><blockquote><p>对一个有向图来说，若其邻接矩阵为三角矩阵，则存在拓扑序列，但不一定唯一。</p><p>有向无环图的拓扑序列唯一，并不能唯一确定该图</p></blockquote><p>拓扑排序的实现思路：</p><ol type="1"><li>从AOV网中选择一个没有前驱的顶点（入度为<spanclass="math inline">\(0\)</span>）并输出。</li><li>从AOV网中删除该顶点和所有以它为起点的有向边。</li><li>重复1,2知道AOV网为空 或 当前网中不存在无前驱的顶点为止</li></ol><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230308153335979-2024-12-811:05:27.png" alt="image-20230308153335979" style="zoom:55%;" /></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230308154206648-2024-12-811:05:29.png" alt="image-20230308154206648" style="zoom:55%;" /></p><p>使用邻接表存储该有向图，用indegree[]存储各个顶点的入度，用print[]数组记录拓扑序列，用栈s保存当前入度为<spanclass="math inline">\(0\)</span>的顶点，使用count记录已输出顶点的个数，若最终count等于顶点数，则拓扑排序完成，否则说明有环。</p><p>拓扑排序中的顶点之间不存在祖先或子孙关系，它们在拓扑序列中的关系是任意的，保存入度为<spanclass="math inline">\(0\)</span>的顶点使用栈、队列或者数组都可以，暂存的都是入度为<spanclass="math inline">\(0\)</span>的顶点，此时入度为<spanclass="math inline">\(0\)</span>的所有结点之间没有关系。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TopologicalSort</span><span class="hljs-params">(Graph G)</span> </span>&#123;    <span class="hljs-built_in">InitStack</span>(S);    <span class="hljs-type">int</span> indegree[G.vexnum] = &#123;<span class="hljs-number">0</span>&#125;;    <span class="hljs-comment">//扫描领接表，计算各顶点的入度</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)        <span class="hljs-keyword">for</span> (p = G.vertices[i].firstarc; p ;p = p-&gt;nextarc)            Indegree[p-&gt;adjvex]++;        <span class="hljs-comment">//保存图中入度为0的顶点</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G.vexnum; i++)         <span class="hljs-keyword">if</span> (indegree[i] == <span class="hljs-number">0</span>)            <span class="hljs-built_in">push</span>(S,i);    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录已经输入的顶点数</span>    <span class="hljs-keyword">while</span> (! <span class="hljs-built_in">IsEmpty</span>(S)) &#123; <span class="hljs-comment">//栈不为空，说明有度为0的顶点</span>        <span class="hljs-built_in">pop</span>(S,i);         print[count++] = i; <span class="hljs-comment">//输出栈顶元素，count++</span>        <span class="hljs-comment">//将所i指向的顶点入度减一，并且将入度减为0的顶点压入栈中</span>        <span class="hljs-keyword">for</span> (p = G.vertices[i].firstarc; p; p = p-&gt;nextarc) &#123;            v = p-&gt;adjvex; <span class="hljs-comment">//边表结点对应的顶点编号</span>            <span class="hljs-keyword">if</span> (!(--indegree[v]))                <span class="hljs-built_in">push</span>(S,v);<span class="hljs-comment">//此时v的入度为0，压入栈中</span>        &#125;<span class="hljs-comment">//for</span>    &#125;<span class="hljs-comment">//while</span>    <span class="hljs-keyword">if</span>(count &lt; G.vexnum) <span class="hljs-comment">// **拓扑排序失败，图中有回路**</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//拓扑排序成功</span>&#125;</code></pre></div><p>由于要访问各个顶点和每条边，在用邻接表存储时，时间复杂度为<spanclass="math inline">\(O(|V|+|E|)\)</span>；用邻接矩阵存储时，时间复杂度为<span class="math inline">\(O(|V|^2)\)</span></p><p><strong>逆拓扑排序</strong></p><p>对一个AOV网，如果采用下列步骤进行排序，则称之为逆拓扑排序：</p><ol type="1"><li>从AOV网中选择一个没有后继（出度为<spanclass="math inline">\(0\)</span>）的顶点并输出。</li><li>从网中删除该顶点和所有以它为终点的有向边</li><li>重复1,2直到当前的AOV网为空</li></ol><p>实现逆拓扑排序：</p><ul><li>按照定义实现</li><li>利用DFS算法实现逆拓扑排序。由深度优先遍历的顶点出栈顺序得到的就是逆拓扑序列。在DFS中，每次当前结点没有指向下一结点的边时出栈，因此出栈的一定是出度为<spanclass="math inline">\(0\)</span>的顶点。</li></ul><h3 id="关键路径">6.4.5、关键路径</h3><p><strong>AOE网</strong>：在带权有向图中，以顶点表示事件，以有向边表示活动，以边的权值表示完成活动的开销，称之为用边表示活动的网络，简称AOE网。(用边<strong>E</strong>dge表示活动<strong>A</strong>ctivity)（<strong>事件的发生是瞬间的，而活动需要持续一段时间</strong>）</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230308162144446-2024-12-811:05:37.png" alt="image-20230308162144446" style="zoom:50%;" /></p><p>性质：</p><ul><li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始。</li><li>只有在进入某顶点的各有向边代表的活动都结束时，该顶点所代表的事件才能发生。有些活动是可以并行的</li></ul><p>在AOE网中仅有一个入度为<spanclass="math inline">\(0\)</span>的顶点，称为开始顶点（源点），它表示整个工程的开始；也仅有一个出度为<spanclass="math inline">\(0\)</span>的顶点，称为结束顶点（汇点），它表示整个工程的结束。</p><p>从源点到汇点的路径可能有多条，所有路径中<u>具有最大路径长度的路径</u>称为<strong>关键路径</strong>，关键路径上的活动称为<strong>关键活动</strong>。完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长</p><p><strong>寻找关键路径</strong></p><p>相关概念：</p><ul><li>事件<span class="math inline">\(v_k\)</span>的最早发生时间 <spanclass="math inline">\(ve(k)\)</span>：决定了所有从<spanclass="math inline">\(v_k\)</span>开始的活动能开工的最早时间</li><li><strong>活动<span class="math inline">\(a_i\)</span>的最早开始时间<spanclass="math inline">\(e(i)\)</span>：该活动弧的起点表示的事件发生的最早时间</strong>*</li><li>事件<span class="math inline">\(v_k\)</span>的最迟发生时间 <spanclass="math inline">\(vl(k)\)</span>：指不推迟整个工程完成的前提下，该事件最迟必须发生的时间</li><li><strong>活动<span class="math inline">\(a_i\)</span>的最迟发生时间<spanclass="math inline">\(l(i)\)</span>：指该活动弧的终点表示的事件的最迟发生时间和该活动所需时间之差</strong></li><li>活动<span class="math inline">\(a_i\)</span>的时间余量 <spanclass="math inline">\(d(i) = l(i) -e(i)\)</span>，表示在不增加整个工程完成总时间的情况下，活动<spanclass="math inline">\(a_i\)</span>可以拖延的时间</li></ul><p>若有一个活动的时间余量为<spanclass="math inline">\(0\)</span>，则说明该活动必须如期完成。<spanclass="math inline">\(d(i) = 0\)</span>,即<spanclass="math inline">\(l(i) = e(i)\)</span>的活动为关键活动。</p><p>关键活动组成的路径为关键路径。</p><p>求关键路径的方法：</p><ol type="1"><li><p>求所有事件的最早发生时间</p><p>按照<strong>拓扑排序序列</strong>，依次求各个顶点的 <spanclass="math inline">\(ve(k)\)</span>。<spanclass="math inline">\(ve(源点) = 0\)</span>。</p><p><span class="math inline">\(ve(k) = max\{ve(j)+weight&lt;v_j,v_k&gt;\}\)</span>，即<u>前驱加权值的最大值</u>，<spanclass="math inline">\(v_j\)</span>是<spanclass="math inline">\(v_k\)</span>的任意前驱</p></li><li><p>求所有事件的最迟发生时间</p><p>按<strong>逆拓扑排序序列</strong>，依次求各个顶点的 <spanclass="math inline">\(vl(k)\)</span>。 <spanclass="math inline">\(vl(汇点) = ve(汇点)\)</span></p><p><span class="math inline">\(vl(k) =min\{vl(j)-weight&lt;v_K,v_j&gt;\}\)</span>，即<u>后继减权值的最小值</u>，<spanclass="math inline">\(v_j\)</span>是<spanclass="math inline">\(v_k\)</span>的任意后继</p></li><li><p>求所有活动的最早发生时间</p><p>若边<span class="math inline">\(&lt;v_k,v_j&gt;\)</span>表示活动<span class="math inline">\(a_i\)</span>，则 <spanclass="math inline">\(e(i) =ve(k)\)</span>，即弧起点的最早发生时间</p></li><li><p>求所有活动的最迟发生时间</p><p>若边<span class="math inline">\(&lt;v_k,v_j&gt;\)</span>表示活动<span class="math inline">\(a_i\)</span>，则<spanclass="math inline">\(l(i) = l(j) -weight&lt;v_k,v_j&gt;\)</span>，即弧终点的最迟发生时间-权值</p></li><li><p>求时间余量</p><p><span class="math inline">\(d(i) = l(i) - e(i)\)</span>。<spanclass="math inline">\(d(i) =0\)</span>的活动就是关键活动，由关键活动可得关键路径。</p></li></ol><p>特性：</p><ul><li>若关键活动的时间增加，则整个工程的工期将延长</li><li>缩短关键活动的时间，可以缩短整个工程的工期。当关键活动时间缩短到一定程度时，关键活动可能会变为非关键活动。</li><li>当有多条关键路径时，只有加快那些包含在所有关键路径上的关键活动才能缩短整个工期（<strong>同时加快每条关键路径才能缩短工期</strong>）<ul><li>错误说法：任何一个关键活动提前完成，将使整个工程提前完成。（其他的关键活动可能延期）</li><li>正确说法：任何一个关键活动不按期完成，将会影响整个工程的完成时间。所有关键活动提前完成，那么整个工程将会提前完成。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>广度优先遍历</tag>
      
      <tag>深度优先遍历</tag>
      
      <tag>最小生成树</tag>
      
      <tag>最短路径</tag>
      
      <tag>拓扑排序</tag>
      
      <tag>关键路径</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>五、树和二叉树</title>
    <link href="/453281de/"/>
    <url>/453281de/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="一树的基本概念">一、树的基本概念</h2><h3 id="树的定义">1.1、树的定义</h3><p>树的定义：树是一种递归的数据结构，是n（n≥0）个结点的有限集。当n=0时，称为空树。在任意一棵非空树中满足：</p><ul><li>有且仅有一个根节点</li><li>当n&gt;1时，其余节点可分为m(m&gt;0)个不相交的有限集T1,T2,..Tm，其中每个集合本身又是一棵树，并且称为根的子树</li></ul><p>非空树的性质：</p><ul><li>有且仅有一个根结点。</li><li>根结点没有前驱，除根结点外的所有结点有且仅有一个前驱。</li><li>每个结点可以有0个或多个后继。</li><li>没有后继的结点称为叶子结点，有后继的结点称为分支结点。</li></ul><p>树是一种递归的数据结构，是一种<strong>逻辑结构</strong>，也是一种分层结构，适合于表示具有层次结构的数据。</p><h3 id="基本术语">1.2、基本术语</h3><p>结点之间关系的描述：</p><ul><li><p>祖先结点：从该结点到根结点的唯一路径上的所有结点，均是其祖先结点。</p></li><li><p>子孙结点：从该结点出发的所有分支中的结点，都是其子孙结点。</p></li><li><p>双亲结点（父结点）：一个结点的直接前驱是其父结点。</p></li><li><p>孩子结点：一个结点的直接后继是其孩子结点。</p></li><li><p>兄弟结点：有相同双亲的结点称为兄弟结点。</p></li><li><p>堂兄弟结点：双亲在同一层的结点互为堂兄弟。</p></li><li><p>路径：树中两个结点之间的路径是由这两个结点之间所经过的<strong>结点序列</strong>构成。由于树中的分支是有向的，即双亲指向孩子，所以<strong>树中的路径是从上向下的</strong>。</p></li><li><p>路径长度：路径上所经过的<strong>边的个数</strong>。</p><ul><li>树的路径长度：从根结点到每个结点的路径长度之和（注意和哈夫曼树的带权路径长度相区别）</li><li>树的内路径长度：除叶结点外，从根到树中其他所有结点的路径长度之和</li><li>树的外路径长度：从根结点到树中所有叶子结点的路径长度之和</li></ul></li></ul><p>结点、树的属性描述：</p><ul><li><p>结点的层次（深度）：是从根结点开始<strong>自顶向下</strong>逐层累加的。（水面）</p></li><li><p>节点的高度：从叶节点开始<strong>自底向上</strong>逐层累加的。（高楼）</p></li><li><p>树的高度（深度）：总共有多少层。</p></li><li><p>结点的度：孩子的个数称为该结点的度。</p></li><li><p>树的度：各结点度的最大值。</p></li><li><p>有序树：逻辑上看，树中的各个子树从左至右是有次序的，不能互换。</p></li><li><p>无序树：逻辑上看，树中的各个子树从左至右是没有次序的，可以互换。</p></li></ul><p>具体看需要用树存储什么信息，是否需要用节点的左右位置来反应某些逻辑关系，若需要则为有序树，否则为无序树。</p><ul><li>森林：m(m≥0)个互不相交的树的集合</li></ul><h3 id="树的常考性质">1.3、树的常考性质</h3><ul><li><p><strong>总结点数 = 总度数 + 1</strong>（总度数即树所有分支的个数，即除根结点外所有结点的个数）</p></li><li><p>度为m的树和m叉树</p><ul><li><p>度为m的树：树中所有结点的最大度数为m</p></li><li><p>m叉树：每个结点最多有m个孩子的树，即每个结点的度最大是m，也可以为0</p></li></ul><table><thead><tr class="header"><th>度为m的树</th><th>m叉树</th></tr></thead><tbody><tr class="odd"><td>任意结点的度 ≤ m</td><td>任意结点的度 ≤ m</td></tr><tr class="even"><td>至少有一个度为m的结点</td><td>允许所有结点的度均小于m</td></tr><tr class="odd"><td>一定是非空树，至少有m+1个结点</td><td>可以是空树</td></tr></tbody></table></li><li><p>度为m的树第i层至多有<spanclass="math inline">\(m^{i-1}\)</span>个结点。（第一层有一个，第二层有m个，第三层有<spanclass="math inline">\(m^2\)</span>个，以此类推）</p><p>m叉树的第i层至多有<spanclass="math inline">\(m^{i-1}\)</span>个结点。</p></li><li><p>高度为h的m叉树至多有<spanclass="math inline">\(\frac{m^h-1}{m-1}\)</span>个结点（等比数列求和），至少有h个结点</p></li><li><p>高度为h，度为m的树至多有<spanclass="math inline">\(\frac{m^h-1}{m-1}\)</span>个结点，至少有h+m-1个结点</p></li><li><p>具有n个结点的m叉树，其最大高度为n，最小高度为<spanclass="math inline">\(\lceil \log_m{[n(m-1)+1]}\rceil\)</span>。</p><p>具有n个结点的度为m的树，其最大高度为<spanclass="math inline">\(n-m+1\)</span>,最小高度为<spanclass="math inline">\(\lceil \log_m{[n(m-1)+1]}\rceil\)</span>。</p><ul><li><p>推导：设最小高度为h，则前h-1层最多共有 <spanclass="math inline">\(\frac{m^{h-1}-1}{m-1}\)</span>个结点，前h层最多共有<spanclass="math inline">\(\frac{m^h-1}{m-1}\)</span>个结点</p><p><span class="math inline">\(\therefore\)</span> <spanclass="math inline">\(\frac{m^{h-1}-1}{m-1}\)</span> &lt; $n $ ≤ <spanclass="math inline">\(\frac{m^h-1}{m-1}\)</span></p><p><span class="math inline">\(\therefore\)</span> <spanclass="math inline">\(m^{h-1}\)</span> &lt; <spanclass="math inline">\(n(m-1) + 1\)</span> ≤ <spanclass="math inline">\(m^h\)</span></p><p><span class="math inline">\(\therefore\)</span> <spanclass="math inline">\(h-1\)</span> &lt; <spanclass="math inline">\(log_m{[n(m-1)+1]}\)</span> ≤ <spanclass="math inline">\(h\)</span></p><p><span class="math inline">\(\therefore\)</span> <spanclass="math inline">\(h = \lceillog_m{[n(m-1)+1]}\rceil\)</span></p></li></ul></li><li><p>对度为m的树，<spanclass="math inline">\(n_i\)</span>表示度为<spanclass="math inline">\(i\)</span>的结点个数</p><ul><li>总结点数 <spanclass="math inline">\(=n_0+n_1+...+n_m\)</span>，其中<spanclass="math inline">\(n_0\)</span>表示叶子结点的个数</li><li>总度数 <spanclass="math inline">\(=n_1*1+n_2*2+...+n_m*m\)</span>，总度数即总分支数，度为<spanclass="math inline">\(i\)</span>的结点有<spanclass="math inline">\(n_i\)</span>个，度为<spanclass="math inline">\(i\)</span>的结点引出<spanclass="math inline">\(i\)</span>条分支。</li><li>总结点数 = 总度数 + 1。</li></ul></li></ul><h2 id="二二叉树">二、二叉树</h2><h3 id="二叉树的定义及特性">2.1、二叉树的定义及特性</h3><p><strong>定义</strong>：二叉树是n（n≥0）个结点的有限集合：</p><ul><li>或者为空二叉树，即<span class="math inline">\(n=0\)</span></li><li>或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一颗二叉树。</li></ul><p>特点：每个结点至多有两棵子树；<strong>二叉树是有序树，左右子树不能颠倒。</strong></p><p><strong>区分二叉树和度为二的有序树</strong>：</p><ul><li>度为<span class="math inline">\(2\)</span>的有序树至少有<spanclass="math inline">\(3\)</span>个结点，而二叉树可以为空。</li><li>度为<spanclass="math inline">\(2\)</span>的有序树的孩子的左右次序是相对于另一个孩子而言的，若某个结点只有一个孩子，则这孩子就无须区分其左右次序。而二叉树无论其孩子数是否为<spanclass="math inline">\(2\)</span>，均需确定其左右次序，即<strong>二叉树的结点间次序不是相对于另一结点而言，而是确定的。</strong></li></ul><h3 id="几个特殊的二叉树">2.2、几个特殊的二叉树</h3><p><strong>满二叉树</strong></p><p>一棵高度为<span class="math inline">\(h\)</span>，且含有<spanclass="math inline">\(2^h-1\)</span>个结点的二叉树，即树中每层都含有最多的结点。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230216152040612-2024-12-723:06:46.png" alt="image-20230216152040612" style="zoom: 50%;" /></p><ul><li>只有最后一层有叶子结点</li><li>不存在度为 <span class="math inline">\(1\)</span> 的结点</li><li>按层序从 <span class="math inline">\(1\)</span> 开始编号，结点 <spanclass="math inline">\(i\)</span> 的左孩子为 <spanclass="math inline">\(2i\)</span> ,结点 <spanclass="math inline">\(i\)</span> 的右孩子为 <spanclass="math inline">\(2i+1\)</span> ；<spanclass="math inline">\(i\)</span> 结点的父节点为 <spanclass="math inline">\(\lfloor i/2\rfloor\)</span>（如果有的话）。<ul><li>对于一棵满m叉树，按层序从1开始编号，结点<spanclass="math inline">\(i\)</span>的第一个孩子编号为 <spanclass="math inline">\((i-1)*m+2\)</span>，结点<spanclass="math inline">\(i\)</span>的双亲结点编号为 $ +1$。</li><li>推导：首先对于第<spanclass="math inline">\(i\)</span>个分支结点，其前面有 <spanclass="math inline">\(i-1\)</span>个分支结点，而每个分支结点都有<spanclass="math inline">\(m\)</span>个孩子，故第<spanclass="math inline">\(i\)</span>个分支结点的第一个孩子前 共有 <spanclass="math inline">\((i-1)*m+1\)</span>个结点（1是根结点），故其第一个孩子的编号为<spanclass="math inline">\((i-1)*m+2\)</span>；反推得，结点<spanclass="math inline">\(i\)</span>的双亲结点编号为<spanclass="math inline">\(\lfloor \frac{(i-2)}{m} \rfloor +1\)</span>。</li></ul></li><li>n个结点的满二叉树中有 <span class="math inline">\(\color{red}\frac{n+1}{2}\)</span>个叶子结点。（<span class="math inline">\(n =2^h-1\)</span>，叶子结点个数为 <span class="math inline">\(2^{h-1} =\frac{n+1}{2}\)</span> ）</li></ul><p><strong>完全二叉树</strong></p><p>当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树。（在对应满二叉树的基础上，去掉一些<u>连续的编号更大的</u>结点后，即为完全二叉树。）</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230216153410676-2024-12-723:06:59.png" alt="image-20230216153410676" style="zoom:50%;" /></p><ul><li><p>只有最后两层可能有叶子结点</p></li><li><p><strong>最多存在一个度为 <span class="math inline">\(1\)</span>的结点，且该结点只有左孩子而没有右孩子。</strong></p></li><li><p>编号规则和满二叉树相同</p></li><li><p>总结点数为<span class="math inline">\(n\)</span> ，编号为 <spanclass="math inline">\(i\)</span> 的结点，<span class="math inline">\(i\leq \lfloor n/2 \rfloor\)</span> 时为分支结点，<spanclass="math inline">\(i \geq \lfloor n/2 \rfloor\)</span>时为叶子结点。（<span class="math inline">\(\lfloorn/2\rfloor\)</span>,即<span class="math inline">\(\lfloor 前h-1层结点个数\rfloor\)</span>）</p></li></ul><blockquote><p>满二叉树是一种特殊的完全二叉树，但完全二叉树不一定是满二叉树。</p></blockquote><p><strong>二叉排序树</strong></p><ul><li><p>定义：一棵二叉树或者是空二叉树，或者是具有以下性质的二叉树</p><ul><li>左子树上所有结点的关键字均小于根结点的关键字</li><li>右子树上所有结点的关键字均大于根结点的关键字</li><li>左子树和右子树又分别是一棵二叉排序树</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230216155034041-2024-12-723:07:08.png" alt="image-20230216155034041" style="zoom:50%;" /></p></li><li><p>二叉排序树可用于元素的排序、搜索，若一棵二叉排序树是平衡二叉树，其效率会高很多。</p></li></ul><p><strong>平衡二叉树</strong></p><ul><li><p>树上任一结点的左子树和右子树的深度之差不超多 <spanclass="math inline">\(1\)</span>。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230216155116782-2024-12-723:07:14.png" alt="image-20230216155116782" style="zoom: 50%;" /></p></li></ul><h3 id="二叉树的常考性质">2.3、二叉树的常考性质</h3><ul><li><p><strong><span class="math inline">\(n\)</span> 个结点可以构成<span class="math inline">\(\color{red} \frac{1}{n+1}C_{2n}^{n}\)</span> （卡特兰数）个不同的二叉树</strong></p></li><li><p>设<strong>非空二叉树</strong>中度为0、1、2的结点的个数分别为<span class="math inline">\(n_0,n_1，n_2\)</span>，则 <spanclass="math inline">\(\color{red}n_0 = n_2 +1\)</span>。<strong>（叶子结点比二分支结点多一个）</strong></p><p>推导：总结点数 <span class="math inline">\(n = n_0 + n_1 +n_2\)</span>，<span class="math inline">\(n = n_1 + 2n_2 +1\)</span>，故 <span class="math inline">\(n_0 = n_2 +1\)</span></p></li><li><p>二叉树第 <span class="math inline">\(i\)</span> 层最多有 <spanclass="math inline">\(2^{i-1}\)</span> 个结点</p></li><li><p>高度为 <span class="math inline">\(h\)</span> 的二叉树至多有<span class="math inline">\(2^h - 1\)</span> 个结点（满二叉树）。</p></li></ul><p>完全二叉树的常考性质：</p><ul><li><p><strong>具有 <span class="math inline">\(n\)</span> （<spanclass="math inline">\(n&gt;0\)</span>）个结点的完全二叉树，其高度为<span class="math inline">\(\lceil log_2{(n+1)}\rceil\)</span>或 <spanclass="math inline">\(\lfloor log_2n\rfloor + 1\)</span>。</strong></p><p><strong>同理，第 <span class="math inline">\(i\)</span>个结点所在的层次为 <span class="math inline">\(\lceillog_2{(i+1)}\rceil\)</span>或 <span class="math inline">\(\lfloorlog_2i\rfloor + 1\)</span>。</strong></p><p>推导：高为 <span class="math inline">\(h\)</span> 的二叉树至多有<span class="math inline">\(2^h - 1\)</span>个结点，高度为 <spanclass="math inline">\(h-1\)</span> 的二叉树至多有 <spanclass="math inline">\(2^{h-1} - 1\)</span> 个结点</p><p>​ <span class="math inline">\(\therefore\)</span> <spanclass="math inline">\(2^{h-1} -1 &lt; n \le 2^h -1\)</span></p><p>​ <span class="math inline">\(\therefore\)</span> <spanclass="math inline">\(h-1 &lt; log_2{(n+1)} \le h\)</span></p><p>​ <span class="math inline">\(\therefore\)</span> <spanclass="math inline">\(h = \lceil log_2{(n+1)}\rceil\)</span></p><p>​ 或者，高为 <span class="math inline">\(h-1\)</span> 的二叉树至多有$2^{h-1} -1 $个结点，故高为 <span class="math inline">\(h\)</span>的二叉树至少比其多一个结点，为<spanclass="math inline">\(2^{h-1}\)</span>个；高为 <spanclass="math inline">\(h\)</span> 的二叉树至多有 $2^{h} -1$个结点，故高为 <span class="math inline">\(h+1\)</span>的二叉树至少比其多一个结点，为<spanclass="math inline">\(2^h\)</span>个</p><p>​ <span class="math inline">\(\therefore\)</span> <spanclass="math inline">\(2^{h-1} \le n &lt;2^h\)</span></p><p>​ <span class="math inline">\(\therefore\)</span> <spanclass="math inline">\(h-1 \le log_2n &lt; h\)</span></p><p>​ <span class="math inline">\(\therefore\)</span> <spanclass="math inline">\(h = \lfloor log_2n\rfloor + 1\)</span></p></li><li><p>高度为 <span class="math inline">\(h\)</span> 的完全二叉树至少有<span class="math inline">\(2^{h-1}\)</span>个结点，最多有 <spanclass="math inline">\(2^h -1\)</span>个结点。</p></li><li><p><strong>对于完全二叉树，可由结点数 <spanclass="math inline">\(n\)</span> 推断出度为 <spanclass="math inline">\(0,1,2\)</span>的结点个数 <spanclass="math inline">\(n_0,n_1,n_2\)</span>。</strong></p><p><span class="math inline">\(\because\)</span>完全二叉树最多有一个度为 1 的结点，故 <span class="math inline">\(n_1 =0\)</span>或<span class="math inline">\(1\)</span></p><p>又<span class="math inline">\(\because\)</span> <spanclass="math inline">\(n_0 = n_2 + 1\)</span>， <spanclass="math inline">\(\therefore\)</span> <spanclass="math inline">\(n_0 + n_2 = 2 n_2 + 1\)</span></p><p><span class="math inline">\(\therefore\)</span> $ n_0 + n_2一定是奇数$</p><p>当结点数<span class="math inline">\(n =2k\)</span>个为偶数时，<spanclass="math inline">\(n_1 =1, n_0 =k,n_2=k-1\)</span>；即 <spanclass="math inline">\(n_1 =1, n_0=\frac{n}{2},n_2={\frac{n}{2}-1}\)</span></p><p>当结点数<span class="math inline">\(n =2k-1\)</span>个为奇数时，<span class="math inline">\(n_1 =0, n_0=k,n_2=k-1\)</span>；即<span class="math inline">\(n_1 =0, n_0=\frac{n+1}{2},n_2=\frac{n+1}{2}-1\)</span></p></li></ul><h3 id="二叉树的存储结构">2.4、二叉树的存储结构</h3><p><strong>二叉树的顺序存储</strong></p><p>​二叉树的顺序存储是指用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。</p><p>​依据二叉树的性质，<strong>满二叉树和完全二叉树用顺序存储比较合适</strong>，对一般的二叉树，为了让数组下标反映二叉树中结点之间的关系，只能添加一些空结点，造成存储空间的大量浪费。</p><p><strong>二叉树的链式存储</strong></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span>&#123;    ElemType data;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lchild, *rchild;&#125;BiTNode, *BiTree;</code></pre></div><p><strong>在含有<span class="math inline">\(n\)</span>个结点的二叉链表中，有<spanclass="math inline">\(n+1\)</span>个空链域。</strong></p><h3 id="二叉树的遍历">2.5、二叉树的遍历</h3><p>二叉树的遍历是指按某条搜索路径访问树中的每个结点，使得每个结点均被访问一次，且仅被访问一次。</p><p>遍历一棵二叉树便要决定对根节点<span class="math inline">\(N\)</span>,左子树 <span class="math inline">\(L\)</span> 和右子树 <spanclass="math inline">\(R\)</span> 的访问顺序，常见的遍历次序有 先序<spanclass="math inline">\((NLR)\)</span>、中序<spanclass="math inline">\((LNR)\)</span>、后序<spanclass="math inline">\((LRN)\)</span>三种遍历方法。<strong>其中的”序“是指访问根结点在何时被访问。三种遍历算法中，遍历左、右子树的顺序是固定的，只是访问根结点的顺序不同，所以叶子结点的先后顺序是完全相同的。</strong></p><h4 id="先序遍历nlr">先序遍历（NLR）</h4><blockquote><p>递归遍历</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        preOrder(root,res);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preOrder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;         res.add(root.val);        preOrder(root.left,res);        preOrder(root.right,res);    &#125;&#125;</code></pre></div><blockquote><p>非递归遍历</p></blockquote><ul><li>首先根节点入栈。</li><li>此后，若栈不为空，则弹出栈顶元素访问。若栈顶元素右孩子不为空，则先入栈右孩子；若栈顶元素左孩子不为空，则再入栈左孩子。（由于栈后进先出的特性，入栈时先右后左，出栈处理时先左后右）</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();         <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;            Stack&lt;TreeNode&gt; nodeStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;TreeNode&gt;();            TreeNode node;            nodeStack.push(root);            <span class="hljs-keyword">while</span> (!nodeStack.empty()) &#123;                node = nodeStack.pop();                list.add(node.val); <span class="hljs-comment">//根</span>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//右</span>                    nodeStack.push(node.right);                &#125;                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//左</span>                    nodeStack.push(node.left);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> list;    &#125;</code></pre></div><h4 id="中序遍历lnr">中序遍历（LNR）</h4><blockquote><p>递归遍历</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        inOrder(root, res);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inOrder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;        inOrder(root.left, res);        res.add(root.val);        inOrder(root.right, res);    &#125;&#125;</code></pre></div><blockquote><p>非递归遍历</p></blockquote><p>思路：①沿着根的左孩子，依次入栈，直至左孩子为空。此时说明已经找到可以输出的结点；②栈顶元素出栈并访问，若其右孩子为空，继续执行②，若其右孩子不为空，将右子树转执行①。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>();    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;TreeNode&gt; ();    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> root;    <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span> || !stack.empty()) &#123;        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//一路向左，不空就入栈</span>            stack.push(p);            p = p.left;        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//左孩子为空，可以访问当前结点，出栈</span>            p = stack.pop();            list.add(p.val);            p = p.right; <span class="hljs-comment">//转向右孩子</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> list;&#125;</code></pre></div><p>将其中访问结点的操作<code>list.add(p.val)</code>，放在左孩子入栈前即为先序遍历</p><h4 id="后序遍历lrn">后序遍历（LRN）</h4><blockquote><p>递归遍历</p></blockquote><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;    <span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;        List&lt;Integer&gt;res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        postOrder(root,res);        <span class="hljs-keyword">return</span> res;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postOrder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt;res)</span> &#123;        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;        postOrder(root.left,res);        postOrder(root.right,res);        res.add(root.val);    &#125;&#125;</code></pre></div><blockquote><p>非递归遍历</p></blockquote><p>方法一：按照先序遍历的做法，先根节点入栈，再右孩子入栈，再左孩子入栈，最后得到的遍历序列是<code>根 左 右</code>, 若颠倒其中左右孩子入栈顺序可到最终的遍历顺序为<code>根 右 左</code>，再将其逆序（不直接输出，而是存入另一个栈中）可得到后序遍历序列<code>左 右 根</code></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;TreeNode&gt;();        TreeNode node;         <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) &#123;            stack.push(root);            <span class="hljs-keyword">while</span> (!stack.empty()) &#123;                node = stack.pop();                list.add(node.val);                <span class="hljs-comment">//入栈时顺序为：根左右，出栈收集时得到顺序为：根右左，最后逆序即可得到后序遍历序列</span>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;                    stack.push(node.left);                &#125;                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;                    stack.push(node.right);                &#125;            &#125;        &#125;    Collections.reverse(list);<span class="hljs-comment">//逆序</span>        <span class="hljs-keyword">return</span> list;&#125;</code></pre></div><p>方法二：用一个栈实现。使用c指向栈顶结点，h跟踪刚出栈访问的结点。</p><p>对于后序序列 ：左 右 根，</p><ul><li>当栈顶元素的左孩子不为空且刚出栈访问的结点h不是栈顶结点c的左孩子，h也不是右孩子时（当h是右孩子时，说明右子树已经处理完了，左子树也一定处理完了），说明c的左子树还未后序遍历完，将左孩子入栈；</li><li>当栈顶元素的右孩子不为空且刚出栈的不是右孩子时，说明右子树未处理完，将右孩子入栈；</li><li>最后当左右孩子都处理完，或左右孩子均为空时，栈顶元素出栈访问</li></ul><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;                List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();        Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;TreeNode&gt;();        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> list;        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> root; <span class="hljs-comment">//跟踪最近出栈的结点</span>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//c指向栈顶结点</span>        stack.push(h);        <span class="hljs-keyword">while</span> (!stack.empty()) &#123;            c = stack.peek();             <span class="hljs-keyword">if</span> (c.left != <span class="hljs-literal">null</span> &amp;&amp; h != c.left &amp;&amp; h != c.right) <span class="hljs-comment">//最近出栈访问的既不是c左孩子也不是c的右孩子，则c的左子树还没处理完</span>                stack.push(c.left);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c.right != <span class="hljs-literal">null</span> &amp;&amp; h != c.right) <span class="hljs-comment">//最近出栈访问的不是c的右孩子，则c的右子树还未处理完</span>                stack.push(c.right);             <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//左右子树均处理完，或左右子树都为空时，处理当前结点</span>                h = stack.pop();                list.add(h.val);            &#125;        &#125;        <span class="hljs-keyword">return</span> list;     &#125;</code></pre></div><h4 id="层序遍历">层序遍历</h4><ol type="1"><li>初始化一个辅助队列，根节点入队</li><li>若队列非空，队头结点出队并访问该结点，将其左右孩子分别插到队尾（如果有的话）</li><li>重复2直至队列为空</li></ol><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LeverOrder</span><span class="hljs-params">(BiTree T)</span> </span>&#123;    <span class="hljs-built_in">InitQueue</span>(Q);    BiTree p;    <span class="hljs-built_in">EnQueue</span>(Q, T);    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">IsEmpty</span>(Q)) &#123;        <span class="hljs-built_in">DeQueue</span>(Q, p);        <span class="hljs-built_in">visit</span>(p);        <span class="hljs-keyword">if</span> (p-&gt;lchild != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-built_in">EnQueue</span>(p-&gt;lchild);        &#125;        <span class="hljs-keyword">if</span> (p-&gt;rchild != <span class="hljs-literal">NULL</span>) &#123;            <span class="hljs-built_in">EnQueue</span>(p-&gt;rchild);        &#125;    &#125;&#125;</code></pre></div><h4 id="由遍历序列构造二叉树">由遍历序列构造二叉树</h4><p>方法：先从前序、后序、层序序列中寻找根节点，再根据中序序列划分左右子树，再找左右子树的根节点，进一步划分。</p><ul><li>前序 + 中序： 前序： <u>根节点</u>、左子树前序遍历序列、右子树前序遍历序列</li><li>后序 + 中序：后序：左子树后序遍历序列、右子树后序遍历序列、<u>根节点</u></li><li>层序 + 中序： 层序： <u>根节点</u>、 左子树的根、右子树的根</li></ul><blockquote><p>注意点</p></blockquote><ul><li><p>要唯一确定一棵二叉树，必须给出<strong>中序遍历序列</strong>，以及另一种遍历序列。</p></li><li><p>先序和后序不能唯一确定一棵二叉树，但可以确定二叉树中结点的<strong>祖先关系</strong>，如先序序列为e bdc 和后序序列 bcd e,则e是bcd的祖先，b 和d是兄弟，d是c的祖先；</p></li><li><p>前中后序遍历次序是访问根结点的顺序不同，而<u>访问左右子树的次序是固定的</u>，所以<strong>左子树中结点在右子树结点之前，所有叶子结点的次序相同</strong></p></li><li><p>前序为NLR，后序为LRN，<strong>若前序序列和后序序列刚好相反</strong>，则不可能有一个结点同时有左右孩子，即所有非叶结点都只有一个孩子，则其树高为结点个数（要么为NL和LN，要么为NR和RN），只有一个叶结点；<strong>若前序序列和后序序列相同</strong>，即NLR= LRN，则L和R都为空，该二叉树只有一个根结点。</p></li><li><p>一棵二叉树的<strong>前序序列和中序序列相同</strong>，即NLR =LNR，则所有非叶结点都只能只有右孩子。</p></li><li><p>先序的最后一个结点，中序的最后一个结点、后序的第一个结点</p><ul><li>二叉树先序遍历的最后一个结点，先从根结点开始沿右孩子走到底，若该结点没有左孩子则该结点为最后一个遍历的结点，若有左孩子，则最后一个结点在其左子树中，同样的方法寻找。</li><li>二叉树中序遍历的最后一个结点，一定是从根开始沿右孩子走到底的结点</li><li>二叉树后序遍历的第一个结点，先从根节点开始沿左孩子走到底，若其没有右孩子，则为第一个结点；若有右孩子，则第一个结点在其右子树中，同样的方法寻找。</li></ul></li><li><p>根据二叉树前序遍历和中序遍历的递归算法种递归工作栈的状态变化得出：<strong>前序序列和中序序列的关系相当于以前序序列为入栈次序，以中序序列为出栈次序</strong>。所以根据给定的先序序列 abcd，可以确定的中序序列有 <spanclass="math inline">\(\frac{1}{n+1} C_{2n}^{n}\)</span>种，即<spanclass="math inline">\(\frac{1}{5}C_{8}^{4} =14\)</span>种，又由于根据先序序列和中序序列可以确定一棵二叉树，所以先序序列为abcd的二叉树有14种。</p></li></ul><h3 id="线索二叉树">2.6、线索二叉树</h3><h4 id="定义">定义</h4><p>​传统的二叉链表存储仅能体现父子关系（从上到下），<strong>不能直接得到结点在遍历序列中的前驱或后继</strong>，只能从根结点开始进行一次遍历才能确定。将二叉链表中空闲的<spanclass="math inline">\(\color{red}n+1\)</span>个空闲指针域利用起来，将其指向遍历序列中的前驱或后继，方便从一个指定结点出发，找到其前驱、后继，就可以像遍历单链表那样方便地遍历二叉树。</p><p>​<strong>线索，即指向遍历序列中前序或后继的指针。</strong>规定，若无左子树，lchild指向其前驱结点；若无右子树，rchild指向其后继节点。</p><p><strong>二叉树是逻辑结构，线索二叉树是存储结构</strong></p><h4 id="存储结构">存储结构</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadNode</span> &#123;    Elemtype data;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadNode</span> *lchild, *rchild;    <span class="hljs-type">int</span> ltag,rtag; <span class="hljs-comment">//左右线索标志，ltag为1时指针为线索，tag为0时，指针指向孩子。初始化时 tag都为0</span>&#125;ThreadNode, *ThreadTree;</code></pre></div><p>手算画出线索二叉树：确定线索二叉树的类型，按照对应的遍历规则确定各结点的访问顺序，并写上编号，再将n+1个空链域连上前驱和后继。</p><h4 id="二叉树的线索化">二叉树的线索化</h4><p>核心：<strong>对中序、先序、后序遍历算法的改造，当访问一个结点时，建立<u>该结点</u>和<u>其前驱</u>的线索信息。</strong></p><p>易错点：</p><ul><li><p>对最后一个结点rchild、rtag的处理</p></li><li><p>先序线索化中转圈的问题，当ltag =0时才能对左子树进行先序线索化</p></li></ul><p><strong>中序线索化</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225174818508-2024-12-800:12:51.png" alt="image-20230225174818508" style="zoom:50%;" /></p><div class="code-wrapper"><pre><code class="hljs c++">ThreadNode *pre = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//全局变量 pre，指向当前结点的前驱结点</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatInThread</span><span class="hljs-params">(ThreadTree T)</span> </span>&#123;    pre = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">if</span> (T != <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-built_in">InThread</span>(T); <span class="hljs-comment">//中序线索化</span>        <span class="hljs-keyword">if</span> (pre-&gt;rchild == <span class="hljs-literal">NULL</span>)  <span class="hljs-comment">//处理遍历的最后一个结点</span>            pre-&gt;rtag = <span class="hljs-number">1</span>;    &#125;&#125;<span class="hljs-comment">//中序遍历二叉树，一边遍历一边线索化</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InTread</span><span class="hljs-params">(ThreadTree T)</span> </span>&#123;    <span class="hljs-keyword">if</span> (T != <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-built_in">InThread</span>(T-&gt;lchild);        <span class="hljs-built_in">visit</span>(T);        <span class="hljs-built_in">InThread</span>(T-&gt;rchild);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ThreadNode *q)</span> </span>&#123;    <span class="hljs-keyword">if</span> (q-&gt;lchild == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//当前结点左子树为空，建立当前结点的前驱线索</span>        q-&gt;lchild = pre;        q-&gt;ltag = <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">if</span> (pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//建立前驱结点的后继线索</span>        pre-&gt;rchild = q;        pre-&gt;rtag = <span class="hljs-number">1</span>;    &#125;    pre = q; <span class="hljs-comment">//当前结点及其前驱已经处理完，开始准备下一个结点</span>&#125;</code></pre></div><p><strong>先序线索化</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225175853143-2024-12-723:51:31.png" alt="image-20230225175853143" style="zoom:50%;" /></p><p>当q指针指向D，D没有左孩子，建立前驱线索 lchild指向B，pre指向D；根据先序顺序，接下来该处理其左孩子，但在上步其左孩子已经指向了B，导致q再次指向B，出现了死循环。所以根据tag标志判断访问的是左子树还是前驱</p><div class="code-wrapper"><pre><code class="hljs c++">ThreadNode *pre = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//全局变量 pre，指向当前结点的前驱结点</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreatPreThread</span><span class="hljs-params">(ThreadTree T)</span> </span>&#123;...同上&#125;<span class="hljs-comment">//先序遍历二叉树，一边遍历一边线索化</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preTread</span><span class="hljs-params">(ThreadTree T)</span> </span>&#123;    <span class="hljs-keyword">if</span> (T != <span class="hljs-literal">NULL</span>) &#123;        <span class="hljs-built_in">visit</span>(T);        <span class="hljs-keyword">if</span> (T-&gt;ltag == <span class="hljs-number">0</span>)  <span class="hljs-comment">//lchid 不是前驱线索</span>        <span class="hljs-built_in">InThread</span>(T-&gt;lchild);        <span class="hljs-built_in">InThread</span>(T-&gt;rchild);    &#125;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(ThreadNode *q)</span> </span>&#123;...同上&#125;</code></pre></div><p><strong>后序线索化</strong></p><p>​ 同中序线索化，将中序遍历改为后序遍历即可。</p><h4 id="在线索二叉树中找前后驱">在线索二叉树中找前后驱</h4><p>若ltag或rtag为1，则lchild或rchild所指的就是其前驱或后继。</p><p><strong>中序线索二叉树 （LNR）</strong></p><ul><li><p>找p的前驱，若ltag =0，则必有左孩子，前驱为左孩子中最后一个被访问的结点，即<strong>左子树最右下的结点</strong></p></li><li><p>找p的后继，若 rtag =0，则必有右孩子，后继为右子树中第一个被访问的结点，即<strong>右子树中最左下的结点</strong></p></li></ul><p><strong>先序线索二叉树 (NLR)</strong></p><ul><li><p>找p的后继，若rtag =0，则必有右孩子，若也有左孩子，则后继为左孩子；若无左孩子，则后继为右孩子。（有左为左。无右为右）</p></li><li><p>找p的前驱，若ltag = 0且只有lchild和rchild两个指针域时无法找到其前驱。</p><p>要找到其前驱，需<strong>使用三叉链表，在每个结点中记录父节点信息</strong></p><ul><li>若能找到p的父节点，p是左孩子，则p的父节点就是p的前驱</li><li>若能找到p的父节点，p是右孩子且左孩子为空，则p的父节点就是p的前驱</li><li>若能找到p的父节点，p是右孩子且左孩子不为空，则<u>其左兄弟最后一个被遍历的结点即是p的前驱</u>。（先沿左兄弟的右孩子指针一直向下到最后一个，若此结点有左孩子，则再沿左孩子指针向下直到最后一个，依次类推，直至找到最后一个被遍历的结点）</li><li>如果p是根结点，则p无前驱。</li></ul></li></ul><p><strong>后序线索二叉树（LRN）</strong></p><ul><li><p>找p的前驱，若ltag =0，则必有左孩子，若也有右孩子，则右孩子为其前驱；若没有右孩子，则左孩子为其前驱。（有右为右，无右为左）</p></li><li><p>找p的后继，若rtag =0,且只有lchild和rchild两个指针域时无法找到其后继。（<strong>同先序找前驱</strong>）</p><p>要找到其后继，需<strong>使用三叉链表，在每个结点中记录父节点信息</strong></p><ul><li>若能找到p的父节点，p是右孩子，则p的父节点就是p的后继</li><li>若能找到p的父节点，p是左孩子且右孩子为空，则p的父节点就是p的后继</li><li>若能找到p的父节点，p是左孩子且右孩子不为空，则<u>其右兄弟第一个被遍历的结点即是p的后继</u>。（先沿右兄弟的左孩子指针一直向下到最后一个，若此结点有右孩子，则再沿右孩子指针向下直到最后一个，依次类推，直至找到最后一个被遍历的结点）</li><li>如果p是根结点，则p无后继。</li></ul></li></ul><table><thead><tr class="header"><th></th><th>中序线索二叉树</th><th>先序线索二叉树</th><th>后序线索二叉树</th></tr></thead><tbody><tr class="odd"><td>找前驱</td><td>✔</td><td>✘</td><td>✔</td></tr><tr class="even"><td>找后继</td><td>✔</td><td>✔</td><td>✘</td></tr></tbody></table><p>后序线索二叉树的遍历仍需要栈的支持，后序找后继不一定能直接找到。</p><h2 id="三树森林">三、树、森林</h2><h3 id="树的逻辑结构">3.1、树的逻辑结构</h3><p><strong>树</strong>是n（n&gt;0）个结点的有限集合，n=0时，称为空树。在任意一棵非空树中应满足：1）有且仅有一个特定的称为<strong>根</strong>的结点。2）当n&gt;1时，其余结点可分为m（m&gt;0）个<strong>互不相交的有限集</strong>合T1,T2...Tm，其中每个集合本身又是一棵树，并且称为根结点的<strong>子树</strong>。</p><ul><li>树是一种递归定义的数据结构</li></ul><h3 id="树的存储结构">3.2、树的存储结构</h3><p><strong>双亲表示法（顺序存储）</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225200402386-2024-12-723:58:02.png" alt="image-20230225200402386" style="zoom: 67%;" /></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;  <span class="hljs-comment">//树结点的定义</span>    <span class="hljs-type">int</span> data;    <span class="hljs-type">int</span> parent;&#125;PTNode;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">//树的类型定义</span>    PTNode nodes[MAX_TREE_SIZE];     <span class="hljs-type">int</span> n; <span class="hljs-comment">//结点数</span>&#125;</code></pre></div><p>每个结点中保存指向双亲的“指针”，其实就是使用<strong>静态数组</strong>存储。根节点固定存储在0，-1表示没有双亲。</p><ul><li>增加元素，将新元素放到数组末尾并保存双亲结点的位置。新增元素时无需按逻辑上的次序存储。</li><li>删除元素，若删除的是叶节点，可以使用数组最后一个元素覆盖当前结点的内容，并将总结点数减一，保证已存储的均有效，也方便遍历；若删除的是分支结点，则要找到其所有的子孙结点，也将它们全部删除。</li><li>查询孩子结点，需要从头遍历，判断每个位置的双亲结点和要查询的是否一致，依次找到所有的孩子节点。</li></ul><p>优点：查指定结点的双亲很方便；缺点：查指定结点的孩子结点只能从头遍历。</p><p><strong>孩子表示法（顺序+链式）</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225201513725-2024-12-723:58:12.png" alt="image-20230225201513725" style="zoom: 50%;" /></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_TREE_SIZE 100</span><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span>&#123; <span class="hljs-comment">//孩子链表结点的定义</span>    <span class="hljs-type">int</span> child; <span class="hljs-comment">//孩子节点在数组中的位置</span>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span> *next; <span class="hljs-comment">//指向下一个孩子</span>&#125;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">//结点数组元素的定义</span>    ElemType data;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CTNode</span> *firstChild;&#125;CTBox;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;    CTBox nodes[MAX_TREE_SIZE];    <span class="hljs-type">int</span> n,r; <span class="hljs-comment">//结点数和根的位置</span>&#125;CTree;</code></pre></div><p>顺序存储各个结点，每个结点中保存孩子链表的头指针。</p><p>该存储结构找孩子方便，找双亲时需要遍历n个结点对应的孩子链表，在里面找是否有指定结点。</p><p><strong>孩子兄弟表示法 （链式存储）</strong></p><p>左孩子右兄弟</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-02-25_20-30-40-2024-12-723:58:19.png" alt="Snipaste_2023-02-25_20-30-40" style="zoom: 67%;" /></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span>&#123;    ElemType data;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">CSNode</span> *firstchild, *nextsibling; <span class="hljs-comment">//第一个孩子 和 右兄弟指针</span>&#125;CSNode, *CSTree;</code></pre></div><p>该种存储表示法比较灵活，其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲比较麻烦（可以增设一个parent域指向父节点）。</p><h3 id="树森林和二叉树的转换">3.3、树、森林和二叉树的转换</h3><p>森林转换为二叉树：先将每棵树转换为二叉树，因为各个树之间是平级的，所以各个树的根节点可以相互看做兄弟结点，用右指针将各个根节点串联起来即可。</p><blockquote><p>森林转换为对应的二叉树，森林中叶子结点的个数对应二叉树中左指针为空的结点个数</p><p>高度为h的满二叉树，对应的森林所含树的个数为 h</p><p>一棵树转换为二叉树，树中每个非叶结点的最后一个孩子没有右孩子,且根结点没有右兄弟，故树中非叶节点个数+ 1 = 二叉树中右指针为空的结点个数</p><p>一个森林转换为二叉树，各个树的根节点可以相互看做兄弟，最后一棵树没有右兄弟，故森林中非叶结点个数+ 1= 二叉树中右指针为空的节点数</p><p>一棵树或森林转化为二叉树，其中叶结点的个数对应二叉树中左指针为空的结点数。</p><p>若树中任意两个叶结点都不存在相同的双亲，则树中的叶子数和其对应的二叉树中的叶子数相等</p><p>一个森林有 <span class="math inline">\(n\)</span>个结点，<spanclass="math inline">\(m\)</span>条边，则这个森林有$ n - m$ 棵树。（在树中，除了根节点外，每个顶点对应一条边）</p></blockquote><h3 id="树和森林的遍历">3.4、树和森林的遍历</h3><table><thead><tr class="header"><th>树</th><th>森林</th><th>二叉树</th></tr></thead><tbody><tr class="odd"><td>先序遍历</td><td>先序遍历</td><td>先序遍历</td></tr><tr class="even"><td>后序遍历</td><td>中序遍历</td><td>中序遍历</td></tr></tbody></table><h2 id="四树和二叉树的应用">四、树和二叉树的应用</h2><h3 id="哈夫曼树和哈夫曼编码">4.1、哈夫曼树和哈夫曼编码</h3><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225211114726-2024-12-723:58:35.png" alt="image-20230225211114726" style="zoom:50%;" /></p><p>结点的权：有某种现实含义的数值（如：表示结点的重要性，出现次数等）</p><p>结点的带权路径长度：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积</p><p>树的带权路径长度：<strong>所有叶结点</strong>的带权路径长度之和 <spanclass="math inline">\(WPL = \sum_{i=1}^{n} w_i l_i\)</span></p><p><strong>在含有<spanclass="math inline">\(n\)</span>个带权叶结点的二叉树中，其中带权路径长度（<spanclass="math inline">\(WPL\)</span>）最小的二叉树称为哈夫曼树，也称最优二叉树</strong></p><p>特点：</p><ul><li>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度就越大。</li><li>构造过程中一共新建了 <spanclass="math inline">\(n-1\)</span>个结点，因此哈夫曼树的结点总数为 <spanclass="math inline">\(2n -1\)</span>。</li><li>哈夫曼树中，只有度为2和度为<spanclass="math inline">\(0\)</span>的结点，不存在度为 1 的结点。</li><li>哈夫曼树不唯一，但 <spanclass="math inline">\(WPL\)</span>必然相同且为最优。</li></ul><blockquote><p>度为m的哈夫曼树，其中只有度为 m和度为 <spanclass="math inline">\(0\)</span>的结点。有 n个叶结点时，由于总结点数 =<span class="math inline">\(n_0+n_m=m*n_m+1\)</span>，故有 <spanclass="math inline">\(\lceil\frac{n-1}{m-1}\rceil\)</span>个非叶结点。</p></blockquote><p>若没有一个编码是另一个编码的前缀，则称这样的编码为<strong>前缀编码</strong>。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225212551153-2024-12-723:58:42.png" alt="image-20230225212551153" style="zoom:50%;" /></p><p>由哈夫曼树得到哈夫曼编码。首先将每个出现的字符当做一个独立的结点，其权值为它出现的频度或次数，构造出对应的哈夫曼树。所有的字符都出现在叶结点中。可将字符的编码解释为从根到该字符的路径上边标记的序列，其中边标记为0表示“转向左孩子”，边标记为1 表示“转向右孩子”。</p><p>哈夫曼树不唯一，因此哈夫曼编码不唯一。</p><blockquote><p>出现频度高的字符，其哈夫曼编码短；频度低的字符，编码长度更长。</p></blockquote><h3 id="并查集">4.2、并查集</h3><p>逻辑结构：元素之间为 “集合”关系。</p><p><strong>基本操作</strong>：</p><ul><li>初始化 Initial(S)：初始化并查集，将所有数组元素初始化为-1</li><li>Union （S, root1, root2）: <strong>“并”</strong>，把集合S中的子集root2 并入子集 root1中，<strong>要求 root1 和root2不相交</strong></li><li>Find (S,x)：<strong>“查”</strong>，查找集合S中单元素x所在的子集合，并返回该子集合的名字。</li></ul><p><strong>存储结构</strong>：</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230225215722535-2024-12-800:03:19.png" alt="image-20230225215722535" style="zoom: 67%;" /></p><p>​将每个集合组织成一棵树，通常用树（森林）的<strong>双亲表示法</strong>做为并查集的存储结构。通常用数组元素下标代表元素名，用根结点的小标代表子集合名，根结点的双亲结点为负数。</p><blockquote><p>并查集（Disjoint Set）是对逻辑结构 --- 集合 的具体实现，只进行 “并”和 "查"两种基本操作</p><p>并 ：将两个不相交的集合合并为一个，查：确定一个指定元素所属的集合</p></blockquote><p>其中查操作，通过不断向上寻找，找到所在树的根节点，根节点的数组下标代表该元素所属的集合。</p><p>并操作，只需将一个集合的根节点的双亲指针指向另一个集合的根节点即可。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 13</span><span class="hljs-type">int</span> UFSets[SIZE];  <span class="hljs-comment">//集合元素数组</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Initial</span> <span class="hljs-params">(<span class="hljs-type">int</span> s[])</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++)         s[i] = <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span> <span class="hljs-params">(<span class="hljs-type">int</span> s[],<span class="hljs-type">int</span> x)</span> </span>&#123;    <span class="hljs-keyword">while</span> (s[x] &gt;<span class="hljs-number">0</span>)         x = s[x];      <span class="hljs-keyword">return</span> x;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span> <span class="hljs-params">(<span class="hljs-type">int</span> s[], <span class="hljs-type">int</span> root1, <span class="hljs-type">int</span> root2)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root1 == root2) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//要求两个集合不同</span>    s[root2] = root1; <span class="hljs-comment">//将根root1 连接在另一根 root2下</span>&#125;</code></pre></div><p>其中Find操作的最坏时间复杂度为<spanclass="math inline">\(O(n)\)</span>，最坏时间复杂度和树的高度有关。Union操作的时间复杂度为<span class="math inline">\(O(1)\)</span>.</p><p><strong>并查集的优化</strong></p><p>​为了降低Find的时间复杂度，需要在每次Union操作构建树的时候，尽可能让树不长高。用根结点的<strong>绝对值</strong>表示树的结点总数，每次Union操作时都让小树合并到大树。</p><p>​压缩路径—-Find操作，先找到根节点，再将查找路径上所有结点都挂到根结点下。可使树的高度不超过<spanclass="math inline">\(O(α(n))\)</span>。<spanclass="math inline">\(α(n)\)</span>是一个增长很缓慢的函数，对于常见的n值，通常<spanclass="math inline">\(α(n) ≤4\)</span>，因此优化后并查集的Find、Union操作时间开销都很低</p><p>​ <imgsrc="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2023-02-25_22-28-33-2024-12-800:03:31.png"alt="Snipaste_2023-02-25_22-28-33" /></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 13</span><span class="hljs-type">int</span> UFSets[SIZE];  <span class="hljs-comment">//集合元素数组</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Initial</span> <span class="hljs-params">(<span class="hljs-type">int</span> s[])</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++)         s[i] = <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Find</span> <span class="hljs-params">(<span class="hljs-type">int</span> s[],<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-type">int</span> root = x;    <span class="hljs-keyword">while</span> (s[root] &gt; <span class="hljs-number">0</span>) root = s[root];  <span class="hljs-comment">//循环找到根</span>    <span class="hljs-comment">//压缩路径</span>    <span class="hljs-keyword">while</span> (x != root) &#123;        <span class="hljs-type">int</span> t = s[x];        s[x] = root;        x = t;    &#125;    <span class="hljs-keyword">return</span> root;&#125;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span> <span class="hljs-params">(<span class="hljs-type">int</span> s[], <span class="hljs-type">int</span> root1, <span class="hljs-type">int</span> root2)</span> </span>&#123;    <span class="hljs-keyword">if</span> (root1 == root2) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">//要求两个集合不同</span>    <span class="hljs-keyword">if</span> (s[root2] &gt; s[root1]) &#123; <span class="hljs-comment">//root2结点更少，将root2合并到root1</span>        s[root2] = root1;        s[root1] += s[root2];    &#125; <span class="hljs-keyword">else</span> &#123;        s[root1] = root2;        s[root2] += s[root1];    &#125;        &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>二叉树</tag>
      
      <tag>线索二叉树</tag>
      
      <tag>哈夫曼树</tag>
      
      <tag>并查集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>四、串</title>
    <link href="/dac6dce7/"/>
    <url>/dac6dce7/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="一定义">一、定义</h2><p><strong>串</strong> :即字符串(string)，是由零个或多个<u>字符</u>组成的有限序列。长度为0称为空串。</p><p><strong>子串</strong>：串中任意个<u>连续的字符</u>组成的子序列成为该串的字串。如S=‘HelloWorld’，中'He'、'Hello'等是子串，而'HW'不是子串，选取时一定要<u>保证连续</u>。</p><p><strong>主串</strong>：包含子串的串。</p><ul><li><p>字符在串中的位置：字符在串中的序号，即<strong>位序</strong>，是从1开始的。</p></li><li><p>子串在主串中的位置：子串的第一个字符在主串中的位置。</p></li></ul><p>前缀：除最后一个字符外，字符串的<strong>所有头部子串</strong>。</p><p>后缀：除第一个字符外，字符串的<strong>所有尾部子串</strong>。</p><blockquote><p>例如 "abad"的前缀为 {"a", "ab", "aba"}，后缀为{"d", "ad", "bad"}</p></blockquote><p>串和线性表的关系：</p><ul><li><p>串是一种特殊的线性表，数据元素之间呈线性关系。</p></li><li><p>串的数据元素限定为字符（如中英文字符，数字，标点字符等），而一般线性表中所存储的数据元素类型不限。</p><blockquote><p>串是内容受限的线性表</p></blockquote></li><li><p>串的基本操作如增删改查等通常以子串为对象，而一般线性表的基本操作时针对其中某个单独元素的。</p></li></ul><p>补：</p><ul><li><p>串的长度是指串中所含字符的个数</p></li><li><p>长度为n的主串有 n-m+1 个长度为m的子串</p></li><li><p>空串是任意串的子串，任意串是其自身的子串</p></li><li><p>长度为n的主串有 n(n+1)/2 +1个子串，（长度为n的子串有1个，长度为n-1的子串有2个，依次类推是等差数列）</p></li><li><p>非平凡子串：即子串既不为空也不是本身，长度为n的串，有2+3+...+n =(n-1) (n-2) /2个</p></li></ul><h2 id="二串的存储结构">二、串的存储结构</h2><h3 id="顺序存储">2.1、顺序存储</h3><p>类似线性表中的顺序存储，使用一组地址连续的存储单元存储串值的字符序列</p><p>定长顺序存储，使用静态数组</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 255</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-type">char</span> ch[MAXLEN];    <span class="hljs-type">int</span> length;&#125;SString;</code></pre></div><p>堆分配存储</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-type">char</span> *ch;    <span class="hljs-type">int</span> length;&#125;HString;HString S;S.ch = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span> (MAXLEN * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>));S.length = <span class="hljs-number">0</span>;</code></pre></div><p>串的顺序存储的优缺点和顺序表的类似。</p><p>顺序存储有不同的实现方案：</p><ul><li><p>使用变量length记录当前串长，缺点：字符在串中的位序和在数组中的下标相差一</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230209171011324-2024-12-709:57:46.png" alt="image-20230209171011324" style="zoom:80%;" /></p></li><li><p>ch[0]充当length，优点是字符的位序和数组下标相同，但由于一个字符为1B，所能表示的最大数字为255，能记录的范围有限</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230209171115033-2024-12-709:58:14.png" alt="image-20230209171115033" style="zoom:80%;" /></p></li><li><p>不设置length变量，以字符'\0'表示结尾，缺点：想知道当前串长需要从头遍历。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230209171152346-2024-12-709:58:42.png" alt="image-20230209171152346" style="zoom:80%;" /></p></li><li><p>舍弃ch[0]不用，让字符位序和数组下标保持一致，同时设置length变量记录串长。<推荐></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20230209171240955-2024-12-709:59:03.png" alt="image-20230209171240955" style="zoom:80%;" /></p></li></ul><h3 id="串的链式存储">2.2、串的链式存储</h3><p>类似于线性表的链式存储结构，其中每个结点既可以存放一个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构</p><h2 id="三串的基本操作">三、串的基本操作</h2><p>串赋值 StrAssign、串比较 StrCompare、 求串长 StrLength、串连接 Concat及求子串SubString，这五种操作构成串类型的最小操作集，其他串操作均可在该最小操作集上实现。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//清空子串,S.length = 0;</span><span class="hljs-built_in">ClearString</span>(&amp;S); <span class="hljs-comment">//求子串，用sub返回S的第pos个字符起长度为len的子串</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SubString</span><span class="hljs-params">(SString &amp;sub, SString s, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> len)</span> </span>&#123;    <span class="hljs-keyword">if</span> (pos + len - <span class="hljs-number">1</span> &gt; s.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//子串范围越界</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pos; i &lt; pos + len; i++)        sub[i - pos + <span class="hljs-number">1</span>] = s[i];    sub.length = len;    retrun <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">//串比较。S&gt;T,返回值&gt;0;S&lt;T,返回值&lt;0;S=T,返回值=0;</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StrCompare</span><span class="hljs-params">(SString S, SString T)</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= S.length &amp;&amp; i &lt; T.length; i++)         <span class="hljs-keyword">if</span> (S[i] != T[i])            <span class="hljs-keyword">return</span> S[i] - T[i];    <span class="hljs-keyword">return</span> S.length - T.length;&#125;<span class="hljs-comment">//子串定位，若串S中存在与串T值相同的子串，返回该子串在串S中第一次出现的位置。</span><span class="hljs-comment">//结合取子串和串比较，每次从S中取出和T长度相同的子串，和T比较</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">index</span><span class="hljs-params">(SString S, SString T)</span> </span>&#123;    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, n = S.length, m = T.length;    SString Sub;    <span class="hljs-keyword">while</span> (i &lt; n - m + <span class="hljs-number">1</span>) &#123;        <span class="hljs-built_in">SubString</span>(sub,S,i,m);        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">StrCompare</span>(sub, T) != <span class="hljs-number">0</span>)            i++;        <span class="hljs-keyword">else</span>             retrun i;          &#125;    retrun <span class="hljs-number">0</span>; <span class="hljs-comment">//不存在该子串</span>&#125;</code></pre></div><h2 id="四串的模式匹配">四、串的模式匹配</h2><p>一些概念</p><ul><li>主串</li><li>子串, <一定是主串中存在的才叫子串></li><li>模式串, &lt;想尝试在主串中找的串，未必存在&gt;</li></ul><p><strong>串的模式匹配：在主串中找到与模式串相同的子串，并返回位置。即子串的定位操作。</strong></p><h3 id="朴素模式匹配算法">4.1、朴素模式匹配算法</h3><p>思想：依次从主串中找出一个和模式串长度相同的子串，对所取子串和模式串中的元素依次比较，直到找到一个完全匹配的子串，或所有子串都不匹配为止。</p><p>算法分析：若模式串长度为m，主串长度为n。</p><ul><li><p>匹配成功的最好时间复杂度：<em>O</em>(m)，主串的第一个长度为m的子串就和模式串完全匹配。</p></li><li><p>匹配失败的最好情况：每个子串的第一个字符不匹配，其时间复杂度为<em>O</em>(n-m+1)≈<em>O</em>(n)</p><blockquote><p>长度为m的子串有n-m+1个，故时间复杂度为<em>O</em>(n-m+1)</p></blockquote></li><li><p>最坏时间复杂度：<em>O</em>(mn)</p><ul><li>最坏情况是，对主串的n-m+1个长度为m的子串，每次对比时前m-1个字符都匹配，但第m个字符不匹配，其中共对比m* (n-m+1)次，时间复杂度为 <em>O</em>(mn)</li><li>此时主串指针每次都要发生回溯</li></ul></li></ul><h3 id="kmp算法">4.2、KMP算法</h3><p>由于朴素模式匹配算法在某些子串和模式串只能部分匹配时，主串的扫描指针i经常发生回溯，导致时间开销增加，其最坏时间复杂度为<em>O</em>(mn)。</p><p>​KMP算法要利用之前部分成功匹配的信息，<strong>当子串和模式串不能匹配时，主串的扫描指针不回溯，只移动模式串的扫描指针j到一个合适的位置next[j]后，再次开始比较</strong>，其中模式串指针应跳到的位置保存在next数组中，算法平均时间复杂度为<em>O</em>(m+n),其中计算next数组为O(m),匹配需要O(n)。</p><p>next数组手算方法：当模式串中第j个字符匹配失败时，假设由模式串前j-1个字符组成的串为S，</p><p>则 <strong>next[j] = S的最长相等前后缀 +1</strong>，其中next数组第一位和第二位一定是0和1</p><blockquote><ol type="1"><li>next[j]的值只与当前位置之前的模式串结构相关，与主串无关，每个位置对应一个next[j]</li><li>next[0] 不用，next[1] = 0 是规定</li><li>next[j]的值每次最多增加1</li><li>模式串的最后一位字符不影响next数组的结果</li></ol></blockquote><p>KMP算法只有子串和模式串有很多部分成功匹配时才显得比朴素模式匹配算法快。</p><h3 id="kmp算法优化nextval数组">4.3、KMP算法优化：nextval数组</h3><p>当子串和模式串不匹配时，j = nextval[j]。</p><p>若模式串第j个位置的字符和子串匹配失败时，根据KMP算法，让j = next[j]继续比较。但当next[j]位置所指的字符和第j个位置的字符相同，那么比较必然失败，这次比较就没有意义。</p><blockquote><p>如果出现这种情况，则需要再次递归，将next[j]的值修正为next[next[j]]，直至两者不相等或到达初始条件为止</p></blockquote><p>求nextval数组：</p><ul><li>求next数组</li><li>nextval[1] = 0,从左向右依次求：<ul><li>若next[j]位置的字符和当前字符相同，则nextval数组对应的值也相同，即nextval[j] = nextval[ next[j] ]</li><li>若next[j]位置的字符和当前字符不同，则保持不变，即 nextval[j] =next[j]</li></ul></li></ul><h3 id="代码实现求next数组">4.4、代码实现求next数组</h3><p>用代码实现求next数组，核心是由next[j]求next[j+1]。</p><p>由定义next[1] = 0，设next[j] = k，则 <span class="math inline">\(1&lt;k&lt;j\)</span>，且满足 <span class="math inline">\(p_1 ...p_{k-1} =p_{j-k+1}...p_{j-1}\)</span>，这两个子串是相同的。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-07_10-36-02-2024-12-710:36:17.png" alt="image-20230209171011324" style="zoom:80%;" /></p><p>则 next[j + 1]：即<strong>找最长相等前后缀长度，再加一</strong>。</p><ol type="1"><li><p>若 <span class="math inline">\(p_k = p_j\)</span>，则以<spanclass="math inline">\(p_{j+1}\)</span>为结尾的子串的最长相等前后缀长度为k，故<span class="math inline">\(next[j+1] = k+1=next[j]+1\)</span>&lt;<u>最好的情况</u>&gt;</p></li><li><p>若 <span class="math inline">\(p_k \neqp_j\)</span>，此时看作模式串作为子串与自身在与第k位匹配失败，应继续将<spanclass="math inline">\(p_{next[k]}\)</span>和<spanclass="math inline">\({p_j}\)</span>相比较</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-07_11-05-33-2024-12-711:05:42.png" alt="image-20230209171011324" style="zoom:80%;" /></p><p>分析：在<spanclass="math inline">\(p_1\;...\;p_{k-1}\)</span>中被划分出两个长度为next[k]-1的前后缀，由于前后两个大的前后缀相同，由于对称性，故在后面对应位置也划分出了两个长度为next[k]-1的前后缀。</p><p>​ 即此时在<spanclass="math inline">\(p_1\;...\;p_{j-1}\)</span>中有四个长度为next[k] -1的相等子串。为求next[j+1]只关心最前和最后两个子串，若它们各自的下一位字符相等，即<spanclass="math inline">\({p_{next[k]}} =p_j\)</span>，则前j个字符的最长相等前后缀为next[k]，故next[j+1] =next[k] + 1；若各自的下一位字符不相等，即<spanclass="math inline">\({p_{next[k]}} \neqp_j\)</span>，则继续划分下去，重复以上的判断，直至相等或到达初始条件next[1] = 0。</p><blockquote><p>不管被划分成n个相等长度的相同子串，都只看最前面和最后面两个子串的下一位字符是否相等，即可确定最长相等前后缀长度，进而确定next[j+1]。</p></blockquote></li></ol><p>总结上述规律得：</p><ul><li>若<span class="math inline">\(p_{next[k]} =p_j\)</span>，则next[j+1] = next[k] + 1;</li><li>若<span class="math inline">\(p_{next[k]} \neqp_j\)</span>，则重复划分直至相等或到达初始条件next[1] =0 为止。</li></ul><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//实现求next数组</span><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_index</span><span class="hljs-params">(SString p, <span class="hljs-type">int</span> next[])</span> </span>&#123;    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>;    next[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-built_in">StrLength</span>(p)) &#123;        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span> || p[i] == p[j]) &#123;            ++i;            ++j;            next[i] = j; <span class="hljs-comment">// 简写为 next[++i] = ++j;</span>        &#125;<span class="hljs-keyword">else</span> &#123;            j = next[j];        &#125;    &#125;&#125;</code></pre></div><h2 id="五广义表">五、广义表</h2><h3 id="定义">5.1、定义</h3><p>广义表是线性表的推广，一般记作<span class="math inline">\(LS =(a_1,a_2\;...\;a_n), n\geq 0\)</span>。<spanclass="math inline">\(LS\)</span>是广义表<spanclass="math inline">\((a_1,a_2\;...\;a_n)\)</span>的名称，n是其长度。</p><p><spanclass="math inline">\(a_i\)</span>可以是单元素（<u>原子</u>），也可以是广义表（<u>子表</u>），广义表的定义是递归的。</p><p>任何非空广义表<span class="math inline">\(LS =(a_1,a_2\;...\;a_n)\)</span>均可分解为<strong>表头</strong>和<strong>表尾</strong>两部分：</p><ul><li>表头(Head)：第一个元素，<span class="math inline">\(Head(LS) =a_1\)</span>。</li><li>表尾(Tail)：出第一个元素外，<u>其余元素构成的表</u>，<spanclass="math inline">\(Tail(LS) = (a_2,a_3\;...\;a_n)\)</span>。</li></ul><p>例如：</p><ul><li><span class="math inline">\(D=(E,F) = (a,(b,c),F)\)</span>，<spanclass="math inline">\(Head(D) = E\)</span>，<spanclass="math inline">\(Head(E) = a\)</span>，<spanclass="math inline">\(Tail(E) = ((b, c))\)</span></li><li><span class="math inline">\(Head((b,c)) = b\)</span>，<spanclass="math inline">\(Tail((b,c)) = (c)\)</span></li><li><span class="math inline">\(Head(((b,c))) = (b,c)\)</span>，<spanclass="math inline">\(Tail(((b,c))) = ()\)</span></li><li><span class="math inline">\(C = (a,(b,c,d))\)</span>，<spanclass="math inline">\(Head(C) = a\)</span>，<spanclass="math inline">\(Tail(C) = ((b,c,d))\)</span></li></ul><h3 id="特点">5.2、特点</h3><ol type="1"><li>广义表中元素有相对次序。</li><li>广义表的<strong>长度</strong>定义为表中元素的个数。</li><li>广义表的<strong>深度</strong>定义为表的嵌套层数。</li><li>广义表可以改共享，即一个广义表可以作为其他表的子表。</li><li>广义表是一个递归的表。</li></ol><blockquote><p>注：</p><ol type="1"><li>原子的深度为0，空表的深度为1。</li><li>递归表的长度是有限值，深度是无穷值。</li></ol></blockquote><p>例如：</p><ul><li><spanclass="math inline">\(A=()\)</span>，A是一个空表，长度为0，深度为1</li><li><spanclass="math inline">\(B=(e)\)</span>，B只有一个原子，长度为1，深度为1</li><li><spanclass="math inline">\(C=(a,(b,c,d))\)</span>，C有一个原子和一个子表，长度为2，深度为2</li><li><spanclass="math inline">\(D=(A,B,C)\)</span>，D有三个子表，长度为3，深度为3</li><li><spanclass="math inline">\(E=(a,E)\)</span>，E是一个递归的表，长度为2，深度为无穷大</li></ul><h3 id="广义表的存储结构">5.3、广义表的存储结构</h3><p>通常采用链式存储结构，常用的有两种：头尾链表的存储结构 和扩展线性链表的存储结构。</p><ul><li><p>头尾链表的存储结构</p><p>表结点：<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207114745445-2024-12-711:47:46.png" alt="image-20241207114745445" style="zoom: 67%;" /></p><ul><li>hp所指的或为表结点，或为原子结点</li><li>除非表尾为空，则tp指针为空，<u>否则必指向表节点</u></li></ul><p>原子结点：<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207115109332-2024-12-711:51:10.png" alt="image-20241207115109332" style="zoom: 67%;" /></p><p>例如：</p><ul><li><p><span class="math inline">\(C=(a,(b,c,d))\)</span></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207120403971-2024-12-712:04:05.png" alt="image-20241207120403971" style="zoom:67%;" /></p></li><li><p><span class="math inline">\(E=(a,E)\)</span></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207120731172-2024-12-712:07:32.png" alt="image-20241207120731172" style="zoom:67%;" /></p></li><li><p><span class="math inline">\(B=(e)\)</span></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207120909735-2024-12-712:09:10.png" alt="image-20241207120909735" style="zoom:67%;" /></p></li></ul></li><li><p>扩展线性表的存储结构</p><p>无论是表结点还是原子结点均由三个域构成</p><p>表结点：<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207121209271-2024-12-712:12:10.png" alt="image-20241207121209271" style="zoom:67%;" /></p><p>原子结点：<img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207121236230-2024-12-712:12:37.png" alt="image-20241207121236230" style="zoom:67%;" /></p></li></ul><p>例如：<span class="math inline">\(C=(a,(b,c,d))\)</span></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20241207121652380-2024-12-712:16:53.png" alt="image-20241207121652380" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>串</tag>
      
      <tag>串的模式匹配</tag>
      
      <tag>朴素模式匹配</tag>
      
      <tag>KMP算法</tag>
      
      <tag>next数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三、栈和队列</title>
    <link href="/d403458d/"/>
    <url>/d403458d/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="一栈">一、栈</h2><p>定义：只允许在一端进行插入和删除操作的线性表。</p><p>其特点是 <strong>后进先出（LIFO）</strong></p><p>其逻辑结构和普通线性表相同，插入和删除操作有区别。</p><h3 id="顺序栈">1.1、顺序栈</h3><p>采用顺序存储的栈称为顺序栈。</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//结构定义</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_INIT_SIZE 100</span><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_INCRIMENT_SIZE 10;</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    ElemType *base; <span class="hljs-comment">//栈底指针，构造前和销毁后为空</span>    ElemTyoe *top; <span class="hljs-comment">// 栈顶指针,默认指向栈顶元素的下一个位置</span>    <span class="hljs-type">int</span> stackSize; <span class="hljs-comment">// 当前分配的栈的存储空间个数</span>&#125;SqStack;</code></pre></div><p><strong>初始化：</strong></p><ul><li>S.top =0：规定top指针指向下一个栈顶元素的下一个存储单元，即下一个可以存储的位置。</li><li>S.top = -1：规定top指针指向当前栈顶元素所在的存储单元。</li></ul><p>top指针的初始值不同，顺序栈的入栈、出栈、判满操作会有差异</p><ul><li>当S.top = 0 时：<ul><li>入栈：S.data[S.top ++] = x; 或*top++ = x;</li><li>出栈：x = S.data[-- S.top]; 或 x = *--top;</li><li>取栈顶元素： x = S.data[S.top - 1];或 x = *(top -1)</li><li>栈满：S.top == S.base;</li></ul></li><li>当S.top = -1时：<ul><li>入栈：S.data[++ S.top] = x;或 *++top =x ;</li><li>出栈：x = S.data[S.top --]; 或 x = *top--</li><li>取栈顶元素：x = S.data[S.top];或 x = *(top)</li><li>栈满：S.top == S.base</li></ul></li></ul><p>元素插入栈顶时，和顺序表一样，要判断是否栈满<code>S.top - S.base == S.stackSize</code>。若满了，则扩容后插入。</p><h3 id="共享栈">1.2、共享栈</h3><p>顺序栈的大小在声明后不可变，可以在一开始就申请较大的存储空间。<strong>为了提高内存的利用率，</strong>使用<strong>共享栈</strong>。</p><p>两个顺序栈共享一个一维数组，将两个栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221025163530823-2024-12-616:22:53.png" alt="image-20221025163530823" style="zoom:80%;" /></p><p><strong>仅当两个栈顶指针相邻（top1 - top0 =1）时，判定为栈满。</strong></p><p><strong>共享栈是为了更有效地利用存储空间，对存取效率没有什么影响。</strong></p><h3 id="链栈">1.3、链栈</h3><p>采用链式存储的栈称为链栈。通常采用单链表实现。</p><p>链栈的操作和链表类似，出栈和入栈的操作都在链表表头进行。</p><h2 id="二队列">二、队列</h2><p>定义：队列是只在一端进行插入，在另一端进行删除的线性表。</p><p>其特点是 <strong>先进先出（FIFO）</strong></p><h3 id="队列的顺序存储结构">2.1、队列的顺序存储结构</h3><p>用静态数组存放数据元素，设置队头指针front和队尾指针rear。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Maxsize 10 <span class="hljs-comment">//定义队列中最大存放元素的个数</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;    ElemType data[Maxsize];    <span class="hljs-type">int</span> front, rear;&#125;SqQueue;</code></pre></div><p>初始状态：Q.front = Q.rear = 0 （判空条件）</p><p>入队：队列不满时，先送值到队尾元素，再将队尾指针加一。</p><p>出队：队列不空时，先取队头元素，再将队头指针加一。</p><p>不能用 Q.rear ==maxsize作为队列满的条件，这是一种<strong>假溢出</strong>。</p><p><strong>循环队列</strong></p><p>用<strong>模运算</strong>将静态数组的存储空间变成一个<strong>环状。</strong></p><p>循环队列是队列的一种顺序存储结构，引入循环队列时为了<strong>克服假溢出时大量移动元素</strong>。</p><blockquote><p>循环队列也存在空间溢出问题，循环队列解决的是“假溢出”问题，但仍然会出现真正的溢出问题。假溢出是下标溢出，真溢出是空间溢出。</p></blockquote><p>根据<code>Q.front和Q.rear</code>的初始值的不同，对循环链表相同操作的代码有所不同。主要有以下三种初始情况，第一种是严蔚敏教材的初始情况，第二种是西电教材中有关循环队列的规定，第三种也较为常见。</p><p><strong>1、初始时 Q.front =0， Q.rear = 0，此时尾指针指向队尾元素的下一个存放位置，头指针指向队首元素</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221025173320423-2024-12-616_36_34-2024-12-617:00:19.png" alt="image-20221025173320423" style="zoom: 50%;" /></p><ul><li><p>元素入队： Q.data[Q.rear] = x; Q.rear = (Q.rear + 1) %maxsize;</p></li><li><p>元素出队： x = Q.data[Q.front]; Q.front = (Q.front + 1) %maxsize;</p></li><li><p>队列长度： (Q.rear - Q.front + maxsize) % maxsize;</p></li><li><p>判空： Q.front = Q.rear</p></li><li><p>判满</p><ul><li><p><strong>牺牲一个存储空间<放弃的是rear指向的位置>，来区分队空和队满</strong>，<strong>当rear的下一个位置为front时队满</strong>，即（Q.rear + 1) % maxsize == Q.front</p></li><li><p><strong>增加size变量记录当前队列长度</strong>，初始化时size = 0，入队时size++ ，出队时 size--。</p><p>此时队空的条件为 Q.size == 0;队满的条件为 Q.size == maxsize</p></li><li><p>只有出队才会导致队列为空，只有入队才会导致队列变满。通过区分 导致Q.front == Q.rear的最近一次操作时入队还是出队，来判断当前队列为空还是满。</p><p><strong>增加tag标志等于0或1，用于标记最近的一次操作时出队还是入队。</strong>执行出队操作时，Q.tag= 0; 执行入队操作时，Q.tag = 1</p><p>因此判空条件为：Q.front == Q.rear &amp;&amp; Q.tag == 0; 判满条件为：Q.front == Q.rear &amp;&amp; Q.tag == 1;</p></li></ul></li></ul><p><strong>2、初始时 Q.front = Q.rear = maxsize - 1，此时尾指针指向队尾元素，头指针指向队首元素的前一个位置</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221025173320423-2024-12-616:57:08.png" alt="image-20221025173320423" style="zoom: 50%;" /></p><ul><li>入队：rear = (rear + 1) % maxsize， Q.data[rear] = x</li><li>出队：front = (front + 1) % maxsize, x = Q.data[front]</li><li>判空：front == rear</li><li>判满：front == (rear + 1) % maxsize</li><li>元素个数：(rear - front + maxsize) % maxsize</li></ul><p><strong>3、初始时 Q.front = 0 ,Q.rear = maxsize - 1 ,此时队尾指针指向队尾元素，队友指针指向队头元素</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2022-10-25_17-46-22-2024-12-617:37:58.png" alt="Snipaste_2022-10-25_17-46-22" style="zoom: 50%;" /></p><ul><li><p>元素入队：Q.rear = (Q.rear + 1) % maxsize; Q.data[Q.rear] =x;</p></li><li><p>元素出队：x = Q.data[Q.front]; Q.front = (Q.front + 1) %maxsize;</p></li><li><p>判空：（Q.rear + 1 ) % maxsize == Q.front</p></li><li><p>判满</p><ul><li><p><strong>牺牲一个存储空间<放弃的是rear的下一个位置>，来区分空和满，</strong> 判断条件为 (Q.rear +2) % maxsize == Q.front</p></li><li><p>增加辅助变量size，记录当前队列中的元素个数</p></li><li><p>使用tag标志。入队时，tag为1；出队时，tag为0；</p><p>判空条件为 ：(Q.rear + 1) % maxsize == Q.front &amp;&amp; Q.tag ==0</p><p>判满条件为：（Q.rear + 1）%maxsize == Q.front &amp;&amp; Q.tag ==1</p></li></ul></li><li><p>元素个数：(Q.rear - Q.front + 1+ maxsize) % maxsize;</p></li></ul><h3 id="队列的链式存储结构">2.2、队列的链式存储结构</h3><p>队列的链式表示称为<strong>链队列。</strong>它实际上就是一个同时带有队头指针和队尾指针的单链表。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-06_17-51-34-2024-12-617:51:49.png" alt="Snipaste_2022-10-25_17-46-22" style="zoom: 60%;"></p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;    ElemType data;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkNode</span> *next;&#125;LinkNode;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;    LinkNode *front, *rear;&#125;LinkQueue;</code></pre></div><p><strong>带头结点的链队列</strong>：为了统一在第一个位置和其余位置插入和删除操作，一般采用带头结点的单链表</p><ul><li><p>初始化：<code>Q.front = Q.rear = (LinkNode*) malloc (sizeof(LinkNode)); Q.front-&gt;next == NULL;</code></p></li><li><p>元素入队：申请一个LinkNode结点s，<code>s-&gt;next = null; Q.rear -&gt; next = s; Q.rear = s</code>;</p></li><li><p>元素出队：当队列不为空时，删除队头结点<code>p = Q.front-&gt;next; Q.front-&gt;next = p-&gt;next; free(p);</code></p><div class="code-wrapper"><pre><code class="hljs">      **在释放结点p之前需要判断  `Q.rear == p`，若p就是最后一个结点 需要单独处理 `Q.rear = Q.front**</code></pre></div></li><li><p>判空：<code>Q.front == Q.rear</code></p></li></ul><p><strong>不带头结点的链队列</strong>：</p><ul><li>初始化：<code>Q.front = NULL; Q.rear = NULL;</code></li><li>元素入队： 在插入第一个元素结点 s 时，需要单独处理<code>Q.front = s; Q.rear = s;</code></li><li>元素出队：最后一个结点出队时要单独处理，将front和rear都指向NULL；</li><li>判空：<code>Q.front == NULL</code></li></ul><h3 id="双端队列">2.3、双端队列</h3><p>双端队列是指允许两端都可以进项入队和出队操作的队列。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221025214902241-2024-12-617:54:33.png" alt="image-20221025214902241" style="zoom: 67%;" /></p><ul><li>输入受限的双端队列：只允许在一端插入，两端删除的队列</li><li>输出受限的双端队列：只允许从两端插入，一端删除的队列</li></ul><p>在以某一顺序输入若干元素，判断输出是否合法时：</p><ul><li><strong>关键：在输出序列中的某个元素，在该元素之前的所有元素都已经输入</strong></li><li>在输入受限的双端队列中，<strong>只需验证能否利用两侧的出队操作拼凑出目标输出序列</strong></li><li>在输出受限的双端队列中，由于只能从一端出队，所以目标输出序列在队列中的相对位置已知，<strong>只需验证能否通过两端的输入操作得到目标输出序列</strong>。</li></ul><p>在栈中合法的输出序列，在双端队列中也必定合法。</p><h2 id="三栈和队列的应用">三、栈和队列的应用</h2><h3 id="栈在括号匹配中的应用">3.1、栈在括号匹配中的应用</h3><p>思路：依次扫描所有字符，遇到左括号则入栈，遇到右括号则弹出栈顶元素检查是否匹配</p><p>匹配失败的情况：</p><ol type="1"><li>扫描到右括号且栈空，右括号单身。</li><li>扫描完所有字符后，栈非空，左括号单身。</li><li>左右括号不匹配</li></ol><h3 id="栈在表达式求值中的应用">3.2、栈在表达式求值中的应用</h3><p>三种表达式：</p><ul><li>中缀表达：运算符位于两操作数之间</li><li>前缀表达式：运算符位于两操作数之前（波兰表达式）</li><li>后缀表达式：运算算符位于两操作数之后（逆波兰表达式）</li></ul><h4 id="中缀转后缀手算">中缀转后缀（手算）</h4><ol type="1"><li>确定中缀表达式中各个运算符的运算顺序，采用<strong>左优先原则</strong>：只要左边的运算符能先计算就优先让左边的计算。（此时的手算结果与计算机处理结果一致）</li><li>选择下一个运算符，按照【左操作数，右操作数，运算符】的方式组成一个新的操作数</li><li>如果还有运算符未被处理，继续步骤 2</li></ol><p><img src = "https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-06_18-15-07-2024-12-618:15:22.png" alt="Snipaste_2022-10-25_17-46-22" style="zoom: 50%;"></p><blockquote><p>中缀转前缀的手算方法与以上过程类似，在确定哥哥运算符的运算顺序是采用“右优先”原则，并按照【运算符，左操作数，右操作数】的方式组合成新的操作数</p></blockquote><h4 id="custom-id">中缀转后缀（机算）</h4><p>初始化一个栈，用于保存还不确定运算顺序的运算符。从左到右处理各个元素，直到末尾。可能遇到三种情况：</p><ul><li>遇到操作数：直接加入后缀表达式</li><li>遇到界限符：遇到 <code>(</code> 直接入栈，遇到 <code>)</code>则一次弹出栈内运算符并加入后缀表达式，直到弹出 <code>(</code>为止。注意，<code>)</code>不用入栈。</li><li>遇到运算符：一次弹出栈中优先级<strong>高于或等于</strong>当前运算符的所有运算符，并加入后缀表达式，若遇到<code>(</code> 或栈空则停止，之后再把当前运算符入栈。</li></ul><p>按上述规则处理完所有字符后，将栈中剩余运算符依次弹出并加入后缀表达式。</p><h4 id="计算后缀表达式手算">计算后缀表达式（手算）</h4><p>从左往右扫描，每遇到一个运算符，就让其前面最近的两个操作数执行相应的运算，合体为一个操作数。</p><h4 id="计算后缀表达式机算">计算后缀表达式（机算）</h4><p>初始化一个栈，用于存储扫描到的操作数</p><ol type="1"><li><strong>从左往右</strong>扫描下一个元素，直到处理完所有元素。</li><li>若扫描到操作数则入栈，并回到 1；否则执行 3</li><li>扫描到操作符，则弹出两个栈顶元素进行相应的运算（<strong>注：此时先出栈的是右操作数</strong>），运算结果压回栈顶，回到1</li></ol><p>若表达式合法，则最后栈中只会留下一个元素，就是最终结果</p><blockquote><p>用栈实现前缀表达式的方法同上，不同之处在于：i. 从右向左扫描前缀表达式ii.执行运算时，先出栈的是左操作数</p></blockquote><h4 id="利用栈实现中缀表达式的计算">利用栈实现中缀表达式的计算</h4><p>思想：中缀转后缀 + 后缀表达式求值。</p><p>思路：初始化两个栈，操作数栈和操作符栈，从左向右扫描中缀表达式</p><ul><li>若扫描到操作数，则压入操作数栈</li><li>若扫描到操作符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈。期间也会弹出运算符，每弹出一个运算符时，就需要弹出两个操作数栈顶元素来执行相应的运算，运算结果压回操作数栈。</li></ul><h3 id="栈在递归中的应用">3.3、栈在递归中的应用</h3><h3 id="栈在数制转换中的应用">3.4、栈在数制转换中的应用</h3><h3 id="队列在层序遍历中的应用">3.5、队列在层序遍历中的应用</h3><h2 id="四特殊矩阵的压缩存储">四、特殊矩阵的压缩存储</h2><p><ahref="https://blog.csdn.net/erthrerg/article/details/137921762">参考</a></p><p>关键：计算给定元素是顺序存储的第几个元素</p><p>计算给定数组元素的地址：<u>起始位置+<strong>前面元素的个数</strong> *每个元素所占空间</u></p><ul><li>一维：<span class="math inline">\(A[0...{n-1}]\)</span>,则<spanclass="math inline">\(LOC(a_i) = LOC(a_0) + i * L\)</span>,其中<spanclass="math inline">\(L\)</span>为每个数组元素所占的存储单元个数</li><li>二维 <spanclass="math inline">\(A[0...h_1][0...h_2]\)</span>,则<spanclass="math inline">\(LOC(a_{ij}) = LOC(a_{00}) + (i * (h_2 +1)+j)*L\)</span></li></ul><h3id="利用三元组顺序表对稀疏矩阵进行压缩存储">4.1、利用三元组顺序表对稀疏矩阵进行压缩存储</h3><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxsize 10000</span><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> datatype;<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;    <span class="hljs-type">int</span> i, j;    datatype v;<span class="hljs-comment">//非零元素所在行列为i，j，值为v</span>&#125;triple; <span class="hljs-comment">//三元组（i,j,v）</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;    triple data[maxsize];    <span class="hljs-type">int</span> m, n, len;<span class="hljs-comment">//矩阵的行、列、非零元素个数</span>&#125;tripleTable; <span class="hljs-comment">//三元组顺序表</span></code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-06_19-42-51-2024-12-619:43:15.png"></p><p><strong>三元组顺序表的转置</strong></p><ol type="1"><li><p>简单转置方法</p><p>分两步：</p><p>i.将三元组顺序表中的i和j互换，互换后其中的i并不是有序的</p><p>ii.按 i 进行非递减排序，是指变成像之前一样有序的状态。</p><p>其中涉及排序需要采用双重循环时间复杂度高</p></li><li><p>快速转置法</p><p><strong>用空间换时间</strong>，设置两个辅助数组 <code>num</code> 和<code>pos</code></p><p>num[]：用来记录每一列<strong>非零元素个数</strong></p><p>pos[]：用来存放每一列的第一个非零元素在转置后在三元组中存放的位置。</p><blockquote><p>初始时保存的是第一个非零元素的位置，在遍历过程中随着每次读取pos[k]后其值加一，保存该列下一个非零元素的存放位置</p></blockquote><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//求num[]</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; souce.n; i++)    num[i] = <span class="hljs-number">0</span>; <span class="hljs-comment">//共有souce.n列，每列非零元素个数初始化为0</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; souce.len; k++)     num[souce.data[k].j]++;  <span class="hljs-comment">//列号相同则对应的num值加一</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//求pos[]</span>pos[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//第1列第一个非零元素肯定存放在三元组的第一个位置</span><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt; souce.n; k++)     <span class="hljs-comment">//当前列第一个非零元素的位置 = 上一列的第一个非零元素的位置 + 上一列非零元素的个数</span>    pos[k] = pos[k - <span class="hljs-number">1</span>] + num[k - <span class="hljs-number">1</span>];</code></pre></div><p><img src="https://gitee.com/cmyk359/img/raw/master/img/PixPin_2024-12-06_23-09-21-2024-12-623:09:42.png" alt="PixPin_2024-12-06_23-09-21" style="zoom: 67%;" /></p><p>求出<code>num[]</code>和<code>pos[]</code>后，遍历三元组顺序表，每遍历一个元素<code>souce.data[k]</code>，交换它的行和列，再查询<code>pos[souce.data[k].j]</code>得到转置后它的位置，移动它到指定位置。再执行<code>pos[souce.data[k].j] ++</code>，以便同列的下一个非零元素能放在它的后面</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
      <tag>循环队列</tag>
      
      <tag>三元组顺序表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二、线性表</title>
    <link href="/7682ef9a/"/>
    <url>/7682ef9a/</url>
    
    <content type="html"><![CDATA[<!--请求图片资源时，隐藏自己的来源信息，防止出现403错误导致图床图片不显示--><meta name="referrer" content="no-referrer" /><h2 id="一线性表的定义和基本操作">一、线性表的定义和基本操作</h2><h3 id="线性表的定义">1.1、线性表的定义</h3><p><strong>线性表</strong>是有<strong>相同数据类型</strong>的n个<strong>数据元素</strong>的<strong>有限序列</strong>。其中n为表长，一般表示为L = (a1,a2,a3,...,an)。</p><p>从线性表的定义可以看出，线性表的特点：</p><ul><li>表中元素的数据类型相同，每个元素占有相同大小的存储空间。</li><li>表中元素都是数据元素，每个元素都是单个元素。</li><li>表中的元素个数有限。</li><li>表中元素具有逻辑上的顺序性，表中元素有其先后顺序。</li></ul><blockquote><p>线性表是一种<em>逻辑结构</em>，表示元素之间一对一的相邻关系。</p><p>顺序表和链表是指<em>存储结构</em>，是线性表不同存储结构下的实现。</p></blockquote><h3 id="线性表的基本操作">1.2、线性表的基本操作</h3><p>基本操作：创销、增删、查</p><ul><li>initList(&amp;L)：初始化表</li><li>destoryList(&amp;L)：销毁操作</li><li>listInsert(&amp;L,i,e) : 插入元素，在第i个位置插入元素e</li><li>listDelete(&amp;L,i,&amp;e)：删除第i个位置的元素，并用e返回删除元素的值。</li><li>getElem(L,i)：按位查找，获取表中第i个位置的元素值</li><li>locateElem(L,e)：按值查找，在表中查找具有给定关键字值的元素</li><li>empty(L)：判空</li><li>length(L)：获取表长</li><li>printList(L)：按顺序输出表中元素的值</li></ul><h2 id="二顺序表">二、顺序表</h2><h3 id="顺序表的定义">2.1、顺序表的定义</h3><p>​ 线性表的顺序表示 --- 顺序表：用一组<strong>地址连续</strong>的存储单元依次存储线性表中的数据元素，使得在逻辑上相邻的元素在物理位置上也相邻。</p><p>​ 若线性表L存储的起始地址为 LOC(A)，则第i个元素存储的起始地址为 LOC(A)+ (i - 1) * sizeof(ElemType)。</p><blockquote><p>注：线性表中元素的位序是从1开始的，而数组元素的下标是从0开始的。</p></blockquote><h3 id="顺序表的存储结构">2.2、顺序表的存储结构</h3><p>顺序表使用一维数组存储数据元素，该数组可以是<strong>静态分配</strong>的，也可以是<strong>动态分配</strong>的。</p><p>静态分配：</p><p>数组的大小已事先确定，一旦空间占满，再加入新的数据将会产生溢出，进而导致程序崩溃。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 50</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;    ElemType data[MaxSize];    <span class="hljs-type">int</span> lenght;<span class="hljs-comment">//顺序表的当前长度</span>&#125;SqList;SqList L;<span class="hljs-built_in">initList</span>(L); <span class="hljs-comment">//由于会有脏数据，初始化时表当当前长度lenght必须设置为0</span><span class="hljs-comment">//其他操作</span></code></pre></div><p>​</p><p>动态分配：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> InitSize 100</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;    ElemType *data;    <span class="hljs-type">int</span> MaxSize, length;<span class="hljs-comment">//数组的最大容量和当前个数</span>&#125; SeqList;SeqList L; <span class="hljs-comment">//系统在内存中开辟了包含 *data,MaxSize,length这些变量的存储空间</span><span class="hljs-built_in">initList</span>(L); <span class="hljs-comment">//初始化，给以上变量赋值</span><span class="hljs-comment">//初始化</span>L.data = (ElemType *) <span class="hljs-built_in">malloc</span> (<span class="hljs-built_in">sizeof</span>(ElemType) * InitSize);</code></pre></div><ul><li><p>此时存储空间不是在一开始就确定的，而是在程序执行过程中，在数组初始化过程通过动态存储分配语句分配的，一旦数据空间占满，就<strong>另开辟一块更大的空间，将数据元素拷贝过去，释放原来的空间</strong>，从而达到扩容的目的，而不用为线性表一次划分所有空间。</p></li><li><p><strong>动态分配方式不是链式存储</strong>，同样属于顺序存储结构，其物理结构没有发生变化，依然是随机存取方式，只是分配的空间大小可以在运行时决定。</p></li></ul><h3 id="顺序表的特点">2.3、顺序表的特点</h3><ul><li><p><strong>随机访问</strong>：可以在 <em>O(1)</em>内找到第i个元素</p></li><li><p>存储密度高，每个结点只存储数据元素，不用像链表那样消耗空间存储指针。</p></li><li><p>扩容不方便，<strong>静态分配不可以扩容，动态分配扩容时间复杂度也很高</strong></p></li><li><p>插入删除元素不方便，需要大量移动元素</p></li><li><p>由于难以估计所需空间的大小，必须预先分配较大的空间，往往使空间不能得到充分利用。</p></li></ul><h3 id="顺序表上基本操作的实现">2.4、顺序表上基本操作的实现</h3><p>​ 插入操作：在顺序表L的第i个位置 (<strong>1&lt;= i &lt;=L.length+1)</strong> 插入元素e，成功返回true，否则返回false。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insertList</span> <span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> data)</span> </span>&#123;    <span class="hljs-comment">//顺序表中，可以插入的位置 为 [1,length+1], index 为位序</span>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">1</span> || index &gt; L.length<span class="hljs-number">+1</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (index &gt;= Maxsize)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">//从最后一个位置的元素开始，将位置index 到 length的元素都向后移动：移动元素个数为 length - index + 1</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = L.length; i &gt;= index; i--) &#123;        L.data[i] = L.data[i<span class="hljs-number">-1</span>];    &#125;    L.data[index - <span class="hljs-number">1</span>] = data;    L.length ++;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><p>​ 删除操作：删除顺序表L中第i个位置 ( <strong>1&lt;= i &lt;=L.length</strong>)，若成功删除返回true，并将被删除元素用引用变量e返回。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">deleteList</span> <span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> &amp;data)</span> </span>&#123;    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">1</span> || index &gt; L.length)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    data = L.data[index];    <span class="hljs-comment">//从第index+1个位置开始，将其后的元素向前移动，移动元素个数为： length - index</span>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; L.length; i++) &#123;        L.data[i<span class="hljs-number">-1</span>] = L.data[i];    &#125;    L.length --;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><h2 id="三链表">三、链表</h2><p>线性表的链式表示 --- 链表</p><h3 id="单链表的定义">3.1、单链表的定义</h3><p>​它通过一组<strong>任意</strong>的存储单元来存储线性表中的数据元素。为了建立数据元素之间的线性关系，对每个链表结点，除了存放元素自身的信息外，还需存放一个指向其后继的<strong>指针</strong>。</p><p>单链表的结点结构如下：</p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> &#123;</span>    <span class="hljs-type">int</span> data;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> *<span class="hljs-title">next</span>;</span>&#125;<span class="hljs-comment">//增加一个新结点</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> *<span class="hljs-title">p</span> =</span> (<span class="hljs-keyword">struct</span> Lnode *)<span class="hljs-built_in">malloc</span>(siezof(<span class="hljs-keyword">struct</span> Lnode));</code></pre></div><p>为了在编写代码时不用带上 struct 关键字，使用 typedef 关键字对该数据类型 重命名。 typedef <数据类型 > <别名></p><div class="code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> &#123;</span>    <span class="hljs-type">int</span> data;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> *<span class="hljs-title">next</span>;</span>&#125;Lnode, *LinkList;<span class="hljs-comment">//增加一个新结点</span>Lnode *p = (Lnode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Lnode));<span class="hljs-comment">//声明一个单链表</span>LinkList L;</code></pre></div><p>通常用一个<strong>头指针</strong>来标识一个单链表，如单链表L。为了操作方便，在单链表的第一个结点之前附加一个结点，称为<strong>头结点</strong></p><p>二者区别：不管带不带头结点，<strong>头指针始终指向链表的第一个结点</strong>，而头结点是带头结点的链表中第一个结点，节点内通常不存储信息。头结点的指针域指向线性表的第一个元素结点。<strong>可以没有头结点，但不能没有头指针</strong>。</p><p>引入头结点带来的优点：</p><ul><li>让链表在第一个位置的操作和在表其他位置的操作保持一致。若不带头结点，每次插入或删除第一个元素时，需要改变头指针L的指向，要单独处理。</li><li>无论链表是否为空，头指针都指向头结点的非空指针（空表中头结点指针域为空），让空表和非空表的操作的到了统一。</li></ul><h3 id="单链表上基本操作的实现">3.2、单链表上基本操作的实现</h3><h4 id="头插法建立单链表">头插法建立单链表</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//带头结点</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createList_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span> </span>&#123;    <span class="hljs-comment">//用头插法逆序建立带头结点的单链表</span>    L = (LinkList) <span class="hljs-built_in">malloc</span> (<span class="hljs-built_in">sizeof</span>(LNode));    <span class="hljs-keyword">if</span>(!L) <span class="hljs-built_in">exit</span>(<span class="hljs-string">&quot;OVERFLOW&quot;</span>); <span class="hljs-comment">//申请失败，返回内存溢出</span>    L-&gt;next = null;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        p = (LinkList) <span class="hljs-built_in">malloc</span> (<span class="hljs-built_in">sizeof</span>(LNode));        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;p-&gt;data);        p-&gt;next = L-&gt;next;        L-&gt;next = p;    &#125;    &#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//不带头结点</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createList_L</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> n)</span> </span>&#123;    L = <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;        p = (LinkList) <span class="hljs-built_in">malloc</span> (<span class="hljs-built_in">sizeof</span>(LNode));        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;p-&gt;data);        p-&gt;next = L;        L = p; <span class="hljs-comment">//头指针指向第一个元素结点</span>    &#125;</code></pre></div><h4 id="尾插法建立单链表">尾插法建立单链表</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//带头结点</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(LinkList &amp;L)</span> </span>&#123;    <span class="hljs-comment">//创建头结点</span>    L = (LNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LNode));    LNode *r = L; <span class="hljs-comment">//尾指针</span>    <span class="hljs-type">int</span> data = <span class="hljs-number">0</span>;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data);    <span class="hljs-keyword">while</span> (data != <span class="hljs-number">9999</span>) &#123; <span class="hljs-comment">// 输入结点值为9999时停止创建</span>        LNode *node = (LNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (LNode));        node-&gt;data = data;        r-&gt;next = node;        r = node;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data);    &#125;    r-&gt;next = <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-comment">//不带头结点</span><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(LinkList &amp;L)</span> </span>&#123;    L = <span class="hljs-literal">NULL</span>;    LNode *r = L;    <span class="hljs-type">int</span> data;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data);    <span class="hljs-keyword">while</span> (data != <span class="hljs-number">9999</span>) &#123;         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data为 %d&quot;</span>,data);        LNode *node = (LNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (LNode));        node-&gt;data = data;        node-&gt;next = <span class="hljs-literal">NULL</span>;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;data);        <span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//第一个结点单独创建，此时需要改变头指针的指向</span>            L = node;            r = L;            <span class="hljs-keyword">continue</span>;        &#125;        r-&gt;next = node;        r = node;    &#125;&#125;</code></pre></div><h4 id="在第i个位置插入元素">在第i个位置插入元素</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//带头节点</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">listInsert</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> data)</span> </span>&#123;    <span class="hljs-comment">//找到第 index - 1个结点，插在其后</span>    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">1</span> ) <span class="hljs-comment">//位序从1开始</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    LNode *p = L;    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; index - <span class="hljs-number">1</span>) &#123;        p = p-&gt;next;        j++;    &#125;    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<span class="hljs-comment">//index不合法，超出当前链表最大长度+1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    LNode * node = (LNode*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (LNode));    node-&gt;data = data;    node-&gt;next = p-&gt;next;    p-&gt;next = node;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">//不带头结点</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">listInsert</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> data)</span> </span>&#123;    <span class="hljs-keyword">if</span> (index == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//在头部插入，需要单独处理</span>        LNode *node = (LNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (LNode));        node-&gt;data = data;        node-&gt;next = L;        L = node;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;         LNode *p = L;    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; <span class="hljs-comment">// 此时j从1开始</span>    <span class="hljs-keyword">while</span> (p &amp;&amp; j &lt; index - <span class="hljs-number">1</span>) &#123;        p = p-&gt;next;        j ++;    &#125;    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    LNode *node = (LNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (LNode));    node-&gt;data = data;    node-&gt;next = p-&gt;next;    p-&gt;next = node;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><h4 id="指定结点的后插操作">指定结点的后插操作</h4><p>带头结点和不带头结点的单链表操作相同，在给定结点不为空的前提下，申请一个新的结点，将其插在当前结点之后</p><h4 id="指定结点的前插操作">指定结点的前插操作</h4><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><span class="hljs-comment">指定结点的前插操作 相当于 指定结点的前驱的后插操作</span><span class="hljs-comment">1、传入头指针</span><span class="hljs-comment">从头遍历链表找到当前结点的前驱，在其后插入新结点。不带头结点的单链表在第一个结点前插入时要单独处理。</span><span class="hljs-comment">2、不传入头指针</span><span class="hljs-comment">在当前结点后插入新结点，将新结点的数据和当前结点的数据交换，达到前插的 “效果”</span><span class="hljs-comment">*/</span><span class="hljs-comment">//不带头结点</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insertPriorNode</span><span class="hljs-params">(LinkList L, LNode *p, <span class="hljs-type">int</span> data)</span> </span>&#123;    <span class="hljs-keyword">if</span> (L == <span class="hljs-literal">NULL</span> || p == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-comment">/* 不带头结点的链表 多 一个判断是否在第一个结点执行前插操作的判断，单独处理该情况，其余操作均相同*/</span>    LNode *q = L;    <span class="hljs-keyword">while</span>(q-&gt;next != p) &#123; <span class="hljs-comment">//寻找p的前驱</span>        q = q-&gt;next;    &#125;    LNode *node = (LNode *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span> (LNode));    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    node-&gt;data = data;    q-&gt;next = node;    node-&gt;next = p;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><h4 id="按位序删除">按位序删除</h4><p>主要是找到待删除结点的前驱和后继，将其后继作为前驱的后继，并将当前结点删除。若i值不合法找不到第i-1个结点或第i个结点已经为NULL，删除失败。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//带头节点</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">listDelete</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> index, <span class="hljs-type">int</span> &amp;data)</span> </span>&#123;    <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">1</span> || L == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">/*若是不带头结点的单链表，判断index是否等于1.单独处理*/</span>        LNode *pre = L, *p = L-&gt;next;    <span class="hljs-keyword">while</span> (-- index &amp;&amp; p) &#123; <span class="hljs-comment">//寻找第index-1个结点</span>        pre = p;        p = p -&gt; next;    &#125;        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">//i值不合法</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span> (p-&gt;next == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">//p已经是最后一个结点</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        LNode *q = p-&gt;next;    data = q-&gt;data;    p-&gt;next = q-&gt;next;    <span class="hljs-built_in">free</span>(q);    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">//不带头结点</span><span class="hljs-comment">/*</span><span class="hljs-comment">若删除的是第一个结点 (index = 1)，需要改变头指针的指向，需要单独处理</span><span class="hljs-comment">寻找第i-1个结点时， j从1开始，其余操作和不带头结点的相同</span><span class="hljs-comment">*/</span></code></pre></div><h4 id="指定结点p的删除">指定结点p的删除</h4><ul><li>若传入头指针，循环寻找p的前驱，将后继作为前驱的后继</li><li>若不传入头指针，将p和p的后继节点数据交换后，删除后继。&lt;注：若p是最后一个结点时会出错&gt;</li></ul><h3 id="双链表">3.4、双链表</h3><p>​单链表中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后遍历。访问某个结点的前驱结点时只能从头开始遍历，其时间复杂度为<em>O(n)</em>，访问其后继节点的时间复杂度为<em>O(1)</em>。</p><p>​为了克服单链表的上述缺点，引入了双链表。双链表的插入和删除时间复杂度都为<em>O(1)</em>，按值查找和按位查找都需要遍历链表，时间复杂度都为<em>O(n)。</em></p><p>​ 双链表结点中含有两个指针prior 和next，分别指向其前驱和后继结点。</p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221020091225136-2024-12-615:11:00.png" alt="image-20221020091225136" style="zoom:67%;" /></p><p>其结点结构类型如下：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DNode</span> &#123;    ElemType data;    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dnode</span> *prior, *next;&#125;DNode, *DLinkList;</code></pre></div><h4 id="双链表的插入操作">双链表的插入操作</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221020091611880-2024-12-615:15:34.png" alt="image-20221020091611880" style="zoom: 67%;" /></p><p>在p之后插入新结点，其中第1、2步必须在第4步之前，否则就会丢失p的后继节点。</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//先处理好插入节点和p结点后继结点的关系</span><span class="hljs-number">1.</span> p-&gt;next-&gt;prior = s;<span class="hljs-number">2.</span> s-&gt;next = p-&gt;next;<span class="hljs-comment">//再处理插入结点和p结点的关系</span><span class="hljs-number">3.</span> s-&gt;prior = p;<span class="hljs-number">4.</span> p-&gt;next = s;<span class="hljs-comment">//注意边界，当对最后一个结点进行后插操作时，需要特殊处理，直接使用上述代码会出错</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">insertDNode</span><span class="hljs-params">(DNode *p, DNode *s)</span> </span>&#123;    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">if</span>(p-&gt;next != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//若p结点有后继结点</span>        p-&gt;next-&gt;prior = s;    &#125;    s-&gt;next = p-&gt;next;    s-&gt;prior = p;    p-&gt;next = s;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><p>实现了双链表的后插操作后，其他插入操作如按位序i插入（找到第i-1个结点，执行后插操作）和某结点的前插操作（其前驱结点的后插操作都可以转化为后插操作。</p><h4 id="双链表的删除操作">双链表的删除操作</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/Snipaste_2022-10-20_09-25-23-2024-12-615:16:29.png" style="zoom: 67%;" /></p><p>删除p的后继结点：</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//当p或p的后继为最后后一个结点时，该做法会出错</span>p-&gt;next = q-&gt;next;q-&gt;next-&gt;prior = p;<span class="hljs-built_in">free</span>(q);<span class="hljs-comment">//注意边界，当被删除结点为最后一个结点时要特殊处理。</span><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">deleteDNode</span><span class="hljs-params">(DNode *p)</span> </span>&#123;    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    DNode *q = p-&gt;next;    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//p没有后继</span>    p-&gt;next = q-&gt;next;    <span class="hljs-keyword">if</span>(q-&gt;next != <span class="hljs-literal">NULL</span>) &#123;        q-&gt;next-&gt;prior = p;    &#125;    <span class="hljs-built_in">free</span>(q);    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><h3 id="循环链表">3.5、循环链表</h3><h4 id="循环单链表">循环单链表</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221020095402713-2024-12-615:20:17.png" alt="image-20221020095402713" style="zoom:67%;" /></p><p>初始化： <code>L-&gt;next = L</code></p><p>判空：<code>L-&gt;next == L</code></p><p>判断是否为表尾结点 : <code>p-&gt;next == L</code></p><p>在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以从表中的任一结点开始遍历整个链表。</p><p><strong>对于只设置头指针的循环单链表，其要找到表尾结点的时间复杂的仍为<em>O(n)</em>，需要依次遍历整个链表。故通常为循环单链表不设头指针而仅设置尾指针</strong></p><h4 id="循环双链表">循环双链表</h4><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20221020100322600-2024-12-615:20:39.png" alt="image-20221020100322600" style="zoom:67%;" /></p><p>初始化： <code>L-&gt;next = L; L-&gt;prior = L;</code></p><p>判空： <code>L-&gt;next == L</code></p><p>判断是否为表尾结点： <code>p-&gt;next == L</code></p><p>对循环双链表的插入和删除操作和普通双链表基本相同，且不用考虑边界情况。</p><h3 id="静态链表">3.6、静态链表</h3><h2 id="四链表相关的算法题目">四、链表相关的算法题目</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线性表</tag>
      
      <tag>单链表</tag>
      
      <tag>双链表</tag>
      
      <tag>循环链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一、绪论</title>
    <link href="/bfab103e/"/>
    <url>/bfab103e/</url>
    
    <content type="html"><![CDATA[<!--请求图片资源时，隐藏自己的来源信息，防止出现403错误导致图床图片不显示--><meta name="referrer" content="no-referrer" /><h2 id="一数据结构的基本概念">一、数据结构的基本概念</h2><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20220902165335043-2024-12-610:07:40.png" alt="image-20220902165335043" style="zoom:80%;" /></p><h3 id="基本概念">1.1、基本概念</h3><p>用数据库中的相关概念来理解，数据相当于一个数据库，数据对象相当于一个表，数据元素相当于表中的一条记录，数据项相当于一条记录的诸多属性。</p><ul><li><p>数据</p><p>画家，用画笔来描述世界；音乐家，用音符来描述世界；计算机专业人员，用<strong>数据</strong>来描述世界。</p><p>数据是<strong>信息的载体</strong>，是描述客观事物属性的数、字符及所有能输入到计算机中并<strong>被计算机程序识别和处理</strong>的符号的集合。数据是计算机程序加工的原料。</p></li><li><p>数据元素 数据项</p><p>数据元素：是数据的<u><strong>基本单位</strong></u>，通常作为一个整体来考虑和处理。</p><p>数据项：一个数据元素可由若干个数据项组成，数据项是构成数据元素<strong>不可分割的最小单位</strong></p></li><li><p>数据对象 数据结构（都是描述<strong>数据元素之间</strong>的关系）</p><p>数据对象：是<strong>具有相同性质</strong>的数据元素的集合，是数据的一个子集。（强调数据元素具有相同性质）</p><p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。（强调数据元素之间有什么关系---&gt;数据结构三要素）。不同的数据元素可以组成相同的数据结构，相同的数据元素也可以组成不同的数据结构。</p></li><li><p>数据类型 抽象数据类型</p><p>数据类型：是一个值的集合和定义在此集合上的一组操作的总称。如：bool类型，其值的集合为true和false，可以进行的操作有与、或、非......</p><ul><li>原子类型：其值不可再分的数据类型。如int、bool等。</li><li>结构类型：其值可以在分解成若干成分的数据类型。如struct类型。</li></ul><p>抽象数据类型：ADT，描述了数据的逻辑结构和抽象运算，通常用<strong>&lt; 数据对象，数据关系，基本操作集&gt;</strong>这样的三元组来表示，从而构成了一个完整的数据结构定义。只用数学化的语言定义数据的<u>逻辑结构和运算</u>，与具体的实现无关，只有当用实际的计算机实现时，才考虑其存储结构，如栈、队列。</p></li></ul><p><strong>讨论一种数据结构时，先定义其抽象数据类型，即先定义逻辑结构和运算，最后决定用什么存储结构来实现。</strong></p><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20220902172218218-2024-12-610:13:11.png" alt="image-20220902172218218" style="zoom:80%;" /></p><h3 id="数据结构三要素">1.2、数据结构三要素</h3><ul><li><p><strong>逻辑结构</strong>：数据元素之间的逻辑关系是什么</p><ul><li>集合：各元素同属一个集合，别无其他关系</li><li>线性结构：一对一的关系</li><li>树状结构：一对多的关系</li><li>图状结构：多对多的关系</li></ul><p><img src="https://gitee.com/cmyk359/img/raw/master/img/image-20220902172832557-2024-12-610:14:26.png" alt="image-20220902172832557" style="zoom:80%;" /></p><blockquote><p>补充：</p><ol type="1"><li><p>数组：是线性表的推广，它的数据元素是一个线性表，每个数据元素结构相同</p><p>广义表：是线性表的推广，它的数据元素是一个线性表，但不同构，即或者是单元素或者线性表。</p><p>严格来讲，数组（二维）和广义表不属于线性结构</p></li><li><p>栈和队列是操作受限的线性表，而串是内容受限的线性表</p></li></ol></blockquote></li><li><p><strong>存储结构</strong>：如何用计算机表示数据元素之间的逻辑关系</p><ul><li>顺序存储：把逻辑结构上相邻的元素存储在物理位置也相邻的存储单元中。</li><li>链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助<strong>指针</strong>表示其逻辑关系</li><li>索引存储：需要建立附加的索引表</li><li>散列存储：根据元素的关键字直接计算出该元素的存储地址</li></ul></li><li><p><strong>数据的运算</strong></p><p>施加在数据上的运算包括<strong>运算的定义和实现</strong>。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</p></li></ul><blockquote><p>注：</p><p>1、数据的逻辑结构独立与其存储结构，而数据的存储结构是逻辑结构在计算机中的映射，不能独立于逻辑结构而存在。</p><p>2、存储数据时，不仅要存储各数据元素的值，而且要存储他们之间的关系。</p><p>3、两个不同的数据结构，他们的逻辑结构和存储结构有可能完全相同，数据运算也是数据结构的一个重要方面。如：二叉树和二叉排序树，链栈和链队列。</p><p>4、堆是数据元素的序列，存储在一维数组中，可以看成<strong>线性结构</strong></p><p>5、<strong>多型数据类型</strong>，栈、队列、树、图都是多型数据类型，其数据元素既可以是‘单型’（原子类型，如整数，布尔类型等），也可以是结构类型。</p><p>6、有序表是指关键字有序的线性表，仅描述数据间的逻辑关系，它可以链式存储也可以顺序存储，故属于逻辑结构。</p><p>7、算法代表对问题求解步骤的描述，而程序则是算法在计算机上的特定实现。程序不一定满足有穷性，如死循环。</p><p>8、数据结构的形式定义为一个二元组，Data-Struct = &lt;D,R&gt;，其中D是数据元素的有限集，R是D上关系的有限集；</p><p>​ 数据类型表示为 ： Data-Type = &lt;D, R, P&gt;； 抽象数据类型表示为ADT = &lt;D, R, P&gt;。其中D和R同上，P为定义的一组操作。</p></blockquote><h2 id="二算法和算法的评价">二、算法和算法的评价</h2><h3 id="算法">2.1、算法</h3><p><strong>算法（Algorithm）是对特定问题求解步骤的一般描述</strong>，它是指令的有限序列，其中的每条指令表示一个或多个操作。</p><p><strong>程序 = 数据结构 +算法</strong>，其中数据结构是要处理的信息，算法是处理信息的步骤。</p><h3 id="算法的五个特性">2.2、算法的五个特性</h3><p>不满足以上五个特性就不能称为算法。</p><ul><li>有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。</li><li>确定性：算法中的每条指令必须有明确的含义，对于相同的输入只能得到相同的输出</li><li>可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次数来实现</li><li>输入：一个算法有零个或多个输入</li><li>输出：一个算法有一个或多个输出 （必须要有输出）</li></ul><h3 id="好的算法的特质">2.3、好的算法的特质</h3><p>算法的设计目标，从这几方面评价一个算法</p><ul><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效率：算法的执行时间（用<strong>时间复杂度</strong>来刻画）</li><li>低存储量：算法执行过程中所需要的最大存储空间（用<strong>空间复杂度</strong>来刻画）正确性可读性健壮性高效率：算法的执行时间（用<strong>时间复杂度</strong>来刻画）低存储量：算法执行过程中所需要的最大存储空间（用<strong>空间复杂度</strong>来刻画）</li></ul><h3 id="时间复杂度">2.4、时间复杂度</h3><p>一个语句的频度是指该语句在算法中被执行的次数，算法中所有语句的频度之和记为<em>T(n)</em>,它是该算法<strong>问题规模n</strong>的函数，<strong>时间复杂度主要分析<em>T(n)</em>的数量级</strong>。采用<strong>事前分析估计的方法</strong>分析时间开销T(n)与问题规模n的关系。</p><p>​ 算法中基本运算（最深层循环内部的语句）的频度 <em>f(n)</em>和<em>T(n)</em>同数量级，因此通常采用算法中基本运算的频度来分析算法时间复杂度，记为<em>T(n) = O ( f(n) )</em>，其中 O表示同数量级，其严格的数学定义为：T(n)和f(n)为定义在正整数集合上的两个函数，则存在正常数C和n0，使得n&gt;n0时，都满足<strong>0 &lt; T(n) &lt;= C f(n)</strong>。</p><p>​<strong>算法的时间复杂度不仅依赖于问题的规模n，也取决于输入数据的性质</strong>，如在一个一维数组中查找给定值k。因此，有<strong>最好时间复杂度</strong>，<strong>最坏时间复杂度</strong>，<strong>平均时间复杂度</strong>（所有可能输入等概率出现的情况下，算法的期望运行时间）。</p><p>在分析一个算法时间复杂度时，频度f(n)中可能含有多项相加或相乘，有加法和乘法规则：</p><p>​ 加法规则：多项相加只保留最高阶的项，且系数变为1</p><p>​ 乘法规则：多项相乘结果为最终保留</p><blockquote><p>注：1、顺序执行的代码只会影响常数项，可以忽略</p><p>​2、只挑最深层循环中的一个基本语句分析它的执行次数与问题规模n的关系即可</p><p>​ 3、 如果有多层循环，只需关注最深层循环中基本语句的执行次数</p></blockquote><h3 id="空间复杂度">2.5、空间复杂度</h3><p>算法的空间复杂度 <em>S(n)</em>定义为该算法所耗费的存储空间，它是问题规模n的函数， 记为 <em>S(n) = O(g(n) )</em></p><ul><li>只需关注问题规模<strong>n相关的变量</strong>所耗费的存储空间</li><li>函数递归调用带来的内存开销，其空间复杂度 =递归调用的深度。有的算法各层调用时所需存储空间与n有关，所以不同。</li><li>算法原地工作是指算法所需的<strong>辅助空间为常量</strong>，即<em>O(1)</em></li></ul><h3 id="注意点">2.6、注意点</h3><p>1、算法优于算法，是一个宏观上的问题，比如飞机比火车快，程序执行时间的特例不构成反例。故在相同规模n下，时间复杂度为O(n)的算法在时间上总是优于时间复杂度为O(2^n)的算法。时间复杂度为<spanclass="math inline">\(O(1)\)</span>的算法是效率最高的算法。</p><p>2、对于多层循环嵌套的代码，其时间复杂度主要考察最深层代码频度的数量级。</p><ul><li><p>内层和外层没有联系</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;        x++;    &#125;&#125;</code></pre></div><p>执行次数 = 外层循环次数 * 内层循环次数 = n * m</p></li><li><p>内层和外层有联系</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2</span>*i; j++) &#123;        x++;    &#125;&#125;</code></pre></div><p>执行次数计算方法：从内存向外层加和 ,即</p><p><span class="math display">\[ \sum_{i=1}^n \sum_{j=1}^{2i}1=  \sum_{i=1}^n 2i=  2 * \frac{n(n+1)}{2} =  n(n+1)\]</span></p></li><li><p>对于递归函数的时间复杂度</p><p>分析每次递归调用是参数的变化规律，是每次规模减一（n-1），还是规模减半（<spanclass="math inline">\(\frac{n}{2}\)</span>）等，再寻找递归出口所规定的规模，得出递归的次数。通常时间复杂度度与地柜的调用次数相关。​</p><p>一个算法所需时间由下述递归方程表示，求该算法的时间复杂度 <spanclass="math display">\[T(n) = \begin{cases} \ 1,n=1\\ \ 2T(\frac{n}{2})+n, n&gt;1\end{cases}\]</span> ​ 解：<span class="math inline">\(T(n) = 2T(\frac{n}{2})+n =2(2T(\frac{n}{4})+\frac{n}{2})+n = 4T(\frac{n}{4})+2n\)</span></p></li></ul><p>​ <span class="math display">\[= 2^k T(\frac{n}{2^k})+ kn\]</span></p><p>​ <span class="math display">\[当  \frac{n}{2^k} = 1时为止，所以   =\log_2n,将k代入T(n)可得\]</span></p><p>​ <span class="math display">\[T(n)=n*T(1) +n * \log_2n = n +n\log_2n\]</span></p><p>​ 故：该递归函数的时间复杂的为 <spanclass="math inline">\(O(n\log_2n)\)</span></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法基本概念</tag>
      
      <tag>时间复杂度</tag>
      
      <tag>空间复杂度</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
